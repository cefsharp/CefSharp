// Copyright Â© 2020 The CefSharp Authors. All rights reserved.
//
// Use of this source code is governed by a BSD-style license that can be found in the LICENSE file.
//
// **This code was generated by a tool, do not change directly**
// CHROMIUM VERSION 87.0.4280.141
namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// Enum of possible property types.
    /// </summary>
    public enum AXValueType
    {
        /// <summary>
        /// boolean
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("boolean")]
        Boolean,
        /// <summary>
        /// tristate
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("tristate")]
        Tristate,
        /// <summary>
        /// booleanOrUndefined
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("booleanOrUndefined")]
        BooleanOrUndefined,
        /// <summary>
        /// idref
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("idref")]
        Idref,
        /// <summary>
        /// idrefList
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("idrefList")]
        IdrefList,
        /// <summary>
        /// integer
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("integer")]
        Integer,
        /// <summary>
        /// node
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("node")]
        Node,
        /// <summary>
        /// nodeList
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeList")]
        NodeList,
        /// <summary>
        /// number
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("number")]
        Number,
        /// <summary>
        /// string
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("string")]
        String,
        /// <summary>
        /// computedString
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("computedString")]
        ComputedString,
        /// <summary>
        /// token
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("token")]
        Token,
        /// <summary>
        /// tokenList
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("tokenList")]
        TokenList,
        /// <summary>
        /// domRelation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("domRelation")]
        DomRelation,
        /// <summary>
        /// role
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("role")]
        Role,
        /// <summary>
        /// internalRole
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("internalRole")]
        InternalRole,
        /// <summary>
        /// valueUndefined
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("valueUndefined")]
        ValueUndefined
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// Enum of possible property sources.
    /// </summary>
    public enum AXValueSourceType
    {
        /// <summary>
        /// attribute
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attribute")]
        Attribute,
        /// <summary>
        /// implicit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("implicit")]
        Implicit,
        /// <summary>
        /// style
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("style")]
        Style,
        /// <summary>
        /// contents
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contents")]
        Contents,
        /// <summary>
        /// placeholder
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("placeholder")]
        Placeholder,
        /// <summary>
        /// relatedElement
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("relatedElement")]
        RelatedElement
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
    /// </summary>
    public enum AXValueNativeSourceType
    {
        /// <summary>
        /// figcaption
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("figcaption")]
        Figcaption,
        /// <summary>
        /// label
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("label")]
        Label,
        /// <summary>
        /// labelfor
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("labelfor")]
        Labelfor,
        /// <summary>
        /// labelwrapped
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("labelwrapped")]
        Labelwrapped,
        /// <summary>
        /// legend
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("legend")]
        Legend,
        /// <summary>
        /// tablecaption
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("tablecaption")]
        Tablecaption,
        /// <summary>
        /// title
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("title")]
        Title,
        /// <summary>
        /// other
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("other")]
        Other
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// A single source for a computed AX property.
    /// </summary>
    public class AXValueSource : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// What type of source this is.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        public CefSharp.DevTools.Accessibility.AXValueSourceType Type
        {
            get;
            set;
        }

        /// <summary>
        /// The value of this property source.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public CefSharp.DevTools.Accessibility.AXValue Value
        {
            get;
            set;
        }

        /// <summary>
        /// The name of the relevant attribute, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attribute")]
        public string Attribute
        {
            get;
            set;
        }

        /// <summary>
        /// The value of the relevant attribute, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attributeValue")]
        public CefSharp.DevTools.Accessibility.AXValue AttributeValue
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this source is superseded by a higher priority source.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("superseded")]
        public bool? Superseded
        {
            get;
            set;
        }

        /// <summary>
        /// The native markup source for this value, e.g. a &lt;label&gt; element.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nativeSource")]
        public CefSharp.DevTools.Accessibility.AXValueNativeSourceType? NativeSource
        {
            get;
            set;
        }

        /// <summary>
        /// The value, such as a node or node list, of the native source.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nativeSourceValue")]
        public CefSharp.DevTools.Accessibility.AXValue NativeSourceValue
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the value for this property is invalid.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("invalid")]
        public bool? Invalid
        {
            get;
            set;
        }

        /// <summary>
        /// Reason for the value being invalid, if it is.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("invalidReason")]
        public string InvalidReason
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// AXRelatedNode
    /// </summary>
    public class AXRelatedNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The BackendNodeId of the related DOM node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendDOMNodeId")]
        public int BackendDOMNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// The IDRef value provided, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("idref")]
        public string Idref
        {
            get;
            set;
        }

        /// <summary>
        /// The text alternative of this node in the current context.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        public string Text
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// AXProperty
    /// </summary>
    public class AXProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The name of this property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        public CefSharp.DevTools.Accessibility.AXPropertyName Name
        {
            get;
            set;
        }

        /// <summary>
        /// The value of this property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Accessibility.AXValue Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// A single computed AX property.
    /// </summary>
    public class AXValue : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The type of this value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        public CefSharp.DevTools.Accessibility.AXValueType Type
        {
            get;
            set;
        }

        /// <summary>
        /// The computed value of this property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public object Value
        {
            get;
            set;
        }

        /// <summary>
        /// One or more related nodes, if applicable.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("relatedNodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXRelatedNode> RelatedNodes
        {
            get;
            set;
        }

        /// <summary>
        /// The sources which contributed to the computation of this property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sources")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXValueSource> Sources
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// Values of AXProperty name:
    /// - from &apos;busy&apos; to &apos;roledescription&apos;: states which apply to every AX node
    /// - from &apos;live&apos; to &apos;root&apos;: attributes which apply to nodes in live regions
    /// - from &apos;autocomplete&apos; to &apos;valuetext&apos;: attributes which apply to widgets
    /// - from &apos;checked&apos; to &apos;selected&apos;: states which apply to widgets
    /// - from &apos;activedescendant&apos; to &apos;owns&apos; - relationships between elements other than parent/child/sibling.
    /// </summary>
    public enum AXPropertyName
    {
        /// <summary>
        /// busy
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("busy")]
        Busy,
        /// <summary>
        /// disabled
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("disabled")]
        Disabled,
        /// <summary>
        /// editable
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("editable")]
        Editable,
        /// <summary>
        /// focusable
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("focusable")]
        Focusable,
        /// <summary>
        /// focused
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("focused")]
        Focused,
        /// <summary>
        /// hidden
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hidden")]
        Hidden,
        /// <summary>
        /// hiddenRoot
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hiddenRoot")]
        HiddenRoot,
        /// <summary>
        /// invalid
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("invalid")]
        Invalid,
        /// <summary>
        /// keyshortcuts
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyshortcuts")]
        Keyshortcuts,
        /// <summary>
        /// settable
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("settable")]
        Settable,
        /// <summary>
        /// roledescription
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("roledescription")]
        Roledescription,
        /// <summary>
        /// live
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("live")]
        Live,
        /// <summary>
        /// atomic
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("atomic")]
        Atomic,
        /// <summary>
        /// relevant
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("relevant")]
        Relevant,
        /// <summary>
        /// root
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("root")]
        Root,
        /// <summary>
        /// autocomplete
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("autocomplete")]
        Autocomplete,
        /// <summary>
        /// hasPopup
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hasPopup")]
        HasPopup,
        /// <summary>
        /// level
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("level")]
        Level,
        /// <summary>
        /// multiselectable
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("multiselectable")]
        Multiselectable,
        /// <summary>
        /// orientation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("orientation")]
        Orientation,
        /// <summary>
        /// multiline
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("multiline")]
        Multiline,
        /// <summary>
        /// readonly
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("readonly")]
        Readonly,
        /// <summary>
        /// required
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("required")]
        Required,
        /// <summary>
        /// valuemin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("valuemin")]
        Valuemin,
        /// <summary>
        /// valuemax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("valuemax")]
        Valuemax,
        /// <summary>
        /// valuetext
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("valuetext")]
        Valuetext,
        /// <summary>
        /// checked
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("checked")]
        Checked,
        /// <summary>
        /// expanded
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("expanded")]
        Expanded,
        /// <summary>
        /// modal
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("modal")]
        Modal,
        /// <summary>
        /// pressed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pressed")]
        Pressed,
        /// <summary>
        /// selected
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("selected")]
        Selected,
        /// <summary>
        /// activedescendant
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("activedescendant")]
        Activedescendant,
        /// <summary>
        /// controls
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("controls")]
        Controls,
        /// <summary>
        /// describedby
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("describedby")]
        Describedby,
        /// <summary>
        /// details
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("details")]
        Details,
        /// <summary>
        /// errormessage
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errormessage")]
        Errormessage,
        /// <summary>
        /// flowto
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("flowto")]
        Flowto,
        /// <summary>
        /// labelledby
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("labelledby")]
        Labelledby,
        /// <summary>
        /// owns
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("owns")]
        Owns
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// A node in the accessibility tree.
    /// </summary>
    public class AXNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Unique identifier for this node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this node is ignored for accessibility
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ignored")]
        public bool Ignored
        {
            get;
            set;
        }

        /// <summary>
        /// Collection of reasons why this node is hidden.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ignoredReasons")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXProperty> IgnoredReasons
        {
            get;
            set;
        }

        /// <summary>
        /// This `Node`&apos;s role, whether explicit or implicit.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("role")]
        public CefSharp.DevTools.Accessibility.AXValue Role
        {
            get;
            set;
        }

        /// <summary>
        /// The accessible name for this `Node`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        public CefSharp.DevTools.Accessibility.AXValue Name
        {
            get;
            set;
        }

        /// <summary>
        /// The accessible description for this `Node`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("description")]
        public CefSharp.DevTools.Accessibility.AXValue Description
        {
            get;
            set;
        }

        /// <summary>
        /// The value for this `Node`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public CefSharp.DevTools.Accessibility.AXValue Value
        {
            get;
            set;
        }

        /// <summary>
        /// All other properties
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("properties")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXProperty> Properties
        {
            get;
            set;
        }

        /// <summary>
        /// IDs for each of this node&apos;s child nodes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("childIds")]
        public string[] ChildIds
        {
            get;
            set;
        }

        /// <summary>
        /// The backend ID for the associated DOM node, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendDOMNodeId")]
        public int? BackendDOMNodeId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// Animation instance.
    /// </summary>
    public class Animation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `Animation`&apos;s id.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s internal paused state.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pausedState")]
        public bool PausedState
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s play state.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("playState")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlayState
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s playback rate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("playbackRate")]
        public long PlaybackRate
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s start time.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startTime")]
        public long StartTime
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s current time.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("currentTime")]
        public long CurrentTime
        {
            get;
            set;
        }

        /// <summary>
        /// Animation type of `Animation`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s source animation node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("source")]
        public CefSharp.DevTools.Animation.AnimationEffect Source
        {
            get;
            set;
        }

        /// <summary>
        /// A unique ID for `Animation` representing the sources that triggered this CSS
        /// animation/transition.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cssId")]
        public string CssId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// AnimationEffect instance
    /// </summary>
    public class AnimationEffect : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `AnimationEffect`&apos;s delay.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("delay")]
        public long Delay
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s end delay.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endDelay")]
        public long EndDelay
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s iteration start.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("iterationStart")]
        public long IterationStart
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s iterations.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("iterations")]
        public long Iterations
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s iteration duration.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("duration")]
        public long Duration
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s playback direction.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("direction")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Direction
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s fill mode.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fill")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Fill
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s target node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int? BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s keyframes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyframesRule")]
        public CefSharp.DevTools.Animation.KeyframesRule KeyframesRule
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s timing function.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("easing")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Easing
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// Keyframes Rule
    /// </summary>
    public class KeyframesRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CSS keyframed animation&apos;s name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// List of animation keyframes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyframes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Animation.KeyframeStyle> Keyframes
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// Keyframe Style
    /// </summary>
    public class KeyframeStyle : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Keyframe&apos;s time offset.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offset")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Offset
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s timing function.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("easing")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Easing
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.ApplicationCache
{
    /// <summary>
    /// Detailed application cache resource information.
    /// </summary>
    public class ApplicationCacheResource : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Resource url.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Resource size.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("size")]
        public int Size
        {
            get;
            set;
        }

        /// <summary>
        /// Resource type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.ApplicationCache
{
    /// <summary>
    /// Detailed application cache information.
    /// </summary>
    public class ApplicationCache : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Manifest URL.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("manifestURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ManifestURL
        {
            get;
            set;
        }

        /// <summary>
        /// Application cache size.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("size")]
        public long Size
        {
            get;
            set;
        }

        /// <summary>
        /// Application cache creation time.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("creationTime")]
        public long CreationTime
        {
            get;
            set;
        }

        /// <summary>
        /// Application cache update time.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("updateTime")]
        public long UpdateTime
        {
            get;
            set;
        }

        /// <summary>
        /// Application cache resources.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resources")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.ApplicationCache.ApplicationCacheResource> Resources
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.ApplicationCache
{
    /// <summary>
    /// Frame identifier - manifest URL pair.
    /// </summary>
    public class FrameWithManifest : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Frame identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// Manifest URL.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("manifestURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ManifestURL
        {
            get;
            set;
        }

        /// <summary>
        /// Application cache status.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("status")]
        public int Status
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// Information about a cookie that is affected by an inspector issue.
    /// </summary>
    public class AffectedCookie : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The following three properties uniquely identify a cookie
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Path
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("path")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Path
        {
            get;
            set;
        }

        /// <summary>
        /// Domain
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("domain")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Domain
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// Information about a request that is affected by an inspector issue.
    /// </summary>
    public class AffectedRequest : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The unique request id.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            set;
        }

        /// <summary>
        /// Url
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        public string Url
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// Information about the frame affected by an inspector issue.
    /// </summary>
    public class AffectedFrame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// FrameId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// SameSiteCookieExclusionReason
    /// </summary>
    public enum SameSiteCookieExclusionReason
    {
        /// <summary>
        /// ExcludeSameSiteUnspecifiedTreatedAsLax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ExcludeSameSiteUnspecifiedTreatedAsLax")]
        ExcludeSameSiteUnspecifiedTreatedAsLax,
        /// <summary>
        /// ExcludeSameSiteNoneInsecure
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ExcludeSameSiteNoneInsecure")]
        ExcludeSameSiteNoneInsecure,
        /// <summary>
        /// ExcludeSameSiteLax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ExcludeSameSiteLax")]
        ExcludeSameSiteLax,
        /// <summary>
        /// ExcludeSameSiteStrict
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ExcludeSameSiteStrict")]
        ExcludeSameSiteStrict
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// SameSiteCookieWarningReason
    /// </summary>
    public enum SameSiteCookieWarningReason
    {
        /// <summary>
        /// WarnSameSiteUnspecifiedCrossSiteContext
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WarnSameSiteUnspecifiedCrossSiteContext")]
        WarnSameSiteUnspecifiedCrossSiteContext,
        /// <summary>
        /// WarnSameSiteNoneInsecure
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WarnSameSiteNoneInsecure")]
        WarnSameSiteNoneInsecure,
        /// <summary>
        /// WarnSameSiteUnspecifiedLaxAllowUnsafe
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WarnSameSiteUnspecifiedLaxAllowUnsafe")]
        WarnSameSiteUnspecifiedLaxAllowUnsafe,
        /// <summary>
        /// WarnSameSiteStrictLaxDowngradeStrict
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WarnSameSiteStrictLaxDowngradeStrict")]
        WarnSameSiteStrictLaxDowngradeStrict,
        /// <summary>
        /// WarnSameSiteStrictCrossDowngradeStrict
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WarnSameSiteStrictCrossDowngradeStrict")]
        WarnSameSiteStrictCrossDowngradeStrict,
        /// <summary>
        /// WarnSameSiteStrictCrossDowngradeLax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WarnSameSiteStrictCrossDowngradeLax")]
        WarnSameSiteStrictCrossDowngradeLax,
        /// <summary>
        /// WarnSameSiteLaxCrossDowngradeStrict
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WarnSameSiteLaxCrossDowngradeStrict")]
        WarnSameSiteLaxCrossDowngradeStrict,
        /// <summary>
        /// WarnSameSiteLaxCrossDowngradeLax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WarnSameSiteLaxCrossDowngradeLax")]
        WarnSameSiteLaxCrossDowngradeLax
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// SameSiteCookieOperation
    /// </summary>
    public enum SameSiteCookieOperation
    {
        /// <summary>
        /// SetCookie
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SetCookie")]
        SetCookie,
        /// <summary>
        /// ReadCookie
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ReadCookie")]
        ReadCookie
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// This information is currently necessary, as the front-end has a difficult
    /// time finding a specific cookie. With this, we can convey specific error
    /// information without the cookie.
    /// </summary>
    public class SameSiteCookieIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Cookie
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookie")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.AffectedCookie Cookie
        {
            get;
            set;
        }

        /// <summary>
        /// CookieWarningReasons
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookieWarningReasons")]
        public CefSharp.DevTools.Audits.SameSiteCookieWarningReason[] CookieWarningReasons
        {
            get;
            set;
        }

        /// <summary>
        /// CookieExclusionReasons
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookieExclusionReasons")]
        public CefSharp.DevTools.Audits.SameSiteCookieExclusionReason[] CookieExclusionReasons
        {
            get;
            set;
        }

        /// <summary>
        /// Optionally identifies the site-for-cookies and the cookie url, which
        /// may be used by the front-end as additional context.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("operation")]
        public CefSharp.DevTools.Audits.SameSiteCookieOperation Operation
        {
            get;
            set;
        }

        /// <summary>
        /// SiteForCookies
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("siteForCookies")]
        public string SiteForCookies
        {
            get;
            set;
        }

        /// <summary>
        /// CookieUrl
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookieUrl")]
        public string CookieUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Request
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("request")]
        public CefSharp.DevTools.Audits.AffectedRequest Request
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// MixedContentResolutionStatus
    /// </summary>
    public enum MixedContentResolutionStatus
    {
        /// <summary>
        /// MixedContentBlocked
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("MixedContentBlocked")]
        MixedContentBlocked,
        /// <summary>
        /// MixedContentAutomaticallyUpgraded
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("MixedContentAutomaticallyUpgraded")]
        MixedContentAutomaticallyUpgraded,
        /// <summary>
        /// MixedContentWarning
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("MixedContentWarning")]
        MixedContentWarning
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// MixedContentResourceType
    /// </summary>
    public enum MixedContentResourceType
    {
        /// <summary>
        /// Audio
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Audio")]
        Audio,
        /// <summary>
        /// Beacon
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Beacon")]
        Beacon,
        /// <summary>
        /// CSPReport
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CSPReport")]
        CSPReport,
        /// <summary>
        /// Download
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Download")]
        Download,
        /// <summary>
        /// EventSource
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("EventSource")]
        EventSource,
        /// <summary>
        /// Favicon
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Favicon")]
        Favicon,
        /// <summary>
        /// Font
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Font")]
        Font,
        /// <summary>
        /// Form
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Form")]
        Form,
        /// <summary>
        /// Frame
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Frame")]
        Frame,
        /// <summary>
        /// Image
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Image")]
        Image,
        /// <summary>
        /// Import
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Import")]
        Import,
        /// <summary>
        /// Manifest
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Manifest")]
        Manifest,
        /// <summary>
        /// Ping
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Ping")]
        Ping,
        /// <summary>
        /// PluginData
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("PluginData")]
        PluginData,
        /// <summary>
        /// PluginResource
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("PluginResource")]
        PluginResource,
        /// <summary>
        /// Prefetch
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Prefetch")]
        Prefetch,
        /// <summary>
        /// Resource
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Resource")]
        Resource,
        /// <summary>
        /// Script
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Script")]
        Script,
        /// <summary>
        /// ServiceWorker
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ServiceWorker")]
        ServiceWorker,
        /// <summary>
        /// SharedWorker
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SharedWorker")]
        SharedWorker,
        /// <summary>
        /// Stylesheet
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Stylesheet")]
        Stylesheet,
        /// <summary>
        /// Track
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Track")]
        Track,
        /// <summary>
        /// Video
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Video")]
        Video,
        /// <summary>
        /// Worker
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Worker")]
        Worker,
        /// <summary>
        /// XMLHttpRequest
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("XMLHttpRequest")]
        XMLHttpRequest,
        /// <summary>
        /// XSLT
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("XSLT")]
        XSLT
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// MixedContentIssueDetails
    /// </summary>
    public class MixedContentIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The type of resource causing the mixed content issue (css, js, iframe,
        /// form,...). Marked as optional because it is mapped to from
        /// blink::mojom::RequestContextType, which will be replaced
        /// by network::mojom::RequestDestination
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resourceType")]
        public CefSharp.DevTools.Audits.MixedContentResourceType? ResourceType
        {
            get;
            set;
        }

        /// <summary>
        /// The way the mixed content issue is being resolved.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resolutionStatus")]
        public CefSharp.DevTools.Audits.MixedContentResolutionStatus ResolutionStatus
        {
            get;
            set;
        }

        /// <summary>
        /// The unsafe http url causing the mixed content issue.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("insecureURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InsecureURL
        {
            get;
            set;
        }

        /// <summary>
        /// The url responsible for the call to an unsafe url.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mainResourceURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MainResourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// The mixed content request.
        /// Does not always exist (e.g. for unsafe form submission urls).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("request")]
        public CefSharp.DevTools.Audits.AffectedRequest Request
        {
            get;
            set;
        }

        /// <summary>
        /// Optional because not every mixed content issue is necessarily linked to a frame.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frame")]
        public CefSharp.DevTools.Audits.AffectedFrame Frame
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// Enum indicating the reason a response has been blocked. These reasons are
    /// refinements of the net error BLOCKED_BY_RESPONSE.
    /// </summary>
    public enum BlockedByResponseReason
    {
        /// <summary>
        /// CoepFrameResourceNeedsCoepHeader
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CoepFrameResourceNeedsCoepHeader")]
        CoepFrameResourceNeedsCoepHeader,
        /// <summary>
        /// CoopSandboxedIFrameCannotNavigateToCoopPage
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CoopSandboxedIFrameCannotNavigateToCoopPage")]
        CoopSandboxedIFrameCannotNavigateToCoopPage,
        /// <summary>
        /// CorpNotSameOrigin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CorpNotSameOrigin")]
        CorpNotSameOrigin,
        /// <summary>
        /// CorpNotSameOriginAfterDefaultedToSameOriginByCoep
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CorpNotSameOriginAfterDefaultedToSameOriginByCoep")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        /// <summary>
        /// CorpNotSameSite
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CorpNotSameSite")]
        CorpNotSameSite
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
    /// code. Currently only used for COEP/COOP, but may be extended to include
    /// some CSP errors in the future.
    /// </summary>
    public class BlockedByResponseIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Request
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("request")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.AffectedRequest Request
        {
            get;
            set;
        }

        /// <summary>
        /// ParentFrame
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parentFrame")]
        public CefSharp.DevTools.Audits.AffectedFrame ParentFrame
        {
            get;
            set;
        }

        /// <summary>
        /// BlockedFrame
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("blockedFrame")]
        public CefSharp.DevTools.Audits.AffectedFrame BlockedFrame
        {
            get;
            set;
        }

        /// <summary>
        /// Reason
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reason")]
        public CefSharp.DevTools.Audits.BlockedByResponseReason Reason
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// HeavyAdResolutionStatus
    /// </summary>
    public enum HeavyAdResolutionStatus
    {
        /// <summary>
        /// HeavyAdBlocked
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("HeavyAdBlocked")]
        HeavyAdBlocked,
        /// <summary>
        /// HeavyAdWarning
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("HeavyAdWarning")]
        HeavyAdWarning
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// HeavyAdReason
    /// </summary>
    public enum HeavyAdReason
    {
        /// <summary>
        /// NetworkTotalLimit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("NetworkTotalLimit")]
        NetworkTotalLimit,
        /// <summary>
        /// CpuTotalLimit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CpuTotalLimit")]
        CpuTotalLimit,
        /// <summary>
        /// CpuPeakLimit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CpuPeakLimit")]
        CpuPeakLimit
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// HeavyAdIssueDetails
    /// </summary>
    public class HeavyAdIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The resolution status, either blocking the content or warning.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resolution")]
        public CefSharp.DevTools.Audits.HeavyAdResolutionStatus Resolution
        {
            get;
            set;
        }

        /// <summary>
        /// The reason the ad was blocked, total network or cpu or peak cpu.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reason")]
        public CefSharp.DevTools.Audits.HeavyAdReason Reason
        {
            get;
            set;
        }

        /// <summary>
        /// The frame that was blocked.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.AffectedFrame Frame
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// ContentSecurityPolicyViolationType
    /// </summary>
    public enum ContentSecurityPolicyViolationType
    {
        /// <summary>
        /// kInlineViolation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("kInlineViolation")]
        KInlineViolation,
        /// <summary>
        /// kEvalViolation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("kEvalViolation")]
        KEvalViolation,
        /// <summary>
        /// kURLViolation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("kURLViolation")]
        KURLViolation,
        /// <summary>
        /// kTrustedTypesSinkViolation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("kTrustedTypesSinkViolation")]
        KTrustedTypesSinkViolation,
        /// <summary>
        /// kTrustedTypesPolicyViolation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("kTrustedTypesPolicyViolation")]
        KTrustedTypesPolicyViolation
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// SourceCodeLocation
    /// </summary>
    public class SourceCodeLocation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Url
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// LineNumber
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// ColumnNumber
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// ContentSecurityPolicyIssueDetails
    /// </summary>
    public class ContentSecurityPolicyIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The url not included in allowed sources.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("blockedURL")]
        public string BlockedURL
        {
            get;
            set;
        }

        /// <summary>
        /// Specific directive that is violated, causing the CSP issue.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("violatedDirective")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ViolatedDirective
        {
            get;
            set;
        }

        /// <summary>
        /// ContentSecurityPolicyViolationType
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentSecurityPolicyViolationType")]
        public CefSharp.DevTools.Audits.ContentSecurityPolicyViolationType ContentSecurityPolicyViolationType
        {
            get;
            set;
        }

        /// <summary>
        /// FrameAncestor
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameAncestor")]
        public CefSharp.DevTools.Audits.AffectedFrame FrameAncestor
        {
            get;
            set;
        }

        /// <summary>
        /// SourceCodeLocation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sourceCodeLocation")]
        public CefSharp.DevTools.Audits.SourceCodeLocation SourceCodeLocation
        {
            get;
            set;
        }

        /// <summary>
        /// ViolatingNodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("violatingNodeId")]
        public int? ViolatingNodeId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// A unique identifier for the type of issue. Each type may use one of the
    /// optional fields in InspectorIssueDetails to convey more specific
    /// information about the kind of issue.
    /// </summary>
    public enum InspectorIssueCode
    {
        /// <summary>
        /// SameSiteCookieIssue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteCookieIssue")]
        SameSiteCookieIssue,
        /// <summary>
        /// MixedContentIssue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("MixedContentIssue")]
        MixedContentIssue,
        /// <summary>
        /// BlockedByResponseIssue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("BlockedByResponseIssue")]
        BlockedByResponseIssue,
        /// <summary>
        /// HeavyAdIssue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("HeavyAdIssue")]
        HeavyAdIssue,
        /// <summary>
        /// ContentSecurityPolicyIssue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ContentSecurityPolicyIssue")]
        ContentSecurityPolicyIssue
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// This struct holds a list of optional fields with additional information
    /// specific to the kind of issue. When adding a new issue code, please also
    /// add a new optional field to this type.
    /// </summary>
    public class InspectorIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// SameSiteCookieIssueDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sameSiteCookieIssueDetails")]
        public CefSharp.DevTools.Audits.SameSiteCookieIssueDetails SameSiteCookieIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// MixedContentIssueDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mixedContentIssueDetails")]
        public CefSharp.DevTools.Audits.MixedContentIssueDetails MixedContentIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// BlockedByResponseIssueDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("blockedByResponseIssueDetails")]
        public CefSharp.DevTools.Audits.BlockedByResponseIssueDetails BlockedByResponseIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// HeavyAdIssueDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("heavyAdIssueDetails")]
        public CefSharp.DevTools.Audits.HeavyAdIssueDetails HeavyAdIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// ContentSecurityPolicyIssueDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentSecurityPolicyIssueDetails")]
        public CefSharp.DevTools.Audits.ContentSecurityPolicyIssueDetails ContentSecurityPolicyIssueDetails
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// An inspector issue reported from the back-end.
    /// </summary>
    public class InspectorIssue : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Code
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("code")]
        public CefSharp.DevTools.Audits.InspectorIssueCode Code
        {
            get;
            set;
        }

        /// <summary>
        /// Details
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("details")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.InspectorIssueDetails Details
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.BackgroundService
{
    /// <summary>
    /// The Background Service that will be associated with the commands/events.
    /// Every Background Service operates independently, but they share the same
    /// API.
    /// </summary>
    public enum ServiceName
    {
        /// <summary>
        /// backgroundFetch
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backgroundFetch")]
        BackgroundFetch,
        /// <summary>
        /// backgroundSync
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backgroundSync")]
        BackgroundSync,
        /// <summary>
        /// pushMessaging
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pushMessaging")]
        PushMessaging,
        /// <summary>
        /// notifications
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("notifications")]
        Notifications,
        /// <summary>
        /// paymentHandler
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("paymentHandler")]
        PaymentHandler,
        /// <summary>
        /// periodicBackgroundSync
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("periodicBackgroundSync")]
        PeriodicBackgroundSync
    }
}

namespace CefSharp.DevTools.BackgroundService
{
    /// <summary>
    /// A key-value pair for additional event information to pass along.
    /// </summary>
    public class EventMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Key
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.BackgroundService
{
    /// <summary>
    /// BackgroundServiceEvent
    /// </summary>
    public class BackgroundServiceEvent : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Timestamp of the event (in seconds).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timestamp")]
        public long Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// The origin this event belongs to.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// The Service Worker ID that initiated the event.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("serviceWorkerRegistrationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ServiceWorkerRegistrationId
        {
            get;
            set;
        }

        /// <summary>
        /// The Background Service this event belongs to.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("service")]
        public CefSharp.DevTools.BackgroundService.ServiceName Service
        {
            get;
            set;
        }

        /// <summary>
        /// A description of the event.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("eventName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string EventName
        {
            get;
            set;
        }

        /// <summary>
        /// An identifier that groups related events together.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("instanceId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InstanceId
        {
            get;
            set;
        }

        /// <summary>
        /// A list of event-specific information.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("eventMetadata")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.BackgroundService.EventMetadata> EventMetadata
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// The state of the browser window.
    /// </summary>
    public enum WindowState
    {
        /// <summary>
        /// normal
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("normal")]
        Normal,
        /// <summary>
        /// minimized
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("minimized")]
        Minimized,
        /// <summary>
        /// maximized
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maximized")]
        Maximized,
        /// <summary>
        /// fullscreen
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fullscreen")]
        Fullscreen
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// Browser window bounds information
    /// </summary>
    public class Bounds : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The offset from the left edge of the screen to the window in pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("left")]
        public int? Left
        {
            get;
            set;
        }

        /// <summary>
        /// The offset from the top edge of the screen to the window in pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("top")]
        public int? Top
        {
            get;
            set;
        }

        /// <summary>
        /// The window width in pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("width")]
        public int? Width
        {
            get;
            set;
        }

        /// <summary>
        /// The window height in pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("height")]
        public int? Height
        {
            get;
            set;
        }

        /// <summary>
        /// The window state. Default to normal.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("windowState")]
        public CefSharp.DevTools.Browser.WindowState? WindowState
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// PermissionType
    /// </summary>
    public enum PermissionType
    {
        /// <summary>
        /// accessibilityEvents
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("accessibilityEvents")]
        AccessibilityEvents,
        /// <summary>
        /// audioCapture
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("audioCapture")]
        AudioCapture,
        /// <summary>
        /// backgroundSync
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backgroundSync")]
        BackgroundSync,
        /// <summary>
        /// backgroundFetch
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backgroundFetch")]
        BackgroundFetch,
        /// <summary>
        /// clipboardReadWrite
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("clipboardReadWrite")]
        ClipboardReadWrite,
        /// <summary>
        /// clipboardSanitizedWrite
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("clipboardSanitizedWrite")]
        ClipboardSanitizedWrite,
        /// <summary>
        /// durableStorage
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("durableStorage")]
        DurableStorage,
        /// <summary>
        /// flash
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("flash")]
        Flash,
        /// <summary>
        /// geolocation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("geolocation")]
        Geolocation,
        /// <summary>
        /// midi
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("midi")]
        Midi,
        /// <summary>
        /// midiSysex
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("midiSysex")]
        MidiSysex,
        /// <summary>
        /// nfc
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nfc")]
        Nfc,
        /// <summary>
        /// notifications
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("notifications")]
        Notifications,
        /// <summary>
        /// paymentHandler
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("paymentHandler")]
        PaymentHandler,
        /// <summary>
        /// periodicBackgroundSync
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("periodicBackgroundSync")]
        PeriodicBackgroundSync,
        /// <summary>
        /// protectedMediaIdentifier
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("protectedMediaIdentifier")]
        ProtectedMediaIdentifier,
        /// <summary>
        /// sensors
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sensors")]
        Sensors,
        /// <summary>
        /// videoCapture
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("videoCapture")]
        VideoCapture,
        /// <summary>
        /// idleDetection
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("idleDetection")]
        IdleDetection,
        /// <summary>
        /// wakeLockScreen
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("wakeLockScreen")]
        WakeLockScreen,
        /// <summary>
        /// wakeLockSystem
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("wakeLockSystem")]
        WakeLockSystem
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// PermissionSetting
    /// </summary>
    public enum PermissionSetting
    {
        /// <summary>
        /// granted
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("granted")]
        Granted,
        /// <summary>
        /// denied
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("denied")]
        Denied,
        /// <summary>
        /// prompt
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("prompt")]
        Prompt
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// Definition of PermissionDescriptor defined in the Permissions API:
    /// https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
    /// </summary>
    public class PermissionDescriptor : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name of permission.
        /// See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// For &quot;midi&quot; permission, may also specify sysex control.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sysex")]
        public bool? Sysex
        {
            get;
            set;
        }

        /// <summary>
        /// For &quot;push&quot; permission, may specify userVisibleOnly.
        /// Note that userVisibleOnly = true is the only currently supported type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("userVisibleOnly")]
        public bool? UserVisibleOnly
        {
            get;
            set;
        }

        /// <summary>
        /// For &quot;clipboard&quot; permission, may specify allowWithoutSanitization.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("allowWithoutSanitization")]
        public bool? AllowWithoutSanitization
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// Chrome histogram bucket.
    /// </summary>
    public class Bucket : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Minimum value (inclusive).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("low")]
        public int Low
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum value (exclusive).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("high")]
        public int High
        {
            get;
            set;
        }

        /// <summary>
        /// Number of samples.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("count")]
        public int Count
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// Chrome histogram.
    /// </summary>
    public class Histogram : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Sum of sample values.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sum")]
        public int Sum
        {
            get;
            set;
        }

        /// <summary>
        /// Total number of samples.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("count")]
        public int Count
        {
            get;
            set;
        }

        /// <summary>
        /// Buckets.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("buckets")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Browser.Bucket> Buckets
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Stylesheet type: &quot;injected&quot; for stylesheets injected via extension, &quot;user-agent&quot; for user-agent
    /// stylesheets, &quot;inspector&quot; for stylesheets created by the inspector (i.e. those holding the &quot;via
    /// inspector&quot; rules), &quot;regular&quot; for regular stylesheets.
    /// </summary>
    public enum StyleSheetOrigin
    {
        /// <summary>
        /// injected
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("injected")]
        Injected,
        /// <summary>
        /// user-agent
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("user-agent")]
        UserAgent,
        /// <summary>
        /// inspector
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inspector")]
        Inspector,
        /// <summary>
        /// regular
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("regular")]
        Regular
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS rule collection for a single pseudo style.
    /// </summary>
    public class PseudoElementMatches : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Pseudo element type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pseudoType")]
        public CefSharp.DevTools.DOM.PseudoType PseudoType
        {
            get;
            set;
        }

        /// <summary>
        /// Matches of CSS rules applicable to the pseudo style.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("matches")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleMatch> Matches
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Inherited CSS rule collection from ancestor node.
    /// </summary>
    public class InheritedStyleEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The ancestor node&apos;s inline style, if any, in the style inheritance chain.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inlineStyle")]
        public CefSharp.DevTools.CSS.CSSStyle InlineStyle
        {
            get;
            set;
        }

        /// <summary>
        /// Matches of CSS rules matching the ancestor node in the style inheritance chain.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("matchedCSSRules")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleMatch> MatchedCSSRules
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Match data for a CSS rule.
    /// </summary>
    public class RuleMatch : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CSS rule in the match.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rule")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.CSSRule Rule
        {
            get;
            set;
        }

        /// <summary>
        /// Matching selector indices in the rule&apos;s selectorList selectors (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("matchingSelectors")]
        public int[] MatchingSelectors
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Data for a simple selector (these are delimited by commas in a selector list).
    /// </summary>
    public class Value : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Value text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Value range in the underlying resource (if available).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Selector list data.
    /// </summary>
    public class SelectorList : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Selectors in the list.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("selectors")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.Value> Selectors
        {
            get;
            set;
        }

        /// <summary>
        /// Rule selector text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS stylesheet metainformation.
    /// </summary>
    public class CSSStyleSheetHeader : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The stylesheet identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleSheetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Owner frame identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// Stylesheet resource URL.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sourceURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// URL of source map associated with the stylesheet (if any).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sourceMapURL")]
        public string SourceMapURL
        {
            get;
            set;
        }

        /// <summary>
        /// Stylesheet origin.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        public CefSharp.DevTools.CSS.StyleSheetOrigin Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Stylesheet title.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// The backend id for the owner node of the stylesheet.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ownerNode")]
        public int? OwnerNode
        {
            get;
            set;
        }

        /// <summary>
        /// Denotes whether the stylesheet is disabled.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("disabled")]
        public bool Disabled
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the sourceURL field value comes from the sourceURL comment.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hasSourceURL")]
        public bool? HasSourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
        /// document.written STYLE tags.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isInline")]
        public bool IsInline
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this stylesheet is mutable. Inline stylesheets become mutable
        /// after they have been modified via CSSOM API.
        /// &lt;link&gt; element&apos;s stylesheets become mutable only if DevTools modifies them.
        /// Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isMutable")]
        public bool IsMutable
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this stylesheet is a constructed stylesheet (created using new CSSStyleSheet()).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isConstructed")]
        public bool IsConstructed
        {
            get;
            set;
        }

        /// <summary>
        /// Line offset of the stylesheet within the resource (zero based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startLine")]
        public long StartLine
        {
            get;
            set;
        }

        /// <summary>
        /// Column offset of the stylesheet within the resource (zero based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startColumn")]
        public long StartColumn
        {
            get;
            set;
        }

        /// <summary>
        /// Size of the content (in characters).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("length")]
        public long Length
        {
            get;
            set;
        }

        /// <summary>
        /// Line offset of the end of the stylesheet within the resource (zero based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endLine")]
        public long EndLine
        {
            get;
            set;
        }

        /// <summary>
        /// Column offset of the end of the stylesheet within the resource (zero based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endColumn")]
        public long EndColumn
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS rule representation.
    /// </summary>
    public class CSSRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Rule selector data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("selectorList")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.SelectorList SelectorList
        {
            get;
            set;
        }

        /// <summary>
        /// Parent stylesheet&apos;s origin.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        public CefSharp.DevTools.CSS.StyleSheetOrigin Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Associated style declaration.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("style")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.CSSStyle Style
        {
            get;
            set;
        }

        /// <summary>
        /// Media list array (for rules involving media queries). The array enumerates media queries
        /// starting with the innermost one, going outwards.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("media")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSMedia> Media
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS coverage information.
    /// </summary>
    public class RuleUsage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleSheetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Offset of the start of the rule (including selector) from the beginning of the stylesheet.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startOffset")]
        public long StartOffset
        {
            get;
            set;
        }

        /// <summary>
        /// Offset of the end of the rule body from the beginning of the stylesheet.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endOffset")]
        public long EndOffset
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the rule was actually used by some element in the page.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("used")]
        public bool Used
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Text range within a resource. All numbers are zero-based.
    /// </summary>
    public class SourceRange : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Start line of range.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startLine")]
        public int StartLine
        {
            get;
            set;
        }

        /// <summary>
        /// Start column of range (inclusive).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startColumn")]
        public int StartColumn
        {
            get;
            set;
        }

        /// <summary>
        /// End line of range
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endLine")]
        public int EndLine
        {
            get;
            set;
        }

        /// <summary>
        /// End column of range (exclusive).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endColumn")]
        public int EndColumn
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// ShorthandEntry
    /// </summary>
    public class ShorthandEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Shorthand name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Shorthand value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property has &quot;!important&quot; annotation (implies `false` if absent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("important")]
        public bool? Important
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSSComputedStyleProperty
    /// </summary>
    public class CSSComputedStyleProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Computed style property name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Computed style property value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS style representation.
    /// </summary>
    public class CSSStyle : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// CSS properties in the style.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cssProperties")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSProperty> CssProperties
        {
            get;
            set;
        }

        /// <summary>
        /// Computed values for all shorthands found in the style.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shorthandEntries")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.ShorthandEntry> ShorthandEntries
        {
            get;
            set;
        }

        /// <summary>
        /// Style declaration text (if available).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cssText")]
        public string CssText
        {
            get;
            set;
        }

        /// <summary>
        /// Style declaration range in the enclosing stylesheet (if available).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS property declaration data.
    /// </summary>
    public class CSSProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The property name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The property value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property has &quot;!important&quot; annotation (implies `false` if absent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("important")]
        public bool? Important
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property is implicit (implies `false` if absent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("implicit")]
        public bool? Implicit
        {
            get;
            set;
        }

        /// <summary>
        /// The full property text as specified in the style.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property is understood by the browser (implies `true` if absent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parsedOk")]
        public bool? ParsedOk
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property is disabled by the user (present for source-based properties only).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("disabled")]
        public bool? Disabled
        {
            get;
            set;
        }

        /// <summary>
        /// The entire property range in the enclosing style declaration (if available).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS media rule descriptor.
    /// </summary>
    public class CSSMedia : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Media query text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Source of the media query: &quot;mediaRule&quot; if specified by a @media rule, &quot;importRule&quot; if
        /// specified by an @import rule, &quot;linkedSheet&quot; if specified by a &quot;media&quot; attribute in a linked
        /// stylesheet&apos;s LINK tag, &quot;inlineSheet&quot; if specified by a &quot;media&quot; attribute in an inline
        /// stylesheet&apos;s STYLE tag.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("source")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Source
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the document containing the media query description.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sourceURL")]
        public string SourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// The associated rule (@media or @import) header range in the enclosing stylesheet (if
        /// available).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the stylesheet containing this object (if exists).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Array of media queries.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mediaList")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.MediaQuery> MediaList
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Media query descriptor.
    /// </summary>
    public class MediaQuery : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Array of media query expressions.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("expressions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.MediaQueryExpression> Expressions
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the media query condition is satisfied.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("active")]
        public bool Active
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Media query expression descriptor.
    /// </summary>
    public class MediaQueryExpression : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Media query expression value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public long Value
        {
            get;
            set;
        }

        /// <summary>
        /// Media query expression units.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unit")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Unit
        {
            get;
            set;
        }

        /// <summary>
        /// Media query expression feature.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("feature")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Feature
        {
            get;
            set;
        }

        /// <summary>
        /// The associated range of the value text in the enclosing stylesheet (if available).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("valueRange")]
        public CefSharp.DevTools.CSS.SourceRange ValueRange
        {
            get;
            set;
        }

        /// <summary>
        /// Computed length of media query expression (if applicable).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("computedLength")]
        public long? ComputedLength
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Information about amount of glyphs that were rendered with given font.
    /// </summary>
    public class PlatformFontUsage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Font&apos;s family name reported by platform.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("familyName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FamilyName
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates if the font was downloaded or resolved locally.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isCustomFont")]
        public bool IsCustomFont
        {
            get;
            set;
        }

        /// <summary>
        /// Amount of glyphs that were rendered with this font.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("glyphCount")]
        public long GlyphCount
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Information about font variation axes for variable fonts
    /// </summary>
    public class FontVariationAxis : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The font-variation-setting tag (a.k.a. &quot;axis tag&quot;).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("tag")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Tag
        {
            get;
            set;
        }

        /// <summary>
        /// Human-readable variation name in the default language (normally, &quot;en&quot;).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The minimum value (inclusive) the font supports for this tag.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("minValue")]
        public long MinValue
        {
            get;
            set;
        }

        /// <summary>
        /// The maximum value (inclusive) the font supports for this tag.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maxValue")]
        public long MaxValue
        {
            get;
            set;
        }

        /// <summary>
        /// The default value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("defaultValue")]
        public long DefaultValue
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
    /// and additional information such as platformFontFamily and fontVariationAxes.
    /// </summary>
    public class FontFace : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The font-family.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fontFamily")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontFamily
        {
            get;
            set;
        }

        /// <summary>
        /// The font-style.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fontStyle")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontStyle
        {
            get;
            set;
        }

        /// <summary>
        /// The font-variant.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fontVariant")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontVariant
        {
            get;
            set;
        }

        /// <summary>
        /// The font-weight.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fontWeight")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontWeight
        {
            get;
            set;
        }

        /// <summary>
        /// The font-stretch.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fontStretch")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontStretch
        {
            get;
            set;
        }

        /// <summary>
        /// The unicode-range.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unicodeRange")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string UnicodeRange
        {
            get;
            set;
        }

        /// <summary>
        /// The src.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("src")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Src
        {
            get;
            set;
        }

        /// <summary>
        /// The resolved platform font family
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("platformFontFamily")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlatformFontFamily
        {
            get;
            set;
        }

        /// <summary>
        /// Available variation settings (a.k.a. &quot;axes&quot;).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fontVariationAxes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.FontVariationAxis> FontVariationAxes
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS keyframes rule representation.
    /// </summary>
    public class CSSKeyframesRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Animation name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("animationName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.Value AnimationName
        {
            get;
            set;
        }

        /// <summary>
        /// List of keyframes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyframes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSKeyframeRule> Keyframes
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CSS keyframe rule representation.
    /// </summary>
    public class CSSKeyframeRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Parent stylesheet&apos;s origin.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        public CefSharp.DevTools.CSS.StyleSheetOrigin Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Associated key text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.Value KeyText
        {
            get;
            set;
        }

        /// <summary>
        /// Associated style declaration.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("style")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.CSSStyle Style
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// A descriptor of operation to mutate style declaration text.
    /// </summary>
    public class StyleDeclarationEdit : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleSheetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// The range of the style text in the enclosing stylesheet.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("range")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// New style text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// type of HTTP response cached
    /// </summary>
    public enum CachedResponseType
    {
        /// <summary>
        /// basic
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("basic")]
        Basic,
        /// <summary>
        /// cors
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cors")]
        Cors,
        /// <summary>
        /// default
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("default")]
        Default,
        /// <summary>
        /// error
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("error")]
        Error,
        /// <summary>
        /// opaqueResponse
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("opaqueResponse")]
        OpaqueResponse,
        /// <summary>
        /// opaqueRedirect
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("opaqueRedirect")]
        OpaqueRedirect
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// Data entry.
    /// </summary>
    public class DataEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Request URL.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestURL
        {
            get;
            set;
        }

        /// <summary>
        /// Request method.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestMethod")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestMethod
        {
            get;
            set;
        }

        /// <summary>
        /// Request headers
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestHeaders")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Header> RequestHeaders
        {
            get;
            set;
        }

        /// <summary>
        /// Number of seconds since epoch.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("responseTime")]
        public long ResponseTime
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status code.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("responseStatus")]
        public int ResponseStatus
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("responseStatusText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ResponseStatusText
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response type
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("responseType")]
        public CefSharp.DevTools.CacheStorage.CachedResponseType ResponseType
        {
            get;
            set;
        }

        /// <summary>
        /// Response headers
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("responseHeaders")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Header> ResponseHeaders
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// Cache identifier.
    /// </summary>
    public class Cache : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// An opaque unique id of the cache.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cacheId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CacheId
        {
            get;
            set;
        }

        /// <summary>
        /// Security origin of the cache.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SecurityOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// The name of the cache.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cacheName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CacheName
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// Header
    /// </summary>
    public class Header : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// Cached response
    /// </summary>
    public class CachedResponse : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Entry content, base64-encoded.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("body")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] Body
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Cast
{
    /// <summary>
    /// Sink
    /// </summary>
    public class Sink : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Id
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Text describing the current session. Present only if there is an active
        /// session on the sink.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("session")]
        public string Session
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// Backend node with a friendly name.
    /// </summary>
    public class BackendNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `Node`&apos;s nodeType.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeType")]
        public int NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeName.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeName
        {
            get;
            set;
        }

        /// <summary>
        /// BackendNodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int BackendNodeId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// Pseudo element type.
    /// </summary>
    public enum PseudoType
    {
        /// <summary>
        /// first-line
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("first-line")]
        FirstLine,
        /// <summary>
        /// first-letter
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("first-letter")]
        FirstLetter,
        /// <summary>
        /// before
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("before")]
        Before,
        /// <summary>
        /// after
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("after")]
        After,
        /// <summary>
        /// marker
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("marker")]
        Marker,
        /// <summary>
        /// backdrop
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backdrop")]
        Backdrop,
        /// <summary>
        /// selection
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("selection")]
        Selection,
        /// <summary>
        /// first-line-inherited
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("first-line-inherited")]
        FirstLineInherited,
        /// <summary>
        /// scrollbar
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollbar")]
        Scrollbar,
        /// <summary>
        /// scrollbar-thumb
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollbar-thumb")]
        ScrollbarThumb,
        /// <summary>
        /// scrollbar-button
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollbar-button")]
        ScrollbarButton,
        /// <summary>
        /// scrollbar-track
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollbar-track")]
        ScrollbarTrack,
        /// <summary>
        /// scrollbar-track-piece
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollbar-track-piece")]
        ScrollbarTrackPiece,
        /// <summary>
        /// scrollbar-corner
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollbar-corner")]
        ScrollbarCorner,
        /// <summary>
        /// resizer
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resizer")]
        Resizer,
        /// <summary>
        /// input-list-button
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("input-list-button")]
        InputListButton
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// Shadow root type.
    /// </summary>
    public enum ShadowRootType
    {
        /// <summary>
        /// user-agent
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("user-agent")]
        UserAgent,
        /// <summary>
        /// open
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("open")]
        Open,
        /// <summary>
        /// closed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("closed")]
        Closed
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
    /// DOMNode is a base node mirror type.
    /// </summary>
    public class Node : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
        /// will only push node with given `id` once. It is aware of all requested nodes and will only
        /// fire DOM events for nodes known to the client.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// The id of the parent node if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parentId")]
        public int? ParentId
        {
            get;
            set;
        }

        /// <summary>
        /// The BackendNodeId for this node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeType.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeType")]
        public int NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeName.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeName
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s localName.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("localName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LocalName
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeValue.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeValue")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeValue
        {
            get;
            set;
        }

        /// <summary>
        /// Child count for `Container` nodes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("childNodeCount")]
        public int? ChildNodeCount
        {
            get;
            set;
        }

        /// <summary>
        /// Child nodes of this node when requested with children.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("children")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.Node> Children
        {
            get;
            set;
        }

        /// <summary>
        /// Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attributes")]
        public string[] Attributes
        {
            get;
            set;
        }

        /// <summary>
        /// Document URL that `Document` or `FrameOwner` node points to.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("documentURL")]
        public string DocumentURL
        {
            get;
            set;
        }

        /// <summary>
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("baseURL")]
        public string BaseURL
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType`&apos;s publicId.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("publicId")]
        public string PublicId
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType`&apos;s systemId.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("systemId")]
        public string SystemId
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType`&apos;s internalSubset.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("internalSubset")]
        public string InternalSubset
        {
            get;
            set;
        }

        /// <summary>
        /// `Document`&apos;s XML version in case of XML documents.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("xmlVersion")]
        public string XmlVersion
        {
            get;
            set;
        }

        /// <summary>
        /// `Attr`&apos;s name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// `Attr`&apos;s value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Pseudo element type for this node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pseudoType")]
        public CefSharp.DevTools.DOM.PseudoType? PseudoType
        {
            get;
            set;
        }

        /// <summary>
        /// Shadow root type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shadowRootType")]
        public CefSharp.DevTools.DOM.ShadowRootType? ShadowRootType
        {
            get;
            set;
        }

        /// <summary>
        /// Frame ID for frame owner elements.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameId")]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// Content document for frame owner elements.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentDocument")]
        public CefSharp.DevTools.DOM.Node ContentDocument
        {
            get;
            set;
        }

        /// <summary>
        /// Shadow root list for given element host.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shadowRoots")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.Node> ShadowRoots
        {
            get;
            set;
        }

        /// <summary>
        /// Content document fragment for template elements.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("templateContent")]
        public CefSharp.DevTools.DOM.Node TemplateContent
        {
            get;
            set;
        }

        /// <summary>
        /// Pseudo elements associated with this node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pseudoElements")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.Node> PseudoElements
        {
            get;
            set;
        }

        /// <summary>
        /// Import document for the HTMLImport links.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("importedDocument")]
        public CefSharp.DevTools.DOM.Node ImportedDocument
        {
            get;
            set;
        }

        /// <summary>
        /// Distributed nodes for given insertion point.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("distributedNodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.BackendNode> DistributedNodes
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the node is SVG.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isSVG")]
        public bool? IsSVG
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// A structure holding an RGBA color.
    /// </summary>
    public class RGBA : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The red component, in the [0-255] range.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("r")]
        public int R
        {
            get;
            set;
        }

        /// <summary>
        /// The green component, in the [0-255] range.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("g")]
        public int G
        {
            get;
            set;
        }

        /// <summary>
        /// The blue component, in the [0-255] range.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("b")]
        public int B
        {
            get;
            set;
        }

        /// <summary>
        /// The alpha component, in the [0-1] range (default: 1).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("a")]
        public long? A
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// Box model.
    /// </summary>
    public class BoxModel : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Content box
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("content")]
        public long[] Content
        {
            get;
            set;
        }

        /// <summary>
        /// Padding box
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("padding")]
        public long[] Padding
        {
            get;
            set;
        }

        /// <summary>
        /// Border box
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("border")]
        public long[] Border
        {
            get;
            set;
        }

        /// <summary>
        /// Margin box
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("margin")]
        public long[] Margin
        {
            get;
            set;
        }

        /// <summary>
        /// Node width
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("width")]
        public int Width
        {
            get;
            set;
        }

        /// <summary>
        /// Node height
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("height")]
        public int Height
        {
            get;
            set;
        }

        /// <summary>
        /// Shape outside coordinates
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shapeOutside")]
        public CefSharp.DevTools.DOM.ShapeOutsideInfo ShapeOutside
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// CSS Shape Outside details.
    /// </summary>
    public class ShapeOutsideInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Shape bounds
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bounds")]
        public long[] Bounds
        {
            get;
            set;
        }

        /// <summary>
        /// Shape coordinate details
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shape")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public object[] Shape
        {
            get;
            set;
        }

        /// <summary>
        /// Margin shape bounds
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("marginShape")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public object[] MarginShape
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// Rectangle.
    /// </summary>
    public class Rect : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// X coordinate
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("x")]
        public long X
        {
            get;
            set;
        }

        /// <summary>
        /// Y coordinate
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("y")]
        public long Y
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangle width
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("width")]
        public long Width
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangle height
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("height")]
        public long Height
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// CSSComputedStyleProperty
    /// </summary>
    public class CSSComputedStyleProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Computed style property name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Computed style property value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMDebugger
{
    /// <summary>
    /// DOM breakpoint type.
    /// </summary>
    public enum DOMBreakpointType
    {
        /// <summary>
        /// subtree-modified
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subtree-modified")]
        SubtreeModified,
        /// <summary>
        /// attribute-modified
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attribute-modified")]
        AttributeModified,
        /// <summary>
        /// node-removed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("node-removed")]
        NodeRemoved
    }
}

namespace CefSharp.DevTools.DOMDebugger
{
    /// <summary>
    /// Object event listener.
    /// </summary>
    public class EventListener : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `EventListener`&apos;s type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// `EventListener`&apos;s useCapture.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("useCapture")]
        public bool UseCapture
        {
            get;
            set;
        }

        /// <summary>
        /// `EventListener`&apos;s passive flag.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("passive")]
        public bool Passive
        {
            get;
            set;
        }

        /// <summary>
        /// `EventListener`&apos;s once flag.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("once")]
        public bool Once
        {
            get;
            set;
        }

        /// <summary>
        /// Script id of the handler code.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Line number in the script (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Column number in the script (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Event handler function value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("handler")]
        public CefSharp.DevTools.Runtime.RemoteObject Handler
        {
            get;
            set;
        }

        /// <summary>
        /// Event original handler function value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("originalHandler")]
        public CefSharp.DevTools.Runtime.RemoteObject OriginalHandler
        {
            get;
            set;
        }

        /// <summary>
        /// Node the listener is added to (if any).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int? BackendNodeId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// A Node in the DOM tree.
    /// </summary>
    public class DOMNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `Node`&apos;s nodeType.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeType")]
        public int NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeName.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeName
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeValue.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeValue")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for textarea elements, contains the text value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("textValue")]
        public string TextValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for input elements, contains the input&apos;s associated text value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inputValue")]
        public string InputValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for radio and checkbox input elements, indicates if the element has been checked
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inputChecked")]
        public bool? InputChecked
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for option elements, indicates if the element has been selected
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("optionSelected")]
        public bool? OptionSelected
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s id, corresponds to DOM.Node.backendNodeId.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// The indexes of the node&apos;s child nodes in the `domNodes` array returned by `getSnapshot`, if
        /// any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("childNodeIndexes")]
        public int[] ChildNodeIndexes
        {
            get;
            set;
        }

        /// <summary>
        /// Attributes of an `Element` node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attributes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMSnapshot.NameValue> Attributes
        {
            get;
            set;
        }

        /// <summary>
        /// Indexes of pseudo elements associated with this node in the `domNodes` array returned by
        /// `getSnapshot`, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pseudoElementIndexes")]
        public int[] PseudoElementIndexes
        {
            get;
            set;
        }

        /// <summary>
        /// The index of the node&apos;s related layout tree node in the `layoutTreeNodes` array returned by
        /// `getSnapshot`, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("layoutNodeIndex")]
        public int? LayoutNodeIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Document URL that `Document` or `FrameOwner` node points to.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("documentURL")]
        public string DocumentURL
        {
            get;
            set;
        }

        /// <summary>
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("baseURL")]
        public string BaseURL
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for documents, contains the document&apos;s content language.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentLanguage")]
        public string ContentLanguage
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for documents, contains the document&apos;s character set encoding.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("documentEncoding")]
        public string DocumentEncoding
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType` node&apos;s publicId.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("publicId")]
        public string PublicId
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType` node&apos;s systemId.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("systemId")]
        public string SystemId
        {
            get;
            set;
        }

        /// <summary>
        /// Frame ID for frame owner elements and also for the document node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameId")]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// The index of a frame owner element&apos;s content document in the `domNodes` array returned by
        /// `getSnapshot`, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentDocumentIndex")]
        public int? ContentDocumentIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Type of a pseudo element node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pseudoType")]
        public CefSharp.DevTools.DOM.PseudoType? PseudoType
        {
            get;
            set;
        }

        /// <summary>
        /// Shadow root type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shadowRootType")]
        public CefSharp.DevTools.DOM.ShadowRootType? ShadowRootType
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this DOM node responds to mouse clicks. This includes nodes that have had click
        /// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
        /// clicked.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isClickable")]
        public bool? IsClickable
        {
            get;
            set;
        }

        /// <summary>
        /// Details of the node&apos;s event listeners, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("eventListeners")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMDebugger.EventListener> EventListeners
        {
            get;
            set;
        }

        /// <summary>
        /// The selected url for nodes with a srcset attribute.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("currentSourceURL")]
        public string CurrentSourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// The url of the script (if any) that generates this node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("originURL")]
        public string OriginURL
        {
            get;
            set;
        }

        /// <summary>
        /// Scroll offsets, set when this node is a Document.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollOffsetX")]
        public long? ScrollOffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// ScrollOffsetY
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollOffsetY")]
        public long? ScrollOffsetY
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// Details of post layout rendered text positions. The exact layout should not be regarded as
    /// stable and may change between versions.
    /// </summary>
    public class InlineTextBox : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("boundingBox")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect BoundingBox
        {
            get;
            set;
        }

        /// <summary>
        /// The starting index in characters, for this post layout textbox substring. Characters that
        /// would be represented as a surrogate pair in UTF-16 have length 2.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startCharacterIndex")]
        public int StartCharacterIndex
        {
            get;
            set;
        }

        /// <summary>
        /// The number of characters in this post layout textbox substring. Characters that would be
        /// represented as a surrogate pair in UTF-16 have length 2.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("numCharacters")]
        public int NumCharacters
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// Details of an element in the DOM tree with a LayoutObject.
    /// </summary>
    public class LayoutTreeNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("domNodeIndex")]
        public int DomNodeIndex
        {
            get;
            set;
        }

        /// <summary>
        /// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("boundingBox")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect BoundingBox
        {
            get;
            set;
        }

        /// <summary>
        /// Contents of the LayoutText, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("layoutText")]
        public string LayoutText
        {
            get;
            set;
        }

        /// <summary>
        /// The post-layout inline text nodes, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inlineTextNodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMSnapshot.InlineTextBox> InlineTextNodes
        {
            get;
            set;
        }

        /// <summary>
        /// Index into the `computedStyles` array returned by `getSnapshot`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleIndex")]
        public int? StyleIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Global paint order index, which is determined by the stacking order of the nodes. Nodes
        /// that are painted together will have the same index. Only provided if includePaintOrder in
        /// getSnapshot was true.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("paintOrder")]
        public int? PaintOrder
        {
            get;
            set;
        }

        /// <summary>
        /// Set to true to indicate the element begins a new stacking context.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isStackingContext")]
        public bool? IsStackingContext
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// A subset of the full ComputedStyle as defined by the request whitelist.
    /// </summary>
    public class ComputedStyle : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name/value pairs of computed style properties.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("properties")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMSnapshot.NameValue> Properties
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// A name/value pair.
    /// </summary>
    public class NameValue : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Attribute/property name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Attribute/property value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// Data that is only present on rare nodes.
    /// </summary>
    public class RareStringData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("index")]
        public int[] Index
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public int[] Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// RareBooleanData
    /// </summary>
    public class RareBooleanData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("index")]
        public int[] Index
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// RareIntegerData
    /// </summary>
    public class RareIntegerData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("index")]
        public int[] Index
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public int[] Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// Document snapshot.
    /// </summary>
    public class DocumentSnapshot : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Document URL that `Document` or `FrameOwner` node points to.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("documentURL")]
        public int DocumentURL
        {
            get;
            set;
        }

        /// <summary>
        /// Document title.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("title")]
        public int Title
        {
            get;
            set;
        }

        /// <summary>
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("baseURL")]
        public int BaseURL
        {
            get;
            set;
        }

        /// <summary>
        /// Contains the document&apos;s content language.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentLanguage")]
        public int ContentLanguage
        {
            get;
            set;
        }

        /// <summary>
        /// Contains the document&apos;s character set encoding.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("encodingName")]
        public int EncodingName
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType` node&apos;s publicId.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("publicId")]
        public int PublicId
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType` node&apos;s systemId.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("systemId")]
        public int SystemId
        {
            get;
            set;
        }

        /// <summary>
        /// Frame ID for frame owner elements and also for the document node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameId")]
        public int FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// A table with dom nodes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMSnapshot.NodeTreeSnapshot Nodes
        {
            get;
            set;
        }

        /// <summary>
        /// The nodes in the layout tree.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("layout")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMSnapshot.LayoutTreeSnapshot Layout
        {
            get;
            set;
        }

        /// <summary>
        /// The post-layout inline text nodes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("textBoxes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMSnapshot.TextBoxSnapshot TextBoxes
        {
            get;
            set;
        }

        /// <summary>
        /// Horizontal scroll offset.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollOffsetX")]
        public long? ScrollOffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// Vertical scroll offset.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollOffsetY")]
        public long? ScrollOffsetY
        {
            get;
            set;
        }

        /// <summary>
        /// Document content width.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentWidth")]
        public long? ContentWidth
        {
            get;
            set;
        }

        /// <summary>
        /// Document content height.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentHeight")]
        public long? ContentHeight
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// Table containing nodes.
    /// </summary>
    public class NodeTreeSnapshot : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Parent node index.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parentIndex")]
        public int[] ParentIndex
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeType.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeType")]
        public int[] NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeName.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeName")]
        public int[] NodeName
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeValue.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeValue")]
        public int[] NodeValue
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s id, corresponds to DOM.Node.backendNodeId.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int[] BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Attributes of an `Element` node. Flatten name, value pairs.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attributes")]
        public int[] Attributes
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for textarea elements, contains the text value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("textValue")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData TextValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for input elements, contains the input&apos;s associated text value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inputValue")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData InputValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for radio and checkbox input elements, indicates if the element has been checked
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inputChecked")]
        public CefSharp.DevTools.DOMSnapshot.RareBooleanData InputChecked
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for option elements, indicates if the element has been selected
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("optionSelected")]
        public CefSharp.DevTools.DOMSnapshot.RareBooleanData OptionSelected
        {
            get;
            set;
        }

        /// <summary>
        /// The index of the document in the list of the snapshot documents.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentDocumentIndex")]
        public CefSharp.DevTools.DOMSnapshot.RareIntegerData ContentDocumentIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Type of a pseudo element node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pseudoType")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData PseudoType
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this DOM node responds to mouse clicks. This includes nodes that have had click
        /// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
        /// clicked.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isClickable")]
        public CefSharp.DevTools.DOMSnapshot.RareBooleanData IsClickable
        {
            get;
            set;
        }

        /// <summary>
        /// The selected url for nodes with a srcset attribute.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("currentSourceURL")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData CurrentSourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// The url of the script (if any) that generates this node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("originURL")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData OriginURL
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// Table of details of an element in the DOM tree with a LayoutObject.
    /// </summary>
    public class LayoutTreeSnapshot : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeIndex")]
        public int[] NodeIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styles")]
        public int[] Styles
        {
            get;
            set;
        }

        /// <summary>
        /// The absolute position bounding box.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bounds")]
        public long[] Bounds
        {
            get;
            set;
        }

        /// <summary>
        /// Contents of the LayoutText, if any.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        public int[] Text
        {
            get;
            set;
        }

        /// <summary>
        /// Stacking context information.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stackingContexts")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMSnapshot.RareBooleanData StackingContexts
        {
            get;
            set;
        }

        /// <summary>
        /// Global paint order index, which is determined by the stacking order of the nodes. Nodes
        /// that are painted together will have the same index. Only provided if includePaintOrder in
        /// captureSnapshot was true.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("paintOrders")]
        public int[] PaintOrders
        {
            get;
            set;
        }

        /// <summary>
        /// The offset rect of nodes. Only available when includeDOMRects is set to true
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offsetRects")]
        public long[] OffsetRects
        {
            get;
            set;
        }

        /// <summary>
        /// The scroll rect of nodes. Only available when includeDOMRects is set to true
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollRects")]
        public long[] ScrollRects
        {
            get;
            set;
        }

        /// <summary>
        /// The client rect of nodes. Only available when includeDOMRects is set to true
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("clientRects")]
        public long[] ClientRects
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// Table of details of the post layout rendered text positions. The exact layout should not be regarded as
    /// stable and may change between versions.
    /// </summary>
    public class TextBoxSnapshot : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index of the layout tree node that owns this box collection.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("layoutIndex")]
        public int[] LayoutIndex
        {
            get;
            set;
        }

        /// <summary>
        /// The absolute position bounding box.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bounds")]
        public long[] Bounds
        {
            get;
            set;
        }

        /// <summary>
        /// The starting index in characters, for this post layout textbox substring. Characters that
        /// would be represented as a surrogate pair in UTF-16 have length 2.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("start")]
        public int[] Start
        {
            get;
            set;
        }

        /// <summary>
        /// The number of characters in this post layout textbox substring. Characters that would be
        /// represented as a surrogate pair in UTF-16 have length 2.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("length")]
        public int[] Length
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMStorage
{
    /// <summary>
    /// DOM Storage identifier.
    /// </summary>
    public class StorageId : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Security origin for the storage.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SecurityOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the storage is local storage (not session storage).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isLocalStorage")]
        public bool IsLocalStorage
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Database
{
    /// <summary>
    /// Database object.
    /// </summary>
    public class Database : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Database ID.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Database domain.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("domain")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Domain
        {
            get;
            set;
        }

        /// <summary>
        /// Database name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Database version.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("version")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Version
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Database
{
    /// <summary>
    /// Database error.
    /// </summary>
    public class Error : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Error message.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            set;
        }

        /// <summary>
        /// Error code.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("code")]
        public int Code
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// Screen orientation.
    /// </summary>
    public class ScreenOrientation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Orientation type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Orientation angle.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("angle")]
        public int Angle
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// DisplayFeature
    /// </summary>
    public class DisplayFeature : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Orientation of a display feature in relation to screen
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("orientation")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Orientation
        {
            get;
            set;
        }

        /// <summary>
        /// The offset from the screen origin in either the x (for vertical
        /// orientation) or y (for horizontal orientation) direction.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offset")]
        public int Offset
        {
            get;
            set;
        }

        /// <summary>
        /// A display feature may mask content such that it is not physically
        /// displayed - this length along with the offset describes this area.
        /// A display feature that only splits content will have a 0 mask_length.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maskLength")]
        public int MaskLength
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// MediaFeature
    /// </summary>
    public class MediaFeature : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
    /// allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
    /// pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
    /// resource fetches.
    /// </summary>
    public enum VirtualTimePolicy
    {
        /// <summary>
        /// advance
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("advance")]
        Advance,
        /// <summary>
        /// pause
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pause")]
        Pause,
        /// <summary>
        /// pauseIfNetworkFetchesPending
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pauseIfNetworkFetchesPending")]
        PauseIfNetworkFetchesPending
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
    /// </summary>
    public class UserAgentBrandVersion : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Brand
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("brand")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Brand
        {
            get;
            set;
        }

        /// <summary>
        /// Version
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("version")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Version
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
    /// </summary>
    public class UserAgentMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Brands
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("brands")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Emulation.UserAgentBrandVersion> Brands
        {
            get;
            set;
        }

        /// <summary>
        /// FullVersion
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fullVersion")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FullVersion
        {
            get;
            set;
        }

        /// <summary>
        /// Platform
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("platform")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Platform
        {
            get;
            set;
        }

        /// <summary>
        /// PlatformVersion
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("platformVersion")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlatformVersion
        {
            get;
            set;
        }

        /// <summary>
        /// Architecture
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("architecture")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Architecture
        {
            get;
            set;
        }

        /// <summary>
        /// Model
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("model")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Model
        {
            get;
            set;
        }

        /// <summary>
        /// Mobile
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mobile")]
        public bool Mobile
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.HeadlessExperimental
{
    /// <summary>
    /// Encoding options for a screenshot.
    /// </summary>
    public class ScreenshotParams : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Image compression format (defaults to png).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("format")]
        public string Format
        {
            get;
            set;
        }

        /// <summary>
        /// Compression quality from range [0..100] (jpeg only).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("quality")]
        public int? Quality
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// Database with an array of object stores.
    /// </summary>
    public class DatabaseWithObjectStores : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Database name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Database version (type is not &apos;integer&apos;, as the standard
        /// requires the version number to be &apos;unsigned long long&apos;)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("version")]
        public long Version
        {
            get;
            set;
        }

        /// <summary>
        /// Object stores in this database.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("objectStores")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.IndexedDB.ObjectStore> ObjectStores
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// Object store.
    /// </summary>
    public class ObjectStore : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Object store name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Object store key path.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyPath")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.IndexedDB.KeyPath KeyPath
        {
            get;
            set;
        }

        /// <summary>
        /// If true, object store has auto increment flag set.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("autoIncrement")]
        public bool AutoIncrement
        {
            get;
            set;
        }

        /// <summary>
        /// Indexes in this object store.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("indexes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.IndexedDB.ObjectStoreIndex> Indexes
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// Object store index.
    /// </summary>
    public class ObjectStoreIndex : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Index key path.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyPath")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.IndexedDB.KeyPath KeyPath
        {
            get;
            set;
        }

        /// <summary>
        /// If true, index is unique.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unique")]
        public bool Unique
        {
            get;
            set;
        }

        /// <summary>
        /// If true, index allows multiple entries for a key.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("multiEntry")]
        public bool MultiEntry
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// Key.
    /// </summary>
    public class Key : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Number value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("number")]
        public long? Number
        {
            get;
            set;
        }

        /// <summary>
        /// String value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("string")]
        public string String
        {
            get;
            set;
        }

        /// <summary>
        /// Date value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("date")]
        public long? Date
        {
            get;
            set;
        }

        /// <summary>
        /// Array value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("array")]
        public System.Collections.Generic.IList<CefSharp.DevTools.IndexedDB.Key> Array
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// Key range.
    /// </summary>
    public class KeyRange : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Lower bound.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lower")]
        public CefSharp.DevTools.IndexedDB.Key Lower
        {
            get;
            set;
        }

        /// <summary>
        /// Upper bound.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("upper")]
        public CefSharp.DevTools.IndexedDB.Key Upper
        {
            get;
            set;
        }

        /// <summary>
        /// If true lower bound is open.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lowerOpen")]
        public bool LowerOpen
        {
            get;
            set;
        }

        /// <summary>
        /// If true upper bound is open.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("upperOpen")]
        public bool UpperOpen
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// Data entry.
    /// </summary>
    public class DataEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject Key
        {
            get;
            set;
        }

        /// <summary>
        /// Primary key object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("primaryKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject PrimaryKey
        {
            get;
            set;
        }

        /// <summary>
        /// Value object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// Key path.
    /// </summary>
    public class KeyPath : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key path type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// String value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("string")]
        public string String
        {
            get;
            set;
        }

        /// <summary>
        /// Array value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("array")]
        public string[] Array
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Input
{
    /// <summary>
    /// TouchPoint
    /// </summary>
    public class TouchPoint : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// X coordinate of the event relative to the main frame&apos;s viewport in CSS pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("x")]
        public long X
        {
            get;
            set;
        }

        /// <summary>
        /// Y coordinate of the event relative to the main frame&apos;s viewport in CSS pixels. 0 refers to
        /// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("y")]
        public long Y
        {
            get;
            set;
        }

        /// <summary>
        /// X radius of the touch area (default: 1.0).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("radiusX")]
        public long? RadiusX
        {
            get;
            set;
        }

        /// <summary>
        /// Y radius of the touch area (default: 1.0).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("radiusY")]
        public long? RadiusY
        {
            get;
            set;
        }

        /// <summary>
        /// Rotation angle (default: 0.0).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rotationAngle")]
        public long? RotationAngle
        {
            get;
            set;
        }

        /// <summary>
        /// Force (default: 1.0).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("force")]
        public long? Force
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier used to track touch sources between events, must be unique within an event.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        public long? Id
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Input
{
    /// <summary>
    /// GestureSourceType
    /// </summary>
    public enum GestureSourceType
    {
        /// <summary>
        /// default
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("default")]
        Default,
        /// <summary>
        /// touch
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("touch")]
        Touch,
        /// <summary>
        /// mouse
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mouse")]
        Mouse
    }
}

namespace CefSharp.DevTools.Input
{
    /// <summary>
    /// MouseButton
    /// </summary>
    public enum MouseButton
    {
        /// <summary>
        /// none
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("none")]
        None,
        /// <summary>
        /// left
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("left")]
        Left,
        /// <summary>
        /// middle
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("middle")]
        Middle,
        /// <summary>
        /// right
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("right")]
        Right,
        /// <summary>
        /// back
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("back")]
        Back,
        /// <summary>
        /// forward
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("forward")]
        Forward
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// Rectangle where scrolling happens on the main thread.
    /// </summary>
    public class ScrollRect : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Rectangle itself.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect Rect
        {
            get;
            set;
        }

        /// <summary>
        /// Reason for rectangle to force scrolling on the main thread
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// Sticky position constraints.
    /// </summary>
    public class StickyPositionConstraint : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Layout rectangle of the sticky element before being shifted
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stickyBoxRect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect StickyBoxRect
        {
            get;
            set;
        }

        /// <summary>
        /// Layout rectangle of the containing block of the sticky element
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("containingBlockRect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect ContainingBlockRect
        {
            get;
            set;
        }

        /// <summary>
        /// The nearest sticky layer that shifts the sticky box
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nearestLayerShiftingStickyBox")]
        public string NearestLayerShiftingStickyBox
        {
            get;
            set;
        }

        /// <summary>
        /// The nearest sticky layer that shifts the containing block
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nearestLayerShiftingContainingBlock")]
        public string NearestLayerShiftingContainingBlock
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// Serialized fragment of layer picture along with its offset within the layer.
    /// </summary>
    public class PictureTile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Offset from owning layer left boundary
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("x")]
        public long X
        {
            get;
            set;
        }

        /// <summary>
        /// Offset from owning layer top boundary
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("y")]
        public long Y
        {
            get;
            set;
        }

        /// <summary>
        /// Base64-encoded snapshot data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("picture")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] Picture
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// Information about a compositing layer.
    /// </summary>
    public class Layer : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The unique id for this layer.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("layerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LayerId
        {
            get;
            set;
        }

        /// <summary>
        /// The id of parent (not present for root).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parentLayerId")]
        public string ParentLayerId
        {
            get;
            set;
        }

        /// <summary>
        /// The backend id for the node associated with this layer.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int? BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Offset from parent layer, X coordinate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offsetX")]
        public long OffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// Offset from parent layer, Y coordinate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offsetY")]
        public long OffsetY
        {
            get;
            set;
        }

        /// <summary>
        /// Layer width.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("width")]
        public long Width
        {
            get;
            set;
        }

        /// <summary>
        /// Layer height.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("height")]
        public long Height
        {
            get;
            set;
        }

        /// <summary>
        /// Transformation matrix for layer, default is identity matrix
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("transform")]
        public long[] Transform
        {
            get;
            set;
        }

        /// <summary>
        /// Transform anchor point X, absent if no transform specified
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("anchorX")]
        public long? AnchorX
        {
            get;
            set;
        }

        /// <summary>
        /// Transform anchor point Y, absent if no transform specified
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("anchorY")]
        public long? AnchorY
        {
            get;
            set;
        }

        /// <summary>
        /// Transform anchor point Z, absent if no transform specified
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("anchorZ")]
        public long? AnchorZ
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates how many time this layer has painted.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("paintCount")]
        public int PaintCount
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this layer hosts any content, rather than being used for
        /// transform/scrolling purposes only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("drawsContent")]
        public bool DrawsContent
        {
            get;
            set;
        }

        /// <summary>
        /// Set if layer is not visible.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("invisible")]
        public bool? Invisible
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangles scrolling on main thread only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollRects")]
        public System.Collections.Generic.IList<CefSharp.DevTools.LayerTree.ScrollRect> ScrollRects
        {
            get;
            set;
        }

        /// <summary>
        /// Sticky position constraint information
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stickyPositionConstraint")]
        public CefSharp.DevTools.LayerTree.StickyPositionConstraint StickyPositionConstraint
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Log
{
    /// <summary>
    /// Log entry.
    /// </summary>
    public class LogEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Log entry source.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("source")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Source
        {
            get;
            set;
        }

        /// <summary>
        /// Log entry severity.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("level")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Level
        {
            get;
            set;
        }

        /// <summary>
        /// Logged text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Timestamp when this entry was added.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timestamp")]
        public long Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the resource if known.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Line number in the resource.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int? LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript stack trace.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the network request associated with this entry.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("networkRequestId")]
        public string NetworkRequestId
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the worker associated with this entry.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("workerId")]
        public string WorkerId
        {
            get;
            set;
        }

        /// <summary>
        /// Call arguments.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("args")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.RemoteObject> Args
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Log
{
    /// <summary>
    /// Violation configuration setting.
    /// </summary>
    public class ViolationSetting : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Violation type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Time threshold to trigger upon.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("threshold")]
        public long Threshold
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// Memory pressure level.
    /// </summary>
    public enum PressureLevel
    {
        /// <summary>
        /// moderate
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("moderate")]
        Moderate,
        /// <summary>
        /// critical
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("critical")]
        Critical
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// Heap profile sample.
    /// </summary>
    public class SamplingProfileNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Size of the sampled allocation.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("size")]
        public long Size
        {
            get;
            set;
        }

        /// <summary>
        /// Total bytes attributed to this sample.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("total")]
        public long Total
        {
            get;
            set;
        }

        /// <summary>
        /// Execution stack at the point of allocation.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stack")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Stack
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// Array of heap profile samples.
    /// </summary>
    public class SamplingProfile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Samples
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("samples")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Memory.SamplingProfileNode> Samples
        {
            get;
            set;
        }

        /// <summary>
        /// Modules
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("modules")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Memory.Module> Modules
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// Executable module information
    /// </summary>
    public class Module : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name of the module.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// UUID of the module.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("uuid")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Uuid
        {
            get;
            set;
        }

        /// <summary>
        /// Base address where the module is loaded into memory. Encoded as a decimal
        /// or hexadecimal (0x prefixed) string.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("baseAddress")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string BaseAddress
        {
            get;
            set;
        }

        /// <summary>
        /// Size of the module in bytes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("size")]
        public long Size
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Resource type as it was perceived by the rendering engine.
    /// </summary>
    public enum ResourceType
    {
        /// <summary>
        /// Document
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Document")]
        Document,
        /// <summary>
        /// Stylesheet
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Stylesheet")]
        Stylesheet,
        /// <summary>
        /// Image
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Image")]
        Image,
        /// <summary>
        /// Media
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Media")]
        Media,
        /// <summary>
        /// Font
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Font")]
        Font,
        /// <summary>
        /// Script
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Script")]
        Script,
        /// <summary>
        /// TextTrack
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("TextTrack")]
        TextTrack,
        /// <summary>
        /// XHR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("XHR")]
        XHR,
        /// <summary>
        /// Fetch
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Fetch")]
        Fetch,
        /// <summary>
        /// EventSource
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("EventSource")]
        EventSource,
        /// <summary>
        /// WebSocket
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WebSocket")]
        WebSocket,
        /// <summary>
        /// Manifest
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Manifest")]
        Manifest,
        /// <summary>
        /// SignedExchange
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SignedExchange")]
        SignedExchange,
        /// <summary>
        /// Ping
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Ping")]
        Ping,
        /// <summary>
        /// CSPViolationReport
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("CSPViolationReport")]
        CSPViolationReport,
        /// <summary>
        /// Other
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Other")]
        Other
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Network level fetch failure reason.
    /// </summary>
    public enum ErrorReason
    {
        /// <summary>
        /// Failed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Failed")]
        Failed,
        /// <summary>
        /// Aborted
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Aborted")]
        Aborted,
        /// <summary>
        /// TimedOut
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("TimedOut")]
        TimedOut,
        /// <summary>
        /// AccessDenied
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("AccessDenied")]
        AccessDenied,
        /// <summary>
        /// ConnectionClosed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ConnectionClosed")]
        ConnectionClosed,
        /// <summary>
        /// ConnectionReset
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ConnectionReset")]
        ConnectionReset,
        /// <summary>
        /// ConnectionRefused
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ConnectionRefused")]
        ConnectionRefused,
        /// <summary>
        /// ConnectionAborted
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ConnectionAborted")]
        ConnectionAborted,
        /// <summary>
        /// ConnectionFailed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ConnectionFailed")]
        ConnectionFailed,
        /// <summary>
        /// NameNotResolved
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("NameNotResolved")]
        NameNotResolved,
        /// <summary>
        /// InternetDisconnected
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("InternetDisconnected")]
        InternetDisconnected,
        /// <summary>
        /// AddressUnreachable
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("AddressUnreachable")]
        AddressUnreachable,
        /// <summary>
        /// BlockedByClient
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("BlockedByClient")]
        BlockedByClient,
        /// <summary>
        /// BlockedByResponse
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("BlockedByResponse")]
        BlockedByResponse
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// The underlying connection technology that the browser is supposedly using.
    /// </summary>
    public enum ConnectionType
    {
        /// <summary>
        /// none
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("none")]
        None,
        /// <summary>
        /// cellular2g
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cellular2g")]
        Cellular2g,
        /// <summary>
        /// cellular3g
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cellular3g")]
        Cellular3g,
        /// <summary>
        /// cellular4g
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cellular4g")]
        Cellular4g,
        /// <summary>
        /// bluetooth
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bluetooth")]
        Bluetooth,
        /// <summary>
        /// ethernet
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ethernet")]
        Ethernet,
        /// <summary>
        /// wifi
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("wifi")]
        Wifi,
        /// <summary>
        /// wimax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("wimax")]
        Wimax,
        /// <summary>
        /// other
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("other")]
        Other
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Represents the cookie&apos;s &apos;SameSite&apos; status:
    /// https://tools.ietf.org/html/draft-west-first-party-cookies
    /// </summary>
    public enum CookieSameSite
    {
        /// <summary>
        /// Strict
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Strict")]
        Strict,
        /// <summary>
        /// Lax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Lax")]
        Lax,
        /// <summary>
        /// None
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("None")]
        None
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Represents the cookie&apos;s &apos;Priority&apos; status:
    /// https://tools.ietf.org/html/draft-west-cookie-priority-00
    /// </summary>
    public enum CookiePriority
    {
        /// <summary>
        /// Low
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Low")]
        Low,
        /// <summary>
        /// Medium
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Medium")]
        Medium,
        /// <summary>
        /// High
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("High")]
        High
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Timing information for the request.
    /// </summary>
    public class ResourceTiming : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Timing&apos;s requestTime is a baseline in seconds, while the other numbers are ticks in
        /// milliseconds relatively to this requestTime.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestTime")]
        public long RequestTime
        {
            get;
            set;
        }

        /// <summary>
        /// Started resolving proxy.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("proxyStart")]
        public long ProxyStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished resolving proxy.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("proxyEnd")]
        public long ProxyEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Started DNS address resolve.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("dnsStart")]
        public long DnsStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished DNS address resolve.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("dnsEnd")]
        public long DnsEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Started connecting to the remote host.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("connectStart")]
        public long ConnectStart
        {
            get;
            set;
        }

        /// <summary>
        /// Connected to the remote host.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("connectEnd")]
        public long ConnectEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Started SSL handshake.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sslStart")]
        public long SslStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished SSL handshake.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sslEnd")]
        public long SslEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Started running ServiceWorker.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("workerStart")]
        public long WorkerStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished Starting ServiceWorker.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("workerReady")]
        public long WorkerReady
        {
            get;
            set;
        }

        /// <summary>
        /// Started fetch event.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("workerFetchStart")]
        public long WorkerFetchStart
        {
            get;
            set;
        }

        /// <summary>
        /// Settled fetch event respondWith promise.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("workerRespondWithSettled")]
        public long WorkerRespondWithSettled
        {
            get;
            set;
        }

        /// <summary>
        /// Started sending request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sendStart")]
        public long SendStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished sending request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sendEnd")]
        public long SendEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Time the server started pushing request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pushStart")]
        public long PushStart
        {
            get;
            set;
        }

        /// <summary>
        /// Time the server finished pushing request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pushEnd")]
        public long PushEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Finished receiving response headers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("receiveHeadersEnd")]
        public long ReceiveHeadersEnd
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Loading priority of a resource request.
    /// </summary>
    public enum ResourcePriority
    {
        /// <summary>
        /// VeryLow
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("VeryLow")]
        VeryLow,
        /// <summary>
        /// Low
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Low")]
        Low,
        /// <summary>
        /// Medium
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Medium")]
        Medium,
        /// <summary>
        /// High
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("High")]
        High,
        /// <summary>
        /// VeryHigh
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("VeryHigh")]
        VeryHigh
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Post data entry for HTTP request
    /// </summary>
    public class PostDataEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Bytes
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bytes")]
        public byte[] Bytes
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// HTTP request data.
    /// </summary>
    public class Request : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Request URL (without fragment).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Fragment of the requested URL starting with hash, if present.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("urlFragment")]
        public string UrlFragment
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request method.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("method")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Method
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request headers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP POST request data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("postData")]
        public string PostData
        {
            get;
            set;
        }

        /// <summary>
        /// True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hasPostData")]
        public bool? HasPostData
        {
            get;
            set;
        }

        /// <summary>
        /// Request body elements. This will be converted from base64 to binary
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("postDataEntries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.PostDataEntry> PostDataEntries
        {
            get;
            set;
        }

        /// <summary>
        /// The mixed content type of the request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mixedContentType")]
        public CefSharp.DevTools.Security.MixedContentType? MixedContentType
        {
            get;
            set;
        }

        /// <summary>
        /// Priority of the resource request at the time request is sent.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("initialPriority")]
        public CefSharp.DevTools.Network.ResourcePriority InitialPriority
        {
            get;
            set;
        }

        /// <summary>
        /// The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("referrerPolicy")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ReferrerPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// Whether is loaded via link preload.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isLinkPreload")]
        public bool? IsLinkPreload
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Details of a signed certificate timestamp (SCT).
    /// </summary>
    public class SignedCertificateTimestamp : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Validation status.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("status")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Status
        {
            get;
            set;
        }

        /// <summary>
        /// Origin.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Log name / description.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("logDescription")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LogDescription
        {
            get;
            set;
        }

        /// <summary>
        /// Log ID.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("logId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LogId
        {
            get;
            set;
        }

        /// <summary>
        /// Issuance date.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timestamp")]
        public long Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// Hash algorithm.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hashAlgorithm")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string HashAlgorithm
        {
            get;
            set;
        }

        /// <summary>
        /// Signature algorithm.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureAlgorithm")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SignatureAlgorithm
        {
            get;
            set;
        }

        /// <summary>
        /// Signature data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureData")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SignatureData
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Security details about a request.
    /// </summary>
    public class SecurityDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Protocol name (e.g. &quot;TLS 1.2&quot; or &quot;QUIC&quot;).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("protocol")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Protocol
        {
            get;
            set;
        }

        /// <summary>
        /// Key Exchange used by the connection, or the empty string if not applicable.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyExchange")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string KeyExchange
        {
            get;
            set;
        }

        /// <summary>
        /// (EC)DH group used by the connection, if applicable.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyExchangeGroup")]
        public string KeyExchangeGroup
        {
            get;
            set;
        }

        /// <summary>
        /// Cipher name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cipher")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Cipher
        {
            get;
            set;
        }

        /// <summary>
        /// TLS MAC. Note that AEAD ciphers do not have separate MACs.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mac")]
        public string Mac
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate ID value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificateId")]
        public int CertificateId
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate subject name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subjectName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SubjectName
        {
            get;
            set;
        }

        /// <summary>
        /// Subject Alternative Name (SAN) DNS names and IP addresses.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sanList")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] SanList
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the issuing CA.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("issuer")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Issuer
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate valid from date.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("validFrom")]
        public long ValidFrom
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate valid to (expiration) date
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("validTo")]
        public long ValidTo
        {
            get;
            set;
        }

        /// <summary>
        /// List of signed certificate timestamps (SCTs).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signedCertificateTimestampList")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.SignedCertificateTimestamp> SignedCertificateTimestampList
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the request complied with Certificate Transparency policy
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificateTransparencyCompliance")]
        public CefSharp.DevTools.Network.CertificateTransparencyCompliance CertificateTransparencyCompliance
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Whether the request complied with Certificate Transparency policy.
    /// </summary>
    public enum CertificateTransparencyCompliance
    {
        /// <summary>
        /// unknown
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unknown")]
        Unknown,
        /// <summary>
        /// not-compliant
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("not-compliant")]
        NotCompliant,
        /// <summary>
        /// compliant
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("compliant")]
        Compliant
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// The reason why request was blocked.
    /// </summary>
    public enum BlockedReason
    {
        /// <summary>
        /// other
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("other")]
        Other,
        /// <summary>
        /// csp
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("csp")]
        Csp,
        /// <summary>
        /// mixed-content
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mixed-content")]
        MixedContent,
        /// <summary>
        /// origin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        Origin,
        /// <summary>
        /// inspector
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inspector")]
        Inspector,
        /// <summary>
        /// subresource-filter
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subresource-filter")]
        SubresourceFilter,
        /// <summary>
        /// content-type
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("content-type")]
        ContentType,
        /// <summary>
        /// collapsed-by-client
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("collapsed-by-client")]
        CollapsedByClient,
        /// <summary>
        /// coep-frame-resource-needs-coep-header
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("coep-frame-resource-needs-coep-header")]
        CoepFrameResourceNeedsCoepHeader,
        /// <summary>
        /// coop-sandboxed-iframe-cannot-navigate-to-coop-page
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("coop-sandboxed-iframe-cannot-navigate-to-coop-page")]
        CoopSandboxedIframeCannotNavigateToCoopPage,
        /// <summary>
        /// corp-not-same-origin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("corp-not-same-origin")]
        CorpNotSameOrigin,
        /// <summary>
        /// corp-not-same-origin-after-defaulted-to-same-origin-by-coep
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("corp-not-same-origin-after-defaulted-to-same-origin-by-coep")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        /// <summary>
        /// corp-not-same-site
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("corp-not-same-site")]
        CorpNotSameSite
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Source of serviceworker response.
    /// </summary>
    public enum ServiceWorkerResponseSource
    {
        /// <summary>
        /// cache-storage
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cache-storage")]
        CacheStorage,
        /// <summary>
        /// http-cache
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("http-cache")]
        HttpCache,
        /// <summary>
        /// fallback-code
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fallback-code")]
        FallbackCode,
        /// <summary>
        /// network
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("network")]
        Network
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// HTTP response data.
    /// </summary>
    public class Response : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Response URL. This URL can be different from CachedResource.url in case of redirect.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status code.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("status")]
        public int Status
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("statusText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StatusText
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response headers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response headers text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("headersText")]
        public string HeadersText
        {
            get;
            set;
        }

        /// <summary>
        /// Resource mimeType as determined by the browser.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mimeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MimeType
        {
            get;
            set;
        }

        /// <summary>
        /// Refined HTTP request headers that were actually transmitted over the network.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestHeaders")]
        public CefSharp.DevTools.Network.Headers RequestHeaders
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request headers text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestHeadersText")]
        public string RequestHeadersText
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies whether physical connection was actually reused for this request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("connectionReused")]
        public bool ConnectionReused
        {
            get;
            set;
        }

        /// <summary>
        /// Physical connection id that was actually used for this request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("connectionId")]
        public long ConnectionId
        {
            get;
            set;
        }

        /// <summary>
        /// Remote IP address.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("remoteIPAddress")]
        public string RemoteIPAddress
        {
            get;
            set;
        }

        /// <summary>
        /// Remote port.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("remotePort")]
        public int? RemotePort
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies that the request was served from the disk cache.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fromDiskCache")]
        public bool? FromDiskCache
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies that the request was served from the ServiceWorker.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fromServiceWorker")]
        public bool? FromServiceWorker
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies that the request was served from the prefetch cache.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fromPrefetchCache")]
        public bool? FromPrefetchCache
        {
            get;
            set;
        }

        /// <summary>
        /// Total number of bytes received for this request so far.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("encodedDataLength")]
        public long EncodedDataLength
        {
            get;
            set;
        }

        /// <summary>
        /// Timing information for the given request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timing")]
        public CefSharp.DevTools.Network.ResourceTiming Timing
        {
            get;
            set;
        }

        /// <summary>
        /// Response source of response from ServiceWorker.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("serviceWorkerResponseSource")]
        public CefSharp.DevTools.Network.ServiceWorkerResponseSource? ServiceWorkerResponseSource
        {
            get;
            set;
        }

        /// <summary>
        /// The time at which the returned response was generated.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("responseTime")]
        public long? ResponseTime
        {
            get;
            set;
        }

        /// <summary>
        /// Cache Storage Cache Name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cacheStorageCacheName")]
        public string CacheStorageCacheName
        {
            get;
            set;
        }

        /// <summary>
        /// Protocol used to fetch this request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("protocol")]
        public string Protocol
        {
            get;
            set;
        }

        /// <summary>
        /// Security state of the request resource.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityState")]
        public CefSharp.DevTools.Security.SecurityState SecurityState
        {
            get;
            set;
        }

        /// <summary>
        /// Security details for the request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityDetails")]
        public CefSharp.DevTools.Network.SecurityDetails SecurityDetails
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// WebSocket request data.
    /// </summary>
    public class WebSocketRequest : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// HTTP request headers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// WebSocket response data.
    /// </summary>
    public class WebSocketResponse : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// HTTP response status code.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("status")]
        public int Status
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("statusText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StatusText
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response headers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response headers text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("headersText")]
        public string HeadersText
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request headers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestHeaders")]
        public CefSharp.DevTools.Network.Headers RequestHeaders
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request headers text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestHeadersText")]
        public string RequestHeadersText
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
    /// </summary>
    public class WebSocketFrame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// WebSocket message opcode.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("opcode")]
        public long Opcode
        {
            get;
            set;
        }

        /// <summary>
        /// WebSocket message mask.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mask")]
        public bool Mask
        {
            get;
            set;
        }

        /// <summary>
        /// WebSocket message payload data.
        /// If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
        /// If the opcode isn&apos;t 1, then payloadData is a base64 encoded string representing binary data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("payloadData")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PayloadData
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Information about the cached resource.
    /// </summary>
    public class CachedResource : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Resource URL. This is the url of the original network request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Type of this resource.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        public CefSharp.DevTools.Network.ResourceType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Cached response data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("response")]
        public CefSharp.DevTools.Network.Response Response
        {
            get;
            set;
        }

        /// <summary>
        /// Cached response body size.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bodySize")]
        public long BodySize
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Information about the request initiator.
    /// </summary>
    public class Initiator : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Type of this initiator.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Initiator JavaScript stack trace, set for Script only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stack")]
        public CefSharp.DevTools.Runtime.StackTrace Stack
        {
            get;
            set;
        }

        /// <summary>
        /// Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Initiator line number, set for Parser type or for Script type (when script is importing
        /// module) (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public long? LineNumber
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Cookie object
    /// </summary>
    public class Cookie : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Cookie name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie domain.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("domain")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Domain
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie path.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("path")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Path
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie expiration date as the number of seconds since the UNIX epoch.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("expires")]
        public long Expires
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie size.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("size")]
        public int Size
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is http-only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("httpOnly")]
        public bool HttpOnly
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is secure.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("secure")]
        public bool Secure
        {
            get;
            set;
        }

        /// <summary>
        /// True in case of session cookie.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("session")]
        public bool Session
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie SameSite type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sameSite")]
        public CefSharp.DevTools.Network.CookieSameSite? SameSite
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie Priority
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("priority")]
        public CefSharp.DevTools.Network.CookiePriority Priority
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Types of reasons why a cookie may not be stored from a response.
    /// </summary>
    public enum SetCookieBlockedReason
    {
        /// <summary>
        /// SecureOnly
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SecureOnly")]
        SecureOnly,
        /// <summary>
        /// SameSiteStrict
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteStrict")]
        SameSiteStrict,
        /// <summary>
        /// SameSiteLax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteLax")]
        SameSiteLax,
        /// <summary>
        /// SameSiteUnspecifiedTreatedAsLax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteUnspecifiedTreatedAsLax")]
        SameSiteUnspecifiedTreatedAsLax,
        /// <summary>
        /// SameSiteNoneInsecure
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteNoneInsecure")]
        SameSiteNoneInsecure,
        /// <summary>
        /// UserPreferences
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("UserPreferences")]
        UserPreferences,
        /// <summary>
        /// SyntaxError
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SyntaxError")]
        SyntaxError,
        /// <summary>
        /// SchemeNotSupported
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SchemeNotSupported")]
        SchemeNotSupported,
        /// <summary>
        /// OverwriteSecure
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("OverwriteSecure")]
        OverwriteSecure,
        /// <summary>
        /// InvalidDomain
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("InvalidDomain")]
        InvalidDomain,
        /// <summary>
        /// InvalidPrefix
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("InvalidPrefix")]
        InvalidPrefix,
        /// <summary>
        /// UnknownError
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("UnknownError")]
        UnknownError
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Types of reasons why a cookie may not be sent with a request.
    /// </summary>
    public enum CookieBlockedReason
    {
        /// <summary>
        /// SecureOnly
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SecureOnly")]
        SecureOnly,
        /// <summary>
        /// NotOnPath
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("NotOnPath")]
        NotOnPath,
        /// <summary>
        /// DomainMismatch
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("DomainMismatch")]
        DomainMismatch,
        /// <summary>
        /// SameSiteStrict
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteStrict")]
        SameSiteStrict,
        /// <summary>
        /// SameSiteLax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteLax")]
        SameSiteLax,
        /// <summary>
        /// SameSiteUnspecifiedTreatedAsLax
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteUnspecifiedTreatedAsLax")]
        SameSiteUnspecifiedTreatedAsLax,
        /// <summary>
        /// SameSiteNoneInsecure
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameSiteNoneInsecure")]
        SameSiteNoneInsecure,
        /// <summary>
        /// UserPreferences
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("UserPreferences")]
        UserPreferences,
        /// <summary>
        /// UnknownError
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("UnknownError")]
        UnknownError
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// A cookie which was not stored from a response with the corresponding reason.
    /// </summary>
    public class BlockedSetCookieWithReason : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The reason(s) this cookie was blocked.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("blockedReasons")]
        public CefSharp.DevTools.Network.SetCookieBlockedReason[] BlockedReasons
        {
            get;
            set;
        }

        /// <summary>
        /// The string representing this individual cookie as it would appear in the header.
        /// This is not the entire &quot;cookie&quot; or &quot;set-cookie&quot; header which could have multiple cookies.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookieLine")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CookieLine
        {
            get;
            set;
        }

        /// <summary>
        /// The cookie object which represents the cookie which was not stored. It is optional because
        /// sometimes complete cookie information is not available, such as in the case of parsing
        /// errors.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookie")]
        public CefSharp.DevTools.Network.Cookie Cookie
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// A cookie with was not sent with a request with the corresponding reason.
    /// </summary>
    public class BlockedCookieWithReason : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The reason(s) the cookie was blocked.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("blockedReasons")]
        public CefSharp.DevTools.Network.CookieBlockedReason[] BlockedReasons
        {
            get;
            set;
        }

        /// <summary>
        /// The cookie object representing the cookie which was not sent.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookie")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Cookie Cookie
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Cookie parameter object
    /// </summary>
    public class CookieParam : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Cookie name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// The request-URI to associate with the setting of the cookie. This value can affect the
        /// default domain and path values of the created cookie.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie domain.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("domain")]
        public string Domain
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie path.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("path")]
        public string Path
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is secure.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("secure")]
        public bool? Secure
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is http-only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("httpOnly")]
        public bool? HttpOnly
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie SameSite type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sameSite")]
        public CefSharp.DevTools.Network.CookieSameSite? SameSite
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie expiration date, session cookie if not set
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("expires")]
        public long? Expires
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie Priority.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("priority")]
        public CefSharp.DevTools.Network.CookiePriority? Priority
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Authorization challenge for HTTP status code 401 or 407.
    /// </summary>
    public class AuthChallenge : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Source of the authentication challenge.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("source")]
        public string Source
        {
            get;
            set;
        }

        /// <summary>
        /// Origin of the challenger.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// The authentication scheme used, such as basic or digest
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scheme")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Scheme
        {
            get;
            set;
        }

        /// <summary>
        /// The realm of the challenge. May be empty.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("realm")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Realm
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Response to an AuthChallenge.
    /// </summary>
    public class AuthChallengeResponse : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The decision on what to do in response to the authorization challenge.  Default means
        /// deferring to the default behavior of the net stack, which will likely either the Cancel
        /// authentication or display a popup dialog box.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("response")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Response
        {
            get;
            set;
        }

        /// <summary>
        /// The username to provide, possibly empty. Should only be set if response is
        /// ProvideCredentials.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("username")]
        public string Username
        {
            get;
            set;
        }

        /// <summary>
        /// The password to provide, possibly empty. Should only be set if response is
        /// ProvideCredentials.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("password")]
        public string Password
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Stages of the interception to begin intercepting. Request will intercept before the request is
    /// sent. Response will intercept after the response is received.
    /// </summary>
    public enum InterceptionStage
    {
        /// <summary>
        /// Request
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Request")]
        Request,
        /// <summary>
        /// HeadersReceived
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("HeadersReceived")]
        HeadersReceived
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Request pattern for interception.
    /// </summary>
    public class RequestPattern : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Wildcards (&apos;*&apos; -&gt; zero or more, &apos;?&apos; -&gt; exactly one) are allowed. Escape character is
        /// backslash. Omitting is equivalent to &quot;*&quot;.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("urlPattern")]
        public string UrlPattern
        {
            get;
            set;
        }

        /// <summary>
        /// If set, only requests for matching resource types will be intercepted.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resourceType")]
        public CefSharp.DevTools.Network.ResourceType? ResourceType
        {
            get;
            set;
        }

        /// <summary>
        /// Stage at wich to begin intercepting requests. Default is Request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("interceptionStage")]
        public CefSharp.DevTools.Network.InterceptionStage? InterceptionStage
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Information about a signed exchange signature.
    /// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
    /// </summary>
    public class SignedExchangeSignature : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Signed exchange signature label.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("label")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Label
        {
            get;
            set;
        }

        /// <summary>
        /// The hex string of signed exchange signature.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signature")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Signature
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature integrity.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("integrity")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Integrity
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature cert Url.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certUrl")]
        public string CertUrl
        {
            get;
            set;
        }

        /// <summary>
        /// The hex string of signed exchange signature cert sha256.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certSha256")]
        public string CertSha256
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature validity Url.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("validityUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ValidityUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature date.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("date")]
        public int Date
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature expires.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("expires")]
        public int Expires
        {
            get;
            set;
        }

        /// <summary>
        /// The encoded certificates.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificates")]
        public string[] Certificates
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Information about a signed exchange header.
    /// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
    /// </summary>
    public class SignedExchangeHeader : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Signed exchange request URL.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange response code.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("responseCode")]
        public int ResponseCode
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange response headers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("responseHeaders")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers ResponseHeaders
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange response signature.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatures")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.SignedExchangeSignature> Signatures
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange header integrity hash in the form of &quot;sha256-&lt;base64-hash-value&gt; &quot;.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("headerIntegrity")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string HeaderIntegrity
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Field type for a signed exchange related error.
    /// </summary>
    public enum SignedExchangeErrorField
    {
        /// <summary>
        /// signatureSig
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureSig")]
        SignatureSig,
        /// <summary>
        /// signatureIntegrity
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureIntegrity")]
        SignatureIntegrity,
        /// <summary>
        /// signatureCertUrl
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureCertUrl")]
        SignatureCertUrl,
        /// <summary>
        /// signatureCertSha256
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureCertSha256")]
        SignatureCertSha256,
        /// <summary>
        /// signatureValidityUrl
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureValidityUrl")]
        SignatureValidityUrl,
        /// <summary>
        /// signatureTimestamps
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureTimestamps")]
        SignatureTimestamps
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Information about a signed exchange response.
    /// </summary>
    public class SignedExchangeError : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Error message.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            set;
        }

        /// <summary>
        /// The index of the signature which caused the error.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signatureIndex")]
        public int? SignatureIndex
        {
            get;
            set;
        }

        /// <summary>
        /// The field which caused the error.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errorField")]
        public CefSharp.DevTools.Network.SignedExchangeErrorField? ErrorField
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Information about a signed exchange response.
    /// </summary>
    public class SignedExchangeInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The outer response of signed HTTP exchange which was received from network.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("outerResponse")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Response OuterResponse
        {
            get;
            set;
        }

        /// <summary>
        /// Information about the signed exchange header.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("header")]
        public CefSharp.DevTools.Network.SignedExchangeHeader Header
        {
            get;
            set;
        }

        /// <summary>
        /// Security details for the signed exchange header.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityDetails")]
        public CefSharp.DevTools.Network.SecurityDetails SecurityDetails
        {
            get;
            set;
        }

        /// <summary>
        /// Errors occurred while handling the signed exchagne.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errors")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.SignedExchangeError> Errors
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// CrossOriginOpenerPolicyValue
    /// </summary>
    public enum CrossOriginOpenerPolicyValue
    {
        /// <summary>
        /// SameOrigin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameOrigin")]
        SameOrigin,
        /// <summary>
        /// SameOriginAllowPopups
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameOriginAllowPopups")]
        SameOriginAllowPopups,
        /// <summary>
        /// UnsafeNone
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("UnsafeNone")]
        UnsafeNone,
        /// <summary>
        /// SameOriginPlusCoep
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SameOriginPlusCoep")]
        SameOriginPlusCoep
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// CrossOriginOpenerPolicyStatus
    /// </summary>
    public class CrossOriginOpenerPolicyStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public CefSharp.DevTools.Network.CrossOriginOpenerPolicyValue Value
        {
            get;
            set;
        }

        /// <summary>
        /// ReportOnlyValue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reportOnlyValue")]
        public CefSharp.DevTools.Network.CrossOriginOpenerPolicyValue ReportOnlyValue
        {
            get;
            set;
        }

        /// <summary>
        /// ReportingEndpoint
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reportingEndpoint")]
        public string ReportingEndpoint
        {
            get;
            set;
        }

        /// <summary>
        /// ReportOnlyReportingEndpoint
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reportOnlyReportingEndpoint")]
        public string ReportOnlyReportingEndpoint
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// CrossOriginEmbedderPolicyValue
    /// </summary>
    public enum CrossOriginEmbedderPolicyValue
    {
        /// <summary>
        /// None
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("None")]
        None,
        /// <summary>
        /// RequireCorp
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("RequireCorp")]
        RequireCorp
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// CrossOriginEmbedderPolicyStatus
    /// </summary>
    public class CrossOriginEmbedderPolicyStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public CefSharp.DevTools.Network.CrossOriginEmbedderPolicyValue Value
        {
            get;
            set;
        }

        /// <summary>
        /// ReportOnlyValue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reportOnlyValue")]
        public CefSharp.DevTools.Network.CrossOriginEmbedderPolicyValue ReportOnlyValue
        {
            get;
            set;
        }

        /// <summary>
        /// ReportingEndpoint
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reportingEndpoint")]
        public string ReportingEndpoint
        {
            get;
            set;
        }

        /// <summary>
        /// ReportOnlyReportingEndpoint
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reportOnlyReportingEndpoint")]
        public string ReportOnlyReportingEndpoint
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// SecurityIsolationStatus
    /// </summary>
    public class SecurityIsolationStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Coop
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("coop")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.CrossOriginOpenerPolicyStatus Coop
        {
            get;
            set;
        }

        /// <summary>
        /// Coep
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("coep")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.CrossOriginEmbedderPolicyStatus Coep
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// An object providing the result of a network resource load.
    /// </summary>
    public class LoadNetworkResourcePageResult : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Success
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("success")]
        public bool Success
        {
            get;
            set;
        }

        /// <summary>
        /// Optional values used for error reporting.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("netError")]
        public long? NetError
        {
            get;
            set;
        }

        /// <summary>
        /// NetErrorName
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("netErrorName")]
        public string NetErrorName
        {
            get;
            set;
        }

        /// <summary>
        /// HttpStatusCode
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("httpStatusCode")]
        public long? HttpStatusCode
        {
            get;
            set;
        }

        /// <summary>
        /// If successful, one of the following two fields holds the result.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stream")]
        public string Stream
        {
            get;
            set;
        }

        /// <summary>
        /// Response headers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("headers")]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// An options object that may be extended later to better support CORS,
    /// CORB and streaming.
    /// </summary>
    public class LoadNetworkResourceOptions : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// DisableCache
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("disableCache")]
        public bool DisableCache
        {
            get;
            set;
        }

        /// <summary>
        /// IncludeCredentials
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("includeCredentials")]
        public bool IncludeCredentials
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// Configuration data for drawing the source order of an elements children.
    /// </summary>
    public class SourceOrderConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// the color to outline the givent element in.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parentOutlineColor")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.RGBA ParentOutlineColor
        {
            get;
            set;
        }

        /// <summary>
        /// the color to outline the child elements in.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("childOutlineColor")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.RGBA ChildOutlineColor
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// Configuration data for the highlighting of Grid elements.
    /// </summary>
    public class GridHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Whether the extension lines from grid cells to the rulers should be shown (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showGridExtensionLines")]
        public bool? ShowGridExtensionLines
        {
            get;
            set;
        }

        /// <summary>
        /// Show Positive line number labels (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showPositiveLineNumbers")]
        public bool? ShowPositiveLineNumbers
        {
            get;
            set;
        }

        /// <summary>
        /// Show Negative line number labels (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showNegativeLineNumbers")]
        public bool? ShowNegativeLineNumbers
        {
            get;
            set;
        }

        /// <summary>
        /// Show area name labels (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showAreaNames")]
        public bool? ShowAreaNames
        {
            get;
            set;
        }

        /// <summary>
        /// Show line name labels (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showLineNames")]
        public bool? ShowLineNames
        {
            get;
            set;
        }

        /// <summary>
        /// Show track size labels (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showTrackSizes")]
        public bool? ShowTrackSizes
        {
            get;
            set;
        }

        /// <summary>
        /// The grid container border highlight color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("gridBorderColor")]
        public CefSharp.DevTools.DOM.RGBA GridBorderColor
        {
            get;
            set;
        }

        /// <summary>
        /// The cell border color (default: transparent). Deprecated, please use rowLineColor and columnLineColor instead.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cellBorderColor")]
        public CefSharp.DevTools.DOM.RGBA CellBorderColor
        {
            get;
            set;
        }

        /// <summary>
        /// The row line color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rowLineColor")]
        public CefSharp.DevTools.DOM.RGBA RowLineColor
        {
            get;
            set;
        }

        /// <summary>
        /// The column line color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnLineColor")]
        public CefSharp.DevTools.DOM.RGBA ColumnLineColor
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the grid border is dashed (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("gridBorderDash")]
        public bool? GridBorderDash
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the cell border is dashed (default: false). Deprecated, please us rowLineDash and columnLineDash instead.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cellBorderDash")]
        public bool? CellBorderDash
        {
            get;
            set;
        }

        /// <summary>
        /// Whether row lines are dashed (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rowLineDash")]
        public bool? RowLineDash
        {
            get;
            set;
        }

        /// <summary>
        /// Whether column lines are dashed (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnLineDash")]
        public bool? ColumnLineDash
        {
            get;
            set;
        }

        /// <summary>
        /// The row gap highlight fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rowGapColor")]
        public CefSharp.DevTools.DOM.RGBA RowGapColor
        {
            get;
            set;
        }

        /// <summary>
        /// The row gap hatching fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rowHatchColor")]
        public CefSharp.DevTools.DOM.RGBA RowHatchColor
        {
            get;
            set;
        }

        /// <summary>
        /// The column gap highlight fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnGapColor")]
        public CefSharp.DevTools.DOM.RGBA ColumnGapColor
        {
            get;
            set;
        }

        /// <summary>
        /// The column gap hatching fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnHatchColor")]
        public CefSharp.DevTools.DOM.RGBA ColumnHatchColor
        {
            get;
            set;
        }

        /// <summary>
        /// The named grid areas border color (Default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("areaBorderColor")]
        public CefSharp.DevTools.DOM.RGBA AreaBorderColor
        {
            get;
            set;
        }

        /// <summary>
        /// The grid container background color (Default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("gridBackgroundColor")]
        public CefSharp.DevTools.DOM.RGBA GridBackgroundColor
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// Configuration data for the highlighting of page elements.
    /// </summary>
    public class HighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Whether the node info tooltip should be shown (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showInfo")]
        public bool? ShowInfo
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the node styles in the tooltip (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showStyles")]
        public bool? ShowStyles
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the rulers should be shown (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showRulers")]
        public bool? ShowRulers
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the a11y info should be shown (default: true).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showAccessibilityInfo")]
        public bool? ShowAccessibilityInfo
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the extension lines from node to the rulers should be shown (default: false).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showExtensionLines")]
        public bool? ShowExtensionLines
        {
            get;
            set;
        }

        /// <summary>
        /// The content box highlight fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentColor")]
        public CefSharp.DevTools.DOM.RGBA ContentColor
        {
            get;
            set;
        }

        /// <summary>
        /// The padding highlight fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("paddingColor")]
        public CefSharp.DevTools.DOM.RGBA PaddingColor
        {
            get;
            set;
        }

        /// <summary>
        /// The border highlight fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("borderColor")]
        public CefSharp.DevTools.DOM.RGBA BorderColor
        {
            get;
            set;
        }

        /// <summary>
        /// The margin highlight fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("marginColor")]
        public CefSharp.DevTools.DOM.RGBA MarginColor
        {
            get;
            set;
        }

        /// <summary>
        /// The event target element highlight fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("eventTargetColor")]
        public CefSharp.DevTools.DOM.RGBA EventTargetColor
        {
            get;
            set;
        }

        /// <summary>
        /// The shape outside fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shapeColor")]
        public CefSharp.DevTools.DOM.RGBA ShapeColor
        {
            get;
            set;
        }

        /// <summary>
        /// The shape margin fill color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shapeMarginColor")]
        public CefSharp.DevTools.DOM.RGBA ShapeMarginColor
        {
            get;
            set;
        }

        /// <summary>
        /// The grid layout color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cssGridColor")]
        public CefSharp.DevTools.DOM.RGBA CssGridColor
        {
            get;
            set;
        }

        /// <summary>
        /// The color format used to format color styles (default: hex).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("colorFormat")]
        public CefSharp.DevTools.Overlay.ColorFormat? ColorFormat
        {
            get;
            set;
        }

        /// <summary>
        /// The grid layout highlight configuration (default: all transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("gridHighlightConfig")]
        public CefSharp.DevTools.Overlay.GridHighlightConfig GridHighlightConfig
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// ColorFormat
    /// </summary>
    public enum ColorFormat
    {
        /// <summary>
        /// rgb
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rgb")]
        Rgb,
        /// <summary>
        /// hsl
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hsl")]
        Hsl,
        /// <summary>
        /// hex
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hex")]
        Hex
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// Configurations for Persistent Grid Highlight
    /// </summary>
    public class GridNodeHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// A descriptor for the highlight appearance.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("gridHighlightConfig")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Overlay.GridHighlightConfig GridHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the node to highlight.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// Configuration for dual screen hinge
    /// </summary>
    public class HingeConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// A rectangle represent hinge
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect Rect
        {
            get;
            set;
        }

        /// <summary>
        /// The content box highlight fill color (default: a dark color).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentColor")]
        public CefSharp.DevTools.DOM.RGBA ContentColor
        {
            get;
            set;
        }

        /// <summary>
        /// The content box highlight outline color (default: transparent).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("outlineColor")]
        public CefSharp.DevTools.DOM.RGBA OutlineColor
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// InspectMode
    /// </summary>
    public enum InspectMode
    {
        /// <summary>
        /// searchForNode
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("searchForNode")]
        SearchForNode,
        /// <summary>
        /// searchForUAShadowDOM
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("searchForUAShadowDOM")]
        SearchForUAShadowDOM,
        /// <summary>
        /// captureAreaScreenshot
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("captureAreaScreenshot")]
        CaptureAreaScreenshot,
        /// <summary>
        /// showDistances
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("showDistances")]
        ShowDistances,
        /// <summary>
        /// none
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("none")]
        None
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Indicates whether a frame has been identified as an ad.
    /// </summary>
    public enum AdFrameType
    {
        /// <summary>
        /// none
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("none")]
        None,
        /// <summary>
        /// child
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("child")]
        Child,
        /// <summary>
        /// root
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("root")]
        Root
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Indicates whether the frame is a secure context and why it is the case.
    /// </summary>
    public enum SecureContextType
    {
        /// <summary>
        /// Secure
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Secure")]
        Secure,
        /// <summary>
        /// SecureLocalhost
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("SecureLocalhost")]
        SecureLocalhost,
        /// <summary>
        /// InsecureScheme
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("InsecureScheme")]
        InsecureScheme,
        /// <summary>
        /// InsecureAncestor
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("InsecureAncestor")]
        InsecureAncestor
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Indicates whether the frame is cross-origin isolated and why it is the case.
    /// </summary>
    public enum CrossOriginIsolatedContextType
    {
        /// <summary>
        /// Isolated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Isolated")]
        Isolated,
        /// <summary>
        /// NotIsolated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("NotIsolated")]
        NotIsolated,
        /// <summary>
        /// NotIsolatedFeatureDisabled
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("NotIsolatedFeatureDisabled")]
        NotIsolatedFeatureDisabled
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Information about the Frame on the page.
    /// </summary>
    public class Frame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Frame unique identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Parent frame identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parentId")]
        public string ParentId
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the loader associated with this frame.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            set;
        }

        /// <summary>
        /// Frame&apos;s name as specified in the tag.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s URL without fragment.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s URL fragment including the &apos;#&apos;.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("urlFragment")]
        public string UrlFragment
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s registered domain, taking the public suffixes list into account.
        /// Extracted from the Frame&apos;s url.
        /// Example URLs: http://www.google.com/file.html -&gt; &quot;google.com&quot;
        ///               http://a.b.co.uk/file.html      -&gt; &quot;b.co.uk&quot;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("domainAndRegistry")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DomainAndRegistry
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s security origin.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SecurityOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s mimeType as determined by the browser.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mimeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MimeType
        {
            get;
            set;
        }

        /// <summary>
        /// If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unreachableUrl")]
        public string UnreachableUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this frame was tagged as an ad.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("adFrameType")]
        public CefSharp.DevTools.Page.AdFrameType? AdFrameType
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the main document is a secure context and explains why that is the case.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("secureContextType")]
        public CefSharp.DevTools.Page.SecureContextType SecureContextType
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this is a cross origin isolated context.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("crossOriginIsolatedContextType")]
        public CefSharp.DevTools.Page.CrossOriginIsolatedContextType CrossOriginIsolatedContextType
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Information about the Resource on the page.
    /// </summary>
    public class FrameResource : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Resource URL.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Type of this resource.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        public CefSharp.DevTools.Network.ResourceType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Resource mimeType as determined by the browser.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mimeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MimeType
        {
            get;
            set;
        }

        /// <summary>
        /// last-modified timestamp as reported by server.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lastModified")]
        public long? LastModified
        {
            get;
            set;
        }

        /// <summary>
        /// Resource content size.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentSize")]
        public long? ContentSize
        {
            get;
            set;
        }

        /// <summary>
        /// True if the resource failed to load.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("failed")]
        public bool? Failed
        {
            get;
            set;
        }

        /// <summary>
        /// True if the resource was canceled during loading.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("canceled")]
        public bool? Canceled
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Information about the Frame hierarchy along with their cached resources.
    /// </summary>
    public class FrameResourceTree : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Frame information for this tree item.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.Frame Frame
        {
            get;
            set;
        }

        /// <summary>
        /// Child frames.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("childFrames")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.FrameResourceTree> ChildFrames
        {
            get;
            set;
        }

        /// <summary>
        /// Information about frame resources.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resources")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.FrameResource> Resources
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Information about the Frame hierarchy.
    /// </summary>
    public class FrameTree : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Frame information for this tree item.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.Frame Frame
        {
            get;
            set;
        }

        /// <summary>
        /// Child frames.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("childFrames")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.FrameTree> ChildFrames
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Transition type.
    /// </summary>
    public enum TransitionType
    {
        /// <summary>
        /// link
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("link")]
        Link,
        /// <summary>
        /// typed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("typed")]
        Typed,
        /// <summary>
        /// address_bar
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("address_bar")]
        AddressBar,
        /// <summary>
        /// auto_bookmark
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("auto_bookmark")]
        AutoBookmark,
        /// <summary>
        /// auto_subframe
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("auto_subframe")]
        AutoSubframe,
        /// <summary>
        /// manual_subframe
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("manual_subframe")]
        ManualSubframe,
        /// <summary>
        /// generated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("generated")]
        Generated,
        /// <summary>
        /// auto_toplevel
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("auto_toplevel")]
        AutoToplevel,
        /// <summary>
        /// form_submit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("form_submit")]
        FormSubmit,
        /// <summary>
        /// reload
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reload")]
        Reload,
        /// <summary>
        /// keyword
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyword")]
        Keyword,
        /// <summary>
        /// keyword_generated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyword_generated")]
        KeywordGenerated,
        /// <summary>
        /// other
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("other")]
        Other
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Navigation history entry.
    /// </summary>
    public class NavigationEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Unique id of the navigation history entry.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the navigation history entry.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// URL that the user typed in the url bar.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("userTypedURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string UserTypedURL
        {
            get;
            set;
        }

        /// <summary>
        /// Title of the navigation history entry.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// Transition type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("transitionType")]
        public CefSharp.DevTools.Page.TransitionType TransitionType
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Screencast frame metadata.
    /// </summary>
    public class ScreencastFrameMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Top offset in DIP.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offsetTop")]
        public long OffsetTop
        {
            get;
            set;
        }

        /// <summary>
        /// Page scale factor.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pageScaleFactor")]
        public long PageScaleFactor
        {
            get;
            set;
        }

        /// <summary>
        /// Device screen width in DIP.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("deviceWidth")]
        public long DeviceWidth
        {
            get;
            set;
        }

        /// <summary>
        /// Device screen height in DIP.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("deviceHeight")]
        public long DeviceHeight
        {
            get;
            set;
        }

        /// <summary>
        /// Position of horizontal scroll in CSS pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollOffsetX")]
        public long ScrollOffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// Position of vertical scroll in CSS pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scrollOffsetY")]
        public long ScrollOffsetY
        {
            get;
            set;
        }

        /// <summary>
        /// Frame swap timestamp.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timestamp")]
        public long? Timestamp
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Javascript dialog type.
    /// </summary>
    public enum DialogType
    {
        /// <summary>
        /// alert
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("alert")]
        Alert,
        /// <summary>
        /// confirm
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("confirm")]
        Confirm,
        /// <summary>
        /// prompt
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("prompt")]
        Prompt,
        /// <summary>
        /// beforeunload
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("beforeunload")]
        Beforeunload
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Error while paring app manifest.
    /// </summary>
    public class AppManifestError : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Error message.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            set;
        }

        /// <summary>
        /// If criticial, this is a non-recoverable parse error.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("critical")]
        public int Critical
        {
            get;
            set;
        }

        /// <summary>
        /// Error line.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("line")]
        public int Line
        {
            get;
            set;
        }

        /// <summary>
        /// Error column.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("column")]
        public int Column
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Parsed app manifest properties.
    /// </summary>
    public class AppManifestParsedProperties : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Computed scope value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scope")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Scope
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Layout viewport position and dimensions.
    /// </summary>
    public class LayoutViewport : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Horizontal offset relative to the document (CSS pixels).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pageX")]
        public int PageX
        {
            get;
            set;
        }

        /// <summary>
        /// Vertical offset relative to the document (CSS pixels).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pageY")]
        public int PageY
        {
            get;
            set;
        }

        /// <summary>
        /// Width (CSS pixels), excludes scrollbar if present.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("clientWidth")]
        public int ClientWidth
        {
            get;
            set;
        }

        /// <summary>
        /// Height (CSS pixels), excludes scrollbar if present.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("clientHeight")]
        public int ClientHeight
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Visual viewport position, dimensions, and scale.
    /// </summary>
    public class VisualViewport : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Horizontal offset relative to the layout viewport (CSS pixels).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offsetX")]
        public long OffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// Vertical offset relative to the layout viewport (CSS pixels).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offsetY")]
        public long OffsetY
        {
            get;
            set;
        }

        /// <summary>
        /// Horizontal offset relative to the document (CSS pixels).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pageX")]
        public long PageX
        {
            get;
            set;
        }

        /// <summary>
        /// Vertical offset relative to the document (CSS pixels).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pageY")]
        public long PageY
        {
            get;
            set;
        }

        /// <summary>
        /// Width (CSS pixels), excludes scrollbar if present.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("clientWidth")]
        public long ClientWidth
        {
            get;
            set;
        }

        /// <summary>
        /// Height (CSS pixels), excludes scrollbar if present.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("clientHeight")]
        public long ClientHeight
        {
            get;
            set;
        }

        /// <summary>
        /// Scale relative to the ideal viewport (size at width=device-width).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scale")]
        public long Scale
        {
            get;
            set;
        }

        /// <summary>
        /// Page zoom factor (CSS to device independent pixels ratio).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("zoom")]
        public long? Zoom
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Viewport for capturing screenshot.
    /// </summary>
    public class Viewport : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// X offset in device independent pixels (dip).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("x")]
        public long X
        {
            get;
            set;
        }

        /// <summary>
        /// Y offset in device independent pixels (dip).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("y")]
        public long Y
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangle width in device independent pixels (dip).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("width")]
        public long Width
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangle height in device independent pixels (dip).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("height")]
        public long Height
        {
            get;
            set;
        }

        /// <summary>
        /// Page scale factor.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scale")]
        public long Scale
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Generic font families collection.
    /// </summary>
    public class FontFamilies : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The standard font-family.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("standard")]
        public string Standard
        {
            get;
            set;
        }

        /// <summary>
        /// The fixed font-family.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fixed")]
        public string Fixed
        {
            get;
            set;
        }

        /// <summary>
        /// The serif font-family.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("serif")]
        public string Serif
        {
            get;
            set;
        }

        /// <summary>
        /// The sansSerif font-family.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sansSerif")]
        public string SansSerif
        {
            get;
            set;
        }

        /// <summary>
        /// The cursive font-family.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cursive")]
        public string Cursive
        {
            get;
            set;
        }

        /// <summary>
        /// The fantasy font-family.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fantasy")]
        public string Fantasy
        {
            get;
            set;
        }

        /// <summary>
        /// The pictograph font-family.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pictograph")]
        public string Pictograph
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Default font sizes.
    /// </summary>
    public class FontSizes : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Default standard font size.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("standard")]
        public int? Standard
        {
            get;
            set;
        }

        /// <summary>
        /// Default fixed font size.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fixed")]
        public int? Fixed
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// ClientNavigationReason
    /// </summary>
    public enum ClientNavigationReason
    {
        /// <summary>
        /// formSubmissionGet
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("formSubmissionGet")]
        FormSubmissionGet,
        /// <summary>
        /// formSubmissionPost
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("formSubmissionPost")]
        FormSubmissionPost,
        /// <summary>
        /// httpHeaderRefresh
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("httpHeaderRefresh")]
        HttpHeaderRefresh,
        /// <summary>
        /// scriptInitiated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptInitiated")]
        ScriptInitiated,
        /// <summary>
        /// metaTagRefresh
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("metaTagRefresh")]
        MetaTagRefresh,
        /// <summary>
        /// pageBlockInterstitial
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pageBlockInterstitial")]
        PageBlockInterstitial,
        /// <summary>
        /// reload
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("reload")]
        Reload,
        /// <summary>
        /// anchorClick
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("anchorClick")]
        AnchorClick
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// ClientNavigationDisposition
    /// </summary>
    public enum ClientNavigationDisposition
    {
        /// <summary>
        /// currentTab
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("currentTab")]
        CurrentTab,
        /// <summary>
        /// newTab
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("newTab")]
        NewTab,
        /// <summary>
        /// newWindow
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("newWindow")]
        NewWindow,
        /// <summary>
        /// download
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("download")]
        Download
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// InstallabilityErrorArgument
    /// </summary>
    public class InstallabilityErrorArgument : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Argument name (e.g. name:&apos;minimum-icon-size-in-pixels&apos;).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Argument value (e.g. value:&apos;64&apos;).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// The installability error
    /// </summary>
    public class InstallabilityError : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The error id (e.g. &apos;manifest-missing-suitable-icon&apos;).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errorId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorId
        {
            get;
            set;
        }

        /// <summary>
        /// The list of error arguments (e.g. {name:&apos;minimum-icon-size-in-pixels&apos;, value:&apos;64&apos;}).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errorArguments")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.InstallabilityErrorArgument> ErrorArguments
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// The referring-policy used for the navigation.
    /// </summary>
    public enum ReferrerPolicy
    {
        /// <summary>
        /// noReferrer
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("noReferrer")]
        NoReferrer,
        /// <summary>
        /// noReferrerWhenDowngrade
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("noReferrerWhenDowngrade")]
        NoReferrerWhenDowngrade,
        /// <summary>
        /// origin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        Origin,
        /// <summary>
        /// originWhenCrossOrigin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("originWhenCrossOrigin")]
        OriginWhenCrossOrigin,
        /// <summary>
        /// sameOrigin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sameOrigin")]
        SameOrigin,
        /// <summary>
        /// strictOrigin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("strictOrigin")]
        StrictOrigin,
        /// <summary>
        /// strictOriginWhenCrossOrigin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("strictOriginWhenCrossOrigin")]
        StrictOriginWhenCrossOrigin,
        /// <summary>
        /// unsafeUrl
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unsafeUrl")]
        UnsafeUrl
    }
}

namespace CefSharp.DevTools.Performance
{
    /// <summary>
    /// Run-time execution metric.
    /// </summary>
    public class Metric : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Metric name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Metric value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public long Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// A description of mixed content (HTTP resources on HTTPS pages), as defined by
    /// https://www.w3.org/TR/mixed-content/#categories
    /// </summary>
    public enum MixedContentType
    {
        /// <summary>
        /// blockable
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("blockable")]
        Blockable,
        /// <summary>
        /// optionally-blockable
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("optionally-blockable")]
        OptionallyBlockable,
        /// <summary>
        /// none
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("none")]
        None
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// The security level of a page or resource.
    /// </summary>
    public enum SecurityState
    {
        /// <summary>
        /// unknown
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unknown")]
        Unknown,
        /// <summary>
        /// neutral
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("neutral")]
        Neutral,
        /// <summary>
        /// insecure
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("insecure")]
        Insecure,
        /// <summary>
        /// secure
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("secure")]
        Secure,
        /// <summary>
        /// info
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("info")]
        Info,
        /// <summary>
        /// insecure-broken
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("insecure-broken")]
        InsecureBroken
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// Details about the security state of the page certificate.
    /// </summary>
    public class CertificateSecurityState : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Protocol name (e.g. &quot;TLS 1.2&quot; or &quot;QUIC&quot;).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("protocol")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Protocol
        {
            get;
            set;
        }

        /// <summary>
        /// Key Exchange used by the connection, or the empty string if not applicable.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyExchange")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string KeyExchange
        {
            get;
            set;
        }

        /// <summary>
        /// (EC)DH group used by the connection, if applicable.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyExchangeGroup")]
        public string KeyExchangeGroup
        {
            get;
            set;
        }

        /// <summary>
        /// Cipher name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cipher")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Cipher
        {
            get;
            set;
        }

        /// <summary>
        /// TLS MAC. Note that AEAD ciphers do not have separate MACs.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mac")]
        public string Mac
        {
            get;
            set;
        }

        /// <summary>
        /// Page certificate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificate")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Certificate
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate subject name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subjectName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SubjectName
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the issuing CA.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("issuer")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Issuer
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate valid from date.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("validFrom")]
        public long ValidFrom
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate valid to (expiration) date
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("validTo")]
        public long ValidTo
        {
            get;
            set;
        }

        /// <summary>
        /// The highest priority network error code, if the certificate has an error.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificateNetworkError")]
        public string CertificateNetworkError
        {
            get;
            set;
        }

        /// <summary>
        /// True if the certificate uses a weak signature aglorithm.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificateHasWeakSignature")]
        public bool CertificateHasWeakSignature
        {
            get;
            set;
        }

        /// <summary>
        /// True if the certificate has a SHA1 signature in the chain.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificateHasSha1Signature")]
        public bool CertificateHasSha1Signature
        {
            get;
            set;
        }

        /// <summary>
        /// True if modern SSL
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("modernSSL")]
        public bool ModernSSL
        {
            get;
            set;
        }

        /// <summary>
        /// True if the connection is using an obsolete SSL protocol.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("obsoleteSslProtocol")]
        public bool ObsoleteSslProtocol
        {
            get;
            set;
        }

        /// <summary>
        /// True if the connection is using an obsolete SSL key exchange.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("obsoleteSslKeyExchange")]
        public bool ObsoleteSslKeyExchange
        {
            get;
            set;
        }

        /// <summary>
        /// True if the connection is using an obsolete SSL cipher.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("obsoleteSslCipher")]
        public bool ObsoleteSslCipher
        {
            get;
            set;
        }

        /// <summary>
        /// True if the connection is using an obsolete SSL signature.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("obsoleteSslSignature")]
        public bool ObsoleteSslSignature
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// SafetyTipStatus
    /// </summary>
    public enum SafetyTipStatus
    {
        /// <summary>
        /// badReputation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("badReputation")]
        BadReputation,
        /// <summary>
        /// lookalike
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lookalike")]
        Lookalike
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// SafetyTipInfo
    /// </summary>
    public class SafetyTipInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("safetyTipStatus")]
        public CefSharp.DevTools.Security.SafetyTipStatus SafetyTipStatus
        {
            get;
            set;
        }

        /// <summary>
        /// The URL the safety tip suggested (&quot;Did you mean?&quot;). Only filled in for lookalike matches.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("safeUrl")]
        public string SafeUrl
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// Security state information about the page.
    /// </summary>
    public class VisibleSecurityState : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The security level of the page.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityState")]
        public CefSharp.DevTools.Security.SecurityState SecurityState
        {
            get;
            set;
        }

        /// <summary>
        /// Security state details about the page certificate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificateSecurityState")]
        public CefSharp.DevTools.Security.CertificateSecurityState CertificateSecurityState
        {
            get;
            set;
        }

        /// <summary>
        /// The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("safetyTipInfo")]
        public CefSharp.DevTools.Security.SafetyTipInfo SafetyTipInfo
        {
            get;
            set;
        }

        /// <summary>
        /// Array of security state issues ids.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityStateIssueIds")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] SecurityStateIssueIds
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// An explanation of an factor contributing to the security state.
    /// </summary>
    public class SecurityStateExplanation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Security state representing the severity of the factor being explained.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("securityState")]
        public CefSharp.DevTools.Security.SecurityState SecurityState
        {
            get;
            set;
        }

        /// <summary>
        /// Title describing the type of factor.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// Short phrase describing the type of factor.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("summary")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Summary
        {
            get;
            set;
        }

        /// <summary>
        /// Full text explanation of the factor.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("description")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// The type of mixed content described by the explanation.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("mixedContentType")]
        public CefSharp.DevTools.Security.MixedContentType MixedContentType
        {
            get;
            set;
        }

        /// <summary>
        /// Page certificate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("certificate")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Certificate
        {
            get;
            set;
        }

        /// <summary>
        /// Recommendations to fix any issues.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("recommendations")]
        public string[] Recommendations
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// Information about insecure content on the page.
    /// </summary>
    public class InsecureContentStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Always false.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ranMixedContent")]
        public bool RanMixedContent
        {
            get;
            set;
        }

        /// <summary>
        /// Always false.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("displayedMixedContent")]
        public bool DisplayedMixedContent
        {
            get;
            set;
        }

        /// <summary>
        /// Always false.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("containedMixedForm")]
        public bool ContainedMixedForm
        {
            get;
            set;
        }

        /// <summary>
        /// Always false.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ranContentWithCertErrors")]
        public bool RanContentWithCertErrors
        {
            get;
            set;
        }

        /// <summary>
        /// Always false.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("displayedContentWithCertErrors")]
        public bool DisplayedContentWithCertErrors
        {
            get;
            set;
        }

        /// <summary>
        /// Always set to unknown.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ranInsecureContentStyle")]
        public CefSharp.DevTools.Security.SecurityState RanInsecureContentStyle
        {
            get;
            set;
        }

        /// <summary>
        /// Always set to unknown.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("displayedInsecureContentStyle")]
        public CefSharp.DevTools.Security.SecurityState DisplayedInsecureContentStyle
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// The action to take when a certificate error occurs. continue will continue processing the
    /// request and cancel will cancel the request.
    /// </summary>
    public enum CertificateErrorAction
    {
        /// <summary>
        /// continue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("continue")]
        Continue,
        /// <summary>
        /// cancel
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cancel")]
        Cancel
    }
}

namespace CefSharp.DevTools.ServiceWorker
{
    /// <summary>
    /// ServiceWorker registration.
    /// </summary>
    public class ServiceWorkerRegistration : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// RegistrationId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("registrationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RegistrationId
        {
            get;
            set;
        }

        /// <summary>
        /// ScopeURL
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scopeURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScopeURL
        {
            get;
            set;
        }

        /// <summary>
        /// IsDeleted
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isDeleted")]
        public bool IsDeleted
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.ServiceWorker
{
    /// <summary>
    /// ServiceWorkerVersionRunningStatus
    /// </summary>
    public enum ServiceWorkerVersionRunningStatus
    {
        /// <summary>
        /// stopped
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stopped")]
        Stopped,
        /// <summary>
        /// starting
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("starting")]
        Starting,
        /// <summary>
        /// running
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("running")]
        Running,
        /// <summary>
        /// stopping
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stopping")]
        Stopping
    }
}

namespace CefSharp.DevTools.ServiceWorker
{
    /// <summary>
    /// ServiceWorkerVersionStatus
    /// </summary>
    public enum ServiceWorkerVersionStatus
    {
        /// <summary>
        /// new
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("new")]
        New,
        /// <summary>
        /// installing
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("installing")]
        Installing,
        /// <summary>
        /// installed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("installed")]
        Installed,
        /// <summary>
        /// activating
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("activating")]
        Activating,
        /// <summary>
        /// activated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("activated")]
        Activated,
        /// <summary>
        /// redundant
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("redundant")]
        Redundant
    }
}

namespace CefSharp.DevTools.ServiceWorker
{
    /// <summary>
    /// ServiceWorker version.
    /// </summary>
    public class ServiceWorkerVersion : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// VersionId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("versionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string VersionId
        {
            get;
            set;
        }

        /// <summary>
        /// RegistrationId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("registrationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RegistrationId
        {
            get;
            set;
        }

        /// <summary>
        /// ScriptURL
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptURL
        {
            get;
            set;
        }

        /// <summary>
        /// RunningStatus
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("runningStatus")]
        public CefSharp.DevTools.ServiceWorker.ServiceWorkerVersionRunningStatus RunningStatus
        {
            get;
            set;
        }

        /// <summary>
        /// Status
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("status")]
        public CefSharp.DevTools.ServiceWorker.ServiceWorkerVersionStatus Status
        {
            get;
            set;
        }

        /// <summary>
        /// The Last-Modified header value of the main script.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptLastModified")]
        public long? ScriptLastModified
        {
            get;
            set;
        }

        /// <summary>
        /// The time at which the response headers of the main script were received from the server.
        /// For cached script it is the last time the cache entry was validated.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptResponseTime")]
        public long? ScriptResponseTime
        {
            get;
            set;
        }

        /// <summary>
        /// ControlledClients
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("controlledClients")]
        public string[] ControlledClients
        {
            get;
            set;
        }

        /// <summary>
        /// TargetId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("targetId")]
        public string TargetId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.ServiceWorker
{
    /// <summary>
    /// ServiceWorker error message.
    /// </summary>
    public class ServiceWorkerErrorMessage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ErrorMessage
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errorMessage")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorMessage
        {
            get;
            set;
        }

        /// <summary>
        /// RegistrationId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("registrationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RegistrationId
        {
            get;
            set;
        }

        /// <summary>
        /// VersionId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("versionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string VersionId
        {
            get;
            set;
        }

        /// <summary>
        /// SourceURL
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sourceURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// LineNumber
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// ColumnNumber
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// Enum of possible storage types.
    /// </summary>
    public enum StorageType
    {
        /// <summary>
        /// appcache
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("appcache")]
        Appcache,
        /// <summary>
        /// cookies
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookies")]
        Cookies,
        /// <summary>
        /// file_systems
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("file_systems")]
        FileSystems,
        /// <summary>
        /// indexeddb
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("indexeddb")]
        Indexeddb,
        /// <summary>
        /// local_storage
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("local_storage")]
        LocalStorage,
        /// <summary>
        /// shader_cache
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shader_cache")]
        ShaderCache,
        /// <summary>
        /// websql
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("websql")]
        Websql,
        /// <summary>
        /// service_workers
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("service_workers")]
        ServiceWorkers,
        /// <summary>
        /// cache_storage
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cache_storage")]
        CacheStorage,
        /// <summary>
        /// all
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("all")]
        All,
        /// <summary>
        /// other
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("other")]
        Other
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// Usage for a storage type.
    /// </summary>
    public class UsageForType : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name of storage type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("storageType")]
        public CefSharp.DevTools.Storage.StorageType StorageType
        {
            get;
            set;
        }

        /// <summary>
        /// Storage usage (bytes).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("usage")]
        public long Usage
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Describes a single graphics processor (GPU).
    /// </summary>
    public class GPUDevice : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// PCI ID of the GPU vendor, if available; 0 otherwise.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("vendorId")]
        public long VendorId
        {
            get;
            set;
        }

        /// <summary>
        /// PCI ID of the GPU device, if available; 0 otherwise.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("deviceId")]
        public long DeviceId
        {
            get;
            set;
        }

        /// <summary>
        /// Sub sys ID of the GPU, only available on Windows.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subSysId")]
        public long? SubSysId
        {
            get;
            set;
        }

        /// <summary>
        /// Revision of the GPU, only available on Windows.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("revision")]
        public long? Revision
        {
            get;
            set;
        }

        /// <summary>
        /// String description of the GPU vendor, if the PCI ID is not available.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("vendorString")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string VendorString
        {
            get;
            set;
        }

        /// <summary>
        /// String description of the GPU device, if the PCI ID is not available.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("deviceString")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DeviceString
        {
            get;
            set;
        }

        /// <summary>
        /// String description of the GPU driver vendor.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("driverVendor")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DriverVendor
        {
            get;
            set;
        }

        /// <summary>
        /// String description of the GPU driver version.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("driverVersion")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DriverVersion
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Describes the width and height dimensions of an entity.
    /// </summary>
    public class Size : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Width in pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("width")]
        public int Width
        {
            get;
            set;
        }

        /// <summary>
        /// Height in pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("height")]
        public int Height
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Describes a supported video decoding profile with its associated minimum and
    /// maximum resolutions.
    /// </summary>
    public class VideoDecodeAcceleratorCapability : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Video codec profile that is supported, e.g. VP9 Profile 2.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("profile")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Profile
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum video dimensions in pixels supported for this |profile|.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maxResolution")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MaxResolution
        {
            get;
            set;
        }

        /// <summary>
        /// Minimum video dimensions in pixels supported for this |profile|.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("minResolution")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MinResolution
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Describes a supported video encoding profile with its associated maximum
    /// resolution and maximum framerate.
    /// </summary>
    public class VideoEncodeAcceleratorCapability : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Video codec profile that is supported, e.g H264 Main.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("profile")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Profile
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum video dimensions in pixels supported for this |profile|.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maxResolution")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MaxResolution
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum encoding framerate in frames per second supported for this
        /// |profile|, as fraction&apos;s numerator and denominator, e.g. 24/1 fps,
        /// 24000/1001 fps, etc.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maxFramerateNumerator")]
        public int MaxFramerateNumerator
        {
            get;
            set;
        }

        /// <summary>
        /// MaxFramerateDenominator
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maxFramerateDenominator")]
        public int MaxFramerateDenominator
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// YUV subsampling type of the pixels of a given image.
    /// </summary>
    public enum SubsamplingFormat
    {
        /// <summary>
        /// yuv420
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("yuv420")]
        Yuv420,
        /// <summary>
        /// yuv422
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("yuv422")]
        Yuv422,
        /// <summary>
        /// yuv444
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("yuv444")]
        Yuv444
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Image format of a given image.
    /// </summary>
    public enum ImageType
    {
        /// <summary>
        /// jpeg
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("jpeg")]
        Jpeg,
        /// <summary>
        /// webp
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("webp")]
        Webp,
        /// <summary>
        /// unknown
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unknown")]
        Unknown
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Describes a supported image decoding profile with its associated minimum and
    /// maximum resolutions and subsampling.
    /// </summary>
    public class ImageDecodeAcceleratorCapability : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Image coded, e.g. Jpeg.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("imageType")]
        public CefSharp.DevTools.SystemInfo.ImageType ImageType
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum supported dimensions of the image in pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maxDimensions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MaxDimensions
        {
            get;
            set;
        }

        /// <summary>
        /// Minimum supported dimensions of the image in pixels.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("minDimensions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MinDimensions
        {
            get;
            set;
        }

        /// <summary>
        /// Optional array of supported subsampling formats, e.g. 4:2:0, if known.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subsamplings")]
        public CefSharp.DevTools.SystemInfo.SubsamplingFormat[] Subsamplings
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Provides information about the GPU(s) on the system.
    /// </summary>
    public class GPUInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The graphics devices on the system. Element 0 is the primary GPU.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("devices")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.GPUDevice> Devices
        {
            get;
            set;
        }

        /// <summary>
        /// An optional dictionary of additional GPU related attributes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("auxAttributes")]
        public object AuxAttributes
        {
            get;
            set;
        }

        /// <summary>
        /// An optional dictionary of graphics features and their status.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("featureStatus")]
        public object FeatureStatus
        {
            get;
            set;
        }

        /// <summary>
        /// An optional array of GPU driver bug workarounds.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("driverBugWorkarounds")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] DriverBugWorkarounds
        {
            get;
            set;
        }

        /// <summary>
        /// Supported accelerated video decoding capabilities.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("videoDecoding")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.VideoDecodeAcceleratorCapability> VideoDecoding
        {
            get;
            set;
        }

        /// <summary>
        /// Supported accelerated video encoding capabilities.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("videoEncoding")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.VideoEncodeAcceleratorCapability> VideoEncoding
        {
            get;
            set;
        }

        /// <summary>
        /// Supported accelerated image decoding capabilities.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("imageDecoding")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.ImageDecodeAcceleratorCapability> ImageDecoding
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Represents process info.
    /// </summary>
    public class ProcessInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Specifies process type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies process id.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies cumulative CPU usage in seconds across all threads of the
        /// process since the process start.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cpuTime")]
        public long CpuTime
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// TargetInfo
    /// </summary>
    public class TargetInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// TargetId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("targetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TargetId
        {
            get;
            set;
        }

        /// <summary>
        /// Type
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Title
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// Url
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the target has an attached client.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attached")]
        public bool Attached
        {
            get;
            set;
        }

        /// <summary>
        /// Opener target Id
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("openerId")]
        public string OpenerId
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the target has access to the originating window.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("canAccessOpener")]
        public bool CanAccessOpener
        {
            get;
            set;
        }

        /// <summary>
        /// Frame id of originating window (is only set if target has an opener).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("openerFrameId")]
        public string OpenerFrameId
        {
            get;
            set;
        }

        /// <summary>
        /// BrowserContextId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("browserContextId")]
        public string BrowserContextId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// RemoteLocation
    /// </summary>
    public class RemoteLocation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Host
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("host")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Host
        {
            get;
            set;
        }

        /// <summary>
        /// Port
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("port")]
        public int Port
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    /// <summary>
    /// TraceConfig
    /// </summary>
    public class TraceConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Controls how the trace buffer stores data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("recordMode")]
        public string RecordMode
        {
            get;
            set;
        }

        /// <summary>
        /// Turns on JavaScript stack sampling.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("enableSampling")]
        public bool? EnableSampling
        {
            get;
            set;
        }

        /// <summary>
        /// Turns on system tracing.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("enableSystrace")]
        public bool? EnableSystrace
        {
            get;
            set;
        }

        /// <summary>
        /// Turns on argument filter.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("enableArgumentFilter")]
        public bool? EnableArgumentFilter
        {
            get;
            set;
        }

        /// <summary>
        /// Included category filters.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("includedCategories")]
        public string[] IncludedCategories
        {
            get;
            set;
        }

        /// <summary>
        /// Excluded category filters.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("excludedCategories")]
        public string[] ExcludedCategories
        {
            get;
            set;
        }

        /// <summary>
        /// Configuration to synthesize the delays in tracing.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("syntheticDelays")]
        public string[] SyntheticDelays
        {
            get;
            set;
        }

        /// <summary>
        /// Configuration for memory dump triggers. Used only when &quot;memory-infra&quot; category is enabled.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("memoryDumpConfig")]
        public CefSharp.DevTools.Tracing.MemoryDumpConfig MemoryDumpConfig
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    /// <summary>
    /// Data format of a trace. Can be either the legacy JSON format or the
    /// protocol buffer format. Note that the JSON format will be deprecated soon.
    /// </summary>
    public enum StreamFormat
    {
        /// <summary>
        /// json
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("json")]
        Json,
        /// <summary>
        /// proto
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("proto")]
        Proto
    }
}

namespace CefSharp.DevTools.Tracing
{
    /// <summary>
    /// Compression type to use for traces returned via streams.
    /// </summary>
    public enum StreamCompression
    {
        /// <summary>
        /// none
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("none")]
        None,
        /// <summary>
        /// gzip
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("gzip")]
        Gzip
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// Stages of the request to handle. Request will intercept before the request is
    /// sent. Response will intercept after the response is received (but before response
    /// body is received.
    /// </summary>
    public enum RequestStage
    {
        /// <summary>
        /// Request
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Request")]
        Request,
        /// <summary>
        /// Response
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("Response")]
        Response
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// RequestPattern
    /// </summary>
    public class RequestPattern : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Wildcards (&apos;*&apos; -&gt; zero or more, &apos;?&apos; -&gt; exactly one) are allowed. Escape character is
        /// backslash. Omitting is equivalent to &quot;*&quot;.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("urlPattern")]
        public string UrlPattern
        {
            get;
            set;
        }

        /// <summary>
        /// If set, only requests for matching resource types will be intercepted.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resourceType")]
        public CefSharp.DevTools.Network.ResourceType? ResourceType
        {
            get;
            set;
        }

        /// <summary>
        /// Stage at wich to begin intercepting requests. Default is Request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("requestStage")]
        public CefSharp.DevTools.Fetch.RequestStage? RequestStage
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// Response HTTP header entry
    /// </summary>
    public class HeaderEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// Authorization challenge for HTTP status code 401 or 407.
    /// </summary>
    public class AuthChallenge : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Source of the authentication challenge.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("source")]
        public string Source
        {
            get;
            set;
        }

        /// <summary>
        /// Origin of the challenger.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// The authentication scheme used, such as basic or digest
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scheme")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Scheme
        {
            get;
            set;
        }

        /// <summary>
        /// The realm of the challenge. May be empty.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("realm")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Realm
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// Response to an AuthChallenge.
    /// </summary>
    public class AuthChallengeResponse : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The decision on what to do in response to the authorization challenge.  Default means
        /// deferring to the default behavior of the net stack, which will likely either the Cancel
        /// authentication or display a popup dialog box.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("response")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Response
        {
            get;
            set;
        }

        /// <summary>
        /// The username to provide, possibly empty. Should only be set if response is
        /// ProvideCredentials.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("username")]
        public string Username
        {
            get;
            set;
        }

        /// <summary>
        /// The password to provide, possibly empty. Should only be set if response is
        /// ProvideCredentials.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("password")]
        public string Password
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Enum of BaseAudioContext types
    /// </summary>
    public enum ContextType
    {
        /// <summary>
        /// realtime
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("realtime")]
        Realtime,
        /// <summary>
        /// offline
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offline")]
        Offline
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Enum of AudioContextState from the spec
    /// </summary>
    public enum ContextState
    {
        /// <summary>
        /// suspended
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("suspended")]
        Suspended,
        /// <summary>
        /// running
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("running")]
        Running,
        /// <summary>
        /// closed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("closed")]
        Closed
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Enum of AudioNode::ChannelCountMode from the spec
    /// </summary>
    public enum ChannelCountMode
    {
        /// <summary>
        /// clamped-max
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("clamped-max")]
        ClampedMax,
        /// <summary>
        /// explicit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("explicit")]
        Explicit,
        /// <summary>
        /// max
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("max")]
        Max
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Enum of AudioNode::ChannelInterpretation from the spec
    /// </summary>
    public enum ChannelInterpretation
    {
        /// <summary>
        /// discrete
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("discrete")]
        Discrete,
        /// <summary>
        /// speakers
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("speakers")]
        Speakers
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Enum of AudioParam::AutomationRate from the spec
    /// </summary>
    public enum AutomationRate
    {
        /// <summary>
        /// a-rate
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("a-rate")]
        ARate,
        /// <summary>
        /// k-rate
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("k-rate")]
        KRate
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Fields in AudioContext that change in real-time.
    /// </summary>
    public class ContextRealtimeData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The current context time in second in BaseAudioContext.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("currentTime")]
        public long CurrentTime
        {
            get;
            set;
        }

        /// <summary>
        /// The time spent on rendering graph divided by render qunatum duration,
        /// and multiplied by 100. 100 means the audio renderer reached the full
        /// capacity and glitch may occur.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("renderCapacity")]
        public long RenderCapacity
        {
            get;
            set;
        }

        /// <summary>
        /// A running mean of callback interval.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callbackIntervalMean")]
        public long CallbackIntervalMean
        {
            get;
            set;
        }

        /// <summary>
        /// A running variance of callback interval.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callbackIntervalVariance")]
        public long CallbackIntervalVariance
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Protocol object for BaseAudioContext
    /// </summary>
    public class BaseAudioContext : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            set;
        }

        /// <summary>
        /// ContextType
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contextType")]
        public CefSharp.DevTools.WebAudio.ContextType ContextType
        {
            get;
            set;
        }

        /// <summary>
        /// ContextState
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contextState")]
        public CefSharp.DevTools.WebAudio.ContextState ContextState
        {
            get;
            set;
        }

        /// <summary>
        /// RealtimeData
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("realtimeData")]
        public CefSharp.DevTools.WebAudio.ContextRealtimeData RealtimeData
        {
            get;
            set;
        }

        /// <summary>
        /// Platform-dependent callback buffer size.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callbackBufferSize")]
        public long CallbackBufferSize
        {
            get;
            set;
        }

        /// <summary>
        /// Number of output channels supported by audio hardware in use.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maxOutputChannelCount")]
        public long MaxOutputChannelCount
        {
            get;
            set;
        }

        /// <summary>
        /// Context sample rate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sampleRate")]
        public long SampleRate
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Protocol object for AudioListener
    /// </summary>
    public class AudioListener : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ListenerId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("listenerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ListenerId
        {
            get;
            set;
        }

        /// <summary>
        /// ContextId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Protocol object for AudioNode
    /// </summary>
    public class AudioNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// NodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// ContextId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            set;
        }

        /// <summary>
        /// NodeType
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// NumberOfInputs
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("numberOfInputs")]
        public long NumberOfInputs
        {
            get;
            set;
        }

        /// <summary>
        /// NumberOfOutputs
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("numberOfOutputs")]
        public long NumberOfOutputs
        {
            get;
            set;
        }

        /// <summary>
        /// ChannelCount
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("channelCount")]
        public long ChannelCount
        {
            get;
            set;
        }

        /// <summary>
        /// ChannelCountMode
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("channelCountMode")]
        public CefSharp.DevTools.WebAudio.ChannelCountMode ChannelCountMode
        {
            get;
            set;
        }

        /// <summary>
        /// ChannelInterpretation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("channelInterpretation")]
        public CefSharp.DevTools.WebAudio.ChannelInterpretation ChannelInterpretation
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Protocol object for AudioParam
    /// </summary>
    public class AudioParam : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ParamId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("paramId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ParamId
        {
            get;
            set;
        }

        /// <summary>
        /// NodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// ContextId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            set;
        }

        /// <summary>
        /// ParamType
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("paramType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ParamType
        {
            get;
            set;
        }

        /// <summary>
        /// Rate
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rate")]
        public CefSharp.DevTools.WebAudio.AutomationRate Rate
        {
            get;
            set;
        }

        /// <summary>
        /// DefaultValue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("defaultValue")]
        public long DefaultValue
        {
            get;
            set;
        }

        /// <summary>
        /// MinValue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("minValue")]
        public long MinValue
        {
            get;
            set;
        }

        /// <summary>
        /// MaxValue
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maxValue")]
        public long MaxValue
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// AuthenticatorProtocol
    /// </summary>
    public enum AuthenticatorProtocol
    {
        /// <summary>
        /// u2f
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("u2f")]
        U2f,
        /// <summary>
        /// ctap2
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ctap2")]
        Ctap2
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// AuthenticatorTransport
    /// </summary>
    public enum AuthenticatorTransport
    {
        /// <summary>
        /// usb
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("usb")]
        Usb,
        /// <summary>
        /// nfc
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nfc")]
        Nfc,
        /// <summary>
        /// ble
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ble")]
        Ble,
        /// <summary>
        /// cable
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cable")]
        Cable,
        /// <summary>
        /// internal
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("internal")]
        Internal
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// VirtualAuthenticatorOptions
    /// </summary>
    public class VirtualAuthenticatorOptions : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Protocol
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("protocol")]
        public CefSharp.DevTools.WebAuthn.AuthenticatorProtocol Protocol
        {
            get;
            set;
        }

        /// <summary>
        /// Transport
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("transport")]
        public CefSharp.DevTools.WebAuthn.AuthenticatorTransport Transport
        {
            get;
            set;
        }

        /// <summary>
        /// Defaults to false.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hasResidentKey")]
        public bool? HasResidentKey
        {
            get;
            set;
        }

        /// <summary>
        /// Defaults to false.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hasUserVerification")]
        public bool? HasUserVerification
        {
            get;
            set;
        }

        /// <summary>
        /// If set to true, tests of user presence will succeed immediately.
        /// Otherwise, they will not be resolved. Defaults to true.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("automaticPresenceSimulation")]
        public bool? AutomaticPresenceSimulation
        {
            get;
            set;
        }

        /// <summary>
        /// Sets whether User Verification succeeds or fails for an authenticator.
        /// Defaults to false.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isUserVerified")]
        public bool? IsUserVerified
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// Credential
    /// </summary>
    public class Credential : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CredentialId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("credentialId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] CredentialId
        {
            get;
            set;
        }

        /// <summary>
        /// IsResidentCredential
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isResidentCredential")]
        public bool IsResidentCredential
        {
            get;
            set;
        }

        /// <summary>
        /// Relying Party ID the credential is scoped to. Must be set when adding a
        /// credential.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rpId")]
        public string RpId
        {
            get;
            set;
        }

        /// <summary>
        /// The ECDSA P-256 private key in PKCS#8 format.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("privateKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] PrivateKey
        {
            get;
            set;
        }

        /// <summary>
        /// An opaque byte sequence with a maximum size of 64 bytes mapping the
        /// credential to a specific user.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("userHandle")]
        public byte[] UserHandle
        {
            get;
            set;
        }

        /// <summary>
        /// Signature counter. This is incremented by one for each successful
        /// assertion.
        /// See https://w3c.github.io/webauthn/#signature-counter
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("signCount")]
        public int SignCount
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Media
{
    /// <summary>
    /// Have one type per entry in MediaLogRecord::Type
    /// Corresponds to kMessage
    /// </summary>
    public class PlayerMessage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Keep in sync with MediaLogMessageLevel
        /// We are currently keeping the message level &apos;error&apos; separate from the
        /// PlayerError type because right now they represent different things,
        /// this one being a DVLOG(ERROR) style log message that gets printed
        /// based on what log level is selected in the UI, and the other is a
        /// representation of a media::PipelineStatus object. Soon however we&apos;re
        /// going to be moving away from using PipelineStatus for errors and
        /// introducing a new error type which should hopefully let us integrate
        /// the error log level into the PlayerError type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("level")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Level
        {
            get;
            set;
        }

        /// <summary>
        /// Message
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Media
{
    /// <summary>
    /// Corresponds to kMediaPropertyChange
    /// </summary>
    public class PlayerProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Media
{
    /// <summary>
    /// Corresponds to kMediaEventTriggered
    /// </summary>
    public class PlayerEvent : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Timestamp
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timestamp")]
        public long Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Media
{
    /// <summary>
    /// Corresponds to kMediaError
    /// </summary>
    public class PlayerError : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Type
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// When this switches to using media::Status instead of PipelineStatus
        /// we can remove &quot;errorCode&quot; and replace it with the fields from
        /// a Status instance. This also seems like a duplicate of the error
        /// level enum - there is a todo bug to have that level removed and
        /// use this instead. (crbug.com/1068454)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errorCode")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorCode
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// Location in the source code.
    /// </summary>
    public class Location : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Script identifier as reported in the `Debugger.scriptParsed`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Line number in the script (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Column number in the script (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNumber")]
        public int? ColumnNumber
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// Location in the source code.
    /// </summary>
    public class ScriptPosition : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// LineNumber
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// ColumnNumber
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// Location range within one script.
    /// </summary>
    public class LocationRange : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ScriptId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Start
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("start")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.ScriptPosition Start
        {
            get;
            set;
        }

        /// <summary>
        /// End
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("end")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.ScriptPosition End
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// JavaScript call frame. Array of call frames form the call stack.
    /// </summary>
    public class CallFrame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Call frame identifier. This identifier is only valid while the virtual machine is paused.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callFrameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CallFrameId
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the JavaScript function called on this call frame.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("functionName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FunctionName
        {
            get;
            set;
        }

        /// <summary>
        /// Location in the source code.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("functionLocation")]
        public CefSharp.DevTools.Debugger.Location FunctionLocation
        {
            get;
            set;
        }

        /// <summary>
        /// Location in the source code.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("location")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.Location Location
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script name or url.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Scope chain for this call frame.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scopeChain")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.Scope> ScopeChain
        {
            get;
            set;
        }

        /// <summary>
        /// `this` object for this call frame.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("this")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject This
        {
            get;
            set;
        }

        /// <summary>
        /// The value being returned, if the function is at return point.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("returnValue")]
        public CefSharp.DevTools.Runtime.RemoteObject ReturnValue
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// Scope description.
    /// </summary>
    public class Scope : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Scope type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Object representing the scope. For `global` and `with` scopes it represents the actual
        /// object; for the rest of the scopes, it is artificial transient object enumerating scope
        /// variables as its properties.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("object")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject Object
        {
            get;
            set;
        }

        /// <summary>
        /// Name
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Location in the source code where scope starts
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startLocation")]
        public CefSharp.DevTools.Debugger.Location StartLocation
        {
            get;
            set;
        }

        /// <summary>
        /// Location in the source code where scope ends
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endLocation")]
        public CefSharp.DevTools.Debugger.Location EndLocation
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// Search match for resource.
    /// </summary>
    public class SearchMatch : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Line number in resource content.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public long LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Line with match content.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineContent")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LineContent
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// BreakLocation
    /// </summary>
    public class BreakLocation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Script identifier as reported in the `Debugger.scriptParsed`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Line number in the script (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Column number in the script (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNumber")]
        public int? ColumnNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Type
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        public string Type
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// Enum of possible script languages.
    /// </summary>
    public enum ScriptLanguage
    {
        /// <summary>
        /// JavaScript
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("JavaScript")]
        JavaScript,
        /// <summary>
        /// WebAssembly
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("WebAssembly")]
        WebAssembly
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// Debug symbols available for a wasm script.
    /// </summary>
    public class DebugSymbols : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Type of the debug symbols.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the external symbol source.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("externalURL")]
        public string ExternalURL
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
    /// </summary>
    public class SamplingHeapProfileNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Function location.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callFrame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.CallFrame CallFrame
        {
            get;
            set;
        }

        /// <summary>
        /// Allocations size in bytes for the node excluding children.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("selfSize")]
        public long SelfSize
        {
            get;
            set;
        }

        /// <summary>
        /// Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// Child nodes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("children")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.HeapProfiler.SamplingHeapProfileNode> Children
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// A single sample from a sampling profile.
    /// </summary>
    public class SamplingHeapProfileSample : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Allocation size in bytes attributed to the sample.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("size")]
        public long Size
        {
            get;
            set;
        }

        /// <summary>
        /// Id of the corresponding profile tree node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Time-ordered sample ordinal number. It is unique across all profiles retrieved
        /// between startSampling and stopSampling.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ordinal")]
        public long Ordinal
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// Sampling profile.
    /// </summary>
    public class SamplingHeapProfile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Head
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("head")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.HeapProfiler.SamplingHeapProfileNode Head
        {
            get;
            set;
        }

        /// <summary>
        /// Samples
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("samples")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.HeapProfiler.SamplingHeapProfileSample> Samples
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Profile node. Holds callsite information, execution statistics and child nodes.
    /// </summary>
    public class ProfileNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Unique id of the node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// Function location.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callFrame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.CallFrame CallFrame
        {
            get;
            set;
        }

        /// <summary>
        /// Number of samples where this node was on top of the call stack.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hitCount")]
        public int? HitCount
        {
            get;
            set;
        }

        /// <summary>
        /// Child node ids.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("children")]
        public int[] Children
        {
            get;
            set;
        }

        /// <summary>
        /// The reason of being not optimized. The function may be deoptimized or marked as don&apos;t
        /// optimize.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("deoptReason")]
        public string DeoptReason
        {
            get;
            set;
        }

        /// <summary>
        /// An array of source position ticks.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("positionTicks")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.PositionTickInfo> PositionTicks
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Profile.
    /// </summary>
    public class Profile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The list of profile nodes. First item is the root node.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.ProfileNode> Nodes
        {
            get;
            set;
        }

        /// <summary>
        /// Profiling start timestamp in microseconds.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startTime")]
        public long StartTime
        {
            get;
            set;
        }

        /// <summary>
        /// Profiling end timestamp in microseconds.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endTime")]
        public long EndTime
        {
            get;
            set;
        }

        /// <summary>
        /// Ids of samples top nodes.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("samples")]
        public int[] Samples
        {
            get;
            set;
        }

        /// <summary>
        /// Time intervals between adjacent samples in microseconds. The first delta is relative to the
        /// profile startTime.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timeDeltas")]
        public int[] TimeDeltas
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Specifies a number of samples attributed to a certain source position.
    /// </summary>
    public class PositionTickInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Source line number (1-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("line")]
        public int Line
        {
            get;
            set;
        }

        /// <summary>
        /// Number of samples attributed to the source line.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ticks")]
        public int Ticks
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Coverage data for a source range.
    /// </summary>
    public class CoverageRange : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript script source offset for the range start.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("startOffset")]
        public int StartOffset
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script source offset for the range end.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("endOffset")]
        public int EndOffset
        {
            get;
            set;
        }

        /// <summary>
        /// Collected execution count of the source range.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("count")]
        public int Count
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Coverage data for a JavaScript function.
    /// </summary>
    public class FunctionCoverage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript function name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("functionName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FunctionName
        {
            get;
            set;
        }

        /// <summary>
        /// Source ranges inside the function with coverage data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ranges")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.CoverageRange> Ranges
        {
            get;
            set;
        }

        /// <summary>
        /// Whether coverage data for this function has block granularity.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isBlockCoverage")]
        public bool IsBlockCoverage
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Coverage data for a JavaScript script.
    /// </summary>
    public class ScriptCoverage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript script id.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script name or url.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Functions contained in the script that has coverage data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("functions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.FunctionCoverage> Functions
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Describes a type collected during runtime.
    /// </summary>
    public class TypeObject : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name of a type collected with type profiling.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Source offset and types for a parameter or return value.
    /// </summary>
    public class TypeProfileEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Source offset of the parameter or end of function for return values.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("offset")]
        public int Offset
        {
            get;
            set;
        }

        /// <summary>
        /// The types for this parameter or return value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("types")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.TypeObject> Types
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Type profile data collected during runtime for a JavaScript script.
    /// </summary>
    public class ScriptTypeProfile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript script id.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script name or url.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Type profile entries for parameters and return values of the functions in the script.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("entries")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.TypeProfileEntry> Entries
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Collected counter information.
    /// </summary>
    public class CounterInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Counter name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Counter value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public int Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Runtime call counter information.
    /// </summary>
    public class RuntimeCallCounterInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Counter name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Counter value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public long Value
        {
            get;
            set;
        }

        /// <summary>
        /// Counter time in seconds.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("time")]
        public long Time
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Mirror object referencing original JavaScript object.
    /// </summary>
    public class RemoteObject : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Object type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Object subtype hint. Specified for `object` or `wasm` type values only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subtype")]
        public string Subtype
        {
            get;
            set;
        }

        /// <summary>
        /// Object class (constructor) name. Specified for `object` type values only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("className")]
        public string ClassName
        {
            get;
            set;
        }

        /// <summary>
        /// Remote object value in case of primitive values or JSON values (if it was requested).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public object Value
        {
            get;
            set;
        }

        /// <summary>
        /// Primitive value which can not be JSON-stringified does not have `value`, but gets this
        /// property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unserializableValue")]
        public string UnserializableValue
        {
            get;
            set;
        }

        /// <summary>
        /// String representation of the object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("description")]
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// Unique object identifier (for non-primitive values).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("objectId")]
        public string ObjectId
        {
            get;
            set;
        }

        /// <summary>
        /// Preview containing abbreviated property values. Specified for `object` type values only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("preview")]
        public CefSharp.DevTools.Runtime.ObjectPreview Preview
        {
            get;
            set;
        }

        /// <summary>
        /// CustomPreview
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("customPreview")]
        public CefSharp.DevTools.Runtime.CustomPreview CustomPreview
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// CustomPreview
    /// </summary>
    public class CustomPreview : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The JSON-stringified result of formatter.header(object, config) call.
        /// It contains json ML array that represents RemoteObject.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("header")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Header
        {
            get;
            set;
        }

        /// <summary>
        /// If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
        /// contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
        /// The result value is json ML array.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bodyGetterId")]
        public string BodyGetterId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Object containing abbreviated remote object value.
    /// </summary>
    public class ObjectPreview : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Object type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Object subtype hint. Specified for `object` type values only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subtype")]
        public string Subtype
        {
            get;
            set;
        }

        /// <summary>
        /// String representation of the object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("description")]
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// True iff some of the properties or entries of the original object did not fit.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("overflow")]
        public bool Overflow
        {
            get;
            set;
        }

        /// <summary>
        /// List of the properties.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("properties")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.PropertyPreview> Properties
        {
            get;
            set;
        }

        /// <summary>
        /// List of the entries. Specified for `map` and `set` subtype values only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("entries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.EntryPreview> Entries
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// PropertyPreview
    /// </summary>
    public class PropertyPreview : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Property name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Object type. Accessor means that the property itself is an accessor property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// User-friendly property value string.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Nested value preview.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("valuePreview")]
        public CefSharp.DevTools.Runtime.ObjectPreview ValuePreview
        {
            get;
            set;
        }

        /// <summary>
        /// Object subtype hint. Specified for `object` type values only.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("subtype")]
        public string Subtype
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// EntryPreview
    /// </summary>
    public class EntryPreview : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Preview of the key. Specified for map-like collection entries.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("key")]
        public CefSharp.DevTools.Runtime.ObjectPreview Key
        {
            get;
            set;
        }

        /// <summary>
        /// Preview of the value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.ObjectPreview Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Object property descriptor.
    /// </summary>
    public class PropertyDescriptor : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Property name or symbol description.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The value associated with the property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public CefSharp.DevTools.Runtime.RemoteObject Value
        {
            get;
            set;
        }

        /// <summary>
        /// True if the value associated with the property may be changed (data descriptors only).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("writable")]
        public bool? Writable
        {
            get;
            set;
        }

        /// <summary>
        /// A function which serves as a getter for the property, or `undefined` if there is no getter
        /// (accessor descriptors only).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("get")]
        public CefSharp.DevTools.Runtime.RemoteObject Get
        {
            get;
            set;
        }

        /// <summary>
        /// A function which serves as a setter for the property, or `undefined` if there is no setter
        /// (accessor descriptors only).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("set")]
        public CefSharp.DevTools.Runtime.RemoteObject Set
        {
            get;
            set;
        }

        /// <summary>
        /// True if the type of this property descriptor may be changed and if the property may be
        /// deleted from the corresponding object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("configurable")]
        public bool Configurable
        {
            get;
            set;
        }

        /// <summary>
        /// True if this property shows up during enumeration of the properties on the corresponding
        /// object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("enumerable")]
        public bool Enumerable
        {
            get;
            set;
        }

        /// <summary>
        /// True if the result was thrown during the evaluation.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("wasThrown")]
        public bool? WasThrown
        {
            get;
            set;
        }

        /// <summary>
        /// True if the property is owned for the object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("isOwn")]
        public bool? IsOwn
        {
            get;
            set;
        }

        /// <summary>
        /// Property symbol object, if the property is of the `symbol` type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("symbol")]
        public CefSharp.DevTools.Runtime.RemoteObject Symbol
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Object internal property descriptor. This property isn&apos;t normally visible in JavaScript code.
    /// </summary>
    public class InternalPropertyDescriptor : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Conventional property name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The value associated with the property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public CefSharp.DevTools.Runtime.RemoteObject Value
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Object private field descriptor.
    /// </summary>
    public class PrivatePropertyDescriptor : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Private property name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The value associated with the private property.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public CefSharp.DevTools.Runtime.RemoteObject Value
        {
            get;
            set;
        }

        /// <summary>
        /// A function which serves as a getter for the private property,
        /// or `undefined` if there is no getter (accessor descriptors only).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("get")]
        public CefSharp.DevTools.Runtime.RemoteObject Get
        {
            get;
            set;
        }

        /// <summary>
        /// A function which serves as a setter for the private property,
        /// or `undefined` if there is no setter (accessor descriptors only).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("set")]
        public CefSharp.DevTools.Runtime.RemoteObject Set
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Represents function call argument. Either remote object id `objectId`, primitive `value`,
    /// unserializable primitive value or neither of (for undefined) them should be specified.
    /// </summary>
    public class CallArgument : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Primitive value or serializable javascript object.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("value")]
        public object Value
        {
            get;
            set;
        }

        /// <summary>
        /// Primitive value which can not be JSON-stringified.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("unserializableValue")]
        public string UnserializableValue
        {
            get;
            set;
        }

        /// <summary>
        /// Remote object handle.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("objectId")]
        public string ObjectId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Description of an isolated world.
    /// </summary>
    public class ExecutionContextDescription : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Unique id of the execution context. It can be used to specify in which execution context
        /// script evaluation should be performed.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// Execution context origin.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Human readable name describing given context.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Embedder-specific auxiliary data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("auxData")]
        public object AuxData
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Detailed information about exception (or error) that was thrown during script compilation or
    /// execution.
    /// </summary>
    public class ExceptionDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Exception id.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionId")]
        public int ExceptionId
        {
            get;
            set;
        }

        /// <summary>
        /// Exception text, which should be used together with exception object when available.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Line number of the exception location (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Column number of the exception location (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Script ID of the exception location.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the exception location, to be used when the script was not reported.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript stack trace if available.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            set;
        }

        /// <summary>
        /// Exception object if available.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exception")]
        public CefSharp.DevTools.Runtime.RemoteObject Exception
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the context where exception happened.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("executionContextId")]
        public int? ExecutionContextId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Stack entry for runtime errors and assertions.
    /// </summary>
    public class CallFrame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript function name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("functionName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FunctionName
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script id.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script name or url.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script line number (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script column number (0-based).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// Call frames for assertions or error messages.
    /// </summary>
    public class StackTrace : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// String label of this stack trace. For async traces this may be a name of the function that
        /// initiated the async call.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("description")]
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript function name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callFrames")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.CallFrame> CallFrames
        {
            get;
            set;
        }

        /// <summary>
        /// Asynchronous JavaScript stack trace that preceded this stack, if available.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parent")]
        public CefSharp.DevTools.Runtime.StackTrace Parent
        {
            get;
            set;
        }

        /// <summary>
        /// Asynchronous JavaScript stack trace that preceded this stack, if available.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parentId")]
        public CefSharp.DevTools.Runtime.StackTraceId ParentId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
    /// allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
    /// </summary>
    public class StackTraceId : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// DebuggerId
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("debuggerId")]
        public string DebuggerId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// GetPartialAXTreeResponse
    /// </summary>
    public class GetPartialAXTreeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodes
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// GetFullAXTreeResponse
    /// </summary>
    public class GetFullAXTreeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodes
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// QueryAXTreeResponse
    /// </summary>
    public class QueryAXTreeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodes
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    using System.Linq;

    /// <summary>
    /// Accessibility
    /// </summary>
    public partial class AccessibilityClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public AccessibilityClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables the accessibility domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Accessibility.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
        /// This turns on accessibility for the page, which can impact performance until accessibility is disabled.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Accessibility.enable", dict);
            return methodResult;
        }

        partial void ValidateGetPartialAXTree(int? nodeId = null, int? backendNodeId = null, string objectId = null, bool? fetchRelatives = null);
        /// <summary>
        /// Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node to get the partial accessibility tree for.</param>
        /// <param name = "backendNodeId">Identifier of the backend node to get the partial accessibility tree for.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper to get the partial accessibility tree for.</param>
        /// <param name = "fetchRelatives">Whether to fetch this nodes ancestors, siblings and children. Defaults to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPartialAXTreeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetPartialAXTreeResponse> GetPartialAXTreeAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null, bool? fetchRelatives = null)
        {
            ValidateGetPartialAXTree(nodeId, backendNodeId, objectId, fetchRelatives);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if (fetchRelatives.HasValue)
            {
                dict.Add("fetchRelatives", fetchRelatives.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Accessibility.getPartialAXTree", dict);
            return methodResult.DeserializeJson<GetPartialAXTreeResponse>();
        }

        /// <summary>
        /// Fetches the entire accessibility tree
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFullAXTreeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetFullAXTreeResponse> GetFullAXTreeAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Accessibility.getFullAXTree", dict);
            return methodResult.DeserializeJson<GetFullAXTreeResponse>();
        }

        partial void ValidateQueryAXTree(int? nodeId = null, int? backendNodeId = null, string objectId = null, string accessibleName = null, string role = null);
        /// <summary>
        /// Query a DOM node&apos;s accessibility subtree for accessible name and role.
        /// This command computes the name and role for all nodes in the subtree, including those that are
        /// ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
        /// node is specified, or the DOM node does not exist, the command returns an error. If neither
        /// `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node for the root to query.</param>
        /// <param name = "backendNodeId">Identifier of the backend node for the root to query.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper for the root to query.</param>
        /// <param name = "accessibleName">Find nodes with this computed name.</param>
        /// <param name = "role">Find nodes with this computed role.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;QueryAXTreeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<QueryAXTreeResponse> QueryAXTreeAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null, string accessibleName = null, string role = null)
        {
            ValidateQueryAXTree(nodeId, backendNodeId, objectId, accessibleName, role);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if (!(string.IsNullOrEmpty(accessibleName)))
            {
                dict.Add("accessibleName", accessibleName);
            }

            if (!(string.IsNullOrEmpty(role)))
            {
                dict.Add("role", role);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Accessibility.queryAXTree", dict);
            return methodResult.DeserializeJson<QueryAXTreeResponse>();
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// GetCurrentTimeResponse
    /// </summary>
    public class GetCurrentTimeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// currentTime
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("currentTime")]
        public long CurrentTime
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// GetPlaybackRateResponse
    /// </summary>
    public class GetPlaybackRateResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// playbackRate
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("playbackRate")]
        public long PlaybackRate
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// ResolveAnimationResponse
    /// </summary>
    public class ResolveAnimationResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// remoteObject
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("remoteObject")]
        public CefSharp.DevTools.Runtime.RemoteObject RemoteObject
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    using System.Linq;

    /// <summary>
    /// Animation
    /// </summary>
    public partial class AnimationClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public AnimationClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables animation domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables animation domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.enable", dict);
            return methodResult;
        }

        partial void ValidateGetCurrentTime(string id);
        /// <summary>
        /// Returns the current time of the an animation.
        /// </summary>
        /// <param name = "id">Id of animation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCurrentTimeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetCurrentTimeResponse> GetCurrentTimeAsync(string id)
        {
            ValidateGetCurrentTime(id);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("id", id);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.getCurrentTime", dict);
            return methodResult.DeserializeJson<GetCurrentTimeResponse>();
        }

        /// <summary>
        /// Gets the playback rate of the document timeline.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPlaybackRateResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetPlaybackRateResponse> GetPlaybackRateAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.getPlaybackRate", dict);
            return methodResult.DeserializeJson<GetPlaybackRateResponse>();
        }

        partial void ValidateReleaseAnimations(string[] animations);
        /// <summary>
        /// Releases a set of animations to no longer be manipulated.
        /// </summary>
        /// <param name = "animations">List of animation ids to seek.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ReleaseAnimationsAsync(string[] animations)
        {
            ValidateReleaseAnimations(animations);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animations", animations);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.releaseAnimations", dict);
            return methodResult;
        }

        partial void ValidateResolveAnimation(string animationId);
        /// <summary>
        /// Gets the remote object of the Animation.
        /// </summary>
        /// <param name = "animationId">Animation id.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ResolveAnimationResponse&gt;</returns>
        public async System.Threading.Tasks.Task<ResolveAnimationResponse> ResolveAnimationAsync(string animationId)
        {
            ValidateResolveAnimation(animationId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animationId", animationId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.resolveAnimation", dict);
            return methodResult.DeserializeJson<ResolveAnimationResponse>();
        }

        partial void ValidateSeekAnimations(string[] animations, long currentTime);
        /// <summary>
        /// Seek a set of animations to a particular time within each animation.
        /// </summary>
        /// <param name = "animations">List of animation ids to seek.</param>
        /// <param name = "currentTime">Set the current time of each animation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SeekAnimationsAsync(string[] animations, long currentTime)
        {
            ValidateSeekAnimations(animations, currentTime);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animations", animations);
            dict.Add("currentTime", currentTime);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.seekAnimations", dict);
            return methodResult;
        }

        partial void ValidateSetPaused(string[] animations, bool paused);
        /// <summary>
        /// Sets the paused state of a set of animations.
        /// </summary>
        /// <param name = "animations">Animations to set the pause state of.</param>
        /// <param name = "paused">Paused state to set to.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetPausedAsync(string[] animations, bool paused)
        {
            ValidateSetPaused(animations, paused);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animations", animations);
            dict.Add("paused", paused);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.setPaused", dict);
            return methodResult;
        }

        partial void ValidateSetPlaybackRate(long playbackRate);
        /// <summary>
        /// Sets the playback rate of the document timeline.
        /// </summary>
        /// <param name = "playbackRate">Playback rate for animations on page</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetPlaybackRateAsync(long playbackRate)
        {
            ValidateSetPlaybackRate(playbackRate);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("playbackRate", playbackRate);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.setPlaybackRate", dict);
            return methodResult;
        }

        partial void ValidateSetTiming(string animationId, long duration, long delay);
        /// <summary>
        /// Sets the timing of an animation node.
        /// </summary>
        /// <param name = "animationId">Animation id.</param>
        /// <param name = "duration">Duration of the animation.</param>
        /// <param name = "delay">Delay of the animation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetTimingAsync(string animationId, long duration, long delay)
        {
            ValidateSetTiming(animationId, duration, delay);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animationId", animationId);
            dict.Add("duration", duration);
            dict.Add("delay", delay);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Animation.setTiming", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.ApplicationCache
{
    /// <summary>
    /// GetApplicationCacheForFrameResponse
    /// </summary>
    public class GetApplicationCacheForFrameResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// applicationCache
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("applicationCache")]
        public CefSharp.DevTools.ApplicationCache.ApplicationCache ApplicationCache
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.ApplicationCache
{
    /// <summary>
    /// GetFramesWithManifestsResponse
    /// </summary>
    public class GetFramesWithManifestsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// frameIds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameIds")]
        public System.Collections.Generic.IList<CefSharp.DevTools.ApplicationCache.FrameWithManifest> FrameIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.ApplicationCache
{
    /// <summary>
    /// GetManifestForFrameResponse
    /// </summary>
    public class GetManifestForFrameResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// manifestURL
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("manifestURL")]
        public string ManifestURL
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.ApplicationCache
{
    using System.Linq;

    /// <summary>
    /// ApplicationCache
    /// </summary>
    public partial class ApplicationCacheClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public ApplicationCacheClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Enables application cache domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ApplicationCache.enable", dict);
            return methodResult;
        }

        partial void ValidateGetApplicationCacheForFrame(string frameId);
        /// <summary>
        /// Returns relevant application cache data for the document in given frame.
        /// </summary>
        /// <param name = "frameId">Identifier of the frame containing document whose application cache is retrieved.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetApplicationCacheForFrameResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetApplicationCacheForFrameResponse> GetApplicationCacheForFrameAsync(string frameId)
        {
            ValidateGetApplicationCacheForFrame(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ApplicationCache.getApplicationCacheForFrame", dict);
            return methodResult.DeserializeJson<GetApplicationCacheForFrameResponse>();
        }

        /// <summary>
        /// Returns array of frame identifiers with manifest urls for each frame containing a document
        /// associated with some application cache.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFramesWithManifestsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetFramesWithManifestsResponse> GetFramesWithManifestsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ApplicationCache.getFramesWithManifests", dict);
            return methodResult.DeserializeJson<GetFramesWithManifestsResponse>();
        }

        partial void ValidateGetManifestForFrame(string frameId);
        /// <summary>
        /// Returns manifest URL for document in the given frame.
        /// </summary>
        /// <param name = "frameId">Identifier of the frame containing document whose manifest is retrieved.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetManifestForFrameResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetManifestForFrameResponse> GetManifestForFrameAsync(string frameId)
        {
            ValidateGetManifestForFrame(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ApplicationCache.getManifestForFrame", dict);
            return methodResult.DeserializeJson<GetManifestForFrameResponse>();
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// GetEncodedResponseResponse
    /// </summary>
    public class GetEncodedResponseResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// body
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("body")]
        public byte[] Body
        {
            get;
            private set;
        }

        /// <summary>
        /// originalSize
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("originalSize")]
        public int OriginalSize
        {
            get;
            private set;
        }

        /// <summary>
        /// encodedSize
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("encodedSize")]
        public int EncodedSize
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    using System.Linq;

    /// <summary>
    /// Audits domain allows investigation of page violations and possible improvements.
    /// </summary>
    public partial class AuditsClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public AuditsClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateGetEncodedResponse(string requestId, string encoding, long? quality = null, bool? sizeOnly = null);
        /// <summary>
        /// Returns the response body and size if it were re-encoded with the specified settings. Only
        /// applies to images.
        /// </summary>
        /// <param name = "requestId">Identifier of the network request to get content for.</param>
        /// <param name = "encoding">The encoding to use.</param>
        /// <param name = "quality">The quality of the encoding (0-1). (defaults to 1)</param>
        /// <param name = "sizeOnly">Whether to only return the size information (defaults to false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetEncodedResponseResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetEncodedResponseResponse> GetEncodedResponseAsync(string requestId, string encoding, long? quality = null, bool? sizeOnly = null)
        {
            ValidateGetEncodedResponse(requestId, encoding, quality, sizeOnly);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("encoding", encoding);
            if (quality.HasValue)
            {
                dict.Add("quality", quality.Value);
            }

            if (sizeOnly.HasValue)
            {
                dict.Add("sizeOnly", sizeOnly.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Audits.getEncodedResponse", dict);
            return methodResult.DeserializeJson<GetEncodedResponseResponse>();
        }

        /// <summary>
        /// Disables issues domain, prevents further issues from being reported to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Audits.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables issues domain, sends the issues collected so far to the client by means of the
        /// `issueAdded` event.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Audits.enable", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.BackgroundService
{
    using System.Linq;

    /// <summary>
    /// Defines events for background web platform features.
    /// </summary>
    public partial class BackgroundServiceClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public BackgroundServiceClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateStartObserving(CefSharp.DevTools.BackgroundService.ServiceName service);
        /// <summary>
        /// Enables event updates for the service.
        /// </summary>
        /// <param name = "service">service</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartObservingAsync(CefSharp.DevTools.BackgroundService.ServiceName service)
        {
            ValidateStartObserving(service);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("service", this.EnumToString(service));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("BackgroundService.startObserving", dict);
            return methodResult;
        }

        partial void ValidateStopObserving(CefSharp.DevTools.BackgroundService.ServiceName service);
        /// <summary>
        /// Disables event updates for the service.
        /// </summary>
        /// <param name = "service">service</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopObservingAsync(CefSharp.DevTools.BackgroundService.ServiceName service)
        {
            ValidateStopObserving(service);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("service", this.EnumToString(service));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("BackgroundService.stopObserving", dict);
            return methodResult;
        }

        partial void ValidateSetRecording(bool shouldRecord, CefSharp.DevTools.BackgroundService.ServiceName service);
        /// <summary>
        /// Set the recording state for the service.
        /// </summary>
        /// <param name = "shouldRecord">shouldRecord</param>
        /// <param name = "service">service</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetRecordingAsync(bool shouldRecord, CefSharp.DevTools.BackgroundService.ServiceName service)
        {
            ValidateSetRecording(shouldRecord, service);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("shouldRecord", shouldRecord);
            dict.Add("service", this.EnumToString(service));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("BackgroundService.setRecording", dict);
            return methodResult;
        }

        partial void ValidateClearEvents(CefSharp.DevTools.BackgroundService.ServiceName service);
        /// <summary>
        /// Clears all stored data for the service.
        /// </summary>
        /// <param name = "service">service</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearEventsAsync(CefSharp.DevTools.BackgroundService.ServiceName service)
        {
            ValidateClearEvents(service);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("service", this.EnumToString(service));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("BackgroundService.clearEvents", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetVersionResponse
    /// </summary>
    public class GetVersionResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// protocolVersion
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("protocolVersion")]
        public string ProtocolVersion
        {
            get;
            private set;
        }

        /// <summary>
        /// product
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("product")]
        public string Product
        {
            get;
            private set;
        }

        /// <summary>
        /// revision
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("revision")]
        public string Revision
        {
            get;
            private set;
        }

        /// <summary>
        /// userAgent
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("userAgent")]
        public string UserAgent
        {
            get;
            private set;
        }

        /// <summary>
        /// jsVersion
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("jsVersion")]
        public string JsVersion
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetBrowserCommandLineResponse
    /// </summary>
    public class GetBrowserCommandLineResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// arguments
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("arguments")]
        public string[] Arguments
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetHistogramsResponse
    /// </summary>
    public class GetHistogramsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// histograms
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("histograms")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Browser.Histogram> Histograms
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetHistogramResponse
    /// </summary>
    public class GetHistogramResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// histogram
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("histogram")]
        public CefSharp.DevTools.Browser.Histogram Histogram
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetWindowBoundsResponse
    /// </summary>
    public class GetWindowBoundsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// bounds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bounds")]
        public CefSharp.DevTools.Browser.Bounds Bounds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetWindowForTargetResponse
    /// </summary>
    public class GetWindowForTargetResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// windowId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("windowId")]
        public int WindowId
        {
            get;
            private set;
        }

        /// <summary>
        /// bounds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bounds")]
        public CefSharp.DevTools.Browser.Bounds Bounds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    using System.Linq;

    /// <summary>
    /// The Browser domain defines methods and events for browser managing.
    /// </summary>
    public partial class BrowserClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public BrowserClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateSetPermission(CefSharp.DevTools.Browser.PermissionDescriptor permission, CefSharp.DevTools.Browser.PermissionSetting setting, string origin = null, string browserContextId = null);
        /// <summary>
        /// Set permission settings for given origin.
        /// </summary>
        /// <param name = "permission">Descriptor of permission to override.</param>
        /// <param name = "setting">Setting of the permission.</param>
        /// <param name = "origin">Origin the permission applies to, all origins if not specified.</param>
        /// <param name = "browserContextId">Context to override. When omitted, default browser context is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetPermissionAsync(CefSharp.DevTools.Browser.PermissionDescriptor permission, CefSharp.DevTools.Browser.PermissionSetting setting, string origin = null, string browserContextId = null)
        {
            ValidateSetPermission(permission, setting, origin, browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("permission", permission.ToDictionary());
            dict.Add("setting", this.EnumToString(setting));
            if (!(string.IsNullOrEmpty(origin)))
            {
                dict.Add("origin", origin);
            }

            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.setPermission", dict);
            return methodResult;
        }

        partial void ValidateGrantPermissions(CefSharp.DevTools.Browser.PermissionType[] permissions, string origin = null, string browserContextId = null);
        /// <summary>
        /// Grant specific permissions to the given origin and reject all others.
        /// </summary>
        /// <param name = "permissions">permissions</param>
        /// <param name = "origin">Origin the permission applies to, all origins if not specified.</param>
        /// <param name = "browserContextId">BrowserContext to override permissions. When omitted, default browser context is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> GrantPermissionsAsync(CefSharp.DevTools.Browser.PermissionType[] permissions, string origin = null, string browserContextId = null)
        {
            ValidateGrantPermissions(permissions, origin, browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("permissions", this.EnumToString(permissions));
            if (!(string.IsNullOrEmpty(origin)))
            {
                dict.Add("origin", origin);
            }

            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.grantPermissions", dict);
            return methodResult;
        }

        partial void ValidateResetPermissions(string browserContextId = null);
        /// <summary>
        /// Reset all permission management for all origins.
        /// </summary>
        /// <param name = "browserContextId">BrowserContext to reset permissions. When omitted, default browser context is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ResetPermissionsAsync(string browserContextId = null)
        {
            ValidateResetPermissions(browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.resetPermissions", dict);
            return methodResult;
        }

        partial void ValidateSetDownloadBehavior(string behavior, string browserContextId = null, string downloadPath = null);
        /// <summary>
        /// Set the behavior when downloading a file.
        /// </summary>
        /// <param name = "behavior">Whether to allow all or deny all download requests, or use default Chrome behavior ifavailable (otherwise deny). |allowAndName| allows download and names files according totheir dowmload guids.</param>
        /// <param name = "browserContextId">BrowserContext to set download behavior. When omitted, default browser context is used.</param>
        /// <param name = "downloadPath">The default path to save downloaded files to. This is requred if behavior is set to 'allow'or 'allowAndName'.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDownloadBehaviorAsync(string behavior, string browserContextId = null, string downloadPath = null)
        {
            ValidateSetDownloadBehavior(behavior, browserContextId, downloadPath);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("behavior", behavior);
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            if (!(string.IsNullOrEmpty(downloadPath)))
            {
                dict.Add("downloadPath", downloadPath);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.setDownloadBehavior", dict);
            return methodResult;
        }

        /// <summary>
        /// Close browser gracefully.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> CloseAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.close", dict);
            return methodResult;
        }

        /// <summary>
        /// Crashes browser on the main thread.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> CrashAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.crash", dict);
            return methodResult;
        }

        /// <summary>
        /// Crashes GPU process.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> CrashGpuProcessAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.crashGpuProcess", dict);
            return methodResult;
        }

        /// <summary>
        /// Returns version information.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetVersionResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetVersionResponse> GetVersionAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.getVersion", dict);
            return methodResult.DeserializeJson<GetVersionResponse>();
        }

        /// <summary>
        /// Returns the command line switches for the browser process if, and only if
        /// --enable-automation is on the commandline.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBrowserCommandLineResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetBrowserCommandLineResponse> GetBrowserCommandLineAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.getBrowserCommandLine", dict);
            return methodResult.DeserializeJson<GetBrowserCommandLineResponse>();
        }

        partial void ValidateGetHistograms(string query = null, bool? delta = null);
        /// <summary>
        /// Get Chrome histograms.
        /// </summary>
        /// <param name = "query">Requested substring in name. Only histograms which have query as asubstring in their name are extracted. An empty or absent query returnsall histograms.</param>
        /// <param name = "delta">If true, retrieve delta since last call.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHistogramsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetHistogramsResponse> GetHistogramsAsync(string query = null, bool? delta = null)
        {
            ValidateGetHistograms(query, delta);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(query)))
            {
                dict.Add("query", query);
            }

            if (delta.HasValue)
            {
                dict.Add("delta", delta.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.getHistograms", dict);
            return methodResult.DeserializeJson<GetHistogramsResponse>();
        }

        partial void ValidateGetHistogram(string name, bool? delta = null);
        /// <summary>
        /// Get a Chrome histogram by name.
        /// </summary>
        /// <param name = "name">Requested histogram name.</param>
        /// <param name = "delta">If true, retrieve delta since last call.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHistogramResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetHistogramResponse> GetHistogramAsync(string name, bool? delta = null)
        {
            ValidateGetHistogram(name, delta);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            if (delta.HasValue)
            {
                dict.Add("delta", delta.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.getHistogram", dict);
            return methodResult.DeserializeJson<GetHistogramResponse>();
        }

        partial void ValidateGetWindowBounds(int windowId);
        /// <summary>
        /// Get position and size of the browser window.
        /// </summary>
        /// <param name = "windowId">Browser window id.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetWindowBoundsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetWindowBoundsResponse> GetWindowBoundsAsync(int windowId)
        {
            ValidateGetWindowBounds(windowId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("windowId", windowId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.getWindowBounds", dict);
            return methodResult.DeserializeJson<GetWindowBoundsResponse>();
        }

        partial void ValidateGetWindowForTarget(string targetId = null);
        /// <summary>
        /// Get the browser window that contains the devtools target.
        /// </summary>
        /// <param name = "targetId">Devtools agent host id. If called as a part of the session, associated targetId is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetWindowForTargetResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetWindowForTargetResponse> GetWindowForTargetAsync(string targetId = null)
        {
            ValidateGetWindowForTarget(targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(targetId)))
            {
                dict.Add("targetId", targetId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.getWindowForTarget", dict);
            return methodResult.DeserializeJson<GetWindowForTargetResponse>();
        }

        partial void ValidateSetWindowBounds(int windowId, CefSharp.DevTools.Browser.Bounds bounds);
        /// <summary>
        /// Set position and/or size of the browser window.
        /// </summary>
        /// <param name = "windowId">Browser window id.</param>
        /// <param name = "bounds">New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combinedwith 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetWindowBoundsAsync(int windowId, CefSharp.DevTools.Browser.Bounds bounds)
        {
            ValidateSetWindowBounds(windowId, bounds);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("windowId", windowId);
            dict.Add("bounds", bounds.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.setWindowBounds", dict);
            return methodResult;
        }

        partial void ValidateSetDockTile(string badgeLabel = null, byte[] image = null);
        /// <summary>
        /// Set dock tile details, platform-specific.
        /// </summary>
        /// <param name = "badgeLabel">badgeLabel</param>
        /// <param name = "image">Png encoded image.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDockTileAsync(string badgeLabel = null, byte[] image = null)
        {
            ValidateSetDockTile(badgeLabel, image);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(badgeLabel)))
            {
                dict.Add("badgeLabel", badgeLabel);
            }

            if ((image) != (null))
            {
                dict.Add("image", ToBase64String(image));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Browser.setDockTile", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// AddRuleResponse
    /// </summary>
    public class AddRuleResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// rule
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("rule")]
        public CefSharp.DevTools.CSS.CSSRule Rule
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CollectClassNamesResponse
    /// </summary>
    public class CollectClassNamesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// classNames
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("classNames")]
        public string[] ClassNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CreateStyleSheetResponse
    /// </summary>
    public class CreateStyleSheetResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// styleSheetId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styleSheetId")]
        public string StyleSheetId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetBackgroundColorsResponse
    /// </summary>
    public class GetBackgroundColorsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// backgroundColors
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backgroundColors")]
        public string[] BackgroundColors
        {
            get;
            private set;
        }

        /// <summary>
        /// computedFontSize
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("computedFontSize")]
        public string ComputedFontSize
        {
            get;
            private set;
        }

        /// <summary>
        /// computedFontWeight
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("computedFontWeight")]
        public string ComputedFontWeight
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetComputedStyleForNodeResponse
    /// </summary>
    public class GetComputedStyleForNodeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// computedStyle
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("computedStyle")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSComputedStyleProperty> ComputedStyle
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetInlineStylesForNodeResponse
    /// </summary>
    public class GetInlineStylesForNodeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// inlineStyle
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inlineStyle")]
        public CefSharp.DevTools.CSS.CSSStyle InlineStyle
        {
            get;
            private set;
        }

        /// <summary>
        /// attributesStyle
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attributesStyle")]
        public CefSharp.DevTools.CSS.CSSStyle AttributesStyle
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetMatchedStylesForNodeResponse
    /// </summary>
    public class GetMatchedStylesForNodeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// inlineStyle
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inlineStyle")]
        public CefSharp.DevTools.CSS.CSSStyle InlineStyle
        {
            get;
            private set;
        }

        /// <summary>
        /// attributesStyle
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attributesStyle")]
        public CefSharp.DevTools.CSS.CSSStyle AttributesStyle
        {
            get;
            private set;
        }

        /// <summary>
        /// matchedCSSRules
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("matchedCSSRules")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleMatch> MatchedCSSRules
        {
            get;
            private set;
        }

        /// <summary>
        /// pseudoElements
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("pseudoElements")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.PseudoElementMatches> PseudoElements
        {
            get;
            private set;
        }

        /// <summary>
        /// inherited
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("inherited")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.InheritedStyleEntry> Inherited
        {
            get;
            private set;
        }

        /// <summary>
        /// cssKeyframesRules
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cssKeyframesRules")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSKeyframesRule> CssKeyframesRules
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetMediaQueriesResponse
    /// </summary>
    public class GetMediaQueriesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// medias
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("medias")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSMedia> Medias
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetPlatformFontsForNodeResponse
    /// </summary>
    public class GetPlatformFontsForNodeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// fonts
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("fonts")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.PlatformFontUsage> Fonts
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetStyleSheetTextResponse
    /// </summary>
    public class GetStyleSheetTextResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// text
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("text")]
        public string Text
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// TakeComputedStyleUpdatesResponse
    /// </summary>
    public class TakeComputedStyleUpdatesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetKeyframeKeyResponse
    /// </summary>
    public class SetKeyframeKeyResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// keyText
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyText")]
        public CefSharp.DevTools.CSS.Value KeyText
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetMediaTextResponse
    /// </summary>
    public class SetMediaTextResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// media
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("media")]
        public CefSharp.DevTools.CSS.CSSMedia Media
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetRuleSelectorResponse
    /// </summary>
    public class SetRuleSelectorResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// selectorList
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("selectorList")]
        public CefSharp.DevTools.CSS.SelectorList SelectorList
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetStyleSheetTextResponse
    /// </summary>
    public class SetStyleSheetTextResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// sourceMapURL
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sourceMapURL")]
        public string SourceMapURL
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetStyleTextsResponse
    /// </summary>
    public class SetStyleTextsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// styles
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("styles")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSStyle> Styles
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// StopRuleUsageTrackingResponse
    /// </summary>
    public class StopRuleUsageTrackingResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// ruleUsage
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ruleUsage")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleUsage> RuleUsage
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// TakeCoverageDeltaResponse
    /// </summary>
    public class TakeCoverageDeltaResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// coverage
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("coverage")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleUsage> Coverage
        {
            get;
            private set;
        }

        /// <summary>
        /// timestamp
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timestamp")]
        public long Timestamp
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    using System.Linq;

    /// <summary>
    /// This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
    /// have an associated `id` used in subsequent operations on the related object. Each object type has
    /// a specific `id` structure, and those are not interchangeable between objects of different kinds.
    /// CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
    /// can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
    /// subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods.
    /// </summary>
    public partial class CSSClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public CSSClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateAddRule(string styleSheetId, string ruleText, CefSharp.DevTools.CSS.SourceRange location);
        /// <summary>
        /// Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
        /// position specified by `location`.
        /// </summary>
        /// <param name = "styleSheetId">The css style sheet identifier where a new rule should be inserted.</param>
        /// <param name = "ruleText">The text of a new rule.</param>
        /// <param name = "location">Text position of a new rule in the target style sheet.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AddRuleResponse&gt;</returns>
        public async System.Threading.Tasks.Task<AddRuleResponse> AddRuleAsync(string styleSheetId, string ruleText, CefSharp.DevTools.CSS.SourceRange location)
        {
            ValidateAddRule(styleSheetId, ruleText, location);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("ruleText", ruleText);
            dict.Add("location", location.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.addRule", dict);
            return methodResult.DeserializeJson<AddRuleResponse>();
        }

        partial void ValidateCollectClassNames(string styleSheetId);
        /// <summary>
        /// Returns all class names from specified stylesheet.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CollectClassNamesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CollectClassNamesResponse> CollectClassNamesAsync(string styleSheetId)
        {
            ValidateCollectClassNames(styleSheetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.collectClassNames", dict);
            return methodResult.DeserializeJson<CollectClassNamesResponse>();
        }

        partial void ValidateCreateStyleSheet(string frameId);
        /// <summary>
        /// Creates a new special &quot;via-inspector&quot; stylesheet in the frame with given `frameId`.
        /// </summary>
        /// <param name = "frameId">Identifier of the frame where "via-inspector" stylesheet should be created.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CreateStyleSheetResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CreateStyleSheetResponse> CreateStyleSheetAsync(string frameId)
        {
            ValidateCreateStyleSheet(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.createStyleSheet", dict);
            return methodResult.DeserializeJson<CreateStyleSheetResponse>();
        }

        /// <summary>
        /// Disables the CSS agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
        /// enabled until the result of this command is received.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.enable", dict);
            return methodResult;
        }

        partial void ValidateForcePseudoState(int nodeId, string[] forcedPseudoClasses);
        /// <summary>
        /// Ensures that the given node will have specified pseudo-classes whenever its style is computed by
        /// the browser.
        /// </summary>
        /// <param name = "nodeId">The element id for which to force the pseudo state.</param>
        /// <param name = "forcedPseudoClasses">Element pseudo classes to force when computing the element's style.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ForcePseudoStateAsync(int nodeId, string[] forcedPseudoClasses)
        {
            ValidateForcePseudoState(nodeId, forcedPseudoClasses);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("forcedPseudoClasses", forcedPseudoClasses);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.forcePseudoState", dict);
            return methodResult;
        }

        partial void ValidateGetBackgroundColors(int nodeId);
        /// <summary>
        /// GetBackgroundColors
        /// </summary>
        /// <param name = "nodeId">Id of the node to get background colors for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBackgroundColorsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetBackgroundColorsResponse> GetBackgroundColorsAsync(int nodeId)
        {
            ValidateGetBackgroundColors(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.getBackgroundColors", dict);
            return methodResult.DeserializeJson<GetBackgroundColorsResponse>();
        }

        partial void ValidateGetComputedStyleForNode(int nodeId);
        /// <summary>
        /// Returns the computed style for a DOM node identified by `nodeId`.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetComputedStyleForNodeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetComputedStyleForNodeResponse> GetComputedStyleForNodeAsync(int nodeId)
        {
            ValidateGetComputedStyleForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.getComputedStyleForNode", dict);
            return methodResult.DeserializeJson<GetComputedStyleForNodeResponse>();
        }

        partial void ValidateGetInlineStylesForNode(int nodeId);
        /// <summary>
        /// Returns the styles defined inline (explicitly in the &quot;style&quot; attribute and implicitly, using DOM
        /// attributes) for a DOM node identified by `nodeId`.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetInlineStylesForNodeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetInlineStylesForNodeResponse> GetInlineStylesForNodeAsync(int nodeId)
        {
            ValidateGetInlineStylesForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.getInlineStylesForNode", dict);
            return methodResult.DeserializeJson<GetInlineStylesForNodeResponse>();
        }

        partial void ValidateGetMatchedStylesForNode(int nodeId);
        /// <summary>
        /// Returns requested styles for a DOM node identified by `nodeId`.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetMatchedStylesForNodeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetMatchedStylesForNodeResponse> GetMatchedStylesForNodeAsync(int nodeId)
        {
            ValidateGetMatchedStylesForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.getMatchedStylesForNode", dict);
            return methodResult.DeserializeJson<GetMatchedStylesForNodeResponse>();
        }

        /// <summary>
        /// Returns all media queries parsed by the rendering engine.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetMediaQueriesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetMediaQueriesResponse> GetMediaQueriesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.getMediaQueries", dict);
            return methodResult.DeserializeJson<GetMediaQueriesResponse>();
        }

        partial void ValidateGetPlatformFontsForNode(int nodeId);
        /// <summary>
        /// Requests information about platform fonts which we used to render child TextNodes in the given
        /// node.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPlatformFontsForNodeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetPlatformFontsForNodeResponse> GetPlatformFontsForNodeAsync(int nodeId)
        {
            ValidateGetPlatformFontsForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.getPlatformFontsForNode", dict);
            return methodResult.DeserializeJson<GetPlatformFontsForNodeResponse>();
        }

        partial void ValidateGetStyleSheetText(string styleSheetId);
        /// <summary>
        /// Returns the current textual content for a stylesheet.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetStyleSheetTextResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetStyleSheetTextResponse> GetStyleSheetTextAsync(string styleSheetId)
        {
            ValidateGetStyleSheetText(styleSheetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.getStyleSheetText", dict);
            return methodResult.DeserializeJson<GetStyleSheetTextResponse>();
        }

        partial void ValidateTrackComputedStyleUpdates(System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSComputedStyleProperty> propertiesToTrack);
        /// <summary>
        /// Starts tracking the given computed styles for updates. The specified array of properties
        /// replaces the one previously specified. Pass empty array to disable tracking.
        /// Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
        /// The changes to computed style properties are only tracked for nodes pushed to the front-end
        /// by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
        /// to the front-end, no updates will be issued for the node.
        /// </summary>
        /// <param name = "propertiesToTrack">propertiesToTrack</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> TrackComputedStyleUpdatesAsync(System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSComputedStyleProperty> propertiesToTrack)
        {
            ValidateTrackComputedStyleUpdates(propertiesToTrack);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("propertiesToTrack", propertiesToTrack.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.trackComputedStyleUpdates", dict);
            return methodResult;
        }

        /// <summary>
        /// Polls the next batch of computed style updates.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeComputedStyleUpdatesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<TakeComputedStyleUpdatesResponse> TakeComputedStyleUpdatesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.takeComputedStyleUpdates", dict);
            return methodResult.DeserializeJson<TakeComputedStyleUpdatesResponse>();
        }

        partial void ValidateSetEffectivePropertyValueForNode(int nodeId, string propertyName, string value);
        /// <summary>
        /// Find a rule with the given active property for the given node and set the new value for this
        /// property
        /// </summary>
        /// <param name = "nodeId">The element id for which to set property.</param>
        /// <param name = "propertyName">propertyName</param>
        /// <param name = "value">value</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetEffectivePropertyValueForNodeAsync(int nodeId, string propertyName, string value)
        {
            ValidateSetEffectivePropertyValueForNode(nodeId, propertyName, value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("propertyName", propertyName);
            dict.Add("value", value);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.setEffectivePropertyValueForNode", dict);
            return methodResult;
        }

        partial void ValidateSetKeyframeKey(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string keyText);
        /// <summary>
        /// Modifies the keyframe rule key text.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "keyText">keyText</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetKeyframeKeyResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetKeyframeKeyResponse> SetKeyframeKeyAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string keyText)
        {
            ValidateSetKeyframeKey(styleSheetId, range, keyText);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("keyText", keyText);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.setKeyframeKey", dict);
            return methodResult.DeserializeJson<SetKeyframeKeyResponse>();
        }

        partial void ValidateSetMediaText(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text);
        /// <summary>
        /// Modifies the rule selector.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "text">text</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetMediaTextResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetMediaTextResponse> SetMediaTextAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text)
        {
            ValidateSetMediaText(styleSheetId, range, text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("text", text);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.setMediaText", dict);
            return methodResult.DeserializeJson<SetMediaTextResponse>();
        }

        partial void ValidateSetRuleSelector(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string selector);
        /// <summary>
        /// Modifies the rule selector.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "selector">selector</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetRuleSelectorResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetRuleSelectorResponse> SetRuleSelectorAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string selector)
        {
            ValidateSetRuleSelector(styleSheetId, range, selector);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("selector", selector);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.setRuleSelector", dict);
            return methodResult.DeserializeJson<SetRuleSelectorResponse>();
        }

        partial void ValidateSetStyleSheetText(string styleSheetId, string text);
        /// <summary>
        /// Sets the new stylesheet text.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "text">text</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetStyleSheetTextResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetStyleSheetTextResponse> SetStyleSheetTextAsync(string styleSheetId, string text)
        {
            ValidateSetStyleSheetText(styleSheetId, text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("text", text);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.setStyleSheetText", dict);
            return methodResult.DeserializeJson<SetStyleSheetTextResponse>();
        }

        partial void ValidateSetStyleTexts(System.Collections.Generic.IList<CefSharp.DevTools.CSS.StyleDeclarationEdit> edits);
        /// <summary>
        /// Applies specified style edits one after another in the given order.
        /// </summary>
        /// <param name = "edits">edits</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetStyleTextsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetStyleTextsResponse> SetStyleTextsAsync(System.Collections.Generic.IList<CefSharp.DevTools.CSS.StyleDeclarationEdit> edits)
        {
            ValidateSetStyleTexts(edits);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("edits", edits.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.setStyleTexts", dict);
            return methodResult.DeserializeJson<SetStyleTextsResponse>();
        }

        /// <summary>
        /// Enables the selector recording.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartRuleUsageTrackingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.startRuleUsageTracking", dict);
            return methodResult;
        }

        /// <summary>
        /// Stop tracking rule usage and return the list of rules that were used since last call to
        /// `takeCoverageDelta` (or since start of coverage instrumentation)
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;StopRuleUsageTrackingResponse&gt;</returns>
        public async System.Threading.Tasks.Task<StopRuleUsageTrackingResponse> StopRuleUsageTrackingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.stopRuleUsageTracking", dict);
            return methodResult.DeserializeJson<StopRuleUsageTrackingResponse>();
        }

        /// <summary>
        /// Obtain list of rules that became used since last call to this method (or since start of coverage
        /// instrumentation)
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeCoverageDeltaResponse&gt;</returns>
        public async System.Threading.Tasks.Task<TakeCoverageDeltaResponse> TakeCoverageDeltaAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.takeCoverageDelta", dict);
            return methodResult.DeserializeJson<TakeCoverageDeltaResponse>();
        }

        partial void ValidateSetLocalFontsEnabled(bool enabled);
        /// <summary>
        /// Enables/disables rendering of local CSS fonts (enabled by default).
        /// </summary>
        /// <param name = "enabled">Whether rendering of local fonts is enabled.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetLocalFontsEnabledAsync(bool enabled)
        {
            ValidateSetLocalFontsEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CSS.setLocalFontsEnabled", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// RequestCacheNamesResponse
    /// </summary>
    public class RequestCacheNamesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// caches
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("caches")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Cache> Caches
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// RequestCachedResponseResponse
    /// </summary>
    public class RequestCachedResponseResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// response
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("response")]
        public CefSharp.DevTools.CacheStorage.CachedResponse Response
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// RequestEntriesResponse
    /// </summary>
    public class RequestEntriesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// cacheDataEntries
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cacheDataEntries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.DataEntry> CacheDataEntries
        {
            get;
            private set;
        }

        /// <summary>
        /// returnCount
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("returnCount")]
        public long ReturnCount
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    using System.Linq;

    /// <summary>
    /// CacheStorage
    /// </summary>
    public partial class CacheStorageClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public CacheStorageClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateDeleteCache(string cacheId);
        /// <summary>
        /// Deletes a cache.
        /// </summary>
        /// <param name = "cacheId">Id of cache for deletion.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteCacheAsync(string cacheId)
        {
            ValidateDeleteCache(cacheId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheId", cacheId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CacheStorage.deleteCache", dict);
            return methodResult;
        }

        partial void ValidateDeleteEntry(string cacheId, string request);
        /// <summary>
        /// Deletes a cache entry.
        /// </summary>
        /// <param name = "cacheId">Id of cache where the entry will be deleted.</param>
        /// <param name = "request">URL spec of the request.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteEntryAsync(string cacheId, string request)
        {
            ValidateDeleteEntry(cacheId, request);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheId", cacheId);
            dict.Add("request", request);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CacheStorage.deleteEntry", dict);
            return methodResult;
        }

        partial void ValidateRequestCacheNames(string securityOrigin);
        /// <summary>
        /// Requests cache names.
        /// </summary>
        /// <param name = "securityOrigin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestCacheNamesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RequestCacheNamesResponse> RequestCacheNamesAsync(string securityOrigin)
        {
            ValidateRequestCacheNames(securityOrigin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("securityOrigin", securityOrigin);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CacheStorage.requestCacheNames", dict);
            return methodResult.DeserializeJson<RequestCacheNamesResponse>();
        }

        partial void ValidateRequestCachedResponse(string cacheId, string requestURL, System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Header> requestHeaders);
        /// <summary>
        /// Fetches cache entry.
        /// </summary>
        /// <param name = "cacheId">Id of cache that contains the entry.</param>
        /// <param name = "requestURL">URL spec of the request.</param>
        /// <param name = "requestHeaders">headers of the request.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestCachedResponseResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RequestCachedResponseResponse> RequestCachedResponseAsync(string cacheId, string requestURL, System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Header> requestHeaders)
        {
            ValidateRequestCachedResponse(cacheId, requestURL, requestHeaders);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheId", cacheId);
            dict.Add("requestURL", requestURL);
            dict.Add("requestHeaders", requestHeaders.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("CacheStorage.requestCachedResponse", dict);
            return methodResult.DeserializeJson<RequestCachedResponseResponse>();
        }

        partial void ValidateRequestEntries(string cacheId, int? skipCount = null, int? pageSize = null, string pathFilter = null);
        /// <summary>
        /// Requests data from cache.
        /// </summary>
        /// <param name = "cacheId">ID of cache to get entries from.</param>
        /// <param name = "skipCount">Number of records to skip.</param>
        /// <param name = "pageSize">Number of records to fetch.</param>
        /// <param name = "pathFilter">If present, only return the entries containing this substring in the path</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestEntriesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RequestEntriesResponse> RequestEntriesAsync(string cacheId, int? skipCount = null, int? pageSize = null, string pathFilter = null)
        {
            ValidateRequestEntries(cacheId, skipCount, pageSize, pathFilter);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheId", cacheId);
            if (skipCount.HasValue)
            {
                dict.Add("skipCount", skipCount.Value);
            }

            if (pageSize.HasValue)
            {
                dict.Add("pageSize", pageSize.Value);
            }

            if (!(string.IsNullOrEmpty(pathFilter)))
            {
                dict.Add("pathFilter", pathFilter);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("CacheStorage.requestEntries", dict);
            return methodResult.DeserializeJson<RequestEntriesResponse>();
        }
    }
}

namespace CefSharp.DevTools.Cast
{
    using System.Linq;

    /// <summary>
    /// A domain for interacting with Cast, Presentation API, and Remote Playback API
    /// functionalities.
    /// </summary>
    public partial class CastClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public CastClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateEnable(string presentationUrl = null);
        /// <summary>
        /// Starts observing for sinks that can be used for tab mirroring, and if set,
        /// sinks compatible with |presentationUrl| as well. When sinks are found, a
        /// |sinksUpdated| event is fired.
        /// Also starts observing for issue messages. When an issue is added or removed,
        /// an |issueUpdated| event is fired.
        /// </summary>
        /// <param name = "presentationUrl">presentationUrl</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(string presentationUrl = null)
        {
            ValidateEnable(presentationUrl);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(presentationUrl)))
            {
                dict.Add("presentationUrl", presentationUrl);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Cast.enable", dict);
            return methodResult;
        }

        /// <summary>
        /// Stops observing for sinks and issues.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Cast.disable", dict);
            return methodResult;
        }

        partial void ValidateSetSinkToUse(string sinkName);
        /// <summary>
        /// Sets a sink to be used when the web page requests the browser to choose a
        /// sink via Presentation API, Remote Playback API, or Cast SDK.
        /// </summary>
        /// <param name = "sinkName">sinkName</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetSinkToUseAsync(string sinkName)
        {
            ValidateSetSinkToUse(sinkName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sinkName", sinkName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Cast.setSinkToUse", dict);
            return methodResult;
        }

        partial void ValidateStartTabMirroring(string sinkName);
        /// <summary>
        /// Starts mirroring the tab to the sink.
        /// </summary>
        /// <param name = "sinkName">sinkName</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartTabMirroringAsync(string sinkName)
        {
            ValidateStartTabMirroring(sinkName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sinkName", sinkName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Cast.startTabMirroring", dict);
            return methodResult;
        }

        partial void ValidateStopCasting(string sinkName);
        /// <summary>
        /// Stops the active Cast session on the sink.
        /// </summary>
        /// <param name = "sinkName">sinkName</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopCastingAsync(string sinkName)
        {
            ValidateStopCasting(sinkName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sinkName", sinkName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Cast.stopCasting", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// CollectClassNamesFromSubtreeResponse
    /// </summary>
    public class CollectClassNamesFromSubtreeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// classNames
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("classNames")]
        public string[] ClassNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// CopyToResponse
    /// </summary>
    public class CopyToResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// DescribeNodeResponse
    /// </summary>
    public class DescribeNodeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// node
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("node")]
        public CefSharp.DevTools.DOM.Node Node
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetAttributesResponse
    /// </summary>
    public class GetAttributesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// attributes
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("attributes")]
        public string[] Attributes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetBoxModelResponse
    /// </summary>
    public class GetBoxModelResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// model
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("model")]
        public CefSharp.DevTools.DOM.BoxModel Model
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetContentQuadsResponse
    /// </summary>
    public class GetContentQuadsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// quads
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("quads")]
        public long[] Quads
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetDocumentResponse
    /// </summary>
    public class GetDocumentResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// root
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("root")]
        public CefSharp.DevTools.DOM.Node Root
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetNodesForSubtreeByStyleResponse
    /// </summary>
    public class GetNodesForSubtreeByStyleResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetNodeForLocationResponse
    /// </summary>
    public class GetNodeForLocationResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// backendNodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int BackendNodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// frameId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameId")]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int? NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetOuterHTMLResponse
    /// </summary>
    public class GetOuterHTMLResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// outerHTML
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("outerHTML")]
        public string OuterHTML
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetRelayoutBoundaryResponse
    /// </summary>
    public class GetRelayoutBoundaryResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetSearchResultsResponse
    /// </summary>
    public class GetSearchResultsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// MoveToResponse
    /// </summary>
    public class MoveToResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// PerformSearchResponse
    /// </summary>
    public class PerformSearchResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// searchId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("searchId")]
        public string SearchId
        {
            get;
            private set;
        }

        /// <summary>
        /// resultCount
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resultCount")]
        public int ResultCount
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// PushNodeByPathToFrontendResponse
    /// </summary>
    public class PushNodeByPathToFrontendResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// PushNodesByBackendIdsToFrontendResponse
    /// </summary>
    public class PushNodesByBackendIdsToFrontendResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// QuerySelectorResponse
    /// </summary>
    public class QuerySelectorResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// QuerySelectorAllResponse
    /// </summary>
    public class QuerySelectorAllResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// RequestNodeResponse
    /// </summary>
    public class RequestNodeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// ResolveNodeResponse
    /// </summary>
    public class ResolveNodeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// object
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("object")]
        public CefSharp.DevTools.Runtime.RemoteObject Object
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetNodeStackTracesResponse
    /// </summary>
    public class GetNodeStackTracesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// creation
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("creation")]
        public CefSharp.DevTools.Runtime.StackTrace Creation
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetFileInfoResponse
    /// </summary>
    public class GetFileInfoResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// path
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("path")]
        public string Path
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// SetNodeNameResponse
    /// </summary>
    public class SetNodeNameResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetFrameOwnerResponse
    /// </summary>
    public class GetFrameOwnerResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// backendNodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("backendNodeId")]
        public int BackendNodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// nodeId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodeId")]
        public int? NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    using System.Linq;

    /// <summary>
    /// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
    /// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
    /// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
    /// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
    /// and never sends the same node twice. It is client&apos;s responsibility to collect information about
    /// the nodes that were sent to the client.&lt;p&gt;Note that `iframe` owner elements will return
    /// corresponding document elements as their child nodes.&lt;/p&gt;
    /// </summary>
    public partial class DOMClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public DOMClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateCollectClassNamesFromSubtree(int nodeId);
        /// <summary>
        /// Collects class names for the node with given id and all of it&apos;s child nodes.
        /// </summary>
        /// <param name = "nodeId">Id of the node to collect class names.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CollectClassNamesFromSubtreeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CollectClassNamesFromSubtreeResponse> CollectClassNamesFromSubtreeAsync(int nodeId)
        {
            ValidateCollectClassNamesFromSubtree(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.collectClassNamesFromSubtree", dict);
            return methodResult.DeserializeJson<CollectClassNamesFromSubtreeResponse>();
        }

        partial void ValidateCopyTo(int nodeId, int targetNodeId, int? insertBeforeNodeId = null);
        /// <summary>
        /// Creates a deep copy of the specified node and places it into the target container before the
        /// given anchor.
        /// </summary>
        /// <param name = "nodeId">Id of the node to copy.</param>
        /// <param name = "targetNodeId">Id of the element to drop the copy into.</param>
        /// <param name = "insertBeforeNodeId">Drop the copy before this node (if absent, the copy becomes the last child of`targetNodeId`).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CopyToResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CopyToResponse> CopyToAsync(int nodeId, int targetNodeId, int? insertBeforeNodeId = null)
        {
            ValidateCopyTo(nodeId, targetNodeId, insertBeforeNodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("targetNodeId", targetNodeId);
            if (insertBeforeNodeId.HasValue)
            {
                dict.Add("insertBeforeNodeId", insertBeforeNodeId.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.copyTo", dict);
            return methodResult.DeserializeJson<CopyToResponse>();
        }

        partial void ValidateDescribeNode(int? nodeId = null, int? backendNodeId = null, string objectId = null, int? depth = null, bool? pierce = null);
        /// <summary>
        /// Describes node given its id, does not require domain to be enabled. Does not start tracking any
        /// objects, can be used for automation.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <param name = "depth">The maximum depth at which children should be retrieved, defaults to 1. Use -1 for theentire subtree or provide an integer larger than 0.</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots should be traversed when returning the subtree(default is false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DescribeNodeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DescribeNodeResponse> DescribeNodeAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null, int? depth = null, bool? pierce = null)
        {
            ValidateDescribeNode(nodeId, backendNodeId, objectId, depth, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.describeNode", dict);
            return methodResult.DeserializeJson<DescribeNodeResponse>();
        }

        partial void ValidateScrollIntoViewIfNeeded(int? nodeId = null, int? backendNodeId = null, string objectId = null, CefSharp.DevTools.DOM.Rect rect = null);
        /// <summary>
        /// Scrolls the specified rect of the given node into view if not already visible.
        /// Note: exactly one between nodeId, backendNodeId and objectId should be passed
        /// to identify the node.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <param name = "rect">The rect to be scrolled into view, relative to the node's border box, in CSS pixels.When omitted, center of the node will be used, similar to Element.scrollIntoView.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ScrollIntoViewIfNeededAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null, CefSharp.DevTools.DOM.Rect rect = null)
        {
            ValidateScrollIntoViewIfNeeded(nodeId, backendNodeId, objectId, rect);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if ((rect) != (null))
            {
                dict.Add("rect", rect.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.scrollIntoViewIfNeeded", dict);
            return methodResult;
        }

        /// <summary>
        /// Disables DOM agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.disable", dict);
            return methodResult;
        }

        partial void ValidateDiscardSearchResults(string searchId);
        /// <summary>
        /// Discards search results from the session with the given id. `getSearchResults` should no longer
        /// be called for that search.
        /// </summary>
        /// <param name = "searchId">Unique search session identifier.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DiscardSearchResultsAsync(string searchId)
        {
            ValidateDiscardSearchResults(searchId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("searchId", searchId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.discardSearchResults", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables DOM agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.enable", dict);
            return methodResult;
        }

        partial void ValidateFocus(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Focuses the given element.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> FocusAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateFocus(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.focus", dict);
            return methodResult;
        }

        partial void ValidateGetAttributes(int nodeId);
        /// <summary>
        /// Returns attributes for the specified node.
        /// </summary>
        /// <param name = "nodeId">Id of the node to retrieve attibutes for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAttributesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetAttributesResponse> GetAttributesAsync(int nodeId)
        {
            ValidateGetAttributes(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getAttributes", dict);
            return methodResult.DeserializeJson<GetAttributesResponse>();
        }

        partial void ValidateGetBoxModel(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Returns boxes for the given node.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBoxModelResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetBoxModelResponse> GetBoxModelAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateGetBoxModel(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getBoxModel", dict);
            return methodResult.DeserializeJson<GetBoxModelResponse>();
        }

        partial void ValidateGetContentQuads(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Returns quads that describe node position on the page. This method
        /// might return multiple quads for inline nodes.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetContentQuadsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetContentQuadsResponse> GetContentQuadsAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateGetContentQuads(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getContentQuads", dict);
            return methodResult.DeserializeJson<GetContentQuadsResponse>();
        }

        partial void ValidateGetDocument(int? depth = null, bool? pierce = null);
        /// <summary>
        /// Returns the root DOM node (and optionally the subtree) to the caller.
        /// </summary>
        /// <param name = "depth">The maximum depth at which children should be retrieved, defaults to 1. Use -1 for theentire subtree or provide an integer larger than 0.</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots should be traversed when returning the subtree(default is false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetDocumentResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetDocumentResponse> GetDocumentAsync(int? depth = null, bool? pierce = null)
        {
            ValidateGetDocument(depth, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getDocument", dict);
            return methodResult.DeserializeJson<GetDocumentResponse>();
        }

        partial void ValidateGetNodesForSubtreeByStyle(int nodeId, System.Collections.Generic.IList<CefSharp.DevTools.DOM.CSSComputedStyleProperty> computedStyles, bool? pierce = null);
        /// <summary>
        /// Finds nodes with a given computed style in a subtree.
        /// </summary>
        /// <param name = "nodeId">Node ID pointing to the root of a subtree.</param>
        /// <param name = "computedStyles">The style to filter nodes by (includes nodes if any of properties matches).</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots in the same target should be traversed when returning theresults (default is false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetNodesForSubtreeByStyleResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetNodesForSubtreeByStyleResponse> GetNodesForSubtreeByStyleAsync(int nodeId, System.Collections.Generic.IList<CefSharp.DevTools.DOM.CSSComputedStyleProperty> computedStyles, bool? pierce = null)
        {
            ValidateGetNodesForSubtreeByStyle(nodeId, computedStyles, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("computedStyles", computedStyles.Select(x => x.ToDictionary()));
            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getNodesForSubtreeByStyle", dict);
            return methodResult.DeserializeJson<GetNodesForSubtreeByStyleResponse>();
        }

        partial void ValidateGetNodeForLocation(int x, int y, bool? includeUserAgentShadowDOM = null, bool? ignorePointerEventsNone = null);
        /// <summary>
        /// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
        /// either returned or not.
        /// </summary>
        /// <param name = "x">X coordinate.</param>
        /// <param name = "y">Y coordinate.</param>
        /// <param name = "includeUserAgentShadowDOM">False to skip to the nearest non-UA shadow root ancestor (default: false).</param>
        /// <param name = "ignorePointerEventsNone">Whether to ignore pointer-events: none on elements and hit test them.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetNodeForLocationResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetNodeForLocationResponse> GetNodeForLocationAsync(int x, int y, bool? includeUserAgentShadowDOM = null, bool? ignorePointerEventsNone = null)
        {
            ValidateGetNodeForLocation(x, y, includeUserAgentShadowDOM, ignorePointerEventsNone);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            if (includeUserAgentShadowDOM.HasValue)
            {
                dict.Add("includeUserAgentShadowDOM", includeUserAgentShadowDOM.Value);
            }

            if (ignorePointerEventsNone.HasValue)
            {
                dict.Add("ignorePointerEventsNone", ignorePointerEventsNone.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getNodeForLocation", dict);
            return methodResult.DeserializeJson<GetNodeForLocationResponse>();
        }

        partial void ValidateGetOuterHTML(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Returns node&apos;s HTML markup.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetOuterHTMLResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetOuterHTMLResponse> GetOuterHTMLAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateGetOuterHTML(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getOuterHTML", dict);
            return methodResult.DeserializeJson<GetOuterHTMLResponse>();
        }

        partial void ValidateGetRelayoutBoundary(int nodeId);
        /// <summary>
        /// Returns the id of the nearest ancestor that is a relayout boundary.
        /// </summary>
        /// <param name = "nodeId">Id of the node.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetRelayoutBoundaryResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetRelayoutBoundaryResponse> GetRelayoutBoundaryAsync(int nodeId)
        {
            ValidateGetRelayoutBoundary(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getRelayoutBoundary", dict);
            return methodResult.DeserializeJson<GetRelayoutBoundaryResponse>();
        }

        partial void ValidateGetSearchResults(string searchId, int fromIndex, int toIndex);
        /// <summary>
        /// Returns search results from given `fromIndex` to given `toIndex` from the search with the given
        /// identifier.
        /// </summary>
        /// <param name = "searchId">Unique search session identifier.</param>
        /// <param name = "fromIndex">Start index of the search result to be returned.</param>
        /// <param name = "toIndex">End index of the search result to be returned.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSearchResultsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetSearchResultsResponse> GetSearchResultsAsync(string searchId, int fromIndex, int toIndex)
        {
            ValidateGetSearchResults(searchId, fromIndex, toIndex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("searchId", searchId);
            dict.Add("fromIndex", fromIndex);
            dict.Add("toIndex", toIndex);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getSearchResults", dict);
            return methodResult.DeserializeJson<GetSearchResultsResponse>();
        }

        /// <summary>
        /// Hides any highlight.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HideHighlightAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.hideHighlight", dict);
            return methodResult;
        }

        /// <summary>
        /// Highlights DOM node.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightNodeAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.highlightNode", dict);
            return methodResult;
        }

        /// <summary>
        /// Highlights given rectangle.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightRectAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.highlightRect", dict);
            return methodResult;
        }

        /// <summary>
        /// Marks last undoable state.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> MarkUndoableStateAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.markUndoableState", dict);
            return methodResult;
        }

        partial void ValidateMoveTo(int nodeId, int targetNodeId, int? insertBeforeNodeId = null);
        /// <summary>
        /// Moves node into the new container, places it before the given anchor.
        /// </summary>
        /// <param name = "nodeId">Id of the node to move.</param>
        /// <param name = "targetNodeId">Id of the element to drop the moved node into.</param>
        /// <param name = "insertBeforeNodeId">Drop node before this one (if absent, the moved node becomes the last child of`targetNodeId`).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;MoveToResponse&gt;</returns>
        public async System.Threading.Tasks.Task<MoveToResponse> MoveToAsync(int nodeId, int targetNodeId, int? insertBeforeNodeId = null)
        {
            ValidateMoveTo(nodeId, targetNodeId, insertBeforeNodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("targetNodeId", targetNodeId);
            if (insertBeforeNodeId.HasValue)
            {
                dict.Add("insertBeforeNodeId", insertBeforeNodeId.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.moveTo", dict);
            return methodResult.DeserializeJson<MoveToResponse>();
        }

        partial void ValidatePerformSearch(string query, bool? includeUserAgentShadowDOM = null);
        /// <summary>
        /// Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
        /// `cancelSearch` to end this search session.
        /// </summary>
        /// <param name = "query">Plain text or query selector or XPath search query.</param>
        /// <param name = "includeUserAgentShadowDOM">True to search in user agent shadow DOM.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;PerformSearchResponse&gt;</returns>
        public async System.Threading.Tasks.Task<PerformSearchResponse> PerformSearchAsync(string query, bool? includeUserAgentShadowDOM = null)
        {
            ValidatePerformSearch(query, includeUserAgentShadowDOM);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("query", query);
            if (includeUserAgentShadowDOM.HasValue)
            {
                dict.Add("includeUserAgentShadowDOM", includeUserAgentShadowDOM.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.performSearch", dict);
            return methodResult.DeserializeJson<PerformSearchResponse>();
        }

        partial void ValidatePushNodeByPathToFrontend(string path);
        /// <summary>
        /// Requests that the node is sent to the caller given its path. // FIXME, use XPath
        /// </summary>
        /// <param name = "path">Path to node in the proprietary format.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;PushNodeByPathToFrontendResponse&gt;</returns>
        public async System.Threading.Tasks.Task<PushNodeByPathToFrontendResponse> PushNodeByPathToFrontendAsync(string path)
        {
            ValidatePushNodeByPathToFrontend(path);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("path", path);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.pushNodeByPathToFrontend", dict);
            return methodResult.DeserializeJson<PushNodeByPathToFrontendResponse>();
        }

        partial void ValidatePushNodesByBackendIdsToFrontend(int[] backendNodeIds);
        /// <summary>
        /// Requests that a batch of nodes is sent to the caller given their backend node ids.
        /// </summary>
        /// <param name = "backendNodeIds">The array of backend node ids.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;PushNodesByBackendIdsToFrontendResponse&gt;</returns>
        public async System.Threading.Tasks.Task<PushNodesByBackendIdsToFrontendResponse> PushNodesByBackendIdsToFrontendAsync(int[] backendNodeIds)
        {
            ValidatePushNodesByBackendIdsToFrontend(backendNodeIds);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("backendNodeIds", backendNodeIds);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.pushNodesByBackendIdsToFrontend", dict);
            return methodResult.DeserializeJson<PushNodesByBackendIdsToFrontendResponse>();
        }

        partial void ValidateQuerySelector(int nodeId, string selector);
        /// <summary>
        /// Executes `querySelector` on a given node.
        /// </summary>
        /// <param name = "nodeId">Id of the node to query upon.</param>
        /// <param name = "selector">Selector string.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;QuerySelectorResponse&gt;</returns>
        public async System.Threading.Tasks.Task<QuerySelectorResponse> QuerySelectorAsync(int nodeId, string selector)
        {
            ValidateQuerySelector(nodeId, selector);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("selector", selector);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.querySelector", dict);
            return methodResult.DeserializeJson<QuerySelectorResponse>();
        }

        partial void ValidateQuerySelectorAll(int nodeId, string selector);
        /// <summary>
        /// Executes `querySelectorAll` on a given node.
        /// </summary>
        /// <param name = "nodeId">Id of the node to query upon.</param>
        /// <param name = "selector">Selector string.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;QuerySelectorAllResponse&gt;</returns>
        public async System.Threading.Tasks.Task<QuerySelectorAllResponse> QuerySelectorAllAsync(int nodeId, string selector)
        {
            ValidateQuerySelectorAll(nodeId, selector);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("selector", selector);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.querySelectorAll", dict);
            return methodResult.DeserializeJson<QuerySelectorAllResponse>();
        }

        /// <summary>
        /// Re-does the last undone action.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RedoAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.redo", dict);
            return methodResult;
        }

        partial void ValidateRemoveAttribute(int nodeId, string name);
        /// <summary>
        /// Removes attribute with given name from an element with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the element to remove attribute from.</param>
        /// <param name = "name">Name of the attribute to remove.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveAttributeAsync(int nodeId, string name)
        {
            ValidateRemoveAttribute(nodeId, name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("name", name);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.removeAttribute", dict);
            return methodResult;
        }

        partial void ValidateRemoveNode(int nodeId);
        /// <summary>
        /// Removes node with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the node to remove.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveNodeAsync(int nodeId)
        {
            ValidateRemoveNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.removeNode", dict);
            return methodResult;
        }

        partial void ValidateRequestChildNodes(int nodeId, int? depth = null, bool? pierce = null);
        /// <summary>
        /// Requests that children of the node with given id are returned to the caller in form of
        /// `setChildNodes` events where not only immediate children are retrieved, but all children down to
        /// the specified depth.
        /// </summary>
        /// <param name = "nodeId">Id of the node to get children for.</param>
        /// <param name = "depth">The maximum depth at which children should be retrieved, defaults to 1. Use -1 for theentire subtree or provide an integer larger than 0.</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots should be traversed when returning the sub-tree(default is false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RequestChildNodesAsync(int nodeId, int? depth = null, bool? pierce = null)
        {
            ValidateRequestChildNodes(nodeId, depth, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.requestChildNodes", dict);
            return methodResult;
        }

        partial void ValidateRequestNode(string objectId);
        /// <summary>
        /// Requests that the node is sent to the caller given the JavaScript node object reference. All
        /// nodes that form the path from the node to the root are also sent to the client as a series of
        /// `setChildNodes` notifications.
        /// </summary>
        /// <param name = "objectId">JavaScript object id to convert into node.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestNodeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RequestNodeResponse> RequestNodeAsync(string objectId)
        {
            ValidateRequestNode(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.requestNode", dict);
            return methodResult.DeserializeJson<RequestNodeResponse>();
        }

        partial void ValidateResolveNode(int? nodeId = null, int? backendNodeId = null, string objectGroup = null, int? executionContextId = null);
        /// <summary>
        /// Resolves the JavaScript node object for a given NodeId or BackendNodeId.
        /// </summary>
        /// <param name = "nodeId">Id of the node to resolve.</param>
        /// <param name = "backendNodeId">Backend identifier of the node to resolve.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects.</param>
        /// <param name = "executionContextId">Execution context in which to resolve the node.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ResolveNodeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<ResolveNodeResponse> ResolveNodeAsync(int? nodeId = null, int? backendNodeId = null, string objectGroup = null, int? executionContextId = null)
        {
            ValidateResolveNode(nodeId, backendNodeId, objectGroup, executionContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.resolveNode", dict);
            return methodResult.DeserializeJson<ResolveNodeResponse>();
        }

        partial void ValidateSetAttributeValue(int nodeId, string name, string value);
        /// <summary>
        /// Sets attribute for an element with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the element to set attribute for.</param>
        /// <param name = "name">Attribute name.</param>
        /// <param name = "value">Attribute value.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetAttributeValueAsync(int nodeId, string name, string value)
        {
            ValidateSetAttributeValue(nodeId, name, value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("name", name);
            dict.Add("value", value);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.setAttributeValue", dict);
            return methodResult;
        }

        partial void ValidateSetAttributesAsText(int nodeId, string text, string name = null);
        /// <summary>
        /// Sets attributes on element with given id. This method is useful when user edits some existing
        /// attribute value and types in several attribute name/value pairs.
        /// </summary>
        /// <param name = "nodeId">Id of the element to set attributes for.</param>
        /// <param name = "text">Text with a number of attributes. Will parse this text using HTML parser.</param>
        /// <param name = "name">Attribute name to replace with new attributes derived from text in case text parsedsuccessfully.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetAttributesAsTextAsync(int nodeId, string text, string name = null)
        {
            ValidateSetAttributesAsText(nodeId, text, name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("text", text);
            if (!(string.IsNullOrEmpty(name)))
            {
                dict.Add("name", name);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.setAttributesAsText", dict);
            return methodResult;
        }

        partial void ValidateSetFileInputFiles(string[] files, int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Sets files for the given file input element.
        /// </summary>
        /// <param name = "files">Array of file paths to set.</param>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetFileInputFilesAsync(string[] files, int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateSetFileInputFiles(files, nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("files", files);
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.setFileInputFiles", dict);
            return methodResult;
        }

        partial void ValidateSetNodeStackTracesEnabled(bool enable);
        /// <summary>
        /// Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
        /// </summary>
        /// <param name = "enable">Enable or disable.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetNodeStackTracesEnabledAsync(bool enable)
        {
            ValidateSetNodeStackTracesEnabled(enable);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enable", enable);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.setNodeStackTracesEnabled", dict);
            return methodResult;
        }

        partial void ValidateGetNodeStackTraces(int nodeId);
        /// <summary>
        /// Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
        /// </summary>
        /// <param name = "nodeId">Id of the node to get stack traces for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetNodeStackTracesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetNodeStackTracesResponse> GetNodeStackTracesAsync(int nodeId)
        {
            ValidateGetNodeStackTraces(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getNodeStackTraces", dict);
            return methodResult.DeserializeJson<GetNodeStackTracesResponse>();
        }

        partial void ValidateGetFileInfo(string objectId);
        /// <summary>
        /// Returns file information for the given
        /// File wrapper.
        /// </summary>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFileInfoResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetFileInfoResponse> GetFileInfoAsync(string objectId)
        {
            ValidateGetFileInfo(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getFileInfo", dict);
            return methodResult.DeserializeJson<GetFileInfoResponse>();
        }

        partial void ValidateSetInspectedNode(int nodeId);
        /// <summary>
        /// Enables console to refer to the node with given id via $x (see Command Line API for more details
        /// $x functions).
        /// </summary>
        /// <param name = "nodeId">DOM node id to be accessible by means of $x command line API.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetInspectedNodeAsync(int nodeId)
        {
            ValidateSetInspectedNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.setInspectedNode", dict);
            return methodResult;
        }

        partial void ValidateSetNodeName(int nodeId, string name);
        /// <summary>
        /// Sets node name for a node with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the node to set name for.</param>
        /// <param name = "name">New node's name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetNodeNameResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetNodeNameResponse> SetNodeNameAsync(int nodeId, string name)
        {
            ValidateSetNodeName(nodeId, name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("name", name);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.setNodeName", dict);
            return methodResult.DeserializeJson<SetNodeNameResponse>();
        }

        partial void ValidateSetNodeValue(int nodeId, string value);
        /// <summary>
        /// Sets node value for a node with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the node to set value for.</param>
        /// <param name = "value">New node's value.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetNodeValueAsync(int nodeId, string value)
        {
            ValidateSetNodeValue(nodeId, value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("value", value);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.setNodeValue", dict);
            return methodResult;
        }

        partial void ValidateSetOuterHTML(int nodeId, string outerHTML);
        /// <summary>
        /// Sets node HTML markup, returns new node id.
        /// </summary>
        /// <param name = "nodeId">Id of the node to set markup for.</param>
        /// <param name = "outerHTML">Outer HTML markup to set.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetOuterHTMLAsync(int nodeId, string outerHTML)
        {
            ValidateSetOuterHTML(nodeId, outerHTML);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("outerHTML", outerHTML);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.setOuterHTML", dict);
            return methodResult;
        }

        /// <summary>
        /// Undoes the last performed action.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> UndoAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.undo", dict);
            return methodResult;
        }

        partial void ValidateGetFrameOwner(string frameId);
        /// <summary>
        /// Returns iframe node that owns iframe with the given domain.
        /// </summary>
        /// <param name = "frameId">frameId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFrameOwnerResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetFrameOwnerResponse> GetFrameOwnerAsync(string frameId)
        {
            ValidateGetFrameOwner(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOM.getFrameOwner", dict);
            return methodResult.DeserializeJson<GetFrameOwnerResponse>();
        }
    }
}

namespace CefSharp.DevTools.DOMDebugger
{
    /// <summary>
    /// GetEventListenersResponse
    /// </summary>
    public class GetEventListenersResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// listeners
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("listeners")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMDebugger.EventListener> Listeners
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOMDebugger
{
    using System.Linq;

    /// <summary>
    /// DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
    /// execution will stop on these operations as if there was a regular breakpoint set.
    /// </summary>
    public partial class DOMDebuggerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public DOMDebuggerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateGetEventListeners(string objectId, int? depth = null, bool? pierce = null);
        /// <summary>
        /// Returns event listeners of the given object.
        /// </summary>
        /// <param name = "objectId">Identifier of the object to return listeners for.</param>
        /// <param name = "depth">The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for theentire subtree or provide an integer larger than 0.</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots should be traversed when returning the subtree(default is false). Reports listeners for all contexts if pierce is enabled.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetEventListenersResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetEventListenersResponse> GetEventListenersAsync(string objectId, int? depth = null, bool? pierce = null)
        {
            ValidateGetEventListeners(objectId, depth, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.getEventListeners", dict);
            return methodResult.DeserializeJson<GetEventListenersResponse>();
        }

        partial void ValidateRemoveDOMBreakpoint(int nodeId, CefSharp.DevTools.DOMDebugger.DOMBreakpointType type);
        /// <summary>
        /// Removes DOM breakpoint that was set using `setDOMBreakpoint`.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node to remove breakpoint from.</param>
        /// <param name = "type">Type of the breakpoint to remove.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveDOMBreakpointAsync(int nodeId, CefSharp.DevTools.DOMDebugger.DOMBreakpointType type)
        {
            ValidateRemoveDOMBreakpoint(nodeId, type);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("type", this.EnumToString(type));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.removeDOMBreakpoint", dict);
            return methodResult;
        }

        partial void ValidateRemoveEventListenerBreakpoint(string eventName, string targetName = null);
        /// <summary>
        /// Removes breakpoint on particular DOM event.
        /// </summary>
        /// <param name = "eventName">Event name.</param>
        /// <param name = "targetName">EventTarget interface name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveEventListenerBreakpointAsync(string eventName, string targetName = null)
        {
            ValidateRemoveEventListenerBreakpoint(eventName, targetName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            if (!(string.IsNullOrEmpty(targetName)))
            {
                dict.Add("targetName", targetName);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.removeEventListenerBreakpoint", dict);
            return methodResult;
        }

        partial void ValidateRemoveInstrumentationBreakpoint(string eventName);
        /// <summary>
        /// Removes breakpoint on particular native event.
        /// </summary>
        /// <param name = "eventName">Instrumentation name to stop on.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveInstrumentationBreakpointAsync(string eventName)
        {
            ValidateRemoveInstrumentationBreakpoint(eventName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.removeInstrumentationBreakpoint", dict);
            return methodResult;
        }

        partial void ValidateRemoveXHRBreakpoint(string url);
        /// <summary>
        /// Removes breakpoint from XMLHttpRequest.
        /// </summary>
        /// <param name = "url">Resource URL substring.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveXHRBreakpointAsync(string url)
        {
            ValidateRemoveXHRBreakpoint(url);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.removeXHRBreakpoint", dict);
            return methodResult;
        }

        partial void ValidateSetDOMBreakpoint(int nodeId, CefSharp.DevTools.DOMDebugger.DOMBreakpointType type);
        /// <summary>
        /// Sets breakpoint on particular operation with DOM.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node to set breakpoint on.</param>
        /// <param name = "type">Type of the operation to stop upon.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDOMBreakpointAsync(int nodeId, CefSharp.DevTools.DOMDebugger.DOMBreakpointType type)
        {
            ValidateSetDOMBreakpoint(nodeId, type);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("type", this.EnumToString(type));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.setDOMBreakpoint", dict);
            return methodResult;
        }

        partial void ValidateSetEventListenerBreakpoint(string eventName, string targetName = null);
        /// <summary>
        /// Sets breakpoint on particular DOM event.
        /// </summary>
        /// <param name = "eventName">DOM Event name to stop on (any DOM event will do).</param>
        /// <param name = "targetName">EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on anyEventTarget.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetEventListenerBreakpointAsync(string eventName, string targetName = null)
        {
            ValidateSetEventListenerBreakpoint(eventName, targetName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            if (!(string.IsNullOrEmpty(targetName)))
            {
                dict.Add("targetName", targetName);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.setEventListenerBreakpoint", dict);
            return methodResult;
        }

        partial void ValidateSetInstrumentationBreakpoint(string eventName);
        /// <summary>
        /// Sets breakpoint on particular native event.
        /// </summary>
        /// <param name = "eventName">Instrumentation name to stop on.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetInstrumentationBreakpointAsync(string eventName)
        {
            ValidateSetInstrumentationBreakpoint(eventName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.setInstrumentationBreakpoint", dict);
            return methodResult;
        }

        partial void ValidateSetXHRBreakpoint(string url);
        /// <summary>
        /// Sets breakpoint on XMLHttpRequest.
        /// </summary>
        /// <param name = "url">Resource URL substring. All XHRs having this substring in the URL will get stopped upon.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetXHRBreakpointAsync(string url)
        {
            ValidateSetXHRBreakpoint(url);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMDebugger.setXHRBreakpoint", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// CaptureSnapshotResponse
    /// </summary>
    public class CaptureSnapshotResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// documents
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("documents")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMSnapshot.DocumentSnapshot> Documents
        {
            get;
            private set;
        }

        /// <summary>
        /// strings
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("strings")]
        public string[] Strings
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    using System.Linq;

    /// <summary>
    /// This domain facilitates obtaining document snapshots with DOM, layout, and style information.
    /// </summary>
    public partial class DOMSnapshotClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public DOMSnapshotClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables DOM snapshot agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMSnapshot.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables DOM snapshot agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMSnapshot.enable", dict);
            return methodResult;
        }

        partial void ValidateCaptureSnapshot(string[] computedStyles, bool? includePaintOrder = null, bool? includeDOMRects = null);
        /// <summary>
        /// Returns a document snapshot, including the full DOM tree of the root node (including iframes,
        /// template contents, and imported documents) in a flattened array, as well as layout and
        /// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
        /// flattened.
        /// </summary>
        /// <param name = "computedStyles">Whitelist of computed styles to return.</param>
        /// <param name = "includePaintOrder">Whether to include layout object paint orders into the snapshot.</param>
        /// <param name = "includeDOMRects">Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CaptureSnapshotResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CaptureSnapshotResponse> CaptureSnapshotAsync(string[] computedStyles, bool? includePaintOrder = null, bool? includeDOMRects = null)
        {
            ValidateCaptureSnapshot(computedStyles, includePaintOrder, includeDOMRects);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("computedStyles", computedStyles);
            if (includePaintOrder.HasValue)
            {
                dict.Add("includePaintOrder", includePaintOrder.Value);
            }

            if (includeDOMRects.HasValue)
            {
                dict.Add("includeDOMRects", includeDOMRects.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMSnapshot.captureSnapshot", dict);
            return methodResult.DeserializeJson<CaptureSnapshotResponse>();
        }
    }
}

namespace CefSharp.DevTools.DOMStorage
{
    /// <summary>
    /// GetDOMStorageItemsResponse
    /// </summary>
    public class GetDOMStorageItemsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// entries
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("entries")]
        public string[] Entries
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOMStorage
{
    using System.Linq;

    /// <summary>
    /// Query and modify DOM storage.
    /// </summary>
    public partial class DOMStorageClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public DOMStorageClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateClear(CefSharp.DevTools.DOMStorage.StorageId storageId);
        /// <summary>
        /// Clear
        /// </summary>
        /// <param name = "storageId">storageId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearAsync(CefSharp.DevTools.DOMStorage.StorageId storageId)
        {
            ValidateClear(storageId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageId", storageId.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMStorage.clear", dict);
            return methodResult;
        }

        /// <summary>
        /// Disables storage tracking, prevents storage events from being sent to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMStorage.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables storage tracking, storage events will now be delivered to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMStorage.enable", dict);
            return methodResult;
        }

        partial void ValidateGetDOMStorageItems(CefSharp.DevTools.DOMStorage.StorageId storageId);
        /// <summary>
        /// GetDOMStorageItems
        /// </summary>
        /// <param name = "storageId">storageId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetDOMStorageItemsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetDOMStorageItemsResponse> GetDOMStorageItemsAsync(CefSharp.DevTools.DOMStorage.StorageId storageId)
        {
            ValidateGetDOMStorageItems(storageId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageId", storageId.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMStorage.getDOMStorageItems", dict);
            return methodResult.DeserializeJson<GetDOMStorageItemsResponse>();
        }

        partial void ValidateRemoveDOMStorageItem(CefSharp.DevTools.DOMStorage.StorageId storageId, string key);
        /// <summary>
        /// RemoveDOMStorageItem
        /// </summary>
        /// <param name = "storageId">storageId</param>
        /// <param name = "key">key</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveDOMStorageItemAsync(CefSharp.DevTools.DOMStorage.StorageId storageId, string key)
        {
            ValidateRemoveDOMStorageItem(storageId, key);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageId", storageId.ToDictionary());
            dict.Add("key", key);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMStorage.removeDOMStorageItem", dict);
            return methodResult;
        }

        partial void ValidateSetDOMStorageItem(CefSharp.DevTools.DOMStorage.StorageId storageId, string key, string value);
        /// <summary>
        /// SetDOMStorageItem
        /// </summary>
        /// <param name = "storageId">storageId</param>
        /// <param name = "key">key</param>
        /// <param name = "value">value</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDOMStorageItemAsync(CefSharp.DevTools.DOMStorage.StorageId storageId, string key, string value)
        {
            ValidateSetDOMStorageItem(storageId, key, value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageId", storageId.ToDictionary());
            dict.Add("key", key);
            dict.Add("value", value);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DOMStorage.setDOMStorageItem", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Database
{
    /// <summary>
    /// ExecuteSQLResponse
    /// </summary>
    public class ExecuteSQLResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// columnNames
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("columnNames")]
        public string[] ColumnNames
        {
            get;
            private set;
        }

        /// <summary>
        /// values
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("values")]
        public object[] Values
        {
            get;
            private set;
        }

        /// <summary>
        /// sqlError
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sqlError")]
        public CefSharp.DevTools.Database.Error SqlError
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Database
{
    /// <summary>
    /// GetDatabaseTableNamesResponse
    /// </summary>
    public class GetDatabaseTableNamesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// tableNames
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("tableNames")]
        public string[] TableNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Database
{
    using System.Linq;

    /// <summary>
    /// Database
    /// </summary>
    public partial class DatabaseClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public DatabaseClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables database tracking, prevents database events from being sent to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Database.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables database tracking, database events will now be delivered to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Database.enable", dict);
            return methodResult;
        }

        partial void ValidateExecuteSQL(string databaseId, string query);
        /// <summary>
        /// ExecuteSQL
        /// </summary>
        /// <param name = "databaseId">databaseId</param>
        /// <param name = "query">query</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ExecuteSQLResponse&gt;</returns>
        public async System.Threading.Tasks.Task<ExecuteSQLResponse> ExecuteSQLAsync(string databaseId, string query)
        {
            ValidateExecuteSQL(databaseId, query);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseId", databaseId);
            dict.Add("query", query);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Database.executeSQL", dict);
            return methodResult.DeserializeJson<ExecuteSQLResponse>();
        }

        partial void ValidateGetDatabaseTableNames(string databaseId);
        /// <summary>
        /// GetDatabaseTableNames
        /// </summary>
        /// <param name = "databaseId">databaseId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetDatabaseTableNamesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetDatabaseTableNamesResponse> GetDatabaseTableNamesAsync(string databaseId)
        {
            ValidateGetDatabaseTableNames(databaseId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseId", databaseId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Database.getDatabaseTableNames", dict);
            return methodResult.DeserializeJson<GetDatabaseTableNamesResponse>();
        }
    }
}

namespace CefSharp.DevTools.DeviceOrientation
{
    using System.Linq;

    /// <summary>
    /// DeviceOrientation
    /// </summary>
    public partial class DeviceOrientationClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public DeviceOrientationClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Clears the overridden Device Orientation.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearDeviceOrientationOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DeviceOrientation.clearDeviceOrientationOverride", dict);
            return methodResult;
        }

        partial void ValidateSetDeviceOrientationOverride(long alpha, long beta, long gamma);
        /// <summary>
        /// Overrides the Device Orientation.
        /// </summary>
        /// <param name = "alpha">Mock alpha</param>
        /// <param name = "beta">Mock beta</param>
        /// <param name = "gamma">Mock gamma</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDeviceOrientationOverrideAsync(long alpha, long beta, long gamma)
        {
            ValidateSetDeviceOrientationOverride(alpha, beta, gamma);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("alpha", alpha);
            dict.Add("beta", beta);
            dict.Add("gamma", gamma);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("DeviceOrientation.setDeviceOrientationOverride", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// CanEmulateResponse
    /// </summary>
    public class CanEmulateResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public bool Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// SetVirtualTimePolicyResponse
    /// </summary>
    public class SetVirtualTimePolicyResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// virtualTimeTicksBase
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("virtualTimeTicksBase")]
        public long VirtualTimeTicksBase
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    using System.Linq;

    /// <summary>
    /// This domain emulates different environments for the page.
    /// </summary>
    public partial class EmulationClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public EmulationClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Tells whether emulation is supported.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;CanEmulateResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CanEmulateResponse> CanEmulateAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.canEmulate", dict);
            return methodResult.DeserializeJson<CanEmulateResponse>();
        }

        /// <summary>
        /// Clears the overriden device metrics.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearDeviceMetricsOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.clearDeviceMetricsOverride", dict);
            return methodResult;
        }

        /// <summary>
        /// Clears the overriden Geolocation Position and Error.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearGeolocationOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.clearGeolocationOverride", dict);
            return methodResult;
        }

        /// <summary>
        /// Requests that page scale factor is reset to initial values.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ResetPageScaleFactorAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.resetPageScaleFactor", dict);
            return methodResult;
        }

        partial void ValidateSetFocusEmulationEnabled(bool enabled);
        /// <summary>
        /// Enables or disables simulating a focused and active page.
        /// </summary>
        /// <param name = "enabled">Whether to enable to disable focus emulation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetFocusEmulationEnabledAsync(bool enabled)
        {
            ValidateSetFocusEmulationEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setFocusEmulationEnabled", dict);
            return methodResult;
        }

        partial void ValidateSetCPUThrottlingRate(long rate);
        /// <summary>
        /// Enables CPU throttling to emulate slow CPUs.
        /// </summary>
        /// <param name = "rate">Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetCPUThrottlingRateAsync(long rate)
        {
            ValidateSetCPUThrottlingRate(rate);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("rate", rate);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setCPUThrottlingRate", dict);
            return methodResult;
        }

        partial void ValidateSetDefaultBackgroundColorOverride(CefSharp.DevTools.DOM.RGBA color = null);
        /// <summary>
        /// Sets or clears an override of the default background color of the frame. This override is used
        /// if the content does not specify one.
        /// </summary>
        /// <param name = "color">RGBA of the default background color. If not specified, any existing override will becleared.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDefaultBackgroundColorOverrideAsync(CefSharp.DevTools.DOM.RGBA color = null)
        {
            ValidateSetDefaultBackgroundColorOverride(color);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((color) != (null))
            {
                dict.Add("color", color.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setDefaultBackgroundColorOverride", dict);
            return methodResult;
        }

        partial void ValidateSetDeviceMetricsOverride(int width, int height, long deviceScaleFactor, bool mobile, long? scale = null, int? screenWidth = null, int? screenHeight = null, int? positionX = null, int? positionY = null, bool? dontSetVisibleSize = null, CefSharp.DevTools.Emulation.ScreenOrientation screenOrientation = null, CefSharp.DevTools.Page.Viewport viewport = null, CefSharp.DevTools.Emulation.DisplayFeature displayFeature = null);
        /// <summary>
        /// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
        /// window.innerWidth, window.innerHeight, and &quot;device-width&quot;/&quot;device-height&quot;-related CSS media
        /// query results).
        /// </summary>
        /// <param name = "width">Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.</param>
        /// <param name = "height">Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.</param>
        /// <param name = "deviceScaleFactor">Overriding device scale factor value. 0 disables the override.</param>
        /// <param name = "mobile">Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, textautosizing and more.</param>
        /// <param name = "scale">Scale to apply to resulting view image.</param>
        /// <param name = "screenWidth">Overriding screen width value in pixels (minimum 0, maximum 10000000).</param>
        /// <param name = "screenHeight">Overriding screen height value in pixels (minimum 0, maximum 10000000).</param>
        /// <param name = "positionX">Overriding view X position on screen in pixels (minimum 0, maximum 10000000).</param>
        /// <param name = "positionY">Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).</param>
        /// <param name = "dontSetVisibleSize">Do not set visible view size, rely upon explicit setVisibleSize call.</param>
        /// <param name = "screenOrientation">Screen orientation override.</param>
        /// <param name = "viewport">If set, the visible area of the page will be overridden to this viewport. This viewportchange is not observed by the page, e.g. viewport-relative elements do not change positions.</param>
        /// <param name = "displayFeature">If set, the display feature of a multi-segment screen. If not set, multi-segment supportis turned-off.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDeviceMetricsOverrideAsync(int width, int height, long deviceScaleFactor, bool mobile, long? scale = null, int? screenWidth = null, int? screenHeight = null, int? positionX = null, int? positionY = null, bool? dontSetVisibleSize = null, CefSharp.DevTools.Emulation.ScreenOrientation screenOrientation = null, CefSharp.DevTools.Page.Viewport viewport = null, CefSharp.DevTools.Emulation.DisplayFeature displayFeature = null)
        {
            ValidateSetDeviceMetricsOverride(width, height, deviceScaleFactor, mobile, scale, screenWidth, screenHeight, positionX, positionY, dontSetVisibleSize, screenOrientation, viewport, displayFeature);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("width", width);
            dict.Add("height", height);
            dict.Add("deviceScaleFactor", deviceScaleFactor);
            dict.Add("mobile", mobile);
            if (scale.HasValue)
            {
                dict.Add("scale", scale.Value);
            }

            if (screenWidth.HasValue)
            {
                dict.Add("screenWidth", screenWidth.Value);
            }

            if (screenHeight.HasValue)
            {
                dict.Add("screenHeight", screenHeight.Value);
            }

            if (positionX.HasValue)
            {
                dict.Add("positionX", positionX.Value);
            }

            if (positionY.HasValue)
            {
                dict.Add("positionY", positionY.Value);
            }

            if (dontSetVisibleSize.HasValue)
            {
                dict.Add("dontSetVisibleSize", dontSetVisibleSize.Value);
            }

            if ((screenOrientation) != (null))
            {
                dict.Add("screenOrientation", screenOrientation.ToDictionary());
            }

            if ((viewport) != (null))
            {
                dict.Add("viewport", viewport.ToDictionary());
            }

            if ((displayFeature) != (null))
            {
                dict.Add("displayFeature", displayFeature.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setDeviceMetricsOverride", dict);
            return methodResult;
        }

        partial void ValidateSetScrollbarsHidden(bool hidden);
        /// <summary>
        /// SetScrollbarsHidden
        /// </summary>
        /// <param name = "hidden">Whether scrollbars should be always hidden.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetScrollbarsHiddenAsync(bool hidden)
        {
            ValidateSetScrollbarsHidden(hidden);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("hidden", hidden);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setScrollbarsHidden", dict);
            return methodResult;
        }

        partial void ValidateSetDocumentCookieDisabled(bool disabled);
        /// <summary>
        /// SetDocumentCookieDisabled
        /// </summary>
        /// <param name = "disabled">Whether document.coookie API should be disabled.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDocumentCookieDisabledAsync(bool disabled)
        {
            ValidateSetDocumentCookieDisabled(disabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("disabled", disabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setDocumentCookieDisabled", dict);
            return methodResult;
        }

        partial void ValidateSetEmitTouchEventsForMouse(bool enabled, string configuration = null);
        /// <summary>
        /// SetEmitTouchEventsForMouse
        /// </summary>
        /// <param name = "enabled">Whether touch emulation based on mouse input should be enabled.</param>
        /// <param name = "configuration">Touch/gesture events configuration. Default: current platform.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetEmitTouchEventsForMouseAsync(bool enabled, string configuration = null)
        {
            ValidateSetEmitTouchEventsForMouse(enabled, configuration);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            if (!(string.IsNullOrEmpty(configuration)))
            {
                dict.Add("configuration", configuration);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setEmitTouchEventsForMouse", dict);
            return methodResult;
        }

        partial void ValidateSetEmulatedMedia(string media = null, System.Collections.Generic.IList<CefSharp.DevTools.Emulation.MediaFeature> features = null);
        /// <summary>
        /// Emulates the given media type or media feature for CSS media queries.
        /// </summary>
        /// <param name = "media">Media type to emulate. Empty string disables the override.</param>
        /// <param name = "features">Media features to emulate.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetEmulatedMediaAsync(string media = null, System.Collections.Generic.IList<CefSharp.DevTools.Emulation.MediaFeature> features = null)
        {
            ValidateSetEmulatedMedia(media, features);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(media)))
            {
                dict.Add("media", media);
            }

            if ((features) != (null))
            {
                dict.Add("features", features.Select(x => x.ToDictionary()));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setEmulatedMedia", dict);
            return methodResult;
        }

        partial void ValidateSetEmulatedVisionDeficiency(string type);
        /// <summary>
        /// Emulates the given vision deficiency.
        /// </summary>
        /// <param name = "type">Vision deficiency to emulate.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetEmulatedVisionDeficiencyAsync(string type)
        {
            ValidateSetEmulatedVisionDeficiency(type);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", type);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setEmulatedVisionDeficiency", dict);
            return methodResult;
        }

        partial void ValidateSetGeolocationOverride(long? latitude = null, long? longitude = null, long? accuracy = null);
        /// <summary>
        /// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
        /// unavailable.
        /// </summary>
        /// <param name = "latitude">Mock latitude</param>
        /// <param name = "longitude">Mock longitude</param>
        /// <param name = "accuracy">Mock accuracy</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetGeolocationOverrideAsync(long? latitude = null, long? longitude = null, long? accuracy = null)
        {
            ValidateSetGeolocationOverride(latitude, longitude, accuracy);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (latitude.HasValue)
            {
                dict.Add("latitude", latitude.Value);
            }

            if (longitude.HasValue)
            {
                dict.Add("longitude", longitude.Value);
            }

            if (accuracy.HasValue)
            {
                dict.Add("accuracy", accuracy.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setGeolocationOverride", dict);
            return methodResult;
        }

        partial void ValidateSetIdleOverride(bool isUserActive, bool isScreenUnlocked);
        /// <summary>
        /// Overrides the Idle state.
        /// </summary>
        /// <param name = "isUserActive">Mock isUserActive</param>
        /// <param name = "isScreenUnlocked">Mock isScreenUnlocked</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetIdleOverrideAsync(bool isUserActive, bool isScreenUnlocked)
        {
            ValidateSetIdleOverride(isUserActive, isScreenUnlocked);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("isUserActive", isUserActive);
            dict.Add("isScreenUnlocked", isScreenUnlocked);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setIdleOverride", dict);
            return methodResult;
        }

        /// <summary>
        /// Clears Idle state overrides.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearIdleOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.clearIdleOverride", dict);
            return methodResult;
        }

        partial void ValidateSetPageScaleFactor(long pageScaleFactor);
        /// <summary>
        /// Sets a specified page scale factor.
        /// </summary>
        /// <param name = "pageScaleFactor">Page scale factor.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetPageScaleFactorAsync(long pageScaleFactor)
        {
            ValidateSetPageScaleFactor(pageScaleFactor);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("pageScaleFactor", pageScaleFactor);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setPageScaleFactor", dict);
            return methodResult;
        }

        partial void ValidateSetScriptExecutionDisabled(bool value);
        /// <summary>
        /// Switches script execution in the page.
        /// </summary>
        /// <param name = "value">Whether script execution should be disabled in the page.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetScriptExecutionDisabledAsync(bool value)
        {
            ValidateSetScriptExecutionDisabled(value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("value", value);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setScriptExecutionDisabled", dict);
            return methodResult;
        }

        partial void ValidateSetTouchEmulationEnabled(bool enabled, int? maxTouchPoints = null);
        /// <summary>
        /// Enables touch on platforms which do not support them.
        /// </summary>
        /// <param name = "enabled">Whether the touch event emulation should be enabled.</param>
        /// <param name = "maxTouchPoints">Maximum touch points supported. Defaults to one.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetTouchEmulationEnabledAsync(bool enabled, int? maxTouchPoints = null)
        {
            ValidateSetTouchEmulationEnabled(enabled, maxTouchPoints);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            if (maxTouchPoints.HasValue)
            {
                dict.Add("maxTouchPoints", maxTouchPoints.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setTouchEmulationEnabled", dict);
            return methodResult;
        }

        partial void ValidateSetVirtualTimePolicy(CefSharp.DevTools.Emulation.VirtualTimePolicy policy, long? budget = null, int? maxVirtualTimeTaskStarvationCount = null, bool? waitForNavigation = null, long? initialVirtualTime = null);
        /// <summary>
        /// Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
        /// the current virtual time policy.  Note this supersedes any previous time budget.
        /// </summary>
        /// <param name = "policy">policy</param>
        /// <param name = "budget">If set, after this many virtual milliseconds have elapsed virtual time will be paused and avirtualTimeBudgetExpired event is sent.</param>
        /// <param name = "maxVirtualTimeTaskStarvationCount">If set this specifies the maximum number of tasks that can be run before virtual is forcedforwards to prevent deadlock.</param>
        /// <param name = "waitForNavigation">If set the virtual time policy change should be deferred until any frame starts navigating.Note any previous deferred policy change is superseded.</param>
        /// <param name = "initialVirtualTime">If set, base::Time::Now will be overriden to initially return this value.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetVirtualTimePolicyResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetVirtualTimePolicyResponse> SetVirtualTimePolicyAsync(CefSharp.DevTools.Emulation.VirtualTimePolicy policy, long? budget = null, int? maxVirtualTimeTaskStarvationCount = null, bool? waitForNavigation = null, long? initialVirtualTime = null)
        {
            ValidateSetVirtualTimePolicy(policy, budget, maxVirtualTimeTaskStarvationCount, waitForNavigation, initialVirtualTime);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("policy", this.EnumToString(policy));
            if (budget.HasValue)
            {
                dict.Add("budget", budget.Value);
            }

            if (maxVirtualTimeTaskStarvationCount.HasValue)
            {
                dict.Add("maxVirtualTimeTaskStarvationCount", maxVirtualTimeTaskStarvationCount.Value);
            }

            if (waitForNavigation.HasValue)
            {
                dict.Add("waitForNavigation", waitForNavigation.Value);
            }

            if (initialVirtualTime.HasValue)
            {
                dict.Add("initialVirtualTime", initialVirtualTime.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setVirtualTimePolicy", dict);
            return methodResult.DeserializeJson<SetVirtualTimePolicyResponse>();
        }

        partial void ValidateSetLocaleOverride(string locale = null);
        /// <summary>
        /// Overrides default host system locale with the specified one.
        /// </summary>
        /// <param name = "locale">ICU style C locale (e.g. "en_US"). If not specified or empty, disables the override andrestores default host system locale.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetLocaleOverrideAsync(string locale = null)
        {
            ValidateSetLocaleOverride(locale);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(locale)))
            {
                dict.Add("locale", locale);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setLocaleOverride", dict);
            return methodResult;
        }

        partial void ValidateSetTimezoneOverride(string timezoneId);
        /// <summary>
        /// Overrides default host system timezone with the specified one.
        /// </summary>
        /// <param name = "timezoneId">The timezone identifier. If empty, disables the override andrestores default host system timezone.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetTimezoneOverrideAsync(string timezoneId)
        {
            ValidateSetTimezoneOverride(timezoneId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("timezoneId", timezoneId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setTimezoneOverride", dict);
            return methodResult;
        }

        partial void ValidateSetUserAgentOverride(string userAgent, string acceptLanguage = null, string platform = null, CefSharp.DevTools.Emulation.UserAgentMetadata userAgentMetadata = null);
        /// <summary>
        /// Allows overriding user agent with the given string.
        /// </summary>
        /// <param name = "userAgent">User agent to use.</param>
        /// <param name = "acceptLanguage">Browser langugage to emulate.</param>
        /// <param name = "platform">The platform navigator.platform should return.</param>
        /// <param name = "userAgentMetadata">To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetUserAgentOverrideAsync(string userAgent, string acceptLanguage = null, string platform = null, CefSharp.DevTools.Emulation.UserAgentMetadata userAgentMetadata = null)
        {
            ValidateSetUserAgentOverride(userAgent, acceptLanguage, platform, userAgentMetadata);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("userAgent", userAgent);
            if (!(string.IsNullOrEmpty(acceptLanguage)))
            {
                dict.Add("acceptLanguage", acceptLanguage);
            }

            if (!(string.IsNullOrEmpty(platform)))
            {
                dict.Add("platform", platform);
            }

            if ((userAgentMetadata) != (null))
            {
                dict.Add("userAgentMetadata", userAgentMetadata.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Emulation.setUserAgentOverride", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.HeadlessExperimental
{
    /// <summary>
    /// BeginFrameResponse
    /// </summary>
    public class BeginFrameResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// hasDamage
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hasDamage")]
        public bool HasDamage
        {
            get;
            private set;
        }

        /// <summary>
        /// screenshotData
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("screenshotData")]
        public byte[] ScreenshotData
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeadlessExperimental
{
    using System.Linq;

    /// <summary>
    /// This domain provides experimental commands only supported in headless mode.
    /// </summary>
    public partial class HeadlessExperimentalClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public HeadlessExperimentalClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateBeginFrame(long? frameTimeTicks = null, long? interval = null, bool? noDisplayUpdates = null, CefSharp.DevTools.HeadlessExperimental.ScreenshotParams screenshot = null);
        /// <summary>
        /// Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
        /// screenshot from the resulting frame. Requires that the target was created with enabled
        /// BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
        /// https://goo.gl/3zHXhB for more background.
        /// </summary>
        /// <param name = "frameTimeTicks">Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,the current time will be used.</param>
        /// <param name = "interval">The interval between BeginFrames that is reported to the compositor, in milliseconds.Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.</param>
        /// <param name = "noDisplayUpdates">Whether updates should not be committed and drawn onto the display. False by default. Iftrue, only side effects of the BeginFrame will be run, such as layout and animations, butany visual updates may not be visible on the display or in screenshots.</param>
        /// <param name = "screenshot">If set, a screenshot of the frame will be captured and returned in the response. Otherwise,no screenshot will be captured. Note that capturing a screenshot can fail, for example,during renderer initialization. In such a case, no screenshot data will be returned.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;BeginFrameResponse&gt;</returns>
        public async System.Threading.Tasks.Task<BeginFrameResponse> BeginFrameAsync(long? frameTimeTicks = null, long? interval = null, bool? noDisplayUpdates = null, CefSharp.DevTools.HeadlessExperimental.ScreenshotParams screenshot = null)
        {
            ValidateBeginFrame(frameTimeTicks, interval, noDisplayUpdates, screenshot);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (frameTimeTicks.HasValue)
            {
                dict.Add("frameTimeTicks", frameTimeTicks.Value);
            }

            if (interval.HasValue)
            {
                dict.Add("interval", interval.Value);
            }

            if (noDisplayUpdates.HasValue)
            {
                dict.Add("noDisplayUpdates", noDisplayUpdates.Value);
            }

            if ((screenshot) != (null))
            {
                dict.Add("screenshot", screenshot.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeadlessExperimental.beginFrame", dict);
            return methodResult.DeserializeJson<BeginFrameResponse>();
        }

        /// <summary>
        /// Disables headless events for the target.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeadlessExperimental.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables headless events for the target.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeadlessExperimental.enable", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.IO
{
    /// <summary>
    /// ReadResponse
    /// </summary>
    public class ReadResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// base64Encoded
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("base64Encoded")]
        public bool? Base64Encoded
        {
            get;
            private set;
        }

        /// <summary>
        /// data
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("data")]
        public string Data
        {
            get;
            private set;
        }

        /// <summary>
        /// eof
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("eof")]
        public bool Eof
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IO
{
    /// <summary>
    /// ResolveBlobResponse
    /// </summary>
    public class ResolveBlobResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// uuid
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("uuid")]
        public string Uuid
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IO
{
    using System.Linq;

    /// <summary>
    /// Input/Output operations for streams produced by DevTools.
    /// </summary>
    public partial class IOClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public IOClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateClose(string handle);
        /// <summary>
        /// Close the stream, discard any temporary backing storage.
        /// </summary>
        /// <param name = "handle">Handle of the stream to close.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> CloseAsync(string handle)
        {
            ValidateClose(handle);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("handle", handle);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IO.close", dict);
            return methodResult;
        }

        partial void ValidateRead(string handle, int? offset = null, int? size = null);
        /// <summary>
        /// Read a chunk of the stream
        /// </summary>
        /// <param name = "handle">Handle of the stream to read.</param>
        /// <param name = "offset">Seek to the specified offset before reading (if not specificed, proceed with offsetfollowing the last read). Some types of streams may only support sequential reads.</param>
        /// <param name = "size">Maximum number of bytes to read (left upon the agent discretion if not specified).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ReadResponse&gt;</returns>
        public async System.Threading.Tasks.Task<ReadResponse> ReadAsync(string handle, int? offset = null, int? size = null)
        {
            ValidateRead(handle, offset, size);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("handle", handle);
            if (offset.HasValue)
            {
                dict.Add("offset", offset.Value);
            }

            if (size.HasValue)
            {
                dict.Add("size", size.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("IO.read", dict);
            return methodResult.DeserializeJson<ReadResponse>();
        }

        partial void ValidateResolveBlob(string objectId);
        /// <summary>
        /// Return UUID of Blob object specified by a remote object id.
        /// </summary>
        /// <param name = "objectId">Object id of a Blob object wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ResolveBlobResponse&gt;</returns>
        public async System.Threading.Tasks.Task<ResolveBlobResponse> ResolveBlobAsync(string objectId)
        {
            ValidateResolveBlob(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IO.resolveBlob", dict);
            return methodResult.DeserializeJson<ResolveBlobResponse>();
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// RequestDataResponse
    /// </summary>
    public class RequestDataResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// objectStoreDataEntries
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("objectStoreDataEntries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.IndexedDB.DataEntry> ObjectStoreDataEntries
        {
            get;
            private set;
        }

        /// <summary>
        /// hasMore
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("hasMore")]
        public bool HasMore
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// GetMetadataResponse
    /// </summary>
    public class GetMetadataResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// entriesCount
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("entriesCount")]
        public long EntriesCount
        {
            get;
            private set;
        }

        /// <summary>
        /// keyGeneratorValue
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("keyGeneratorValue")]
        public long KeyGeneratorValue
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// RequestDatabaseResponse
    /// </summary>
    public class RequestDatabaseResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// databaseWithObjectStores
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("databaseWithObjectStores")]
        public CefSharp.DevTools.IndexedDB.DatabaseWithObjectStores DatabaseWithObjectStores
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// RequestDatabaseNamesResponse
    /// </summary>
    public class RequestDatabaseNamesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// databaseNames
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("databaseNames")]
        public string[] DatabaseNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    using System.Linq;

    /// <summary>
    /// IndexedDB
    /// </summary>
    public partial class IndexedDBClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public IndexedDBClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateClearObjectStore(string securityOrigin, string databaseName, string objectStoreName);
        /// <summary>
        /// Clears all entries from an object store.
        /// </summary>
        /// <param name = "securityOrigin">Security origin.</param>
        /// <param name = "databaseName">Database name.</param>
        /// <param name = "objectStoreName">Object store name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearObjectStoreAsync(string securityOrigin, string databaseName, string objectStoreName)
        {
            ValidateClearObjectStore(securityOrigin, databaseName, objectStoreName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("securityOrigin", securityOrigin);
            dict.Add("databaseName", databaseName);
            dict.Add("objectStoreName", objectStoreName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.clearObjectStore", dict);
            return methodResult;
        }

        partial void ValidateDeleteDatabase(string securityOrigin, string databaseName);
        /// <summary>
        /// Deletes a database.
        /// </summary>
        /// <param name = "securityOrigin">Security origin.</param>
        /// <param name = "databaseName">Database name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteDatabaseAsync(string securityOrigin, string databaseName)
        {
            ValidateDeleteDatabase(securityOrigin, databaseName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("securityOrigin", securityOrigin);
            dict.Add("databaseName", databaseName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.deleteDatabase", dict);
            return methodResult;
        }

        partial void ValidateDeleteObjectStoreEntries(string securityOrigin, string databaseName, string objectStoreName, CefSharp.DevTools.IndexedDB.KeyRange keyRange);
        /// <summary>
        /// Delete a range of entries from an object store
        /// </summary>
        /// <param name = "securityOrigin">securityOrigin</param>
        /// <param name = "databaseName">databaseName</param>
        /// <param name = "objectStoreName">objectStoreName</param>
        /// <param name = "keyRange">Range of entry keys to delete</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteObjectStoreEntriesAsync(string securityOrigin, string databaseName, string objectStoreName, CefSharp.DevTools.IndexedDB.KeyRange keyRange)
        {
            ValidateDeleteObjectStoreEntries(securityOrigin, databaseName, objectStoreName, keyRange);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("securityOrigin", securityOrigin);
            dict.Add("databaseName", databaseName);
            dict.Add("objectStoreName", objectStoreName);
            dict.Add("keyRange", keyRange.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.deleteObjectStoreEntries", dict);
            return methodResult;
        }

        /// <summary>
        /// Disables events from backend.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables events from backend.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.enable", dict);
            return methodResult;
        }

        partial void ValidateRequestData(string securityOrigin, string databaseName, string objectStoreName, string indexName, int skipCount, int pageSize, CefSharp.DevTools.IndexedDB.KeyRange keyRange = null);
        /// <summary>
        /// Requests data from object store or index.
        /// </summary>
        /// <param name = "securityOrigin">Security origin.</param>
        /// <param name = "databaseName">Database name.</param>
        /// <param name = "objectStoreName">Object store name.</param>
        /// <param name = "indexName">Index name, empty string for object store data requests.</param>
        /// <param name = "skipCount">Number of records to skip.</param>
        /// <param name = "pageSize">Number of records to fetch.</param>
        /// <param name = "keyRange">Key range.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestDataResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RequestDataResponse> RequestDataAsync(string securityOrigin, string databaseName, string objectStoreName, string indexName, int skipCount, int pageSize, CefSharp.DevTools.IndexedDB.KeyRange keyRange = null)
        {
            ValidateRequestData(securityOrigin, databaseName, objectStoreName, indexName, skipCount, pageSize, keyRange);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("securityOrigin", securityOrigin);
            dict.Add("databaseName", databaseName);
            dict.Add("objectStoreName", objectStoreName);
            dict.Add("indexName", indexName);
            dict.Add("skipCount", skipCount);
            dict.Add("pageSize", pageSize);
            if ((keyRange) != (null))
            {
                dict.Add("keyRange", keyRange.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.requestData", dict);
            return methodResult.DeserializeJson<RequestDataResponse>();
        }

        partial void ValidateGetMetadata(string securityOrigin, string databaseName, string objectStoreName);
        /// <summary>
        /// Gets metadata of an object store
        /// </summary>
        /// <param name = "securityOrigin">Security origin.</param>
        /// <param name = "databaseName">Database name.</param>
        /// <param name = "objectStoreName">Object store name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetMetadataResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetMetadataResponse> GetMetadataAsync(string securityOrigin, string databaseName, string objectStoreName)
        {
            ValidateGetMetadata(securityOrigin, databaseName, objectStoreName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("securityOrigin", securityOrigin);
            dict.Add("databaseName", databaseName);
            dict.Add("objectStoreName", objectStoreName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.getMetadata", dict);
            return methodResult.DeserializeJson<GetMetadataResponse>();
        }

        partial void ValidateRequestDatabase(string securityOrigin, string databaseName);
        /// <summary>
        /// Requests database with given name in given frame.
        /// </summary>
        /// <param name = "securityOrigin">Security origin.</param>
        /// <param name = "databaseName">Database name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestDatabaseResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RequestDatabaseResponse> RequestDatabaseAsync(string securityOrigin, string databaseName)
        {
            ValidateRequestDatabase(securityOrigin, databaseName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("securityOrigin", securityOrigin);
            dict.Add("databaseName", databaseName);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.requestDatabase", dict);
            return methodResult.DeserializeJson<RequestDatabaseResponse>();
        }

        partial void ValidateRequestDatabaseNames(string securityOrigin);
        /// <summary>
        /// Requests database names for given security origin.
        /// </summary>
        /// <param name = "securityOrigin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestDatabaseNamesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RequestDatabaseNamesResponse> RequestDatabaseNamesAsync(string securityOrigin)
        {
            ValidateRequestDatabaseNames(securityOrigin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("securityOrigin", securityOrigin);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("IndexedDB.requestDatabaseNames", dict);
            return methodResult.DeserializeJson<RequestDatabaseNamesResponse>();
        }
    }
}

namespace CefSharp.DevTools.Input
{
    using System.Linq;

    /// <summary>
    /// Input
    /// </summary>
    public partial class InputClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public InputClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateDispatchKeyEvent(string type, int? modifiers = null, long? timestamp = null, string text = null, string unmodifiedText = null, string keyIdentifier = null, string code = null, string key = null, int? windowsVirtualKeyCode = null, int? nativeVirtualKeyCode = null, bool? autoRepeat = null, bool? isKeypad = null, bool? isSystemKey = null, int? location = null, string[] commands = null);
        /// <summary>
        /// Dispatches a key event to the page.
        /// </summary>
        /// <param name = "type">Type of the key event.</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <param name = "timestamp">Time at which the event occurred.</param>
        /// <param name = "text">Text as generated by processing a virtual key code with a keyboard layout. Not needed forfor `keyUp` and `rawKeyDown` events (default: "")</param>
        /// <param name = "unmodifiedText">Text that would have been generated by the keyboard if no modifiers were pressed (except forshift). Useful for shortcut (accelerator) key handling (default: "").</param>
        /// <param name = "keyIdentifier">Unique key identifier (e.g., 'U+0041') (default: "").</param>
        /// <param name = "code">Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").</param>
        /// <param name = "key">Unique DOM defined string value describing the meaning of the key in the context of activemodifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").</param>
        /// <param name = "windowsVirtualKeyCode">Windows virtual key code (default: 0).</param>
        /// <param name = "nativeVirtualKeyCode">Native virtual key code (default: 0).</param>
        /// <param name = "autoRepeat">Whether the event was generated from auto repeat (default: false).</param>
        /// <param name = "isKeypad">Whether the event was generated from the keypad (default: false).</param>
        /// <param name = "isSystemKey">Whether the event was a system key event (default: false).</param>
        /// <param name = "location">Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:0).</param>
        /// <param name = "commands">Editing commands to send with the key event (e.g., 'selectAll') (default: []).These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.See https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchKeyEventAsync(string type, int? modifiers = null, long? timestamp = null, string text = null, string unmodifiedText = null, string keyIdentifier = null, string code = null, string key = null, int? windowsVirtualKeyCode = null, int? nativeVirtualKeyCode = null, bool? autoRepeat = null, bool? isKeypad = null, bool? isSystemKey = null, int? location = null, string[] commands = null)
        {
            ValidateDispatchKeyEvent(type, modifiers, timestamp, text, unmodifiedText, keyIdentifier, code, key, windowsVirtualKeyCode, nativeVirtualKeyCode, autoRepeat, isKeypad, isSystemKey, location, commands);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", type);
            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            if (timestamp.HasValue)
            {
                dict.Add("timestamp", timestamp.Value);
            }

            if (!(string.IsNullOrEmpty(text)))
            {
                dict.Add("text", text);
            }

            if (!(string.IsNullOrEmpty(unmodifiedText)))
            {
                dict.Add("unmodifiedText", unmodifiedText);
            }

            if (!(string.IsNullOrEmpty(keyIdentifier)))
            {
                dict.Add("keyIdentifier", keyIdentifier);
            }

            if (!(string.IsNullOrEmpty(code)))
            {
                dict.Add("code", code);
            }

            if (!(string.IsNullOrEmpty(key)))
            {
                dict.Add("key", key);
            }

            if (windowsVirtualKeyCode.HasValue)
            {
                dict.Add("windowsVirtualKeyCode", windowsVirtualKeyCode.Value);
            }

            if (nativeVirtualKeyCode.HasValue)
            {
                dict.Add("nativeVirtualKeyCode", nativeVirtualKeyCode.Value);
            }

            if (autoRepeat.HasValue)
            {
                dict.Add("autoRepeat", autoRepeat.Value);
            }

            if (isKeypad.HasValue)
            {
                dict.Add("isKeypad", isKeypad.Value);
            }

            if (isSystemKey.HasValue)
            {
                dict.Add("isSystemKey", isSystemKey.Value);
            }

            if (location.HasValue)
            {
                dict.Add("location", location.Value);
            }

            if ((commands) != (null))
            {
                dict.Add("commands", commands);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.dispatchKeyEvent", dict);
            return methodResult;
        }

        partial void ValidateInsertText(string text);
        /// <summary>
        /// This method emulates inserting text that doesn&apos;t come from a key press,
        /// for example an emoji keyboard or an IME.
        /// </summary>
        /// <param name = "text">The text to insert.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> InsertTextAsync(string text)
        {
            ValidateInsertText(text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("text", text);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.insertText", dict);
            return methodResult;
        }

        partial void ValidateDispatchMouseEvent(string type, long x, long y, int? modifiers = null, long? timestamp = null, CefSharp.DevTools.Input.MouseButton? button = null, int? buttons = null, int? clickCount = null, long? deltaX = null, long? deltaY = null, string pointerType = null);
        /// <summary>
        /// Dispatches a mouse event to the page.
        /// </summary>
        /// <param name = "type">Type of the mouse event.</param>
        /// <param name = "x">X coordinate of the event relative to the main frame's viewport in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers tothe top of the viewport and Y increases as it proceeds towards the bottom of the viewport.</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <param name = "timestamp">Time at which the event occurred.</param>
        /// <param name = "button">Mouse button (default: "none").</param>
        /// <param name = "buttons">A number indicating which buttons are pressed on the mouse when a mouse event is triggered.Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.</param>
        /// <param name = "clickCount">Number of times the mouse button was clicked (default: 0).</param>
        /// <param name = "deltaX">X delta in CSS pixels for mouse wheel event (default: 0).</param>
        /// <param name = "deltaY">Y delta in CSS pixels for mouse wheel event (default: 0).</param>
        /// <param name = "pointerType">Pointer type (default: "mouse").</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchMouseEventAsync(string type, long x, long y, int? modifiers = null, long? timestamp = null, CefSharp.DevTools.Input.MouseButton? button = null, int? buttons = null, int? clickCount = null, long? deltaX = null, long? deltaY = null, string pointerType = null)
        {
            ValidateDispatchMouseEvent(type, x, y, modifiers, timestamp, button, buttons, clickCount, deltaX, deltaY, pointerType);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", type);
            dict.Add("x", x);
            dict.Add("y", y);
            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            if (timestamp.HasValue)
            {
                dict.Add("timestamp", timestamp.Value);
            }

            if (button.HasValue)
            {
                dict.Add("button", this.EnumToString(button));
            }

            if (buttons.HasValue)
            {
                dict.Add("buttons", buttons.Value);
            }

            if (clickCount.HasValue)
            {
                dict.Add("clickCount", clickCount.Value);
            }

            if (deltaX.HasValue)
            {
                dict.Add("deltaX", deltaX.Value);
            }

            if (deltaY.HasValue)
            {
                dict.Add("deltaY", deltaY.Value);
            }

            if (!(string.IsNullOrEmpty(pointerType)))
            {
                dict.Add("pointerType", pointerType);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.dispatchMouseEvent", dict);
            return methodResult;
        }

        partial void ValidateDispatchTouchEvent(string type, System.Collections.Generic.IList<CefSharp.DevTools.Input.TouchPoint> touchPoints, int? modifiers = null, long? timestamp = null);
        /// <summary>
        /// Dispatches a touch event to the page.
        /// </summary>
        /// <param name = "type">Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, whileTouchStart and TouchMove must contains at least one.</param>
        /// <param name = "touchPoints">Active touch points on the touch device. One event per any changed point (compared toprevious touch event in a sequence) is generated, emulating pressing/moving/releasing pointsone by one.</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <param name = "timestamp">Time at which the event occurred.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchTouchEventAsync(string type, System.Collections.Generic.IList<CefSharp.DevTools.Input.TouchPoint> touchPoints, int? modifiers = null, long? timestamp = null)
        {
            ValidateDispatchTouchEvent(type, touchPoints, modifiers, timestamp);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", type);
            dict.Add("touchPoints", touchPoints.Select(x => x.ToDictionary()));
            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            if (timestamp.HasValue)
            {
                dict.Add("timestamp", timestamp.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.dispatchTouchEvent", dict);
            return methodResult;
        }

        partial void ValidateEmulateTouchFromMouseEvent(string type, int x, int y, CefSharp.DevTools.Input.MouseButton button, long? timestamp = null, long? deltaX = null, long? deltaY = null, int? modifiers = null, int? clickCount = null);
        /// <summary>
        /// Emulates touch event from the mouse event parameters.
        /// </summary>
        /// <param name = "type">Type of the mouse event.</param>
        /// <param name = "x">X coordinate of the mouse pointer in DIP.</param>
        /// <param name = "y">Y coordinate of the mouse pointer in DIP.</param>
        /// <param name = "button">Mouse button. Only "none", "left", "right" are supported.</param>
        /// <param name = "timestamp">Time at which the event occurred (default: current time).</param>
        /// <param name = "deltaX">X delta in DIP for mouse wheel event (default: 0).</param>
        /// <param name = "deltaY">Y delta in DIP for mouse wheel event (default: 0).</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <param name = "clickCount">Number of times the mouse button was clicked (default: 0).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EmulateTouchFromMouseEventAsync(string type, int x, int y, CefSharp.DevTools.Input.MouseButton button, long? timestamp = null, long? deltaX = null, long? deltaY = null, int? modifiers = null, int? clickCount = null)
        {
            ValidateEmulateTouchFromMouseEvent(type, x, y, button, timestamp, deltaX, deltaY, modifiers, clickCount);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", type);
            dict.Add("x", x);
            dict.Add("y", y);
            dict.Add("button", this.EnumToString(button));
            if (timestamp.HasValue)
            {
                dict.Add("timestamp", timestamp.Value);
            }

            if (deltaX.HasValue)
            {
                dict.Add("deltaX", deltaX.Value);
            }

            if (deltaY.HasValue)
            {
                dict.Add("deltaY", deltaY.Value);
            }

            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            if (clickCount.HasValue)
            {
                dict.Add("clickCount", clickCount.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.emulateTouchFromMouseEvent", dict);
            return methodResult;
        }

        partial void ValidateSetIgnoreInputEvents(bool ignore);
        /// <summary>
        /// Ignores input events (useful while auditing page).
        /// </summary>
        /// <param name = "ignore">Ignores input events processing when set to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetIgnoreInputEventsAsync(bool ignore)
        {
            ValidateSetIgnoreInputEvents(ignore);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ignore", ignore);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.setIgnoreInputEvents", dict);
            return methodResult;
        }

        partial void ValidateSynthesizePinchGesture(long x, long y, long scaleFactor, int? relativeSpeed = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null);
        /// <summary>
        /// Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
        /// </summary>
        /// <param name = "x">X coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "scaleFactor">Relative scale factor after zooming (&gt;1.0 zooms in, &lt;1.0 zooms out).</param>
        /// <param name = "relativeSpeed">Relative pointer speed in pixels per second (default: 800).</param>
        /// <param name = "gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platformfor the preferred input type).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SynthesizePinchGestureAsync(long x, long y, long scaleFactor, int? relativeSpeed = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null)
        {
            ValidateSynthesizePinchGesture(x, y, scaleFactor, relativeSpeed, gestureSourceType);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            dict.Add("scaleFactor", scaleFactor);
            if (relativeSpeed.HasValue)
            {
                dict.Add("relativeSpeed", relativeSpeed.Value);
            }

            if (gestureSourceType.HasValue)
            {
                dict.Add("gestureSourceType", this.EnumToString(gestureSourceType));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.synthesizePinchGesture", dict);
            return methodResult;
        }

        partial void ValidateSynthesizeScrollGesture(long x, long y, long? xDistance = null, long? yDistance = null, long? xOverscroll = null, long? yOverscroll = null, bool? preventFling = null, int? speed = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null, int? repeatCount = null, int? repeatDelayMs = null, string interactionMarkerName = null);
        /// <summary>
        /// Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
        /// </summary>
        /// <param name = "x">X coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "xDistance">The distance to scroll along the X axis (positive to scroll left).</param>
        /// <param name = "yDistance">The distance to scroll along the Y axis (positive to scroll up).</param>
        /// <param name = "xOverscroll">The number of additional pixels to scroll back along the X axis, in addition to the givendistance.</param>
        /// <param name = "yOverscroll">The number of additional pixels to scroll back along the Y axis, in addition to the givendistance.</param>
        /// <param name = "preventFling">Prevent fling (default: true).</param>
        /// <param name = "speed">Swipe speed in pixels per second (default: 800).</param>
        /// <param name = "gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platformfor the preferred input type).</param>
        /// <param name = "repeatCount">The number of times to repeat the gesture (default: 0).</param>
        /// <param name = "repeatDelayMs">The number of milliseconds delay between each repeat. (default: 250).</param>
        /// <param name = "interactionMarkerName">The name of the interaction markers to generate, if not empty (default: "").</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SynthesizeScrollGestureAsync(long x, long y, long? xDistance = null, long? yDistance = null, long? xOverscroll = null, long? yOverscroll = null, bool? preventFling = null, int? speed = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null, int? repeatCount = null, int? repeatDelayMs = null, string interactionMarkerName = null)
        {
            ValidateSynthesizeScrollGesture(x, y, xDistance, yDistance, xOverscroll, yOverscroll, preventFling, speed, gestureSourceType, repeatCount, repeatDelayMs, interactionMarkerName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            if (xDistance.HasValue)
            {
                dict.Add("xDistance", xDistance.Value);
            }

            if (yDistance.HasValue)
            {
                dict.Add("yDistance", yDistance.Value);
            }

            if (xOverscroll.HasValue)
            {
                dict.Add("xOverscroll", xOverscroll.Value);
            }

            if (yOverscroll.HasValue)
            {
                dict.Add("yOverscroll", yOverscroll.Value);
            }

            if (preventFling.HasValue)
            {
                dict.Add("preventFling", preventFling.Value);
            }

            if (speed.HasValue)
            {
                dict.Add("speed", speed.Value);
            }

            if (gestureSourceType.HasValue)
            {
                dict.Add("gestureSourceType", this.EnumToString(gestureSourceType));
            }

            if (repeatCount.HasValue)
            {
                dict.Add("repeatCount", repeatCount.Value);
            }

            if (repeatDelayMs.HasValue)
            {
                dict.Add("repeatDelayMs", repeatDelayMs.Value);
            }

            if (!(string.IsNullOrEmpty(interactionMarkerName)))
            {
                dict.Add("interactionMarkerName", interactionMarkerName);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.synthesizeScrollGesture", dict);
            return methodResult;
        }

        partial void ValidateSynthesizeTapGesture(long x, long y, int? duration = null, int? tapCount = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null);
        /// <summary>
        /// Synthesizes a tap gesture over a time period by issuing appropriate touch events.
        /// </summary>
        /// <param name = "x">X coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "duration">Duration between touchdown and touchup events in ms (default: 50).</param>
        /// <param name = "tapCount">Number of times to perform the tap (e.g. 2 for double tap, default: 1).</param>
        /// <param name = "gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platformfor the preferred input type).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SynthesizeTapGestureAsync(long x, long y, int? duration = null, int? tapCount = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null)
        {
            ValidateSynthesizeTapGesture(x, y, duration, tapCount, gestureSourceType);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            if (duration.HasValue)
            {
                dict.Add("duration", duration.Value);
            }

            if (tapCount.HasValue)
            {
                dict.Add("tapCount", tapCount.Value);
            }

            if (gestureSourceType.HasValue)
            {
                dict.Add("gestureSourceType", this.EnumToString(gestureSourceType));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Input.synthesizeTapGesture", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Inspector
{
    using System.Linq;

    /// <summary>
    /// Inspector
    /// </summary>
    public partial class InspectorClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public InspectorClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables inspector domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Inspector.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables inspector domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Inspector.enable", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// CompositingReasonsResponse
    /// </summary>
    public class CompositingReasonsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// compositingReasons
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("compositingReasons")]
        public string[] CompositingReasons
        {
            get;
            private set;
        }

        /// <summary>
        /// compositingReasonIds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("compositingReasonIds")]
        public string[] CompositingReasonIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// LoadSnapshotResponse
    /// </summary>
    public class LoadSnapshotResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// snapshotId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("snapshotId")]
        public string SnapshotId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// MakeSnapshotResponse
    /// </summary>
    public class MakeSnapshotResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// snapshotId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("snapshotId")]
        public string SnapshotId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// ProfileSnapshotResponse
    /// </summary>
    public class ProfileSnapshotResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// timings
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timings")]
        public long[] Timings
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// ReplaySnapshotResponse
    /// </summary>
    public class ReplaySnapshotResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// dataURL
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("dataURL")]
        public string DataURL
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// SnapshotCommandLogResponse
    /// </summary>
    public class SnapshotCommandLogResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// commandLog
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("commandLog")]
        public System.Collections.Generic.IList<object> CommandLog
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    using System.Linq;

    /// <summary>
    /// LayerTree
    /// </summary>
    public partial class LayerTreeClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public LayerTreeClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateCompositingReasons(string layerId);
        /// <summary>
        /// Provides the reasons why the given layer was composited.
        /// </summary>
        /// <param name = "layerId">The id of the layer for which we want to get the reasons it was composited.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CompositingReasonsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CompositingReasonsResponse> CompositingReasonsAsync(string layerId)
        {
            ValidateCompositingReasons(layerId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("layerId", layerId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.compositingReasons", dict);
            return methodResult.DeserializeJson<CompositingReasonsResponse>();
        }

        /// <summary>
        /// Disables compositing tree inspection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables compositing tree inspection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.enable", dict);
            return methodResult;
        }

        partial void ValidateLoadSnapshot(System.Collections.Generic.IList<CefSharp.DevTools.LayerTree.PictureTile> tiles);
        /// <summary>
        /// Returns the snapshot identifier.
        /// </summary>
        /// <param name = "tiles">An array of tiles composing the snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;LoadSnapshotResponse&gt;</returns>
        public async System.Threading.Tasks.Task<LoadSnapshotResponse> LoadSnapshotAsync(System.Collections.Generic.IList<CefSharp.DevTools.LayerTree.PictureTile> tiles)
        {
            ValidateLoadSnapshot(tiles);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("tiles", tiles.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.loadSnapshot", dict);
            return methodResult.DeserializeJson<LoadSnapshotResponse>();
        }

        partial void ValidateMakeSnapshot(string layerId);
        /// <summary>
        /// Returns the layer snapshot identifier.
        /// </summary>
        /// <param name = "layerId">The id of the layer.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;MakeSnapshotResponse&gt;</returns>
        public async System.Threading.Tasks.Task<MakeSnapshotResponse> MakeSnapshotAsync(string layerId)
        {
            ValidateMakeSnapshot(layerId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("layerId", layerId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.makeSnapshot", dict);
            return methodResult.DeserializeJson<MakeSnapshotResponse>();
        }

        partial void ValidateProfileSnapshot(string snapshotId, int? minRepeatCount = null, long? minDuration = null, CefSharp.DevTools.DOM.Rect clipRect = null);
        /// <summary>
        /// ProfileSnapshot
        /// </summary>
        /// <param name = "snapshotId">The id of the layer snapshot.</param>
        /// <param name = "minRepeatCount">The maximum number of times to replay the snapshot (1, if not specified).</param>
        /// <param name = "minDuration">The minimum duration (in seconds) to replay the snapshot.</param>
        /// <param name = "clipRect">The clip rectangle to apply when replaying the snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ProfileSnapshotResponse&gt;</returns>
        public async System.Threading.Tasks.Task<ProfileSnapshotResponse> ProfileSnapshotAsync(string snapshotId, int? minRepeatCount = null, long? minDuration = null, CefSharp.DevTools.DOM.Rect clipRect = null)
        {
            ValidateProfileSnapshot(snapshotId, minRepeatCount, minDuration, clipRect);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("snapshotId", snapshotId);
            if (minRepeatCount.HasValue)
            {
                dict.Add("minRepeatCount", minRepeatCount.Value);
            }

            if (minDuration.HasValue)
            {
                dict.Add("minDuration", minDuration.Value);
            }

            if ((clipRect) != (null))
            {
                dict.Add("clipRect", clipRect.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.profileSnapshot", dict);
            return methodResult.DeserializeJson<ProfileSnapshotResponse>();
        }

        partial void ValidateReleaseSnapshot(string snapshotId);
        /// <summary>
        /// Releases layer snapshot captured by the back-end.
        /// </summary>
        /// <param name = "snapshotId">The id of the layer snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ReleaseSnapshotAsync(string snapshotId)
        {
            ValidateReleaseSnapshot(snapshotId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("snapshotId", snapshotId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.releaseSnapshot", dict);
            return methodResult;
        }

        partial void ValidateReplaySnapshot(string snapshotId, int? fromStep = null, int? toStep = null, long? scale = null);
        /// <summary>
        /// Replays the layer snapshot and returns the resulting bitmap.
        /// </summary>
        /// <param name = "snapshotId">The id of the layer snapshot.</param>
        /// <param name = "fromStep">The first step to replay from (replay from the very start if not specified).</param>
        /// <param name = "toStep">The last step to replay to (replay till the end if not specified).</param>
        /// <param name = "scale">The scale to apply while replaying (defaults to 1).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ReplaySnapshotResponse&gt;</returns>
        public async System.Threading.Tasks.Task<ReplaySnapshotResponse> ReplaySnapshotAsync(string snapshotId, int? fromStep = null, int? toStep = null, long? scale = null)
        {
            ValidateReplaySnapshot(snapshotId, fromStep, toStep, scale);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("snapshotId", snapshotId);
            if (fromStep.HasValue)
            {
                dict.Add("fromStep", fromStep.Value);
            }

            if (toStep.HasValue)
            {
                dict.Add("toStep", toStep.Value);
            }

            if (scale.HasValue)
            {
                dict.Add("scale", scale.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.replaySnapshot", dict);
            return methodResult.DeserializeJson<ReplaySnapshotResponse>();
        }

        partial void ValidateSnapshotCommandLog(string snapshotId);
        /// <summary>
        /// Replays the layer snapshot and returns canvas log.
        /// </summary>
        /// <param name = "snapshotId">The id of the layer snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SnapshotCommandLogResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SnapshotCommandLogResponse> SnapshotCommandLogAsync(string snapshotId)
        {
            ValidateSnapshotCommandLog(snapshotId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("snapshotId", snapshotId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("LayerTree.snapshotCommandLog", dict);
            return methodResult.DeserializeJson<SnapshotCommandLogResponse>();
        }
    }
}

namespace CefSharp.DevTools.Log
{
    using System.Linq;

    /// <summary>
    /// Provides access to log entries.
    /// </summary>
    public partial class LogClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public LogClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Clears the log.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Log.clear", dict);
            return methodResult;
        }

        /// <summary>
        /// Disables log domain, prevents further log entries from being reported to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Log.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables log domain, sends the entries collected so far to the client by means of the
        /// `entryAdded` notification.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Log.enable", dict);
            return methodResult;
        }

        partial void ValidateStartViolationsReport(System.Collections.Generic.IList<CefSharp.DevTools.Log.ViolationSetting> config);
        /// <summary>
        /// start violation reporting.
        /// </summary>
        /// <param name = "config">Configuration for violations.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartViolationsReportAsync(System.Collections.Generic.IList<CefSharp.DevTools.Log.ViolationSetting> config)
        {
            ValidateStartViolationsReport(config);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("config", config.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Log.startViolationsReport", dict);
            return methodResult;
        }

        /// <summary>
        /// Stop violation reporting.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopViolationsReportAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Log.stopViolationsReport", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// GetDOMCountersResponse
    /// </summary>
    public class GetDOMCountersResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// documents
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("documents")]
        public int Documents
        {
            get;
            private set;
        }

        /// <summary>
        /// nodes
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("nodes")]
        public int Nodes
        {
            get;
            private set;
        }

        /// <summary>
        /// jsEventListeners
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("jsEventListeners")]
        public int JsEventListeners
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// GetAllTimeSamplingProfileResponse
    /// </summary>
    public class GetAllTimeSamplingProfileResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("profile")]
        public CefSharp.DevTools.Memory.SamplingProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// GetBrowserSamplingProfileResponse
    /// </summary>
    public class GetBrowserSamplingProfileResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("profile")]
        public CefSharp.DevTools.Memory.SamplingProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// GetSamplingProfileResponse
    /// </summary>
    public class GetSamplingProfileResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("profile")]
        public CefSharp.DevTools.Memory.SamplingProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    using System.Linq;

    /// <summary>
    /// Memory
    /// </summary>
    public partial class MemoryClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public MemoryClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// GetDOMCounters
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetDOMCountersResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetDOMCountersResponse> GetDOMCountersAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.getDOMCounters", dict);
            return methodResult.DeserializeJson<GetDOMCountersResponse>();
        }

        /// <summary>
        /// PrepareForLeakDetection
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> PrepareForLeakDetectionAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.prepareForLeakDetection", dict);
            return methodResult;
        }

        /// <summary>
        /// Simulate OomIntervention by purging V8 memory.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ForciblyPurgeJavaScriptMemoryAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.forciblyPurgeJavaScriptMemory", dict);
            return methodResult;
        }

        partial void ValidateSetPressureNotificationsSuppressed(bool suppressed);
        /// <summary>
        /// Enable/disable suppressing memory pressure notifications in all processes.
        /// </summary>
        /// <param name = "suppressed">If true, memory pressure notifications will be suppressed.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetPressureNotificationsSuppressedAsync(bool suppressed)
        {
            ValidateSetPressureNotificationsSuppressed(suppressed);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("suppressed", suppressed);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.setPressureNotificationsSuppressed", dict);
            return methodResult;
        }

        partial void ValidateSimulatePressureNotification(CefSharp.DevTools.Memory.PressureLevel level);
        /// <summary>
        /// Simulate a memory pressure notification in all processes.
        /// </summary>
        /// <param name = "level">Memory pressure level of the notification.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SimulatePressureNotificationAsync(CefSharp.DevTools.Memory.PressureLevel level)
        {
            ValidateSimulatePressureNotification(level);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("level", this.EnumToString(level));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.simulatePressureNotification", dict);
            return methodResult;
        }

        partial void ValidateStartSampling(int? samplingInterval = null, bool? suppressRandomness = null);
        /// <summary>
        /// Start collecting native memory profile.
        /// </summary>
        /// <param name = "samplingInterval">Average number of bytes between samples.</param>
        /// <param name = "suppressRandomness">Do not randomize intervals between samples.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartSamplingAsync(int? samplingInterval = null, bool? suppressRandomness = null)
        {
            ValidateStartSampling(samplingInterval, suppressRandomness);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (samplingInterval.HasValue)
            {
                dict.Add("samplingInterval", samplingInterval.Value);
            }

            if (suppressRandomness.HasValue)
            {
                dict.Add("suppressRandomness", suppressRandomness.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.startSampling", dict);
            return methodResult;
        }

        /// <summary>
        /// Stop collecting native memory profile.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopSamplingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.stopSampling", dict);
            return methodResult;
        }

        /// <summary>
        /// Retrieve native memory allocations profile
        /// collected since renderer process startup.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAllTimeSamplingProfileResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetAllTimeSamplingProfileResponse> GetAllTimeSamplingProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.getAllTimeSamplingProfile", dict);
            return methodResult.DeserializeJson<GetAllTimeSamplingProfileResponse>();
        }

        /// <summary>
        /// Retrieve native memory allocations profile
        /// collected since browser process startup.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBrowserSamplingProfileResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetBrowserSamplingProfileResponse> GetBrowserSamplingProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.getBrowserSamplingProfile", dict);
            return methodResult.DeserializeJson<GetBrowserSamplingProfileResponse>();
        }

        /// <summary>
        /// Retrieve native memory allocations profile collected since last
        /// `startSampling` call.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSamplingProfileResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetSamplingProfileResponse> GetSamplingProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Memory.getSamplingProfile", dict);
            return methodResult.DeserializeJson<GetSamplingProfileResponse>();
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetAllCookiesResponse
    /// </summary>
    public class GetAllCookiesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// cookies
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookies")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.Cookie> Cookies
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetCertificateResponse
    /// </summary>
    public class GetCertificateResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// tableNames
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("tableNames")]
        public string[] TableNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetCookiesResponse
    /// </summary>
    public class GetCookiesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// cookies
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookies")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.Cookie> Cookies
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetResponseBodyResponse
    /// </summary>
    public class GetResponseBodyResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// body
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("body")]
        public string Body
        {
            get;
            private set;
        }

        /// <summary>
        /// base64Encoded
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("base64Encoded")]
        public bool Base64Encoded
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetRequestPostDataResponse
    /// </summary>
    public class GetRequestPostDataResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// postData
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("postData")]
        public string PostData
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetResponseBodyForInterceptionResponse
    /// </summary>
    public class GetResponseBodyForInterceptionResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// body
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("body")]
        public string Body
        {
            get;
            private set;
        }

        /// <summary>
        /// base64Encoded
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("base64Encoded")]
        public bool Base64Encoded
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// TakeResponseBodyForInterceptionAsStreamResponse
    /// </summary>
    public class TakeResponseBodyForInterceptionAsStreamResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// stream
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stream")]
        public string Stream
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// SearchInResponseBodyResponse
    /// </summary>
    public class SearchInResponseBodyResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.SearchMatch> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// SetCookieResponse
    /// </summary>
    public class SetCookieResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// success
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("success")]
        public bool Success
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetSecurityIsolationStatusResponse
    /// </summary>
    public class GetSecurityIsolationStatusResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// status
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("status")]
        public CefSharp.DevTools.Network.SecurityIsolationStatus Status
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// LoadNetworkResourceResponse
    /// </summary>
    public class LoadNetworkResourceResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// resource
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resource")]
        public CefSharp.DevTools.Network.LoadNetworkResourcePageResult Resource
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    using System.Linq;

    /// <summary>
    /// Network domain allows tracking network activities of the page. It exposes information about http,
    /// file, data and other requests and responses, their headers, bodies, timing, etc.
    /// </summary>
    public partial class NetworkClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public NetworkClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Clears browser cache.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearBrowserCacheAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.clearBrowserCache", dict);
            return methodResult;
        }

        /// <summary>
        /// Clears browser cookies.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearBrowserCookiesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.clearBrowserCookies", dict);
            return methodResult;
        }

        partial void ValidateDeleteCookies(string name, string url = null, string domain = null, string path = null);
        /// <summary>
        /// Deletes browser cookies with matching name and url or domain/path pair.
        /// </summary>
        /// <param name = "name">Name of the cookies to remove.</param>
        /// <param name = "url">If specified, deletes all the cookies with the given name where domain and path matchprovided URL.</param>
        /// <param name = "domain">If specified, deletes only cookies with the exact domain.</param>
        /// <param name = "path">If specified, deletes only cookies with the exact path.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteCookiesAsync(string name, string url = null, string domain = null, string path = null)
        {
            ValidateDeleteCookies(name, url, domain, path);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            if (!(string.IsNullOrEmpty(url)))
            {
                dict.Add("url", url);
            }

            if (!(string.IsNullOrEmpty(domain)))
            {
                dict.Add("domain", domain);
            }

            if (!(string.IsNullOrEmpty(path)))
            {
                dict.Add("path", path);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.deleteCookies", dict);
            return methodResult;
        }

        /// <summary>
        /// Disables network tracking, prevents network events from being sent to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.disable", dict);
            return methodResult;
        }

        partial void ValidateEmulateNetworkConditions(bool offline, long latency, long downloadThroughput, long uploadThroughput, CefSharp.DevTools.Network.ConnectionType? connectionType = null);
        /// <summary>
        /// Activates emulation of network conditions.
        /// </summary>
        /// <param name = "offline">True to emulate internet disconnection.</param>
        /// <param name = "latency">Minimum latency from request sent to response headers received (ms).</param>
        /// <param name = "downloadThroughput">Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.</param>
        /// <param name = "uploadThroughput">Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.</param>
        /// <param name = "connectionType">Connection type if known.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EmulateNetworkConditionsAsync(bool offline, long latency, long downloadThroughput, long uploadThroughput, CefSharp.DevTools.Network.ConnectionType? connectionType = null)
        {
            ValidateEmulateNetworkConditions(offline, latency, downloadThroughput, uploadThroughput, connectionType);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("offline", offline);
            dict.Add("latency", latency);
            dict.Add("downloadThroughput", downloadThroughput);
            dict.Add("uploadThroughput", uploadThroughput);
            if (connectionType.HasValue)
            {
                dict.Add("connectionType", this.EnumToString(connectionType));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.emulateNetworkConditions", dict);
            return methodResult;
        }

        partial void ValidateEnable(int? maxTotalBufferSize = null, int? maxResourceBufferSize = null, int? maxPostDataSize = null);
        /// <summary>
        /// Enables network tracking, network events will now be delivered to the client.
        /// </summary>
        /// <param name = "maxTotalBufferSize">Buffer size in bytes to use when preserving network payloads (XHRs, etc).</param>
        /// <param name = "maxResourceBufferSize">Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).</param>
        /// <param name = "maxPostDataSize">Longest post body size (in bytes) that would be included in requestWillBeSent notification</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(int? maxTotalBufferSize = null, int? maxResourceBufferSize = null, int? maxPostDataSize = null)
        {
            ValidateEnable(maxTotalBufferSize, maxResourceBufferSize, maxPostDataSize);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (maxTotalBufferSize.HasValue)
            {
                dict.Add("maxTotalBufferSize", maxTotalBufferSize.Value);
            }

            if (maxResourceBufferSize.HasValue)
            {
                dict.Add("maxResourceBufferSize", maxResourceBufferSize.Value);
            }

            if (maxPostDataSize.HasValue)
            {
                dict.Add("maxPostDataSize", maxPostDataSize.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.enable", dict);
            return methodResult;
        }

        /// <summary>
        /// Returns all browser cookies. Depending on the backend support, will return detailed cookie
        /// information in the `cookies` field.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAllCookiesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetAllCookiesResponse> GetAllCookiesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.getAllCookies", dict);
            return methodResult.DeserializeJson<GetAllCookiesResponse>();
        }

        partial void ValidateGetCertificate(string origin);
        /// <summary>
        /// Returns the DER-encoded certificate.
        /// </summary>
        /// <param name = "origin">Origin to get certificate for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCertificateResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetCertificateResponse> GetCertificateAsync(string origin)
        {
            ValidateGetCertificate(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.getCertificate", dict);
            return methodResult.DeserializeJson<GetCertificateResponse>();
        }

        partial void ValidateGetCookies(string[] urls = null);
        /// <summary>
        /// Returns all browser cookies for the current URL. Depending on the backend support, will return
        /// detailed cookie information in the `cookies` field.
        /// </summary>
        /// <param name = "urls">The list of URLs for which applicable cookies will be fetched.If not specified, it's assumed to be set to the list containingthe URLs of the page and all of its subframes.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCookiesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetCookiesResponse> GetCookiesAsync(string[] urls = null)
        {
            ValidateGetCookies(urls);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((urls) != (null))
            {
                dict.Add("urls", urls);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.getCookies", dict);
            return methodResult.DeserializeJson<GetCookiesResponse>();
        }

        partial void ValidateGetResponseBody(string requestId);
        /// <summary>
        /// Returns content served for the given request.
        /// </summary>
        /// <param name = "requestId">Identifier of the network request to get content for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResponseBodyResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetResponseBodyResponse> GetResponseBodyAsync(string requestId)
        {
            ValidateGetResponseBody(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.getResponseBody", dict);
            return methodResult.DeserializeJson<GetResponseBodyResponse>();
        }

        partial void ValidateGetRequestPostData(string requestId);
        /// <summary>
        /// Returns post data sent with the request. Returns an error when no data was sent with the request.
        /// </summary>
        /// <param name = "requestId">Identifier of the network request to get content for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetRequestPostDataResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetRequestPostDataResponse> GetRequestPostDataAsync(string requestId)
        {
            ValidateGetRequestPostData(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.getRequestPostData", dict);
            return methodResult.DeserializeJson<GetRequestPostDataResponse>();
        }

        partial void ValidateGetResponseBodyForInterception(string interceptionId);
        /// <summary>
        /// Returns content served for the given currently intercepted request.
        /// </summary>
        /// <param name = "interceptionId">Identifier for the intercepted request to get body for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResponseBodyForInterceptionResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetResponseBodyForInterceptionResponse> GetResponseBodyForInterceptionAsync(string interceptionId)
        {
            ValidateGetResponseBodyForInterception(interceptionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("interceptionId", interceptionId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.getResponseBodyForInterception", dict);
            return methodResult.DeserializeJson<GetResponseBodyForInterceptionResponse>();
        }

        partial void ValidateTakeResponseBodyForInterceptionAsStream(string interceptionId);
        /// <summary>
        /// Returns a handle to the stream representing the response body. Note that after this command,
        /// the intercepted request can&apos;t be continued as is -- you either need to cancel it or to provide
        /// the response body. The stream only supports sequential read, IO.read will fail if the position
        /// is specified.
        /// </summary>
        /// <param name = "interceptionId">interceptionId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeResponseBodyForInterceptionAsStreamResponse&gt;</returns>
        public async System.Threading.Tasks.Task<TakeResponseBodyForInterceptionAsStreamResponse> TakeResponseBodyForInterceptionAsStreamAsync(string interceptionId)
        {
            ValidateTakeResponseBodyForInterceptionAsStream(interceptionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("interceptionId", interceptionId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.takeResponseBodyForInterceptionAsStream", dict);
            return methodResult.DeserializeJson<TakeResponseBodyForInterceptionAsStreamResponse>();
        }

        partial void ValidateReplayXHR(string requestId);
        /// <summary>
        /// This method sends a new XMLHttpRequest which is identical to the original one. The following
        /// parameters should be identical: method, url, async, request body, extra headers, withCredentials
        /// attribute, user, password.
        /// </summary>
        /// <param name = "requestId">Identifier of XHR to replay.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ReplayXHRAsync(string requestId)
        {
            ValidateReplayXHR(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.replayXHR", dict);
            return methodResult;
        }

        partial void ValidateSearchInResponseBody(string requestId, string query, bool? caseSensitive = null, bool? isRegex = null);
        /// <summary>
        /// Searches for given string in response content.
        /// </summary>
        /// <param name = "requestId">Identifier of the network response to search.</param>
        /// <param name = "query">String to search for.</param>
        /// <param name = "caseSensitive">If true, search is case sensitive.</param>
        /// <param name = "isRegex">If true, treats string parameter as regex.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SearchInResponseBodyResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SearchInResponseBodyResponse> SearchInResponseBodyAsync(string requestId, string query, bool? caseSensitive = null, bool? isRegex = null)
        {
            ValidateSearchInResponseBody(requestId, query, caseSensitive, isRegex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("query", query);
            if (caseSensitive.HasValue)
            {
                dict.Add("caseSensitive", caseSensitive.Value);
            }

            if (isRegex.HasValue)
            {
                dict.Add("isRegex", isRegex.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.searchInResponseBody", dict);
            return methodResult.DeserializeJson<SearchInResponseBodyResponse>();
        }

        partial void ValidateSetBlockedURLs(string[] urls);
        /// <summary>
        /// Blocks URLs from loading.
        /// </summary>
        /// <param name = "urls">URL patterns to block. Wildcards ('*') are allowed.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetBlockedURLsAsync(string[] urls)
        {
            ValidateSetBlockedURLs(urls);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("urls", urls);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setBlockedURLs", dict);
            return methodResult;
        }

        partial void ValidateSetBypassServiceWorker(bool bypass);
        /// <summary>
        /// Toggles ignoring of service worker for each request.
        /// </summary>
        /// <param name = "bypass">Bypass service worker and load from network.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetBypassServiceWorkerAsync(bool bypass)
        {
            ValidateSetBypassServiceWorker(bypass);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("bypass", bypass);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setBypassServiceWorker", dict);
            return methodResult;
        }

        partial void ValidateSetCacheDisabled(bool cacheDisabled);
        /// <summary>
        /// Toggles ignoring cache for each request. If `true`, cache will not be used.
        /// </summary>
        /// <param name = "cacheDisabled">Cache disabled state.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetCacheDisabledAsync(bool cacheDisabled)
        {
            ValidateSetCacheDisabled(cacheDisabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheDisabled", cacheDisabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setCacheDisabled", dict);
            return methodResult;
        }

        partial void ValidateSetCookie(string name, string value, string url = null, string domain = null, string path = null, bool? secure = null, bool? httpOnly = null, CefSharp.DevTools.Network.CookieSameSite? sameSite = null, long? expires = null, CefSharp.DevTools.Network.CookiePriority? priority = null);
        /// <summary>
        /// Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
        /// </summary>
        /// <param name = "name">Cookie name.</param>
        /// <param name = "value">Cookie value.</param>
        /// <param name = "url">The request-URI to associate with the setting of the cookie. This value can affect thedefault domain and path values of the created cookie.</param>
        /// <param name = "domain">Cookie domain.</param>
        /// <param name = "path">Cookie path.</param>
        /// <param name = "secure">True if cookie is secure.</param>
        /// <param name = "httpOnly">True if cookie is http-only.</param>
        /// <param name = "sameSite">Cookie SameSite type.</param>
        /// <param name = "expires">Cookie expiration date, session cookie if not set</param>
        /// <param name = "priority">Cookie Priority type.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetCookieResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetCookieResponse> SetCookieAsync(string name, string value, string url = null, string domain = null, string path = null, bool? secure = null, bool? httpOnly = null, CefSharp.DevTools.Network.CookieSameSite? sameSite = null, long? expires = null, CefSharp.DevTools.Network.CookiePriority? priority = null)
        {
            ValidateSetCookie(name, value, url, domain, path, secure, httpOnly, sameSite, expires, priority);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            dict.Add("value", value);
            if (!(string.IsNullOrEmpty(url)))
            {
                dict.Add("url", url);
            }

            if (!(string.IsNullOrEmpty(domain)))
            {
                dict.Add("domain", domain);
            }

            if (!(string.IsNullOrEmpty(path)))
            {
                dict.Add("path", path);
            }

            if (secure.HasValue)
            {
                dict.Add("secure", secure.Value);
            }

            if (httpOnly.HasValue)
            {
                dict.Add("httpOnly", httpOnly.Value);
            }

            if (sameSite.HasValue)
            {
                dict.Add("sameSite", this.EnumToString(sameSite));
            }

            if (expires.HasValue)
            {
                dict.Add("expires", expires.Value);
            }

            if (priority.HasValue)
            {
                dict.Add("priority", this.EnumToString(priority));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setCookie", dict);
            return methodResult.DeserializeJson<SetCookieResponse>();
        }

        partial void ValidateSetCookies(System.Collections.Generic.IList<CefSharp.DevTools.Network.CookieParam> cookies);
        /// <summary>
        /// Sets given cookies.
        /// </summary>
        /// <param name = "cookies">Cookies to be set.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetCookiesAsync(System.Collections.Generic.IList<CefSharp.DevTools.Network.CookieParam> cookies)
        {
            ValidateSetCookies(cookies);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cookies", cookies.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setCookies", dict);
            return methodResult;
        }

        partial void ValidateSetDataSizeLimitsForTest(int maxTotalSize, int maxResourceSize);
        /// <summary>
        /// For testing.
        /// </summary>
        /// <param name = "maxTotalSize">Maximum total buffer size.</param>
        /// <param name = "maxResourceSize">Maximum per-resource size.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDataSizeLimitsForTestAsync(int maxTotalSize, int maxResourceSize)
        {
            ValidateSetDataSizeLimitsForTest(maxTotalSize, maxResourceSize);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("maxTotalSize", maxTotalSize);
            dict.Add("maxResourceSize", maxResourceSize);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setDataSizeLimitsForTest", dict);
            return methodResult;
        }

        partial void ValidateSetExtraHTTPHeaders(CefSharp.DevTools.Network.Headers headers);
        /// <summary>
        /// Specifies whether to always send extra HTTP headers with the requests from this page.
        /// </summary>
        /// <param name = "headers">Map with extra HTTP headers.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetExtraHTTPHeadersAsync(CefSharp.DevTools.Network.Headers headers)
        {
            ValidateSetExtraHTTPHeaders(headers);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("headers", headers.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setExtraHTTPHeaders", dict);
            return methodResult;
        }

        partial void ValidateSetAttachDebugHeader(bool enabled);
        /// <summary>
        /// Specifies whether to sned a debug header to all outgoing requests.
        /// </summary>
        /// <param name = "enabled">Whether to send a debug header.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetAttachDebugHeaderAsync(bool enabled)
        {
            ValidateSetAttachDebugHeader(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setAttachDebugHeader", dict);
            return methodResult;
        }

        partial void ValidateSetUserAgentOverride(string userAgent, string acceptLanguage = null, string platform = null, CefSharp.DevTools.Emulation.UserAgentMetadata userAgentMetadata = null);
        /// <summary>
        /// Allows overriding user agent with the given string.
        /// </summary>
        /// <param name = "userAgent">User agent to use.</param>
        /// <param name = "acceptLanguage">Browser langugage to emulate.</param>
        /// <param name = "platform">The platform navigator.platform should return.</param>
        /// <param name = "userAgentMetadata">To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetUserAgentOverrideAsync(string userAgent, string acceptLanguage = null, string platform = null, CefSharp.DevTools.Emulation.UserAgentMetadata userAgentMetadata = null)
        {
            ValidateSetUserAgentOverride(userAgent, acceptLanguage, platform, userAgentMetadata);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("userAgent", userAgent);
            if (!(string.IsNullOrEmpty(acceptLanguage)))
            {
                dict.Add("acceptLanguage", acceptLanguage);
            }

            if (!(string.IsNullOrEmpty(platform)))
            {
                dict.Add("platform", platform);
            }

            if ((userAgentMetadata) != (null))
            {
                dict.Add("userAgentMetadata", userAgentMetadata.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.setUserAgentOverride", dict);
            return methodResult;
        }

        partial void ValidateGetSecurityIsolationStatus(string frameId = null);
        /// <summary>
        /// Returns information about the COEP/COOP isolation status.
        /// </summary>
        /// <param name = "frameId">If no frameId is provided, the status of the target is provided.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSecurityIsolationStatusResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetSecurityIsolationStatusResponse> GetSecurityIsolationStatusAsync(string frameId = null)
        {
            ValidateGetSecurityIsolationStatus(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(frameId)))
            {
                dict.Add("frameId", frameId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.getSecurityIsolationStatus", dict);
            return methodResult.DeserializeJson<GetSecurityIsolationStatusResponse>();
        }

        partial void ValidateLoadNetworkResource(string frameId, string url, CefSharp.DevTools.Network.LoadNetworkResourceOptions options);
        /// <summary>
        /// Fetches the resource and returns the content.
        /// </summary>
        /// <param name = "frameId">Frame id to get the resource for.</param>
        /// <param name = "url">URL of the resource to get content for.</param>
        /// <param name = "options">Options for the request.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;LoadNetworkResourceResponse&gt;</returns>
        public async System.Threading.Tasks.Task<LoadNetworkResourceResponse> LoadNetworkResourceAsync(string frameId, string url, CefSharp.DevTools.Network.LoadNetworkResourceOptions options)
        {
            ValidateLoadNetworkResource(frameId, url, options);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            dict.Add("url", url);
            dict.Add("options", options.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Network.loadNetworkResource", dict);
            return methodResult.DeserializeJson<LoadNetworkResourceResponse>();
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// GetHighlightObjectForTestResponse
    /// </summary>
    public class GetHighlightObjectForTestResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// highlight
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("highlight")]
        public object Highlight
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// GetGridHighlightObjectsForTestResponse
    /// </summary>
    public class GetGridHighlightObjectsForTestResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// highlights
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("highlights")]
        public object Highlights
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// GetSourceOrderHighlightObjectForTestResponse
    /// </summary>
    public class GetSourceOrderHighlightObjectForTestResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// highlight
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("highlight")]
        public object Highlight
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    using System.Linq;

    /// <summary>
    /// This domain provides various functionality related to drawing atop the inspected page.
    /// </summary>
    public partial class OverlayClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public OverlayClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.enable", dict);
            return methodResult;
        }

        partial void ValidateGetHighlightObjectForTest(int nodeId, bool? includeDistance = null, bool? includeStyle = null, CefSharp.DevTools.Overlay.ColorFormat? colorFormat = null, bool? showAccessibilityInfo = null);
        /// <summary>
        /// For testing.
        /// </summary>
        /// <param name = "nodeId">Id of the node to get highlight object for.</param>
        /// <param name = "includeDistance">Whether to include distance info.</param>
        /// <param name = "includeStyle">Whether to include style info.</param>
        /// <param name = "colorFormat">The color format to get config with (default: hex).</param>
        /// <param name = "showAccessibilityInfo">Whether to show accessibility info (default: true).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHighlightObjectForTestResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetHighlightObjectForTestResponse> GetHighlightObjectForTestAsync(int nodeId, bool? includeDistance = null, bool? includeStyle = null, CefSharp.DevTools.Overlay.ColorFormat? colorFormat = null, bool? showAccessibilityInfo = null)
        {
            ValidateGetHighlightObjectForTest(nodeId, includeDistance, includeStyle, colorFormat, showAccessibilityInfo);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            if (includeDistance.HasValue)
            {
                dict.Add("includeDistance", includeDistance.Value);
            }

            if (includeStyle.HasValue)
            {
                dict.Add("includeStyle", includeStyle.Value);
            }

            if (colorFormat.HasValue)
            {
                dict.Add("colorFormat", this.EnumToString(colorFormat));
            }

            if (showAccessibilityInfo.HasValue)
            {
                dict.Add("showAccessibilityInfo", showAccessibilityInfo.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.getHighlightObjectForTest", dict);
            return methodResult.DeserializeJson<GetHighlightObjectForTestResponse>();
        }

        partial void ValidateGetGridHighlightObjectsForTest(int[] nodeIds);
        /// <summary>
        /// For Persistent Grid testing.
        /// </summary>
        /// <param name = "nodeIds">Ids of the node to get highlight object for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetGridHighlightObjectsForTestResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetGridHighlightObjectsForTestResponse> GetGridHighlightObjectsForTestAsync(int[] nodeIds)
        {
            ValidateGetGridHighlightObjectsForTest(nodeIds);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeIds", nodeIds);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.getGridHighlightObjectsForTest", dict);
            return methodResult.DeserializeJson<GetGridHighlightObjectsForTestResponse>();
        }

        partial void ValidateGetSourceOrderHighlightObjectForTest(int nodeId);
        /// <summary>
        /// For Source Order Viewer testing.
        /// </summary>
        /// <param name = "nodeId">Id of the node to highlight.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSourceOrderHighlightObjectForTestResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetSourceOrderHighlightObjectForTestResponse> GetSourceOrderHighlightObjectForTestAsync(int nodeId)
        {
            ValidateGetSourceOrderHighlightObjectForTest(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.getSourceOrderHighlightObjectForTest", dict);
            return methodResult.DeserializeJson<GetSourceOrderHighlightObjectForTestResponse>();
        }

        /// <summary>
        /// Hides any highlight.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HideHighlightAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.hideHighlight", dict);
            return methodResult;
        }

        partial void ValidateHighlightFrame(string frameId, CefSharp.DevTools.DOM.RGBA contentColor = null, CefSharp.DevTools.DOM.RGBA contentOutlineColor = null);
        /// <summary>
        /// Highlights owner element of the frame with given id.
        /// </summary>
        /// <param name = "frameId">Identifier of the frame to highlight.</param>
        /// <param name = "contentColor">The content box highlight fill color (default: transparent).</param>
        /// <param name = "contentOutlineColor">The content box highlight outline color (default: transparent).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightFrameAsync(string frameId, CefSharp.DevTools.DOM.RGBA contentColor = null, CefSharp.DevTools.DOM.RGBA contentOutlineColor = null)
        {
            ValidateHighlightFrame(frameId, contentColor, contentOutlineColor);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            if ((contentColor) != (null))
            {
                dict.Add("contentColor", contentColor.ToDictionary());
            }

            if ((contentOutlineColor) != (null))
            {
                dict.Add("contentOutlineColor", contentOutlineColor.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.highlightFrame", dict);
            return methodResult;
        }

        partial void ValidateHighlightNode(CefSharp.DevTools.Overlay.HighlightConfig highlightConfig, int? nodeId = null, int? backendNodeId = null, string objectId = null, string selector = null);
        /// <summary>
        /// Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
        /// objectId must be specified.
        /// </summary>
        /// <param name = "highlightConfig">A descriptor for the highlight appearance.</param>
        /// <param name = "nodeId">Identifier of the node to highlight.</param>
        /// <param name = "backendNodeId">Identifier of the backend node to highlight.</param>
        /// <param name = "objectId">JavaScript object id of the node to be highlighted.</param>
        /// <param name = "selector">Selectors to highlight relevant nodes.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightNodeAsync(CefSharp.DevTools.Overlay.HighlightConfig highlightConfig, int? nodeId = null, int? backendNodeId = null, string objectId = null, string selector = null)
        {
            ValidateHighlightNode(highlightConfig, nodeId, backendNodeId, objectId, selector);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("highlightConfig", highlightConfig.ToDictionary());
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if (!(string.IsNullOrEmpty(selector)))
            {
                dict.Add("selector", selector);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.highlightNode", dict);
            return methodResult;
        }

        partial void ValidateHighlightQuad(long[] quad, CefSharp.DevTools.DOM.RGBA color = null, CefSharp.DevTools.DOM.RGBA outlineColor = null);
        /// <summary>
        /// Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
        /// </summary>
        /// <param name = "quad">Quad to highlight</param>
        /// <param name = "color">The highlight fill color (default: transparent).</param>
        /// <param name = "outlineColor">The highlight outline color (default: transparent).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightQuadAsync(long[] quad, CefSharp.DevTools.DOM.RGBA color = null, CefSharp.DevTools.DOM.RGBA outlineColor = null)
        {
            ValidateHighlightQuad(quad, color, outlineColor);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("quad", quad);
            if ((color) != (null))
            {
                dict.Add("color", color.ToDictionary());
            }

            if ((outlineColor) != (null))
            {
                dict.Add("outlineColor", outlineColor.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.highlightQuad", dict);
            return methodResult;
        }

        partial void ValidateHighlightRect(int x, int y, int width, int height, CefSharp.DevTools.DOM.RGBA color = null, CefSharp.DevTools.DOM.RGBA outlineColor = null);
        /// <summary>
        /// Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
        /// </summary>
        /// <param name = "x">X coordinate</param>
        /// <param name = "y">Y coordinate</param>
        /// <param name = "width">Rectangle width</param>
        /// <param name = "height">Rectangle height</param>
        /// <param name = "color">The highlight fill color (default: transparent).</param>
        /// <param name = "outlineColor">The highlight outline color (default: transparent).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightRectAsync(int x, int y, int width, int height, CefSharp.DevTools.DOM.RGBA color = null, CefSharp.DevTools.DOM.RGBA outlineColor = null)
        {
            ValidateHighlightRect(x, y, width, height, color, outlineColor);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            dict.Add("width", width);
            dict.Add("height", height);
            if ((color) != (null))
            {
                dict.Add("color", color.ToDictionary());
            }

            if ((outlineColor) != (null))
            {
                dict.Add("outlineColor", outlineColor.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.highlightRect", dict);
            return methodResult;
        }

        partial void ValidateHighlightSourceOrder(CefSharp.DevTools.Overlay.SourceOrderConfig sourceOrderConfig, int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Highlights the source order of the children of the DOM node with given id or with the given
        /// JavaScript object wrapper. Either nodeId or objectId must be specified.
        /// </summary>
        /// <param name = "sourceOrderConfig">A descriptor for the appearance of the overlay drawing.</param>
        /// <param name = "nodeId">Identifier of the node to highlight.</param>
        /// <param name = "backendNodeId">Identifier of the backend node to highlight.</param>
        /// <param name = "objectId">JavaScript object id of the node to be highlighted.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightSourceOrderAsync(CefSharp.DevTools.Overlay.SourceOrderConfig sourceOrderConfig, int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateHighlightSourceOrder(sourceOrderConfig, nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sourceOrderConfig", sourceOrderConfig.ToDictionary());
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.highlightSourceOrder", dict);
            return methodResult;
        }

        partial void ValidateSetInspectMode(CefSharp.DevTools.Overlay.InspectMode mode, CefSharp.DevTools.Overlay.HighlightConfig highlightConfig = null);
        /// <summary>
        /// Enters the &apos;inspect&apos; mode. In this mode, elements that user is hovering over are highlighted.
        /// Backend then generates &apos;inspectNodeRequested&apos; event upon element selection.
        /// </summary>
        /// <param name = "mode">Set an inspection mode.</param>
        /// <param name = "highlightConfig">A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled== false`.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetInspectModeAsync(CefSharp.DevTools.Overlay.InspectMode mode, CefSharp.DevTools.Overlay.HighlightConfig highlightConfig = null)
        {
            ValidateSetInspectMode(mode, highlightConfig);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("mode", this.EnumToString(mode));
            if ((highlightConfig) != (null))
            {
                dict.Add("highlightConfig", highlightConfig.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setInspectMode", dict);
            return methodResult;
        }

        partial void ValidateSetShowAdHighlights(bool show);
        /// <summary>
        /// Highlights owner element of all frames detected to be ads.
        /// </summary>
        /// <param name = "show">True for showing ad highlights</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowAdHighlightsAsync(bool show)
        {
            ValidateSetShowAdHighlights(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowAdHighlights", dict);
            return methodResult;
        }

        partial void ValidateSetPausedInDebuggerMessage(string message = null);
        /// <summary>
        /// SetPausedInDebuggerMessage
        /// </summary>
        /// <param name = "message">The message to display, also triggers resume and step over controls.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetPausedInDebuggerMessageAsync(string message = null)
        {
            ValidateSetPausedInDebuggerMessage(message);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(message)))
            {
                dict.Add("message", message);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setPausedInDebuggerMessage", dict);
            return methodResult;
        }

        partial void ValidateSetShowDebugBorders(bool show);
        /// <summary>
        /// Requests that backend shows debug borders on layers
        /// </summary>
        /// <param name = "show">True for showing debug borders</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowDebugBordersAsync(bool show)
        {
            ValidateSetShowDebugBorders(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowDebugBorders", dict);
            return methodResult;
        }

        partial void ValidateSetShowFPSCounter(bool show);
        /// <summary>
        /// Requests that backend shows the FPS counter
        /// </summary>
        /// <param name = "show">True for showing the FPS counter</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowFPSCounterAsync(bool show)
        {
            ValidateSetShowFPSCounter(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowFPSCounter", dict);
            return methodResult;
        }

        partial void ValidateSetShowGridOverlays(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.GridNodeHighlightConfig> gridNodeHighlightConfigs);
        /// <summary>
        /// Highlight multiple elements with the CSS Grid overlay.
        /// </summary>
        /// <param name = "gridNodeHighlightConfigs">An array of node identifiers and descriptors for the highlight appearance.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowGridOverlaysAsync(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.GridNodeHighlightConfig> gridNodeHighlightConfigs)
        {
            ValidateSetShowGridOverlays(gridNodeHighlightConfigs);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("gridNodeHighlightConfigs", gridNodeHighlightConfigs.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowGridOverlays", dict);
            return methodResult;
        }

        partial void ValidateSetShowPaintRects(bool result);
        /// <summary>
        /// Requests that backend shows paint rectangles
        /// </summary>
        /// <param name = "result">True for showing paint rectangles</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowPaintRectsAsync(bool result)
        {
            ValidateSetShowPaintRects(result);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("result", result);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowPaintRects", dict);
            return methodResult;
        }

        partial void ValidateSetShowLayoutShiftRegions(bool result);
        /// <summary>
        /// Requests that backend shows layout shift regions
        /// </summary>
        /// <param name = "result">True for showing layout shift regions</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowLayoutShiftRegionsAsync(bool result)
        {
            ValidateSetShowLayoutShiftRegions(result);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("result", result);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowLayoutShiftRegions", dict);
            return methodResult;
        }

        partial void ValidateSetShowScrollBottleneckRects(bool show);
        /// <summary>
        /// Requests that backend shows scroll bottleneck rects
        /// </summary>
        /// <param name = "show">True for showing scroll bottleneck rects</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowScrollBottleneckRectsAsync(bool show)
        {
            ValidateSetShowScrollBottleneckRects(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowScrollBottleneckRects", dict);
            return methodResult;
        }

        partial void ValidateSetShowHitTestBorders(bool show);
        /// <summary>
        /// Requests that backend shows hit-test borders on layers
        /// </summary>
        /// <param name = "show">True for showing hit-test borders</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowHitTestBordersAsync(bool show)
        {
            ValidateSetShowHitTestBorders(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowHitTestBorders", dict);
            return methodResult;
        }

        partial void ValidateSetShowViewportSizeOnResize(bool show);
        /// <summary>
        /// Paints viewport size upon main frame resize.
        /// </summary>
        /// <param name = "show">Whether to paint size or not.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowViewportSizeOnResizeAsync(bool show)
        {
            ValidateSetShowViewportSizeOnResize(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowViewportSizeOnResize", dict);
            return methodResult;
        }

        partial void ValidateSetShowHinge(CefSharp.DevTools.Overlay.HingeConfig hingeConfig = null);
        /// <summary>
        /// Add a dual screen device hinge
        /// </summary>
        /// <param name = "hingeConfig">hinge data, null means hideHinge</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowHingeAsync(CefSharp.DevTools.Overlay.HingeConfig hingeConfig = null)
        {
            ValidateSetShowHinge(hingeConfig);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((hingeConfig) != (null))
            {
                dict.Add("hingeConfig", hingeConfig.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Overlay.setShowHinge", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// AddScriptToEvaluateOnNewDocumentResponse
    /// </summary>
    public class AddScriptToEvaluateOnNewDocumentResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// identifier
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("identifier")]
        public string Identifier
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// CaptureScreenshotResponse
    /// </summary>
    public class CaptureScreenshotResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// data
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("data")]
        public byte[] Data
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// CaptureSnapshotResponse
    /// </summary>
    public class CaptureSnapshotResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// data
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("data")]
        public string Data
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// CreateIsolatedWorldResponse
    /// </summary>
    public class CreateIsolatedWorldResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// executionContextId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("executionContextId")]
        public int ExecutionContextId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetAppManifestResponse
    /// </summary>
    public class GetAppManifestResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// url
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("url")]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// errors
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errors")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.AppManifestError> Errors
        {
            get;
            private set;
        }

        /// <summary>
        /// data
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("data")]
        public string Data
        {
            get;
            private set;
        }

        /// <summary>
        /// parsed
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("parsed")]
        public CefSharp.DevTools.Page.AppManifestParsedProperties Parsed
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetInstallabilityErrorsResponse
    /// </summary>
    public class GetInstallabilityErrorsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// installabilityErrors
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("installabilityErrors")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.InstallabilityError> InstallabilityErrors
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetManifestIconsResponse
    /// </summary>
    public class GetManifestIconsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// primaryIcon
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("primaryIcon")]
        public byte[] PrimaryIcon
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetFrameTreeResponse
    /// </summary>
    public class GetFrameTreeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// frameTree
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameTree")]
        public CefSharp.DevTools.Page.FrameTree FrameTree
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetLayoutMetricsResponse
    /// </summary>
    public class GetLayoutMetricsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// layoutViewport
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("layoutViewport")]
        public CefSharp.DevTools.Page.LayoutViewport LayoutViewport
        {
            get;
            private set;
        }

        /// <summary>
        /// visualViewport
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("visualViewport")]
        public CefSharp.DevTools.Page.VisualViewport VisualViewport
        {
            get;
            private set;
        }

        /// <summary>
        /// contentSize
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("contentSize")]
        public CefSharp.DevTools.DOM.Rect ContentSize
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetNavigationHistoryResponse
    /// </summary>
    public class GetNavigationHistoryResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// currentIndex
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("currentIndex")]
        public int CurrentIndex
        {
            get;
            private set;
        }

        /// <summary>
        /// entries
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("entries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.NavigationEntry> Entries
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetResourceContentResponse
    /// </summary>
    public class GetResourceContentResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// content
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("content")]
        public string Content
        {
            get;
            private set;
        }

        /// <summary>
        /// base64Encoded
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("base64Encoded")]
        public bool Base64Encoded
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetResourceTreeResponse
    /// </summary>
    public class GetResourceTreeResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// frameTree
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameTree")]
        public CefSharp.DevTools.Page.FrameResourceTree FrameTree
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// NavigateResponse
    /// </summary>
    public class NavigateResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// frameId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("frameId")]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// loaderId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("loaderId")]
        public string LoaderId
        {
            get;
            private set;
        }

        /// <summary>
        /// errorText
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("errorText")]
        public string ErrorText
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// PrintToPDFResponse
    /// </summary>
    public class PrintToPDFResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// data
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("data")]
        public byte[] Data
        {
            get;
            private set;
        }

        /// <summary>
        /// stream
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stream")]
        public string Stream
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// SearchInResourceResponse
    /// </summary>
    public class SearchInResourceResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.SearchMatch> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    using System.Linq;

    /// <summary>
    /// Actions and events related to the inspected page belong to the page domain.
    /// </summary>
    public partial class PageClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public PageClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateAddScriptToEvaluateOnNewDocument(string source, string worldName = null);
        /// <summary>
        /// Evaluates given script in every frame upon creation (before loading frame&apos;s scripts).
        /// </summary>
        /// <param name = "source">source</param>
        /// <param name = "worldName">If specified, creates an isolated world with the given name and evaluates given script in it.This world name will be used as the ExecutionContextDescription::name when the correspondingevent is emitted.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AddScriptToEvaluateOnNewDocumentResponse&gt;</returns>
        public async System.Threading.Tasks.Task<AddScriptToEvaluateOnNewDocumentResponse> AddScriptToEvaluateOnNewDocumentAsync(string source, string worldName = null)
        {
            ValidateAddScriptToEvaluateOnNewDocument(source, worldName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("source", source);
            if (!(string.IsNullOrEmpty(worldName)))
            {
                dict.Add("worldName", worldName);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.addScriptToEvaluateOnNewDocument", dict);
            return methodResult.DeserializeJson<AddScriptToEvaluateOnNewDocumentResponse>();
        }

        /// <summary>
        /// Brings page to front (activates tab).
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> BringToFrontAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.bringToFront", dict);
            return methodResult;
        }

        partial void ValidateCaptureScreenshot(string format = null, int? quality = null, CefSharp.DevTools.Page.Viewport clip = null, bool? fromSurface = null);
        /// <summary>
        /// Capture page screenshot.
        /// </summary>
        /// <param name = "format">Image compression format (defaults to png).</param>
        /// <param name = "quality">Compression quality from range [0..100] (jpeg only).</param>
        /// <param name = "clip">Capture the screenshot of a given region only.</param>
        /// <param name = "fromSurface">Capture the screenshot from the surface, rather than the view. Defaults to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CaptureScreenshotResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CaptureScreenshotResponse> CaptureScreenshotAsync(string format = null, int? quality = null, CefSharp.DevTools.Page.Viewport clip = null, bool? fromSurface = null)
        {
            ValidateCaptureScreenshot(format, quality, clip, fromSurface);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(format)))
            {
                dict.Add("format", format);
            }

            if (quality.HasValue)
            {
                dict.Add("quality", quality.Value);
            }

            if ((clip) != (null))
            {
                dict.Add("clip", clip.ToDictionary());
            }

            if (fromSurface.HasValue)
            {
                dict.Add("fromSurface", fromSurface.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.captureScreenshot", dict);
            return methodResult.DeserializeJson<CaptureScreenshotResponse>();
        }

        partial void ValidateCaptureSnapshot(string format = null);
        /// <summary>
        /// Returns a snapshot of the page as a string. For MHTML format, the serialization includes
        /// iframes, shadow DOM, external resources, and element-inline styles.
        /// </summary>
        /// <param name = "format">Format (defaults to mhtml).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CaptureSnapshotResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CaptureSnapshotResponse> CaptureSnapshotAsync(string format = null)
        {
            ValidateCaptureSnapshot(format);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(format)))
            {
                dict.Add("format", format);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.captureSnapshot", dict);
            return methodResult.DeserializeJson<CaptureSnapshotResponse>();
        }

        partial void ValidateCreateIsolatedWorld(string frameId, string worldName = null, bool? grantUniveralAccess = null);
        /// <summary>
        /// Creates an isolated world for the given frame.
        /// </summary>
        /// <param name = "frameId">Id of the frame in which the isolated world should be created.</param>
        /// <param name = "worldName">An optional name which is reported in the Execution Context.</param>
        /// <param name = "grantUniveralAccess">Whether or not universal access should be granted to the isolated world. This is a powerfuloption, use with caution.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CreateIsolatedWorldResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CreateIsolatedWorldResponse> CreateIsolatedWorldAsync(string frameId, string worldName = null, bool? grantUniveralAccess = null)
        {
            ValidateCreateIsolatedWorld(frameId, worldName, grantUniveralAccess);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            if (!(string.IsNullOrEmpty(worldName)))
            {
                dict.Add("worldName", worldName);
            }

            if (grantUniveralAccess.HasValue)
            {
                dict.Add("grantUniveralAccess", grantUniveralAccess.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.createIsolatedWorld", dict);
            return methodResult.DeserializeJson<CreateIsolatedWorldResponse>();
        }

        /// <summary>
        /// Disables page domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables page domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.enable", dict);
            return methodResult;
        }

        /// <summary>
        /// GetAppManifest
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAppManifestResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetAppManifestResponse> GetAppManifestAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.getAppManifest", dict);
            return methodResult.DeserializeJson<GetAppManifestResponse>();
        }

        /// <summary>
        /// GetInstallabilityErrors
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetInstallabilityErrorsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetInstallabilityErrorsResponse> GetInstallabilityErrorsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.getInstallabilityErrors", dict);
            return methodResult.DeserializeJson<GetInstallabilityErrorsResponse>();
        }

        /// <summary>
        /// GetManifestIcons
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetManifestIconsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetManifestIconsResponse> GetManifestIconsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.getManifestIcons", dict);
            return methodResult.DeserializeJson<GetManifestIconsResponse>();
        }

        /// <summary>
        /// Returns present frame tree structure.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFrameTreeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetFrameTreeResponse> GetFrameTreeAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.getFrameTree", dict);
            return methodResult.DeserializeJson<GetFrameTreeResponse>();
        }

        /// <summary>
        /// Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetLayoutMetricsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetLayoutMetricsResponse> GetLayoutMetricsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.getLayoutMetrics", dict);
            return methodResult.DeserializeJson<GetLayoutMetricsResponse>();
        }

        /// <summary>
        /// Returns navigation history for the current page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetNavigationHistoryResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetNavigationHistoryResponse> GetNavigationHistoryAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.getNavigationHistory", dict);
            return methodResult.DeserializeJson<GetNavigationHistoryResponse>();
        }

        /// <summary>
        /// Resets navigation history for the current page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ResetNavigationHistoryAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.resetNavigationHistory", dict);
            return methodResult;
        }

        partial void ValidateGetResourceContent(string frameId, string url);
        /// <summary>
        /// Returns content of the given resource.
        /// </summary>
        /// <param name = "frameId">Frame id to get resource for.</param>
        /// <param name = "url">URL of the resource to get content for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResourceContentResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetResourceContentResponse> GetResourceContentAsync(string frameId, string url)
        {
            ValidateGetResourceContent(frameId, url);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            dict.Add("url", url);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.getResourceContent", dict);
            return methodResult.DeserializeJson<GetResourceContentResponse>();
        }

        /// <summary>
        /// Returns present frame / resource tree structure.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResourceTreeResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetResourceTreeResponse> GetResourceTreeAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.getResourceTree", dict);
            return methodResult.DeserializeJson<GetResourceTreeResponse>();
        }

        partial void ValidateHandleJavaScriptDialog(bool accept, string promptText = null);
        /// <summary>
        /// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
        /// </summary>
        /// <param name = "accept">Whether to accept or dismiss the dialog.</param>
        /// <param name = "promptText">The text to enter into the dialog prompt before accepting. Used only if this is a promptdialog.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> HandleJavaScriptDialogAsync(bool accept, string promptText = null)
        {
            ValidateHandleJavaScriptDialog(accept, promptText);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("accept", accept);
            if (!(string.IsNullOrEmpty(promptText)))
            {
                dict.Add("promptText", promptText);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.handleJavaScriptDialog", dict);
            return methodResult;
        }

        partial void ValidateNavigate(string url, string referrer = null, CefSharp.DevTools.Page.TransitionType? transitionType = null, string frameId = null, CefSharp.DevTools.Page.ReferrerPolicy? referrerPolicy = null);
        /// <summary>
        /// Navigates current page to the given URL.
        /// </summary>
        /// <param name = "url">URL to navigate the page to.</param>
        /// <param name = "referrer">Referrer URL.</param>
        /// <param name = "transitionType">Intended transition type.</param>
        /// <param name = "frameId">Frame id to navigate, if not specified navigates the top frame.</param>
        /// <param name = "referrerPolicy">Referrer-policy used for the navigation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;NavigateResponse&gt;</returns>
        public async System.Threading.Tasks.Task<NavigateResponse> NavigateAsync(string url, string referrer = null, CefSharp.DevTools.Page.TransitionType? transitionType = null, string frameId = null, CefSharp.DevTools.Page.ReferrerPolicy? referrerPolicy = null)
        {
            ValidateNavigate(url, referrer, transitionType, frameId, referrerPolicy);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            if (!(string.IsNullOrEmpty(referrer)))
            {
                dict.Add("referrer", referrer);
            }

            if (transitionType.HasValue)
            {
                dict.Add("transitionType", this.EnumToString(transitionType));
            }

            if (!(string.IsNullOrEmpty(frameId)))
            {
                dict.Add("frameId", frameId);
            }

            if (referrerPolicy.HasValue)
            {
                dict.Add("referrerPolicy", this.EnumToString(referrerPolicy));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.navigate", dict);
            return methodResult.DeserializeJson<NavigateResponse>();
        }

        partial void ValidateNavigateToHistoryEntry(int entryId);
        /// <summary>
        /// Navigates current page to the given history entry.
        /// </summary>
        /// <param name = "entryId">Unique id of the entry to navigate to.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> NavigateToHistoryEntryAsync(int entryId)
        {
            ValidateNavigateToHistoryEntry(entryId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("entryId", entryId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.navigateToHistoryEntry", dict);
            return methodResult;
        }

        partial void ValidatePrintToPDF(bool? landscape = null, bool? displayHeaderFooter = null, bool? printBackground = null, long? scale = null, long? paperWidth = null, long? paperHeight = null, long? marginTop = null, long? marginBottom = null, long? marginLeft = null, long? marginRight = null, string pageRanges = null, bool? ignoreInvalidPageRanges = null, string headerTemplate = null, string footerTemplate = null, bool? preferCSSPageSize = null, string transferMode = null);
        /// <summary>
        /// Print page as PDF.
        /// </summary>
        /// <param name = "landscape">Paper orientation. Defaults to false.</param>
        /// <param name = "displayHeaderFooter">Display header and footer. Defaults to false.</param>
        /// <param name = "printBackground">Print background graphics. Defaults to false.</param>
        /// <param name = "scale">Scale of the webpage rendering. Defaults to 1.</param>
        /// <param name = "paperWidth">Paper width in inches. Defaults to 8.5 inches.</param>
        /// <param name = "paperHeight">Paper height in inches. Defaults to 11 inches.</param>
        /// <param name = "marginTop">Top margin in inches. Defaults to 1cm (~0.4 inches).</param>
        /// <param name = "marginBottom">Bottom margin in inches. Defaults to 1cm (~0.4 inches).</param>
        /// <param name = "marginLeft">Left margin in inches. Defaults to 1cm (~0.4 inches).</param>
        /// <param name = "marginRight">Right margin in inches. Defaults to 1cm (~0.4 inches).</param>
        /// <param name = "pageRanges">Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which meansprint all pages.</param>
        /// <param name = "ignoreInvalidPageRanges">Whether to silently ignore invalid but successfully parsed page ranges, such as '3-2'.Defaults to false.</param>
        /// <param name = "headerTemplate">HTML template for the print header. Should be valid HTML markup with followingclasses used to inject printing values into them:- `date`: formatted print date- `title`: document title- `url`: document location- `pageNumber`: current page number- `totalPages`: total pages in the documentFor example, `&lt;span class=title&gt; &lt;/span&gt;` would generate span containing the title.</param>
        /// <param name = "footerTemplate">HTML template for the print footer. Should use the same format as the `headerTemplate`.</param>
        /// <param name = "preferCSSPageSize">Whether or not to prefer page size as defined by css. Defaults to false,in which case the content will be scaled to fit the paper size.</param>
        /// <param name = "transferMode">return as stream</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;PrintToPDFResponse&gt;</returns>
        public async System.Threading.Tasks.Task<PrintToPDFResponse> PrintToPDFAsync(bool? landscape = null, bool? displayHeaderFooter = null, bool? printBackground = null, long? scale = null, long? paperWidth = null, long? paperHeight = null, long? marginTop = null, long? marginBottom = null, long? marginLeft = null, long? marginRight = null, string pageRanges = null, bool? ignoreInvalidPageRanges = null, string headerTemplate = null, string footerTemplate = null, bool? preferCSSPageSize = null, string transferMode = null)
        {
            ValidatePrintToPDF(landscape, displayHeaderFooter, printBackground, scale, paperWidth, paperHeight, marginTop, marginBottom, marginLeft, marginRight, pageRanges, ignoreInvalidPageRanges, headerTemplate, footerTemplate, preferCSSPageSize, transferMode);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (landscape.HasValue)
            {
                dict.Add("landscape", landscape.Value);
            }

            if (displayHeaderFooter.HasValue)
            {
                dict.Add("displayHeaderFooter", displayHeaderFooter.Value);
            }

            if (printBackground.HasValue)
            {
                dict.Add("printBackground", printBackground.Value);
            }

            if (scale.HasValue)
            {
                dict.Add("scale", scale.Value);
            }

            if (paperWidth.HasValue)
            {
                dict.Add("paperWidth", paperWidth.Value);
            }

            if (paperHeight.HasValue)
            {
                dict.Add("paperHeight", paperHeight.Value);
            }

            if (marginTop.HasValue)
            {
                dict.Add("marginTop", marginTop.Value);
            }

            if (marginBottom.HasValue)
            {
                dict.Add("marginBottom", marginBottom.Value);
            }

            if (marginLeft.HasValue)
            {
                dict.Add("marginLeft", marginLeft.Value);
            }

            if (marginRight.HasValue)
            {
                dict.Add("marginRight", marginRight.Value);
            }

            if (!(string.IsNullOrEmpty(pageRanges)))
            {
                dict.Add("pageRanges", pageRanges);
            }

            if (ignoreInvalidPageRanges.HasValue)
            {
                dict.Add("ignoreInvalidPageRanges", ignoreInvalidPageRanges.Value);
            }

            if (!(string.IsNullOrEmpty(headerTemplate)))
            {
                dict.Add("headerTemplate", headerTemplate);
            }

            if (!(string.IsNullOrEmpty(footerTemplate)))
            {
                dict.Add("footerTemplate", footerTemplate);
            }

            if (preferCSSPageSize.HasValue)
            {
                dict.Add("preferCSSPageSize", preferCSSPageSize.Value);
            }

            if (!(string.IsNullOrEmpty(transferMode)))
            {
                dict.Add("transferMode", transferMode);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.printToPDF", dict);
            return methodResult.DeserializeJson<PrintToPDFResponse>();
        }

        partial void ValidateReload(bool? ignoreCache = null, string scriptToEvaluateOnLoad = null);
        /// <summary>
        /// Reloads given page optionally ignoring the cache.
        /// </summary>
        /// <param name = "ignoreCache">If true, browser cache is ignored (as if the user pressed Shift+refresh).</param>
        /// <param name = "scriptToEvaluateOnLoad">If set, the script will be injected into all frames of the inspected page after reload.Argument will be ignored if reloading dataURL origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ReloadAsync(bool? ignoreCache = null, string scriptToEvaluateOnLoad = null)
        {
            ValidateReload(ignoreCache, scriptToEvaluateOnLoad);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (ignoreCache.HasValue)
            {
                dict.Add("ignoreCache", ignoreCache.Value);
            }

            if (!(string.IsNullOrEmpty(scriptToEvaluateOnLoad)))
            {
                dict.Add("scriptToEvaluateOnLoad", scriptToEvaluateOnLoad);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.reload", dict);
            return methodResult;
        }

        partial void ValidateRemoveScriptToEvaluateOnNewDocument(string identifier);
        /// <summary>
        /// Removes given script from the list.
        /// </summary>
        /// <param name = "identifier">identifier</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveScriptToEvaluateOnNewDocumentAsync(string identifier)
        {
            ValidateRemoveScriptToEvaluateOnNewDocument(identifier);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("identifier", identifier);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.removeScriptToEvaluateOnNewDocument", dict);
            return methodResult;
        }

        partial void ValidateScreencastFrameAck(int sessionId);
        /// <summary>
        /// Acknowledges that a screencast frame has been received by the frontend.
        /// </summary>
        /// <param name = "sessionId">Frame number.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ScreencastFrameAckAsync(int sessionId)
        {
            ValidateScreencastFrameAck(sessionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sessionId", sessionId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.screencastFrameAck", dict);
            return methodResult;
        }

        partial void ValidateSearchInResource(string frameId, string url, string query, bool? caseSensitive = null, bool? isRegex = null);
        /// <summary>
        /// Searches for given string in resource content.
        /// </summary>
        /// <param name = "frameId">Frame id for resource to search in.</param>
        /// <param name = "url">URL of the resource to search in.</param>
        /// <param name = "query">String to search for.</param>
        /// <param name = "caseSensitive">If true, search is case sensitive.</param>
        /// <param name = "isRegex">If true, treats string parameter as regex.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SearchInResourceResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SearchInResourceResponse> SearchInResourceAsync(string frameId, string url, string query, bool? caseSensitive = null, bool? isRegex = null)
        {
            ValidateSearchInResource(frameId, url, query, caseSensitive, isRegex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            dict.Add("url", url);
            dict.Add("query", query);
            if (caseSensitive.HasValue)
            {
                dict.Add("caseSensitive", caseSensitive.Value);
            }

            if (isRegex.HasValue)
            {
                dict.Add("isRegex", isRegex.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.searchInResource", dict);
            return methodResult.DeserializeJson<SearchInResourceResponse>();
        }

        partial void ValidateSetAdBlockingEnabled(bool enabled);
        /// <summary>
        /// Enable Chrome&apos;s experimental ad filter on all sites.
        /// </summary>
        /// <param name = "enabled">Whether to block ads.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetAdBlockingEnabledAsync(bool enabled)
        {
            ValidateSetAdBlockingEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setAdBlockingEnabled", dict);
            return methodResult;
        }

        partial void ValidateSetBypassCSP(bool enabled);
        /// <summary>
        /// Enable page Content Security Policy by-passing.
        /// </summary>
        /// <param name = "enabled">Whether to bypass page CSP.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetBypassCSPAsync(bool enabled)
        {
            ValidateSetBypassCSP(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setBypassCSP", dict);
            return methodResult;
        }

        partial void ValidateSetFontFamilies(CefSharp.DevTools.Page.FontFamilies fontFamilies);
        /// <summary>
        /// Set generic font families.
        /// </summary>
        /// <param name = "fontFamilies">Specifies font families to set. If a font family is not specified, it won't be changed.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetFontFamiliesAsync(CefSharp.DevTools.Page.FontFamilies fontFamilies)
        {
            ValidateSetFontFamilies(fontFamilies);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("fontFamilies", fontFamilies.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setFontFamilies", dict);
            return methodResult;
        }

        partial void ValidateSetFontSizes(CefSharp.DevTools.Page.FontSizes fontSizes);
        /// <summary>
        /// Set default font sizes.
        /// </summary>
        /// <param name = "fontSizes">Specifies font sizes to set. If a font size is not specified, it won't be changed.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetFontSizesAsync(CefSharp.DevTools.Page.FontSizes fontSizes)
        {
            ValidateSetFontSizes(fontSizes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("fontSizes", fontSizes.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setFontSizes", dict);
            return methodResult;
        }

        partial void ValidateSetDocumentContent(string frameId, string html);
        /// <summary>
        /// Sets given markup as the document&apos;s HTML.
        /// </summary>
        /// <param name = "frameId">Frame id to set HTML for.</param>
        /// <param name = "html">HTML content to set.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDocumentContentAsync(string frameId, string html)
        {
            ValidateSetDocumentContent(frameId, html);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            dict.Add("html", html);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setDocumentContent", dict);
            return methodResult;
        }

        partial void ValidateSetLifecycleEventsEnabled(bool enabled);
        /// <summary>
        /// Controls whether page will emit lifecycle events.
        /// </summary>
        /// <param name = "enabled">If true, starts emitting lifecycle events.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetLifecycleEventsEnabledAsync(bool enabled)
        {
            ValidateSetLifecycleEventsEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setLifecycleEventsEnabled", dict);
            return methodResult;
        }

        partial void ValidateStartScreencast(string format = null, int? quality = null, int? maxWidth = null, int? maxHeight = null, int? everyNthFrame = null);
        /// <summary>
        /// Starts sending each frame using the `screencastFrame` event.
        /// </summary>
        /// <param name = "format">Image compression format.</param>
        /// <param name = "quality">Compression quality from range [0..100].</param>
        /// <param name = "maxWidth">Maximum screenshot width.</param>
        /// <param name = "maxHeight">Maximum screenshot height.</param>
        /// <param name = "everyNthFrame">Send every n-th frame.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartScreencastAsync(string format = null, int? quality = null, int? maxWidth = null, int? maxHeight = null, int? everyNthFrame = null)
        {
            ValidateStartScreencast(format, quality, maxWidth, maxHeight, everyNthFrame);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(format)))
            {
                dict.Add("format", format);
            }

            if (quality.HasValue)
            {
                dict.Add("quality", quality.Value);
            }

            if (maxWidth.HasValue)
            {
                dict.Add("maxWidth", maxWidth.Value);
            }

            if (maxHeight.HasValue)
            {
                dict.Add("maxHeight", maxHeight.Value);
            }

            if (everyNthFrame.HasValue)
            {
                dict.Add("everyNthFrame", everyNthFrame.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.startScreencast", dict);
            return methodResult;
        }

        /// <summary>
        /// Force the page stop all navigations and pending resource fetches.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopLoadingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.stopLoading", dict);
            return methodResult;
        }

        /// <summary>
        /// Crashes renderer on the IO thread, generates minidumps.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> CrashAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.crash", dict);
            return methodResult;
        }

        /// <summary>
        /// Tries to close page, running its beforeunload hooks, if any.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> CloseAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.close", dict);
            return methodResult;
        }

        partial void ValidateSetWebLifecycleState(string state);
        /// <summary>
        /// Tries to update the web lifecycle state of the page.
        /// It will transition the page to the given state according to:
        /// https://github.com/WICG/web-lifecycle/
        /// </summary>
        /// <param name = "state">Target lifecycle state</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetWebLifecycleStateAsync(string state)
        {
            ValidateSetWebLifecycleState(state);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("state", state);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setWebLifecycleState", dict);
            return methodResult;
        }

        /// <summary>
        /// Stops sending each frame in the `screencastFrame`.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopScreencastAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.stopScreencast", dict);
            return methodResult;
        }

        partial void ValidateSetProduceCompilationCache(bool enabled);
        /// <summary>
        /// Forces compilation cache to be generated for every subresource script.
        /// </summary>
        /// <param name = "enabled">enabled</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetProduceCompilationCacheAsync(bool enabled)
        {
            ValidateSetProduceCompilationCache(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setProduceCompilationCache", dict);
            return methodResult;
        }

        partial void ValidateAddCompilationCache(string url, byte[] data);
        /// <summary>
        /// Seeds compilation cache for given url. Compilation cache does not survive
        /// cross-process navigation.
        /// </summary>
        /// <param name = "url">url</param>
        /// <param name = "data">Base64-encoded data</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> AddCompilationCacheAsync(string url, byte[] data)
        {
            ValidateAddCompilationCache(url, data);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            dict.Add("data", ToBase64String(data));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.addCompilationCache", dict);
            return methodResult;
        }

        /// <summary>
        /// Clears seeded compilation cache.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearCompilationCacheAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.clearCompilationCache", dict);
            return methodResult;
        }

        partial void ValidateGenerateTestReport(string message, string group = null);
        /// <summary>
        /// Generates a report for testing.
        /// </summary>
        /// <param name = "message">Message to be displayed in the report.</param>
        /// <param name = "group">Specifies the endpoint group to deliver the report to.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> GenerateTestReportAsync(string message, string group = null)
        {
            ValidateGenerateTestReport(message, group);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("message", message);
            if (!(string.IsNullOrEmpty(group)))
            {
                dict.Add("group", group);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.generateTestReport", dict);
            return methodResult;
        }

        /// <summary>
        /// Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> WaitForDebuggerAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.waitForDebugger", dict);
            return methodResult;
        }

        partial void ValidateSetInterceptFileChooserDialog(bool enabled);
        /// <summary>
        /// Intercept file chooser requests and transfer control to protocol clients.
        /// When file chooser interception is enabled, native file chooser dialog is not shown.
        /// Instead, a protocol event `Page.fileChooserOpened` is emitted.
        /// </summary>
        /// <param name = "enabled">enabled</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetInterceptFileChooserDialogAsync(bool enabled)
        {
            ValidateSetInterceptFileChooserDialog(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Page.setInterceptFileChooserDialog", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Performance
{
    /// <summary>
    /// GetMetricsResponse
    /// </summary>
    public class GetMetricsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// metrics
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("metrics")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Performance.Metric> Metrics
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Performance
{
    using System.Linq;

    /// <summary>
    /// Performance
    /// </summary>
    public partial class PerformanceClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public PerformanceClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disable collecting and reporting metrics.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Performance.disable", dict);
            return methodResult;
        }

        partial void ValidateEnable(string timeDomain = null);
        /// <summary>
        /// Enable collecting and reporting metrics.
        /// </summary>
        /// <param name = "timeDomain">Time domain to use for collecting and reporting duration metrics.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(string timeDomain = null)
        {
            ValidateEnable(timeDomain);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(timeDomain)))
            {
                dict.Add("timeDomain", timeDomain);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Performance.enable", dict);
            return methodResult;
        }

        /// <summary>
        /// Retrieve current values of run-time metrics.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetMetricsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetMetricsResponse> GetMetricsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Performance.getMetrics", dict);
            return methodResult.DeserializeJson<GetMetricsResponse>();
        }
    }
}

namespace CefSharp.DevTools.Security
{
    using System.Linq;

    /// <summary>
    /// Security
    /// </summary>
    public partial class SecurityClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public SecurityClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables tracking security state changes.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Security.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables tracking security state changes.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Security.enable", dict);
            return methodResult;
        }

        partial void ValidateSetIgnoreCertificateErrors(bool ignore);
        /// <summary>
        /// Enable/disable whether all certificate errors should be ignored.
        /// </summary>
        /// <param name = "ignore">If true, all certificate errors will be ignored.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetIgnoreCertificateErrorsAsync(bool ignore)
        {
            ValidateSetIgnoreCertificateErrors(ignore);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ignore", ignore);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Security.setIgnoreCertificateErrors", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.ServiceWorker
{
    using System.Linq;

    /// <summary>
    /// ServiceWorker
    /// </summary>
    public partial class ServiceWorkerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public ServiceWorkerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateDeliverPushMessage(string origin, string registrationId, string data);
        /// <summary>
        /// DeliverPushMessage
        /// </summary>
        /// <param name = "origin">origin</param>
        /// <param name = "registrationId">registrationId</param>
        /// <param name = "data">data</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DeliverPushMessageAsync(string origin, string registrationId, string data)
        {
            ValidateDeliverPushMessage(origin, registrationId, data);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            dict.Add("registrationId", registrationId);
            dict.Add("data", data);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.deliverPushMessage", dict);
            return methodResult;
        }

        /// <summary>
        /// Disable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.disable", dict);
            return methodResult;
        }

        partial void ValidateDispatchSyncEvent(string origin, string registrationId, string tag, bool lastChance);
        /// <summary>
        /// DispatchSyncEvent
        /// </summary>
        /// <param name = "origin">origin</param>
        /// <param name = "registrationId">registrationId</param>
        /// <param name = "tag">tag</param>
        /// <param name = "lastChance">lastChance</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchSyncEventAsync(string origin, string registrationId, string tag, bool lastChance)
        {
            ValidateDispatchSyncEvent(origin, registrationId, tag, lastChance);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            dict.Add("registrationId", registrationId);
            dict.Add("tag", tag);
            dict.Add("lastChance", lastChance);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.dispatchSyncEvent", dict);
            return methodResult;
        }

        partial void ValidateDispatchPeriodicSyncEvent(string origin, string registrationId, string tag);
        /// <summary>
        /// DispatchPeriodicSyncEvent
        /// </summary>
        /// <param name = "origin">origin</param>
        /// <param name = "registrationId">registrationId</param>
        /// <param name = "tag">tag</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchPeriodicSyncEventAsync(string origin, string registrationId, string tag)
        {
            ValidateDispatchPeriodicSyncEvent(origin, registrationId, tag);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            dict.Add("registrationId", registrationId);
            dict.Add("tag", tag);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.dispatchPeriodicSyncEvent", dict);
            return methodResult;
        }

        /// <summary>
        /// Enable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.enable", dict);
            return methodResult;
        }

        partial void ValidateInspectWorker(string versionId);
        /// <summary>
        /// InspectWorker
        /// </summary>
        /// <param name = "versionId">versionId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> InspectWorkerAsync(string versionId)
        {
            ValidateInspectWorker(versionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("versionId", versionId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.inspectWorker", dict);
            return methodResult;
        }

        partial void ValidateSetForceUpdateOnPageLoad(bool forceUpdateOnPageLoad);
        /// <summary>
        /// SetForceUpdateOnPageLoad
        /// </summary>
        /// <param name = "forceUpdateOnPageLoad">forceUpdateOnPageLoad</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetForceUpdateOnPageLoadAsync(bool forceUpdateOnPageLoad)
        {
            ValidateSetForceUpdateOnPageLoad(forceUpdateOnPageLoad);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("forceUpdateOnPageLoad", forceUpdateOnPageLoad);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.setForceUpdateOnPageLoad", dict);
            return methodResult;
        }

        partial void ValidateSkipWaiting(string scopeURL);
        /// <summary>
        /// SkipWaiting
        /// </summary>
        /// <param name = "scopeURL">scopeURL</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SkipWaitingAsync(string scopeURL)
        {
            ValidateSkipWaiting(scopeURL);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeURL", scopeURL);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.skipWaiting", dict);
            return methodResult;
        }

        partial void ValidateStartWorker(string scopeURL);
        /// <summary>
        /// StartWorker
        /// </summary>
        /// <param name = "scopeURL">scopeURL</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartWorkerAsync(string scopeURL)
        {
            ValidateStartWorker(scopeURL);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeURL", scopeURL);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.startWorker", dict);
            return methodResult;
        }

        /// <summary>
        /// StopAllWorkers
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopAllWorkersAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.stopAllWorkers", dict);
            return methodResult;
        }

        partial void ValidateStopWorker(string versionId);
        /// <summary>
        /// StopWorker
        /// </summary>
        /// <param name = "versionId">versionId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopWorkerAsync(string versionId)
        {
            ValidateStopWorker(versionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("versionId", versionId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.stopWorker", dict);
            return methodResult;
        }

        partial void ValidateUnregister(string scopeURL);
        /// <summary>
        /// Unregister
        /// </summary>
        /// <param name = "scopeURL">scopeURL</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> UnregisterAsync(string scopeURL)
        {
            ValidateUnregister(scopeURL);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeURL", scopeURL);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.unregister", dict);
            return methodResult;
        }

        partial void ValidateUpdateRegistration(string scopeURL);
        /// <summary>
        /// UpdateRegistration
        /// </summary>
        /// <param name = "scopeURL">scopeURL</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> UpdateRegistrationAsync(string scopeURL)
        {
            ValidateUpdateRegistration(scopeURL);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeURL", scopeURL);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("ServiceWorker.updateRegistration", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetCookiesResponse
    /// </summary>
    public class GetCookiesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// cookies
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("cookies")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.Cookie> Cookies
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetUsageAndQuotaResponse
    /// </summary>
    public class GetUsageAndQuotaResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// usage
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("usage")]
        public long Usage
        {
            get;
            private set;
        }

        /// <summary>
        /// quota
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("quota")]
        public long Quota
        {
            get;
            private set;
        }

        /// <summary>
        /// usageBreakdown
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("usageBreakdown")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Storage.UsageForType> UsageBreakdown
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    using System.Linq;

    /// <summary>
    /// Storage
    /// </summary>
    public partial class StorageClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public StorageClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateClearDataForOrigin(string origin, string storageTypes);
        /// <summary>
        /// Clears storage for origin.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <param name = "storageTypes">Comma separated list of StorageType to clear.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearDataForOriginAsync(string origin, string storageTypes)
        {
            ValidateClearDataForOrigin(origin, storageTypes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            dict.Add("storageTypes", storageTypes);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.clearDataForOrigin", dict);
            return methodResult;
        }

        partial void ValidateGetCookies(string browserContextId = null);
        /// <summary>
        /// Returns all browser cookies.
        /// </summary>
        /// <param name = "browserContextId">Browser context to use when called on the browser endpoint.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCookiesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetCookiesResponse> GetCookiesAsync(string browserContextId = null)
        {
            ValidateGetCookies(browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.getCookies", dict);
            return methodResult.DeserializeJson<GetCookiesResponse>();
        }

        partial void ValidateSetCookies(System.Collections.Generic.IList<CefSharp.DevTools.Network.CookieParam> cookies, string browserContextId = null);
        /// <summary>
        /// Sets given cookies.
        /// </summary>
        /// <param name = "cookies">Cookies to be set.</param>
        /// <param name = "browserContextId">Browser context to use when called on the browser endpoint.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetCookiesAsync(System.Collections.Generic.IList<CefSharp.DevTools.Network.CookieParam> cookies, string browserContextId = null)
        {
            ValidateSetCookies(cookies, browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cookies", cookies.Select(x => x.ToDictionary()));
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.setCookies", dict);
            return methodResult;
        }

        partial void ValidateClearCookies(string browserContextId = null);
        /// <summary>
        /// Clears cookies.
        /// </summary>
        /// <param name = "browserContextId">Browser context to use when called on the browser endpoint.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearCookiesAsync(string browserContextId = null)
        {
            ValidateClearCookies(browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.clearCookies", dict);
            return methodResult;
        }

        partial void ValidateGetUsageAndQuota(string origin);
        /// <summary>
        /// Returns usage and quota in bytes.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetUsageAndQuotaResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetUsageAndQuotaResponse> GetUsageAndQuotaAsync(string origin)
        {
            ValidateGetUsageAndQuota(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.getUsageAndQuota", dict);
            return methodResult.DeserializeJson<GetUsageAndQuotaResponse>();
        }

        partial void ValidateTrackCacheStorageForOrigin(string origin);
        /// <summary>
        /// Registers origin to be notified when an update occurs to its cache storage list.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> TrackCacheStorageForOriginAsync(string origin)
        {
            ValidateTrackCacheStorageForOrigin(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.trackCacheStorageForOrigin", dict);
            return methodResult;
        }

        partial void ValidateTrackIndexedDBForOrigin(string origin);
        /// <summary>
        /// Registers origin to be notified when an update occurs to its IndexedDB.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> TrackIndexedDBForOriginAsync(string origin)
        {
            ValidateTrackIndexedDBForOrigin(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.trackIndexedDBForOrigin", dict);
            return methodResult;
        }

        partial void ValidateUntrackCacheStorageForOrigin(string origin);
        /// <summary>
        /// Unregisters origin from receiving notifications for cache storage.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> UntrackCacheStorageForOriginAsync(string origin)
        {
            ValidateUntrackCacheStorageForOrigin(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.untrackCacheStorageForOrigin", dict);
            return methodResult;
        }

        partial void ValidateUntrackIndexedDBForOrigin(string origin);
        /// <summary>
        /// Unregisters origin from receiving notifications for IndexedDB.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> UntrackIndexedDBForOriginAsync(string origin)
        {
            ValidateUntrackIndexedDBForOrigin(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Storage.untrackIndexedDBForOrigin", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// GetInfoResponse
    /// </summary>
    public class GetInfoResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// gpu
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("gpu")]
        public CefSharp.DevTools.SystemInfo.GPUInfo Gpu
        {
            get;
            private set;
        }

        /// <summary>
        /// modelName
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("modelName")]
        public string ModelName
        {
            get;
            private set;
        }

        /// <summary>
        /// modelVersion
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("modelVersion")]
        public string ModelVersion
        {
            get;
            private set;
        }

        /// <summary>
        /// commandLine
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("commandLine")]
        public string CommandLine
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// GetProcessInfoResponse
    /// </summary>
    public class GetProcessInfoResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// processInfo
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("processInfo")]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.ProcessInfo> ProcessInfo
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    using System.Linq;

    /// <summary>
    /// The SystemInfo domain defines methods and events for querying low-level system information.
    /// </summary>
    public partial class SystemInfoClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public SystemInfoClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Returns information about the system.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetInfoResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetInfoResponse> GetInfoAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("SystemInfo.getInfo", dict);
            return methodResult.DeserializeJson<GetInfoResponse>();
        }

        /// <summary>
        /// Returns information about all running processes.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetProcessInfoResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetProcessInfoResponse> GetProcessInfoAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("SystemInfo.getProcessInfo", dict);
            return methodResult.DeserializeJson<GetProcessInfoResponse>();
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// AttachToTargetResponse
    /// </summary>
    public class AttachToTargetResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// sessionId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sessionId")]
        public string SessionId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// AttachToBrowserTargetResponse
    /// </summary>
    public class AttachToBrowserTargetResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// sessionId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("sessionId")]
        public string SessionId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// CloseTargetResponse
    /// </summary>
    public class CloseTargetResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// success
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("success")]
        public bool Success
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// CreateBrowserContextResponse
    /// </summary>
    public class CreateBrowserContextResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// browserContextId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("browserContextId")]
        public string BrowserContextId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// GetBrowserContextsResponse
    /// </summary>
    public class GetBrowserContextsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// browserContextIds
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("browserContextIds")]
        public string[] BrowserContextIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// CreateTargetResponse
    /// </summary>
    public class CreateTargetResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// targetId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("targetId")]
        public string TargetId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// GetTargetInfoResponse
    /// </summary>
    public class GetTargetInfoResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// targetInfo
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("targetInfo")]
        public CefSharp.DevTools.Target.TargetInfo TargetInfo
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// GetTargetsResponse
    /// </summary>
    public class GetTargetsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// targetInfos
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("targetInfos")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetInfo> TargetInfos
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    using System.Linq;

    /// <summary>
    /// Supports additional targets discovery and allows to attach to them.
    /// </summary>
    public partial class TargetClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public TargetClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateActivateTarget(string targetId);
        /// <summary>
        /// Activates (focuses) the target.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ActivateTargetAsync(string targetId)
        {
            ValidateActivateTarget(targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.activateTarget", dict);
            return methodResult;
        }

        partial void ValidateAttachToTarget(string targetId, bool? flatten = null);
        /// <summary>
        /// Attaches to the target with given id.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <param name = "flatten">Enables "flat" access to the session via specifying sessionId attribute in the commands.We plan to make this the default, deprecate non-flattened mode,and eventually retire it. See crbug.com/991325.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AttachToTargetResponse&gt;</returns>
        public async System.Threading.Tasks.Task<AttachToTargetResponse> AttachToTargetAsync(string targetId, bool? flatten = null)
        {
            ValidateAttachToTarget(targetId, flatten);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            if (flatten.HasValue)
            {
                dict.Add("flatten", flatten.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.attachToTarget", dict);
            return methodResult.DeserializeJson<AttachToTargetResponse>();
        }

        /// <summary>
        /// Attaches to the browser target, only uses flat sessionId mode.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;AttachToBrowserTargetResponse&gt;</returns>
        public async System.Threading.Tasks.Task<AttachToBrowserTargetResponse> AttachToBrowserTargetAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.attachToBrowserTarget", dict);
            return methodResult.DeserializeJson<AttachToBrowserTargetResponse>();
        }

        partial void ValidateCloseTarget(string targetId);
        /// <summary>
        /// Closes the target. If the target is a page that gets closed too.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CloseTargetResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CloseTargetResponse> CloseTargetAsync(string targetId)
        {
            ValidateCloseTarget(targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.closeTarget", dict);
            return methodResult.DeserializeJson<CloseTargetResponse>();
        }

        partial void ValidateExposeDevToolsProtocol(string targetId, string bindingName = null);
        /// <summary>
        /// Inject object to the target&apos;s main frame that provides a communication
        /// channel with browser target.
        /// 
        /// Injected object will be available as `window[bindingName]`.
        /// 
        /// The object has the follwing API:
        /// - `binding.send(json)` - a method to send messages over the remote debugging protocol
        /// - `binding.onmessage = json =&gt; handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <param name = "bindingName">Binding name, 'cdp' if not specified.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ExposeDevToolsProtocolAsync(string targetId, string bindingName = null)
        {
            ValidateExposeDevToolsProtocol(targetId, bindingName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            if (!(string.IsNullOrEmpty(bindingName)))
            {
                dict.Add("bindingName", bindingName);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.exposeDevToolsProtocol", dict);
            return methodResult;
        }

        partial void ValidateCreateBrowserContext(bool? disposeOnDetach = null, string proxyServer = null, string proxyBypassList = null);
        /// <summary>
        /// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
        /// one.
        /// </summary>
        /// <param name = "disposeOnDetach">If specified, disposes this context when debugging session disconnects.</param>
        /// <param name = "proxyServer">Proxy server, similar to the one passed to --proxy-server</param>
        /// <param name = "proxyBypassList">Proxy bypass list, similar to the one passed to --proxy-bypass-list</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CreateBrowserContextResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CreateBrowserContextResponse> CreateBrowserContextAsync(bool? disposeOnDetach = null, string proxyServer = null, string proxyBypassList = null)
        {
            ValidateCreateBrowserContext(disposeOnDetach, proxyServer, proxyBypassList);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (disposeOnDetach.HasValue)
            {
                dict.Add("disposeOnDetach", disposeOnDetach.Value);
            }

            if (!(string.IsNullOrEmpty(proxyServer)))
            {
                dict.Add("proxyServer", proxyServer);
            }

            if (!(string.IsNullOrEmpty(proxyBypassList)))
            {
                dict.Add("proxyBypassList", proxyBypassList);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.createBrowserContext", dict);
            return methodResult.DeserializeJson<CreateBrowserContextResponse>();
        }

        /// <summary>
        /// Returns all browser contexts created with `Target.createBrowserContext` method.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBrowserContextsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetBrowserContextsResponse> GetBrowserContextsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.getBrowserContexts", dict);
            return methodResult.DeserializeJson<GetBrowserContextsResponse>();
        }

        partial void ValidateCreateTarget(string url, int? width = null, int? height = null, string browserContextId = null, bool? enableBeginFrameControl = null, bool? newWindow = null, bool? background = null);
        /// <summary>
        /// Creates a new page.
        /// </summary>
        /// <param name = "url">The initial URL the page will be navigated to.</param>
        /// <param name = "width">Frame width in DIP (headless chrome only).</param>
        /// <param name = "height">Frame height in DIP (headless chrome only).</param>
        /// <param name = "browserContextId">The browser context to create the page in.</param>
        /// <param name = "enableBeginFrameControl">Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,not supported on MacOS yet, false by default).</param>
        /// <param name = "newWindow">Whether to create a new Window or Tab (chrome-only, false by default).</param>
        /// <param name = "background">Whether to create the target in background or foreground (chrome-only,false by default).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CreateTargetResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CreateTargetResponse> CreateTargetAsync(string url, int? width = null, int? height = null, string browserContextId = null, bool? enableBeginFrameControl = null, bool? newWindow = null, bool? background = null)
        {
            ValidateCreateTarget(url, width, height, browserContextId, enableBeginFrameControl, newWindow, background);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            if (width.HasValue)
            {
                dict.Add("width", width.Value);
            }

            if (height.HasValue)
            {
                dict.Add("height", height.Value);
            }

            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            if (enableBeginFrameControl.HasValue)
            {
                dict.Add("enableBeginFrameControl", enableBeginFrameControl.Value);
            }

            if (newWindow.HasValue)
            {
                dict.Add("newWindow", newWindow.Value);
            }

            if (background.HasValue)
            {
                dict.Add("background", background.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.createTarget", dict);
            return methodResult.DeserializeJson<CreateTargetResponse>();
        }

        partial void ValidateDetachFromTarget(string sessionId = null, string targetId = null);
        /// <summary>
        /// Detaches session with given id.
        /// </summary>
        /// <param name = "sessionId">Session to detach.</param>
        /// <param name = "targetId">Deprecated.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DetachFromTargetAsync(string sessionId = null, string targetId = null)
        {
            ValidateDetachFromTarget(sessionId, targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(sessionId)))
            {
                dict.Add("sessionId", sessionId);
            }

            if (!(string.IsNullOrEmpty(targetId)))
            {
                dict.Add("targetId", targetId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.detachFromTarget", dict);
            return methodResult;
        }

        partial void ValidateDisposeBrowserContext(string browserContextId);
        /// <summary>
        /// Deletes a BrowserContext. All the belonging pages will be closed without calling their
        /// beforeunload hooks.
        /// </summary>
        /// <param name = "browserContextId">browserContextId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisposeBrowserContextAsync(string browserContextId)
        {
            ValidateDisposeBrowserContext(browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("browserContextId", browserContextId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.disposeBrowserContext", dict);
            return methodResult;
        }

        partial void ValidateGetTargetInfo(string targetId = null);
        /// <summary>
        /// Returns information about a target.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetTargetInfoResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetTargetInfoResponse> GetTargetInfoAsync(string targetId = null)
        {
            ValidateGetTargetInfo(targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(targetId)))
            {
                dict.Add("targetId", targetId);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.getTargetInfo", dict);
            return methodResult.DeserializeJson<GetTargetInfoResponse>();
        }

        /// <summary>
        /// Retrieves a list of available targets.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetTargetsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetTargetsResponse> GetTargetsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.getTargets", dict);
            return methodResult.DeserializeJson<GetTargetsResponse>();
        }

        partial void ValidateSetAutoAttach(bool autoAttach, bool waitForDebuggerOnStart, bool? flatten = null);
        /// <summary>
        /// Controls whether to automatically attach to new targets which are considered to be related to
        /// this one. When turned on, attaches to all existing related targets as well. When turned off,
        /// automatically detaches from all currently attached targets.
        /// </summary>
        /// <param name = "autoAttach">Whether to auto-attach to related targets.</param>
        /// <param name = "waitForDebuggerOnStart">Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`to run paused targets.</param>
        /// <param name = "flatten">Enables "flat" access to the session via specifying sessionId attribute in the commands.We plan to make this the default, deprecate non-flattened mode,and eventually retire it. See crbug.com/991325.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetAutoAttachAsync(bool autoAttach, bool waitForDebuggerOnStart, bool? flatten = null)
        {
            ValidateSetAutoAttach(autoAttach, waitForDebuggerOnStart, flatten);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("autoAttach", autoAttach);
            dict.Add("waitForDebuggerOnStart", waitForDebuggerOnStart);
            if (flatten.HasValue)
            {
                dict.Add("flatten", flatten.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.setAutoAttach", dict);
            return methodResult;
        }

        partial void ValidateSetDiscoverTargets(bool discover);
        /// <summary>
        /// Controls whether to discover available targets and notify via
        /// `targetCreated/targetInfoChanged/targetDestroyed` events.
        /// </summary>
        /// <param name = "discover">Whether to discover available targets.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetDiscoverTargetsAsync(bool discover)
        {
            ValidateSetDiscoverTargets(discover);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("discover", discover);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.setDiscoverTargets", dict);
            return methodResult;
        }

        partial void ValidateSetRemoteLocations(System.Collections.Generic.IList<CefSharp.DevTools.Target.RemoteLocation> locations);
        /// <summary>
        /// Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
        /// `true`.
        /// </summary>
        /// <param name = "locations">List of remote locations.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetRemoteLocationsAsync(System.Collections.Generic.IList<CefSharp.DevTools.Target.RemoteLocation> locations)
        {
            ValidateSetRemoteLocations(locations);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("locations", locations.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Target.setRemoteLocations", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Tethering
{
    using System.Linq;

    /// <summary>
    /// The Tethering domain defines methods and events for browser port binding.
    /// </summary>
    public partial class TetheringClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public TetheringClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateBind(int port);
        /// <summary>
        /// Request browser port binding.
        /// </summary>
        /// <param name = "port">Port number to bind.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> BindAsync(int port)
        {
            ValidateBind(port);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("port", port);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Tethering.bind", dict);
            return methodResult;
        }

        partial void ValidateUnbind(int port);
        /// <summary>
        /// Request browser port unbinding.
        /// </summary>
        /// <param name = "port">Port number to unbind.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> UnbindAsync(int port)
        {
            ValidateUnbind(port);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("port", port);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Tethering.unbind", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    /// <summary>
    /// GetCategoriesResponse
    /// </summary>
    public class GetCategoriesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// categories
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("categories")]
        public string[] Categories
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    /// <summary>
    /// RequestMemoryDumpResponse
    /// </summary>
    public class RequestMemoryDumpResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// dumpGuid
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("dumpGuid")]
        public string DumpGuid
        {
            get;
            private set;
        }

        /// <summary>
        /// success
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("success")]
        public bool Success
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    using System.Linq;

    /// <summary>
    /// Tracing
    /// </summary>
    public partial class TracingClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public TracingClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Stop trace events collection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EndAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Tracing.end", dict);
            return methodResult;
        }

        /// <summary>
        /// Gets supported tracing categories.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCategoriesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetCategoriesResponse> GetCategoriesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Tracing.getCategories", dict);
            return methodResult.DeserializeJson<GetCategoriesResponse>();
        }

        partial void ValidateRecordClockSyncMarker(string syncId);
        /// <summary>
        /// Record a clock sync marker in the trace.
        /// </summary>
        /// <param name = "syncId">The ID of this clock sync marker</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RecordClockSyncMarkerAsync(string syncId)
        {
            ValidateRecordClockSyncMarker(syncId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("syncId", syncId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Tracing.recordClockSyncMarker", dict);
            return methodResult;
        }

        partial void ValidateRequestMemoryDump(bool? deterministic = null);
        /// <summary>
        /// Request a global memory dump.
        /// </summary>
        /// <param name = "deterministic">Enables more deterministic results by forcing garbage collection</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestMemoryDumpResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RequestMemoryDumpResponse> RequestMemoryDumpAsync(bool? deterministic = null)
        {
            ValidateRequestMemoryDump(deterministic);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (deterministic.HasValue)
            {
                dict.Add("deterministic", deterministic.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Tracing.requestMemoryDump", dict);
            return methodResult.DeserializeJson<RequestMemoryDumpResponse>();
        }

        partial void ValidateStart(string categories = null, string options = null, long? bufferUsageReportingInterval = null, string transferMode = null, CefSharp.DevTools.Tracing.StreamFormat? streamFormat = null, CefSharp.DevTools.Tracing.StreamCompression? streamCompression = null, CefSharp.DevTools.Tracing.TraceConfig traceConfig = null);
        /// <summary>
        /// Start trace events collection.
        /// </summary>
        /// <param name = "categories">Category/tag filter</param>
        /// <param name = "options">Tracing options</param>
        /// <param name = "bufferUsageReportingInterval">If set, the agent will issue bufferUsage events at this interval, specified in milliseconds</param>
        /// <param name = "transferMode">Whether to report trace events as series of dataCollected events or to save trace to astream (defaults to `ReportEvents`).</param>
        /// <param name = "streamFormat">Trace data format to use. This only applies when using `ReturnAsStream`transfer mode (defaults to `json`).</param>
        /// <param name = "streamCompression">Compression format to use. This only applies when using `ReturnAsStream`transfer mode (defaults to `none`)</param>
        /// <param name = "traceConfig">traceConfig</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartAsync(string categories = null, string options = null, long? bufferUsageReportingInterval = null, string transferMode = null, CefSharp.DevTools.Tracing.StreamFormat? streamFormat = null, CefSharp.DevTools.Tracing.StreamCompression? streamCompression = null, CefSharp.DevTools.Tracing.TraceConfig traceConfig = null)
        {
            ValidateStart(categories, options, bufferUsageReportingInterval, transferMode, streamFormat, streamCompression, traceConfig);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(categories)))
            {
                dict.Add("categories", categories);
            }

            if (!(string.IsNullOrEmpty(options)))
            {
                dict.Add("options", options);
            }

            if (bufferUsageReportingInterval.HasValue)
            {
                dict.Add("bufferUsageReportingInterval", bufferUsageReportingInterval.Value);
            }

            if (!(string.IsNullOrEmpty(transferMode)))
            {
                dict.Add("transferMode", transferMode);
            }

            if (streamFormat.HasValue)
            {
                dict.Add("streamFormat", this.EnumToString(streamFormat));
            }

            if (streamCompression.HasValue)
            {
                dict.Add("streamCompression", this.EnumToString(streamCompression));
            }

            if ((traceConfig) != (null))
            {
                dict.Add("traceConfig", traceConfig.ToDictionary());
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Tracing.start", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// GetResponseBodyResponse
    /// </summary>
    public class GetResponseBodyResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// body
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("body")]
        public string Body
        {
            get;
            private set;
        }

        /// <summary>
        /// base64Encoded
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("base64Encoded")]
        public bool Base64Encoded
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// TakeResponseBodyAsStreamResponse
    /// </summary>
    public class TakeResponseBodyAsStreamResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// stream
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stream")]
        public string Stream
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    using System.Linq;

    /// <summary>
    /// A domain for letting clients substitute browser&apos;s network layer with client code.
    /// </summary>
    public partial class FetchClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public FetchClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables the fetch domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Fetch.disable", dict);
            return methodResult;
        }

        partial void ValidateEnable(System.Collections.Generic.IList<CefSharp.DevTools.Fetch.RequestPattern> patterns = null, bool? handleAuthRequests = null);
        /// <summary>
        /// Enables issuing of requestPaused events. A request will be paused until client
        /// calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
        /// </summary>
        /// <param name = "patterns">If specified, only requests matching any of these patterns will producefetchRequested event and will be paused until clients response. If not set,all requests will be affected.</param>
        /// <param name = "handleAuthRequests">If true, authRequired events will be issued and requests will be pausedexpecting a call to continueWithAuth.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(System.Collections.Generic.IList<CefSharp.DevTools.Fetch.RequestPattern> patterns = null, bool? handleAuthRequests = null)
        {
            ValidateEnable(patterns, handleAuthRequests);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((patterns) != (null))
            {
                dict.Add("patterns", patterns.Select(x => x.ToDictionary()));
            }

            if (handleAuthRequests.HasValue)
            {
                dict.Add("handleAuthRequests", handleAuthRequests.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Fetch.enable", dict);
            return methodResult;
        }

        partial void ValidateFailRequest(string requestId, CefSharp.DevTools.Network.ErrorReason errorReason);
        /// <summary>
        /// Causes the request to fail with specified reason.
        /// </summary>
        /// <param name = "requestId">An id the client received in requestPaused event.</param>
        /// <param name = "errorReason">Causes the request to fail with the given reason.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> FailRequestAsync(string requestId, CefSharp.DevTools.Network.ErrorReason errorReason)
        {
            ValidateFailRequest(requestId, errorReason);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("errorReason", this.EnumToString(errorReason));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Fetch.failRequest", dict);
            return methodResult;
        }

        partial void ValidateFulfillRequest(string requestId, int responseCode, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> responseHeaders = null, byte[] binaryResponseHeaders = null, byte[] body = null, string responsePhrase = null);
        /// <summary>
        /// Provides response to the request.
        /// </summary>
        /// <param name = "requestId">An id the client received in requestPaused event.</param>
        /// <param name = "responseCode">An HTTP response code.</param>
        /// <param name = "responseHeaders">Response headers.</param>
        /// <param name = "binaryResponseHeaders">Alternative way of specifying response headers as a \0-separatedseries of name: value pairs. Prefer the above method unless youneed to represent some non-UTF8 values that can't be transmittedover the protocol as text.</param>
        /// <param name = "body">A response body.</param>
        /// <param name = "responsePhrase">A textual representation of responseCode.If absent, a standard phrase matching responseCode is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> FulfillRequestAsync(string requestId, int responseCode, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> responseHeaders = null, byte[] binaryResponseHeaders = null, byte[] body = null, string responsePhrase = null)
        {
            ValidateFulfillRequest(requestId, responseCode, responseHeaders, binaryResponseHeaders, body, responsePhrase);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("responseCode", responseCode);
            if ((responseHeaders) != (null))
            {
                dict.Add("responseHeaders", responseHeaders.Select(x => x.ToDictionary()));
            }

            if ((binaryResponseHeaders) != (null))
            {
                dict.Add("binaryResponseHeaders", ToBase64String(binaryResponseHeaders));
            }

            if ((body) != (null))
            {
                dict.Add("body", ToBase64String(body));
            }

            if (!(string.IsNullOrEmpty(responsePhrase)))
            {
                dict.Add("responsePhrase", responsePhrase);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Fetch.fulfillRequest", dict);
            return methodResult;
        }

        partial void ValidateContinueRequest(string requestId, string url = null, string method = null, byte[] postData = null, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> headers = null);
        /// <summary>
        /// Continues the request, optionally modifying some of its parameters.
        /// </summary>
        /// <param name = "requestId">An id the client received in requestPaused event.</param>
        /// <param name = "url">If set, the request url will be modified in a way that's not observable by page.</param>
        /// <param name = "method">If set, the request method is overridden.</param>
        /// <param name = "postData">If set, overrides the post data in the request.</param>
        /// <param name = "headers">If set, overrides the request headers.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ContinueRequestAsync(string requestId, string url = null, string method = null, byte[] postData = null, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> headers = null)
        {
            ValidateContinueRequest(requestId, url, method, postData, headers);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            if (!(string.IsNullOrEmpty(url)))
            {
                dict.Add("url", url);
            }

            if (!(string.IsNullOrEmpty(method)))
            {
                dict.Add("method", method);
            }

            if ((postData) != (null))
            {
                dict.Add("postData", ToBase64String(postData));
            }

            if ((headers) != (null))
            {
                dict.Add("headers", headers.Select(x => x.ToDictionary()));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Fetch.continueRequest", dict);
            return methodResult;
        }

        partial void ValidateContinueWithAuth(string requestId, CefSharp.DevTools.Fetch.AuthChallengeResponse authChallengeResponse);
        /// <summary>
        /// Continues a request supplying authChallengeResponse following authRequired event.
        /// </summary>
        /// <param name = "requestId">An id the client received in authRequired event.</param>
        /// <param name = "authChallengeResponse">Response to  with an authChallenge.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ContinueWithAuthAsync(string requestId, CefSharp.DevTools.Fetch.AuthChallengeResponse authChallengeResponse)
        {
            ValidateContinueWithAuth(requestId, authChallengeResponse);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("authChallengeResponse", authChallengeResponse.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Fetch.continueWithAuth", dict);
            return methodResult;
        }

        partial void ValidateGetResponseBody(string requestId);
        /// <summary>
        /// Causes the body of the response to be received from the server and
        /// returned as a single string. May only be issued for a request that
        /// is paused in the Response stage and is mutually exclusive with
        /// takeResponseBodyForInterceptionAsStream. Calling other methods that
        /// affect the request or disabling fetch domain before body is received
        /// results in an undefined behavior.
        /// </summary>
        /// <param name = "requestId">Identifier for the intercepted request to get body for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResponseBodyResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetResponseBodyResponse> GetResponseBodyAsync(string requestId)
        {
            ValidateGetResponseBody(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Fetch.getResponseBody", dict);
            return methodResult.DeserializeJson<GetResponseBodyResponse>();
        }

        partial void ValidateTakeResponseBodyAsStream(string requestId);
        /// <summary>
        /// Returns a handle to the stream representing the response body.
        /// The request must be paused in the HeadersReceived stage.
        /// Note that after this command the request can&apos;t be continued
        /// as is -- client either needs to cancel it or to provide the
        /// response body.
        /// The stream only supports sequential read, IO.read will fail if the position
        /// is specified.
        /// This method is mutually exclusive with getResponseBody.
        /// Calling other methods that affect the request or disabling fetch
        /// domain before body is received results in an undefined behavior.
        /// </summary>
        /// <param name = "requestId">requestId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeResponseBodyAsStreamResponse&gt;</returns>
        public async System.Threading.Tasks.Task<TakeResponseBodyAsStreamResponse> TakeResponseBodyAsStreamAsync(string requestId)
        {
            ValidateTakeResponseBodyAsStream(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Fetch.takeResponseBodyAsStream", dict);
            return methodResult.DeserializeJson<TakeResponseBodyAsStreamResponse>();
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// GetRealtimeDataResponse
    /// </summary>
    public class GetRealtimeDataResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// realtimeData
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("realtimeData")]
        public CefSharp.DevTools.WebAudio.ContextRealtimeData RealtimeData
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    using System.Linq;

    /// <summary>
    /// This domain allows inspection of Web Audio API.
    /// https://webaudio.github.io/web-audio-api/
    /// </summary>
    public partial class WebAudioClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public WebAudioClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Enables the WebAudio domain and starts sending context lifetime events.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAudio.enable", dict);
            return methodResult;
        }

        /// <summary>
        /// Disables the WebAudio domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAudio.disable", dict);
            return methodResult;
        }

        partial void ValidateGetRealtimeData(string contextId);
        /// <summary>
        /// Fetch the realtime data from the registered contexts.
        /// </summary>
        /// <param name = "contextId">contextId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetRealtimeDataResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetRealtimeDataResponse> GetRealtimeDataAsync(string contextId)
        {
            ValidateGetRealtimeData(contextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("contextId", contextId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAudio.getRealtimeData", dict);
            return methodResult.DeserializeJson<GetRealtimeDataResponse>();
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// AddVirtualAuthenticatorResponse
    /// </summary>
    public class AddVirtualAuthenticatorResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// authenticatorId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("authenticatorId")]
        public string AuthenticatorId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// GetCredentialResponse
    /// </summary>
    public class GetCredentialResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// credential
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("credential")]
        public CefSharp.DevTools.WebAuthn.Credential Credential
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// GetCredentialsResponse
    /// </summary>
    public class GetCredentialsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// credentials
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("credentials")]
        public System.Collections.Generic.IList<CefSharp.DevTools.WebAuthn.Credential> Credentials
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    using System.Linq;

    /// <summary>
    /// This domain allows configuring virtual authenticators to test the WebAuthn
    /// API.
    /// </summary>
    public partial class WebAuthnClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public WebAuthnClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Enable the WebAuthn domain and start intercepting credential storage and
        /// retrieval with a virtual authenticator.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.enable", dict);
            return methodResult;
        }

        /// <summary>
        /// Disable the WebAuthn domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.disable", dict);
            return methodResult;
        }

        partial void ValidateAddVirtualAuthenticator(CefSharp.DevTools.WebAuthn.VirtualAuthenticatorOptions options);
        /// <summary>
        /// Creates and adds a virtual authenticator.
        /// </summary>
        /// <param name = "options">options</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AddVirtualAuthenticatorResponse&gt;</returns>
        public async System.Threading.Tasks.Task<AddVirtualAuthenticatorResponse> AddVirtualAuthenticatorAsync(CefSharp.DevTools.WebAuthn.VirtualAuthenticatorOptions options)
        {
            ValidateAddVirtualAuthenticator(options);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("options", options.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.addVirtualAuthenticator", dict);
            return methodResult.DeserializeJson<AddVirtualAuthenticatorResponse>();
        }

        partial void ValidateRemoveVirtualAuthenticator(string authenticatorId);
        /// <summary>
        /// Removes the given authenticator.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveVirtualAuthenticatorAsync(string authenticatorId)
        {
            ValidateRemoveVirtualAuthenticator(authenticatorId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.removeVirtualAuthenticator", dict);
            return methodResult;
        }

        partial void ValidateAddCredential(string authenticatorId, CefSharp.DevTools.WebAuthn.Credential credential);
        /// <summary>
        /// Adds the credential to the specified authenticator.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "credential">credential</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> AddCredentialAsync(string authenticatorId, CefSharp.DevTools.WebAuthn.Credential credential)
        {
            ValidateAddCredential(authenticatorId, credential);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("credential", credential.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.addCredential", dict);
            return methodResult;
        }

        partial void ValidateGetCredential(string authenticatorId, byte[] credentialId);
        /// <summary>
        /// Returns a single credential stored in the given virtual authenticator that
        /// matches the credential ID.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "credentialId">credentialId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCredentialResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetCredentialResponse> GetCredentialAsync(string authenticatorId, byte[] credentialId)
        {
            ValidateGetCredential(authenticatorId, credentialId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("credentialId", ToBase64String(credentialId));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.getCredential", dict);
            return methodResult.DeserializeJson<GetCredentialResponse>();
        }

        partial void ValidateGetCredentials(string authenticatorId);
        /// <summary>
        /// Returns all the credentials stored in the given virtual authenticator.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCredentialsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetCredentialsResponse> GetCredentialsAsync(string authenticatorId)
        {
            ValidateGetCredentials(authenticatorId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.getCredentials", dict);
            return methodResult.DeserializeJson<GetCredentialsResponse>();
        }

        partial void ValidateRemoveCredential(string authenticatorId, byte[] credentialId);
        /// <summary>
        /// Removes a credential from the authenticator.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "credentialId">credentialId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveCredentialAsync(string authenticatorId, byte[] credentialId)
        {
            ValidateRemoveCredential(authenticatorId, credentialId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("credentialId", ToBase64String(credentialId));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.removeCredential", dict);
            return methodResult;
        }

        partial void ValidateClearCredentials(string authenticatorId);
        /// <summary>
        /// Clears all the credentials from the specified device.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ClearCredentialsAsync(string authenticatorId)
        {
            ValidateClearCredentials(authenticatorId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.clearCredentials", dict);
            return methodResult;
        }

        partial void ValidateSetUserVerified(string authenticatorId, bool isUserVerified);
        /// <summary>
        /// Sets whether User Verification succeeds or fails for an authenticator.
        /// The default is true.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "isUserVerified">isUserVerified</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetUserVerifiedAsync(string authenticatorId, bool isUserVerified)
        {
            ValidateSetUserVerified(authenticatorId, isUserVerified);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("isUserVerified", isUserVerified);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.setUserVerified", dict);
            return methodResult;
        }

        partial void ValidateSetAutomaticPresenceSimulation(string authenticatorId, bool enabled);
        /// <summary>
        /// Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
        /// The default is true.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "enabled">enabled</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetAutomaticPresenceSimulationAsync(string authenticatorId, bool enabled)
        {
            ValidateSetAutomaticPresenceSimulation(authenticatorId, enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("WebAuthn.setAutomaticPresenceSimulation", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Media
{
    using System.Linq;

    /// <summary>
    /// This domain allows detailed inspection of media elements
    /// </summary>
    public partial class MediaClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public MediaClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Enables the Media domain
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Media.enable", dict);
            return methodResult;
        }

        /// <summary>
        /// Disables the Media domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Media.disable", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// EnableResponse
    /// </summary>
    public class EnableResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// debuggerId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("debuggerId")]
        public string DebuggerId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// EvaluateOnCallFrameResponse
    /// </summary>
    public class EvaluateOnCallFrameResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// ExecuteWasmEvaluatorResponse
    /// </summary>
    public class ExecuteWasmEvaluatorResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// GetPossibleBreakpointsResponse
    /// </summary>
    public class GetPossibleBreakpointsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// locations
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("locations")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.BreakLocation> Locations
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// GetScriptSourceResponse
    /// </summary>
    public class GetScriptSourceResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// scriptSource
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptSource")]
        public string ScriptSource
        {
            get;
            private set;
        }

        /// <summary>
        /// bytecode
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("bytecode")]
        public byte[] Bytecode
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// GetStackTraceResponse
    /// </summary>
    public class GetStackTraceResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// stackTrace
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// RestartFrameResponse
    /// </summary>
    public class RestartFrameResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// callFrames
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callFrames")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.CallFrame> CallFrames
        {
            get;
            private set;
        }

        /// <summary>
        /// asyncStackTrace
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("asyncStackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace AsyncStackTrace
        {
            get;
            private set;
        }

        /// <summary>
        /// asyncStackTraceId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("asyncStackTraceId")]
        public CefSharp.DevTools.Runtime.StackTraceId AsyncStackTraceId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SearchInContentResponse
    /// </summary>
    public class SearchInContentResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.SearchMatch> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetBreakpointResponse
    /// </summary>
    public class SetBreakpointResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// breakpointId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("breakpointId")]
        public string BreakpointId
        {
            get;
            private set;
        }

        /// <summary>
        /// actualLocation
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("actualLocation")]
        public CefSharp.DevTools.Debugger.Location ActualLocation
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetInstrumentationBreakpointResponse
    /// </summary>
    public class SetInstrumentationBreakpointResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// breakpointId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("breakpointId")]
        public string BreakpointId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetBreakpointByUrlResponse
    /// </summary>
    public class SetBreakpointByUrlResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// breakpointId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("breakpointId")]
        public string BreakpointId
        {
            get;
            private set;
        }

        /// <summary>
        /// locations
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("locations")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.Location> Locations
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetBreakpointOnFunctionCallResponse
    /// </summary>
    public class SetBreakpointOnFunctionCallResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// breakpointId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("breakpointId")]
        public string BreakpointId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetScriptSourceResponse
    /// </summary>
    public class SetScriptSourceResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// callFrames
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("callFrames")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.CallFrame> CallFrames
        {
            get;
            private set;
        }

        /// <summary>
        /// stackChanged
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("stackChanged")]
        public bool? StackChanged
        {
            get;
            private set;
        }

        /// <summary>
        /// asyncStackTrace
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("asyncStackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace AsyncStackTrace
        {
            get;
            private set;
        }

        /// <summary>
        /// asyncStackTraceId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("asyncStackTraceId")]
        public CefSharp.DevTools.Runtime.StackTraceId AsyncStackTraceId
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    using System.Linq;

    /// <summary>
    /// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
    /// breakpoints, stepping through execution, exploring stack traces, etc.
    /// </summary>
    public partial class DebuggerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public DebuggerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateContinueToLocation(CefSharp.DevTools.Debugger.Location location, string targetCallFrames = null);
        /// <summary>
        /// Continues execution until specific location is reached.
        /// </summary>
        /// <param name = "location">Location to continue to.</param>
        /// <param name = "targetCallFrames">targetCallFrames</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ContinueToLocationAsync(CefSharp.DevTools.Debugger.Location location, string targetCallFrames = null)
        {
            ValidateContinueToLocation(location, targetCallFrames);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("location", location.ToDictionary());
            if (!(string.IsNullOrEmpty(targetCallFrames)))
            {
                dict.Add("targetCallFrames", targetCallFrames);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.continueToLocation", dict);
            return methodResult;
        }

        /// <summary>
        /// Disables debugger for given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.disable", dict);
            return methodResult;
        }

        partial void ValidateEnable(long? maxScriptsCacheSize = null);
        /// <summary>
        /// Enables debugger for the given page. Clients should not assume that the debugging has been
        /// enabled until the result for this command is received.
        /// </summary>
        /// <param name = "maxScriptsCacheSize">The maximum size in bytes of collected scripts (not referenced by other heap objects)the debugger can hold. Puts no limit if paramter is omitted.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;EnableResponse&gt;</returns>
        public async System.Threading.Tasks.Task<EnableResponse> EnableAsync(long? maxScriptsCacheSize = null)
        {
            ValidateEnable(maxScriptsCacheSize);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (maxScriptsCacheSize.HasValue)
            {
                dict.Add("maxScriptsCacheSize", maxScriptsCacheSize.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.enable", dict);
            return methodResult.DeserializeJson<EnableResponse>();
        }

        partial void ValidateEvaluateOnCallFrame(string callFrameId, string expression, string objectGroup = null, bool? includeCommandLineAPI = null, bool? silent = null, bool? returnByValue = null, bool? generatePreview = null, bool? throwOnSideEffect = null, long? timeout = null);
        /// <summary>
        /// Evaluates expression on a given call frame.
        /// </summary>
        /// <param name = "callFrameId">Call frame identifier to evaluate on.</param>
        /// <param name = "expression">Expression to evaluate.</param>
        /// <param name = "objectGroup">String object group name to put result into (allows rapid releasing resulting object handlesusing `releaseObjectGroup`).</param>
        /// <param name = "includeCommandLineAPI">Specifies whether command line API should be available to the evaluated expression, defaultsto false.</param>
        /// <param name = "silent">In silent mode exceptions thrown during evaluation are not reported and do not pauseexecution. Overrides `setPauseOnException` state.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <param name = "throwOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.</param>
        /// <param name = "timeout">Terminate execution after timing out (number of milliseconds).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;EvaluateOnCallFrameResponse&gt;</returns>
        public async System.Threading.Tasks.Task<EvaluateOnCallFrameResponse> EvaluateOnCallFrameAsync(string callFrameId, string expression, string objectGroup = null, bool? includeCommandLineAPI = null, bool? silent = null, bool? returnByValue = null, bool? generatePreview = null, bool? throwOnSideEffect = null, long? timeout = null)
        {
            ValidateEvaluateOnCallFrame(callFrameId, expression, objectGroup, includeCommandLineAPI, silent, returnByValue, generatePreview, throwOnSideEffect, timeout);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("callFrameId", callFrameId);
            dict.Add("expression", expression);
            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (includeCommandLineAPI.HasValue)
            {
                dict.Add("includeCommandLineAPI", includeCommandLineAPI.Value);
            }

            if (silent.HasValue)
            {
                dict.Add("silent", silent.Value);
            }

            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (throwOnSideEffect.HasValue)
            {
                dict.Add("throwOnSideEffect", throwOnSideEffect.Value);
            }

            if (timeout.HasValue)
            {
                dict.Add("timeout", timeout.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.evaluateOnCallFrame", dict);
            return methodResult.DeserializeJson<EvaluateOnCallFrameResponse>();
        }

        partial void ValidateExecuteWasmEvaluator(string callFrameId, byte[] evaluator, long? timeout = null);
        /// <summary>
        /// Execute a Wasm Evaluator module on a given call frame.
        /// </summary>
        /// <param name = "callFrameId">WebAssembly call frame identifier to evaluate on.</param>
        /// <param name = "evaluator">Code of the evaluator module.</param>
        /// <param name = "timeout">Terminate execution after timing out (number of milliseconds).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ExecuteWasmEvaluatorResponse&gt;</returns>
        public async System.Threading.Tasks.Task<ExecuteWasmEvaluatorResponse> ExecuteWasmEvaluatorAsync(string callFrameId, byte[] evaluator, long? timeout = null)
        {
            ValidateExecuteWasmEvaluator(callFrameId, evaluator, timeout);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("callFrameId", callFrameId);
            dict.Add("evaluator", ToBase64String(evaluator));
            if (timeout.HasValue)
            {
                dict.Add("timeout", timeout.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.executeWasmEvaluator", dict);
            return methodResult.DeserializeJson<ExecuteWasmEvaluatorResponse>();
        }

        partial void ValidateGetPossibleBreakpoints(CefSharp.DevTools.Debugger.Location start, CefSharp.DevTools.Debugger.Location end = null, bool? restrictToFunction = null);
        /// <summary>
        /// Returns possible locations for breakpoint. scriptId in start and end range locations should be
        /// the same.
        /// </summary>
        /// <param name = "start">Start of range to search possible breakpoint locations in.</param>
        /// <param name = "end">End of range to search possible breakpoint locations in (excluding). When not specified, endof scripts is used as end of range.</param>
        /// <param name = "restrictToFunction">Only consider locations which are in the same (non-nested) function as start.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPossibleBreakpointsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetPossibleBreakpointsResponse> GetPossibleBreakpointsAsync(CefSharp.DevTools.Debugger.Location start, CefSharp.DevTools.Debugger.Location end = null, bool? restrictToFunction = null)
        {
            ValidateGetPossibleBreakpoints(start, end, restrictToFunction);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("start", start.ToDictionary());
            if ((end) != (null))
            {
                dict.Add("end", end.ToDictionary());
            }

            if (restrictToFunction.HasValue)
            {
                dict.Add("restrictToFunction", restrictToFunction.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.getPossibleBreakpoints", dict);
            return methodResult.DeserializeJson<GetPossibleBreakpointsResponse>();
        }

        partial void ValidateGetScriptSource(string scriptId);
        /// <summary>
        /// Returns source for the script with given id.
        /// </summary>
        /// <param name = "scriptId">Id of the script to get source for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetScriptSourceResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetScriptSourceResponse> GetScriptSourceAsync(string scriptId)
        {
            ValidateGetScriptSource(scriptId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.getScriptSource", dict);
            return methodResult.DeserializeJson<GetScriptSourceResponse>();
        }

        partial void ValidateGetStackTrace(CefSharp.DevTools.Runtime.StackTraceId stackTraceId);
        /// <summary>
        /// Returns stack trace with given `stackTraceId`.
        /// </summary>
        /// <param name = "stackTraceId">stackTraceId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetStackTraceResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetStackTraceResponse> GetStackTraceAsync(CefSharp.DevTools.Runtime.StackTraceId stackTraceId)
        {
            ValidateGetStackTrace(stackTraceId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("stackTraceId", stackTraceId.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.getStackTrace", dict);
            return methodResult.DeserializeJson<GetStackTraceResponse>();
        }

        /// <summary>
        /// Stops on the next JavaScript statement.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> PauseAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.pause", dict);
            return methodResult;
        }

        partial void ValidateRemoveBreakpoint(string breakpointId);
        /// <summary>
        /// Removes JavaScript breakpoint.
        /// </summary>
        /// <param name = "breakpointId">breakpointId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveBreakpointAsync(string breakpointId)
        {
            ValidateRemoveBreakpoint(breakpointId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("breakpointId", breakpointId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.removeBreakpoint", dict);
            return methodResult;
        }

        partial void ValidateRestartFrame(string callFrameId);
        /// <summary>
        /// Restarts particular call frame from the beginning.
        /// </summary>
        /// <param name = "callFrameId">Call frame identifier to evaluate on.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RestartFrameResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RestartFrameResponse> RestartFrameAsync(string callFrameId)
        {
            ValidateRestartFrame(callFrameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("callFrameId", callFrameId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.restartFrame", dict);
            return methodResult.DeserializeJson<RestartFrameResponse>();
        }

        partial void ValidateResume(bool? terminateOnResume = null);
        /// <summary>
        /// Resumes JavaScript execution.
        /// </summary>
        /// <param name = "terminateOnResume">Set to true to terminate execution upon resuming execution. In contrastto Runtime.terminateExecution, this will allows to execute furtherJavaScript (i.e. via evaluation) until execution of the paused codeis actually resumed, at which point termination is triggered.If execution is currently not paused, this parameter has no effect.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ResumeAsync(bool? terminateOnResume = null)
        {
            ValidateResume(terminateOnResume);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (terminateOnResume.HasValue)
            {
                dict.Add("terminateOnResume", terminateOnResume.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.resume", dict);
            return methodResult;
        }

        partial void ValidateSearchInContent(string scriptId, string query, bool? caseSensitive = null, bool? isRegex = null);
        /// <summary>
        /// Searches for given string in script content.
        /// </summary>
        /// <param name = "scriptId">Id of the script to search in.</param>
        /// <param name = "query">String to search for.</param>
        /// <param name = "caseSensitive">If true, search is case sensitive.</param>
        /// <param name = "isRegex">If true, treats string parameter as regex.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SearchInContentResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SearchInContentResponse> SearchInContentAsync(string scriptId, string query, bool? caseSensitive = null, bool? isRegex = null)
        {
            ValidateSearchInContent(scriptId, query, caseSensitive, isRegex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            dict.Add("query", query);
            if (caseSensitive.HasValue)
            {
                dict.Add("caseSensitive", caseSensitive.Value);
            }

            if (isRegex.HasValue)
            {
                dict.Add("isRegex", isRegex.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.searchInContent", dict);
            return methodResult.DeserializeJson<SearchInContentResponse>();
        }

        partial void ValidateSetAsyncCallStackDepth(int maxDepth);
        /// <summary>
        /// Enables or disables async call stacks tracking.
        /// </summary>
        /// <param name = "maxDepth">Maximum depth of async call stacks. Setting to `0` will effectively disable collecting asynccall stacks (default).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetAsyncCallStackDepthAsync(int maxDepth)
        {
            ValidateSetAsyncCallStackDepth(maxDepth);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("maxDepth", maxDepth);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setAsyncCallStackDepth", dict);
            return methodResult;
        }

        partial void ValidateSetBlackboxPatterns(string[] patterns);
        /// <summary>
        /// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
        /// scripts with url matching one of the patterns. VM will try to leave blackboxed script by
        /// performing &apos;step in&apos; several times, finally resorting to &apos;step out&apos; if unsuccessful.
        /// </summary>
        /// <param name = "patterns">Array of regexps that will be used to check script url for blackbox state.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetBlackboxPatternsAsync(string[] patterns)
        {
            ValidateSetBlackboxPatterns(patterns);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("patterns", patterns);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setBlackboxPatterns", dict);
            return methodResult;
        }

        partial void ValidateSetBlackboxedRanges(string scriptId, System.Collections.Generic.IList<CefSharp.DevTools.Debugger.ScriptPosition> positions);
        /// <summary>
        /// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
        /// scripts by performing &apos;step in&apos; several times, finally resorting to &apos;step out&apos; if unsuccessful.
        /// Positions array contains positions where blackbox state is changed. First interval isn&apos;t
        /// blackboxed. Array should be sorted.
        /// </summary>
        /// <param name = "scriptId">Id of the script.</param>
        /// <param name = "positions">positions</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetBlackboxedRangesAsync(string scriptId, System.Collections.Generic.IList<CefSharp.DevTools.Debugger.ScriptPosition> positions)
        {
            ValidateSetBlackboxedRanges(scriptId, positions);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            dict.Add("positions", positions.Select(x => x.ToDictionary()));
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setBlackboxedRanges", dict);
            return methodResult;
        }

        partial void ValidateSetBreakpoint(CefSharp.DevTools.Debugger.Location location, string condition = null);
        /// <summary>
        /// Sets JavaScript breakpoint at a given location.
        /// </summary>
        /// <param name = "location">Location to set breakpoint in.</param>
        /// <param name = "condition">Expression to use as a breakpoint condition. When specified, debugger will only stop on thebreakpoint if this expression evaluates to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetBreakpointResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetBreakpointResponse> SetBreakpointAsync(CefSharp.DevTools.Debugger.Location location, string condition = null)
        {
            ValidateSetBreakpoint(location, condition);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("location", location.ToDictionary());
            if (!(string.IsNullOrEmpty(condition)))
            {
                dict.Add("condition", condition);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setBreakpoint", dict);
            return methodResult.DeserializeJson<SetBreakpointResponse>();
        }

        partial void ValidateSetInstrumentationBreakpoint(string instrumentation);
        /// <summary>
        /// Sets instrumentation breakpoint.
        /// </summary>
        /// <param name = "instrumentation">Instrumentation name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetInstrumentationBreakpointResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetInstrumentationBreakpointResponse> SetInstrumentationBreakpointAsync(string instrumentation)
        {
            ValidateSetInstrumentationBreakpoint(instrumentation);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("instrumentation", instrumentation);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setInstrumentationBreakpoint", dict);
            return methodResult.DeserializeJson<SetInstrumentationBreakpointResponse>();
        }

        partial void ValidateSetBreakpointByUrl(int lineNumber, string url = null, string urlRegex = null, string scriptHash = null, int? columnNumber = null, string condition = null);
        /// <summary>
        /// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
        /// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
        /// `locations` property. Further matching script parsing will result in subsequent
        /// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
        /// </summary>
        /// <param name = "lineNumber">Line number to set breakpoint at.</param>
        /// <param name = "url">URL of the resources to set breakpoint on.</param>
        /// <param name = "urlRegex">Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or`urlRegex` must be specified.</param>
        /// <param name = "scriptHash">Script hash of the resources to set breakpoint on.</param>
        /// <param name = "columnNumber">Offset in the line to set breakpoint at.</param>
        /// <param name = "condition">Expression to use as a breakpoint condition. When specified, debugger will only stop on thebreakpoint if this expression evaluates to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetBreakpointByUrlResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetBreakpointByUrlResponse> SetBreakpointByUrlAsync(int lineNumber, string url = null, string urlRegex = null, string scriptHash = null, int? columnNumber = null, string condition = null)
        {
            ValidateSetBreakpointByUrl(lineNumber, url, urlRegex, scriptHash, columnNumber, condition);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("lineNumber", lineNumber);
            if (!(string.IsNullOrEmpty(url)))
            {
                dict.Add("url", url);
            }

            if (!(string.IsNullOrEmpty(urlRegex)))
            {
                dict.Add("urlRegex", urlRegex);
            }

            if (!(string.IsNullOrEmpty(scriptHash)))
            {
                dict.Add("scriptHash", scriptHash);
            }

            if (columnNumber.HasValue)
            {
                dict.Add("columnNumber", columnNumber.Value);
            }

            if (!(string.IsNullOrEmpty(condition)))
            {
                dict.Add("condition", condition);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setBreakpointByUrl", dict);
            return methodResult.DeserializeJson<SetBreakpointByUrlResponse>();
        }

        partial void ValidateSetBreakpointOnFunctionCall(string objectId, string condition = null);
        /// <summary>
        /// Sets JavaScript breakpoint before each call to the given function.
        /// If another function was created from the same source as a given one,
        /// calling it will also trigger the breakpoint.
        /// </summary>
        /// <param name = "objectId">Function object id.</param>
        /// <param name = "condition">Expression to use as a breakpoint condition. When specified, debugger willstop on the breakpoint if this expression evaluates to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetBreakpointOnFunctionCallResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetBreakpointOnFunctionCallResponse> SetBreakpointOnFunctionCallAsync(string objectId, string condition = null)
        {
            ValidateSetBreakpointOnFunctionCall(objectId, condition);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            if (!(string.IsNullOrEmpty(condition)))
            {
                dict.Add("condition", condition);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setBreakpointOnFunctionCall", dict);
            return methodResult.DeserializeJson<SetBreakpointOnFunctionCallResponse>();
        }

        partial void ValidateSetBreakpointsActive(bool active);
        /// <summary>
        /// Activates / deactivates all breakpoints on the page.
        /// </summary>
        /// <param name = "active">New value for breakpoints active state.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetBreakpointsActiveAsync(bool active)
        {
            ValidateSetBreakpointsActive(active);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("active", active);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setBreakpointsActive", dict);
            return methodResult;
        }

        partial void ValidateSetPauseOnExceptions(string state);
        /// <summary>
        /// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
        /// no exceptions. Initial pause on exceptions state is `none`.
        /// </summary>
        /// <param name = "state">Pause on exceptions mode.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetPauseOnExceptionsAsync(string state)
        {
            ValidateSetPauseOnExceptions(state);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("state", state);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setPauseOnExceptions", dict);
            return methodResult;
        }

        partial void ValidateSetReturnValue(CefSharp.DevTools.Runtime.CallArgument newValue);
        /// <summary>
        /// Changes return value in top frame. Available only at return break position.
        /// </summary>
        /// <param name = "newValue">New return value.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetReturnValueAsync(CefSharp.DevTools.Runtime.CallArgument newValue)
        {
            ValidateSetReturnValue(newValue);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("newValue", newValue.ToDictionary());
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setReturnValue", dict);
            return methodResult;
        }

        partial void ValidateSetScriptSource(string scriptId, string scriptSource, bool? dryRun = null);
        /// <summary>
        /// Edits JavaScript source live.
        /// </summary>
        /// <param name = "scriptId">Id of the script to edit.</param>
        /// <param name = "scriptSource">New content of the script.</param>
        /// <param name = "dryRun">If true the change will not actually be applied. Dry run may be used to get resultdescription without actually modifying the code.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetScriptSourceResponse&gt;</returns>
        public async System.Threading.Tasks.Task<SetScriptSourceResponse> SetScriptSourceAsync(string scriptId, string scriptSource, bool? dryRun = null)
        {
            ValidateSetScriptSource(scriptId, scriptSource, dryRun);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            dict.Add("scriptSource", scriptSource);
            if (dryRun.HasValue)
            {
                dict.Add("dryRun", dryRun.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setScriptSource", dict);
            return methodResult.DeserializeJson<SetScriptSourceResponse>();
        }

        partial void ValidateSetSkipAllPauses(bool skip);
        /// <summary>
        /// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
        /// </summary>
        /// <param name = "skip">New value for skip pauses state.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetSkipAllPausesAsync(bool skip)
        {
            ValidateSetSkipAllPauses(skip);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("skip", skip);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setSkipAllPauses", dict);
            return methodResult;
        }

        partial void ValidateSetVariableValue(int scopeNumber, string variableName, CefSharp.DevTools.Runtime.CallArgument newValue, string callFrameId);
        /// <summary>
        /// Changes value of variable in a callframe. Object-based scopes are not supported and must be
        /// mutated manually.
        /// </summary>
        /// <param name = "scopeNumber">0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'scope types are allowed. Other scopes could be manipulated manually.</param>
        /// <param name = "variableName">Variable name.</param>
        /// <param name = "newValue">New variable value.</param>
        /// <param name = "callFrameId">Id of callframe that holds variable.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetVariableValueAsync(int scopeNumber, string variableName, CefSharp.DevTools.Runtime.CallArgument newValue, string callFrameId)
        {
            ValidateSetVariableValue(scopeNumber, variableName, newValue, callFrameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeNumber", scopeNumber);
            dict.Add("variableName", variableName);
            dict.Add("newValue", newValue.ToDictionary());
            dict.Add("callFrameId", callFrameId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.setVariableValue", dict);
            return methodResult;
        }

        partial void ValidateStepInto(bool? breakOnAsyncCall = null, System.Collections.Generic.IList<CefSharp.DevTools.Debugger.LocationRange> skipList = null);
        /// <summary>
        /// Steps into the function call.
        /// </summary>
        /// <param name = "breakOnAsyncCall">Debugger will pause on the execution of the first async task which was scheduledbefore next pause.</param>
        /// <param name = "skipList">The skipList specifies location ranges that should be skipped on step into.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StepIntoAsync(bool? breakOnAsyncCall = null, System.Collections.Generic.IList<CefSharp.DevTools.Debugger.LocationRange> skipList = null)
        {
            ValidateStepInto(breakOnAsyncCall, skipList);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (breakOnAsyncCall.HasValue)
            {
                dict.Add("breakOnAsyncCall", breakOnAsyncCall.Value);
            }

            if ((skipList) != (null))
            {
                dict.Add("skipList", skipList.Select(x => x.ToDictionary()));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.stepInto", dict);
            return methodResult;
        }

        /// <summary>
        /// Steps out of the function call.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StepOutAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.stepOut", dict);
            return methodResult;
        }

        partial void ValidateStepOver(System.Collections.Generic.IList<CefSharp.DevTools.Debugger.LocationRange> skipList = null);
        /// <summary>
        /// Steps over the statement.
        /// </summary>
        /// <param name = "skipList">The skipList specifies location ranges that should be skipped on step over.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StepOverAsync(System.Collections.Generic.IList<CefSharp.DevTools.Debugger.LocationRange> skipList = null)
        {
            ValidateStepOver(skipList);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((skipList) != (null))
            {
                dict.Add("skipList", skipList.Select(x => x.ToDictionary()));
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Debugger.stepOver", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// GetHeapObjectIdResponse
    /// </summary>
    public class GetHeapObjectIdResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// heapSnapshotObjectId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("heapSnapshotObjectId")]
        public string HeapSnapshotObjectId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// GetObjectByHeapObjectIdResponse
    /// </summary>
    public class GetObjectByHeapObjectIdResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// GetSamplingProfileResponse
    /// </summary>
    public class GetSamplingProfileResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("profile")]
        public CefSharp.DevTools.HeapProfiler.SamplingHeapProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// StopSamplingResponse
    /// </summary>
    public class StopSamplingResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("profile")]
        public CefSharp.DevTools.HeapProfiler.SamplingHeapProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    using System.Linq;

    /// <summary>
    /// HeapProfiler
    /// </summary>
    public partial class HeapProfilerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public HeapProfilerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateAddInspectedHeapObject(string heapObjectId);
        /// <summary>
        /// Enables console to refer to the node with given id via $x (see Command Line API for more details
        /// $x functions).
        /// </summary>
        /// <param name = "heapObjectId">Heap snapshot object id to be accessible by means of $x command line API.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> AddInspectedHeapObjectAsync(string heapObjectId)
        {
            ValidateAddInspectedHeapObject(heapObjectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("heapObjectId", heapObjectId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.addInspectedHeapObject", dict);
            return methodResult;
        }

        /// <summary>
        /// CollectGarbage
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> CollectGarbageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.collectGarbage", dict);
            return methodResult;
        }

        /// <summary>
        /// Disable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.enable", dict);
            return methodResult;
        }

        partial void ValidateGetHeapObjectId(string objectId);
        /// <summary>
        /// GetHeapObjectId
        /// </summary>
        /// <param name = "objectId">Identifier of the object to get heap object id for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHeapObjectIdResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetHeapObjectIdResponse> GetHeapObjectIdAsync(string objectId)
        {
            ValidateGetHeapObjectId(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.getHeapObjectId", dict);
            return methodResult.DeserializeJson<GetHeapObjectIdResponse>();
        }

        partial void ValidateGetObjectByHeapObjectId(string objectId, string objectGroup = null);
        /// <summary>
        /// GetObjectByHeapObjectId
        /// </summary>
        /// <param name = "objectId">objectId</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetObjectByHeapObjectIdResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetObjectByHeapObjectIdResponse> GetObjectByHeapObjectIdAsync(string objectId, string objectGroup = null)
        {
            ValidateGetObjectByHeapObjectId(objectId, objectGroup);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.getObjectByHeapObjectId", dict);
            return methodResult.DeserializeJson<GetObjectByHeapObjectIdResponse>();
        }

        /// <summary>
        /// GetSamplingProfile
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSamplingProfileResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetSamplingProfileResponse> GetSamplingProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.getSamplingProfile", dict);
            return methodResult.DeserializeJson<GetSamplingProfileResponse>();
        }

        partial void ValidateStartSampling(long? samplingInterval = null);
        /// <summary>
        /// StartSampling
        /// </summary>
        /// <param name = "samplingInterval">Average sample interval in bytes. Poisson distribution is used for the intervals. Thedefault value is 32768 bytes.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartSamplingAsync(long? samplingInterval = null)
        {
            ValidateStartSampling(samplingInterval);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (samplingInterval.HasValue)
            {
                dict.Add("samplingInterval", samplingInterval.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.startSampling", dict);
            return methodResult;
        }

        partial void ValidateStartTrackingHeapObjects(bool? trackAllocations = null);
        /// <summary>
        /// StartTrackingHeapObjects
        /// </summary>
        /// <param name = "trackAllocations">trackAllocations</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartTrackingHeapObjectsAsync(bool? trackAllocations = null)
        {
            ValidateStartTrackingHeapObjects(trackAllocations);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (trackAllocations.HasValue)
            {
                dict.Add("trackAllocations", trackAllocations.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.startTrackingHeapObjects", dict);
            return methodResult;
        }

        /// <summary>
        /// StopSampling
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;StopSamplingResponse&gt;</returns>
        public async System.Threading.Tasks.Task<StopSamplingResponse> StopSamplingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.stopSampling", dict);
            return methodResult.DeserializeJson<StopSamplingResponse>();
        }

        partial void ValidateStopTrackingHeapObjects(bool? reportProgress = null, bool? treatGlobalObjectsAsRoots = null);
        /// <summary>
        /// StopTrackingHeapObjects
        /// </summary>
        /// <param name = "reportProgress">If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being takenwhen the tracking is stopped.</param>
        /// <param name = "treatGlobalObjectsAsRoots">treatGlobalObjectsAsRoots</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopTrackingHeapObjectsAsync(bool? reportProgress = null, bool? treatGlobalObjectsAsRoots = null)
        {
            ValidateStopTrackingHeapObjects(reportProgress, treatGlobalObjectsAsRoots);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (reportProgress.HasValue)
            {
                dict.Add("reportProgress", reportProgress.Value);
            }

            if (treatGlobalObjectsAsRoots.HasValue)
            {
                dict.Add("treatGlobalObjectsAsRoots", treatGlobalObjectsAsRoots.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.stopTrackingHeapObjects", dict);
            return methodResult;
        }

        partial void ValidateTakeHeapSnapshot(bool? reportProgress = null, bool? treatGlobalObjectsAsRoots = null);
        /// <summary>
        /// TakeHeapSnapshot
        /// </summary>
        /// <param name = "reportProgress">If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.</param>
        /// <param name = "treatGlobalObjectsAsRoots">If true, a raw snapshot without artifical roots will be generated</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> TakeHeapSnapshotAsync(bool? reportProgress = null, bool? treatGlobalObjectsAsRoots = null)
        {
            ValidateTakeHeapSnapshot(reportProgress, treatGlobalObjectsAsRoots);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (reportProgress.HasValue)
            {
                dict.Add("reportProgress", reportProgress.Value);
            }

            if (treatGlobalObjectsAsRoots.HasValue)
            {
                dict.Add("treatGlobalObjectsAsRoots", treatGlobalObjectsAsRoots.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("HeapProfiler.takeHeapSnapshot", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// GetBestEffortCoverageResponse
    /// </summary>
    public class GetBestEffortCoverageResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.ScriptCoverage> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// StartPreciseCoverageResponse
    /// </summary>
    public class StartPreciseCoverageResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// timestamp
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timestamp")]
        public long Timestamp
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// StopResponse
    /// </summary>
    public class StopResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("profile")]
        public CefSharp.DevTools.Profiler.Profile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// TakePreciseCoverageResponse
    /// </summary>
    public class TakePreciseCoverageResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.ScriptCoverage> Result
        {
            get;
            private set;
        }

        /// <summary>
        /// timestamp
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("timestamp")]
        public long Timestamp
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// TakeTypeProfileResponse
    /// </summary>
    public class TakeTypeProfileResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.ScriptTypeProfile> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// GetCountersResponse
    /// </summary>
    public class GetCountersResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.CounterInfo> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// GetRuntimeCallStatsResponse
    /// </summary>
    public class GetRuntimeCallStatsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.RuntimeCallCounterInfo> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    using System.Linq;

    /// <summary>
    /// Profiler
    /// </summary>
    public partial class ProfilerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public ProfilerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Enable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.enable", dict);
            return methodResult;
        }

        /// <summary>
        /// Collect coverage data for the current isolate. The coverage data may be incomplete due to
        /// garbage collection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBestEffortCoverageResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetBestEffortCoverageResponse> GetBestEffortCoverageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.getBestEffortCoverage", dict);
            return methodResult.DeserializeJson<GetBestEffortCoverageResponse>();
        }

        partial void ValidateSetSamplingInterval(int interval);
        /// <summary>
        /// Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
        /// </summary>
        /// <param name = "interval">New sampling interval in microseconds.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetSamplingIntervalAsync(int interval)
        {
            ValidateSetSamplingInterval(interval);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("interval", interval);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.setSamplingInterval", dict);
            return methodResult;
        }

        /// <summary>
        /// Start
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.start", dict);
            return methodResult;
        }

        partial void ValidateStartPreciseCoverage(bool? callCount = null, bool? detailed = null, bool? allowTriggeredUpdates = null);
        /// <summary>
        /// Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
        /// coverage may be incomplete. Enabling prevents running optimized code and resets execution
        /// counters.
        /// </summary>
        /// <param name = "callCount">Collect accurate call counts beyond simple 'covered' or 'not covered'.</param>
        /// <param name = "detailed">Collect block-based coverage.</param>
        /// <param name = "allowTriggeredUpdates">Allow the backend to send updates on its own initiative</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;StartPreciseCoverageResponse&gt;</returns>
        public async System.Threading.Tasks.Task<StartPreciseCoverageResponse> StartPreciseCoverageAsync(bool? callCount = null, bool? detailed = null, bool? allowTriggeredUpdates = null)
        {
            ValidateStartPreciseCoverage(callCount, detailed, allowTriggeredUpdates);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (callCount.HasValue)
            {
                dict.Add("callCount", callCount.Value);
            }

            if (detailed.HasValue)
            {
                dict.Add("detailed", detailed.Value);
            }

            if (allowTriggeredUpdates.HasValue)
            {
                dict.Add("allowTriggeredUpdates", allowTriggeredUpdates.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.startPreciseCoverage", dict);
            return methodResult.DeserializeJson<StartPreciseCoverageResponse>();
        }

        /// <summary>
        /// Enable type profile.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StartTypeProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.startTypeProfile", dict);
            return methodResult;
        }

        /// <summary>
        /// Stop
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;StopResponse&gt;</returns>
        public async System.Threading.Tasks.Task<StopResponse> StopAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.stop", dict);
            return methodResult.DeserializeJson<StopResponse>();
        }

        /// <summary>
        /// Disable precise code coverage. Disabling releases unnecessary execution count records and allows
        /// executing optimized code.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopPreciseCoverageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.stopPreciseCoverage", dict);
            return methodResult;
        }

        /// <summary>
        /// Disable type profile. Disabling releases type profile data collected so far.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> StopTypeProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.stopTypeProfile", dict);
            return methodResult;
        }

        /// <summary>
        /// Collect coverage data for the current isolate, and resets execution counters. Precise code
        /// coverage needs to have started.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakePreciseCoverageResponse&gt;</returns>
        public async System.Threading.Tasks.Task<TakePreciseCoverageResponse> TakePreciseCoverageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.takePreciseCoverage", dict);
            return methodResult.DeserializeJson<TakePreciseCoverageResponse>();
        }

        /// <summary>
        /// Collect type profile.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeTypeProfileResponse&gt;</returns>
        public async System.Threading.Tasks.Task<TakeTypeProfileResponse> TakeTypeProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.takeTypeProfile", dict);
            return methodResult.DeserializeJson<TakeTypeProfileResponse>();
        }

        /// <summary>
        /// Enable counters collection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableCountersAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.enableCounters", dict);
            return methodResult;
        }

        /// <summary>
        /// Disable counters collection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableCountersAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.disableCounters", dict);
            return methodResult;
        }

        /// <summary>
        /// Retrieve counters.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCountersResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetCountersResponse> GetCountersAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.getCounters", dict);
            return methodResult.DeserializeJson<GetCountersResponse>();
        }

        /// <summary>
        /// Enable run time call stats collection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableRuntimeCallStatsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.enableRuntimeCallStats", dict);
            return methodResult;
        }

        /// <summary>
        /// Disable run time call stats collection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableRuntimeCallStatsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.disableRuntimeCallStats", dict);
            return methodResult;
        }

        /// <summary>
        /// Retrieve run time call stats.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetRuntimeCallStatsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetRuntimeCallStatsResponse> GetRuntimeCallStatsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Profiler.getRuntimeCallStats", dict);
            return methodResult.DeserializeJson<GetRuntimeCallStatsResponse>();
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// AwaitPromiseResponse
    /// </summary>
    public class AwaitPromiseResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// CallFunctionOnResponse
    /// </summary>
    public class CallFunctionOnResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// CompileScriptResponse
    /// </summary>
    public class CompileScriptResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// scriptId
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scriptId")]
        public string ScriptId
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// EvaluateResponse
    /// </summary>
    public class EvaluateResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GetIsolateIdResponse
    /// </summary>
    public class GetIsolateIdResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// id
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("id")]
        public string Id
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GetHeapUsageResponse
    /// </summary>
    public class GetHeapUsageResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// usedSize
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("usedSize")]
        public long UsedSize
        {
            get;
            private set;
        }

        /// <summary>
        /// totalSize
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("totalSize")]
        public long TotalSize
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GetPropertiesResponse
    /// </summary>
    public class GetPropertiesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.PropertyDescriptor> Result
        {
            get;
            private set;
        }

        /// <summary>
        /// internalProperties
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("internalProperties")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.InternalPropertyDescriptor> InternalProperties
        {
            get;
            private set;
        }

        /// <summary>
        /// privateProperties
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("privateProperties")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.PrivatePropertyDescriptor> PrivateProperties
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GlobalLexicalScopeNamesResponse
    /// </summary>
    public class GlobalLexicalScopeNamesResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// names
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("names")]
        public string[] Names
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// QueryObjectsResponse
    /// </summary>
    public class QueryObjectsResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// objects
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("objects")]
        public CefSharp.DevTools.Runtime.RemoteObject Objects
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// RunScriptResponse
    /// </summary>
    public class RunScriptResponse : CefSharp.DevTools.DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [System.Text.Json.Serialization.JsonIncludeAttribute]
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    using System.Linq;

    /// <summary>
    /// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
    /// Evaluation results are returned as mirror object that expose object type, string representation
    /// and unique identifier that can be used for further object reference. Original objects are
    /// maintained in memory unless they are either explicitly released or are released along with the
    /// other objects in their object group.
    /// </summary>
    public partial class RuntimeClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        public RuntimeClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateAwaitPromise(string promiseObjectId, bool? returnByValue = null, bool? generatePreview = null);
        /// <summary>
        /// Add handler to promise with given promise object id.
        /// </summary>
        /// <param name = "promiseObjectId">Identifier of the promise.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AwaitPromiseResponse&gt;</returns>
        public async System.Threading.Tasks.Task<AwaitPromiseResponse> AwaitPromiseAsync(string promiseObjectId, bool? returnByValue = null, bool? generatePreview = null)
        {
            ValidateAwaitPromise(promiseObjectId, returnByValue, generatePreview);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("promiseObjectId", promiseObjectId);
            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.awaitPromise", dict);
            return methodResult.DeserializeJson<AwaitPromiseResponse>();
        }

        partial void ValidateCallFunctionOn(string functionDeclaration, string objectId = null, System.Collections.Generic.IList<CefSharp.DevTools.Runtime.CallArgument> arguments = null, bool? silent = null, bool? returnByValue = null, bool? generatePreview = null, bool? userGesture = null, bool? awaitPromise = null, int? executionContextId = null, string objectGroup = null);
        /// <summary>
        /// Calls function with given declaration on the given object. Object group of the result is
        /// inherited from the target object.
        /// </summary>
        /// <param name = "functionDeclaration">Declaration of the function to call.</param>
        /// <param name = "objectId">Identifier of the object to call function on. Either objectId or executionContextId shouldbe specified.</param>
        /// <param name = "arguments">Call arguments. All call arguments must belong to the same JavaScript world as the targetobject.</param>
        /// <param name = "silent">In silent mode exceptions thrown during evaluation are not reported and do not pauseexecution. Overrides `setPauseOnException` state.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object which should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <param name = "userGesture">Whether execution should be treated as initiated by user in the UI.</param>
        /// <param name = "awaitPromise">Whether execution should `await` for resulting value and return once awaited promise isresolved.</param>
        /// <param name = "executionContextId">Specifies execution context which global object will be used to call function on. EitherexecutionContextId or objectId should be specified.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects. If objectGroup is notspecified and objectId is, objectGroup will be inherited from object.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CallFunctionOnResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CallFunctionOnResponse> CallFunctionOnAsync(string functionDeclaration, string objectId = null, System.Collections.Generic.IList<CefSharp.DevTools.Runtime.CallArgument> arguments = null, bool? silent = null, bool? returnByValue = null, bool? generatePreview = null, bool? userGesture = null, bool? awaitPromise = null, int? executionContextId = null, string objectGroup = null)
        {
            ValidateCallFunctionOn(functionDeclaration, objectId, arguments, silent, returnByValue, generatePreview, userGesture, awaitPromise, executionContextId, objectGroup);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("functionDeclaration", functionDeclaration);
            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if ((arguments) != (null))
            {
                dict.Add("arguments", arguments.Select(x => x.ToDictionary()));
            }

            if (silent.HasValue)
            {
                dict.Add("silent", silent.Value);
            }

            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (userGesture.HasValue)
            {
                dict.Add("userGesture", userGesture.Value);
            }

            if (awaitPromise.HasValue)
            {
                dict.Add("awaitPromise", awaitPromise.Value);
            }

            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.callFunctionOn", dict);
            return methodResult.DeserializeJson<CallFunctionOnResponse>();
        }

        partial void ValidateCompileScript(string expression, string sourceURL, bool persistScript, int? executionContextId = null);
        /// <summary>
        /// Compiles expression.
        /// </summary>
        /// <param name = "expression">Expression to compile.</param>
        /// <param name = "sourceURL">Source url to be set for the script.</param>
        /// <param name = "persistScript">Specifies whether the compiled script should be persisted.</param>
        /// <param name = "executionContextId">Specifies in which execution context to perform script run. If the parameter is omitted theevaluation will be performed in the context of the inspected page.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CompileScriptResponse&gt;</returns>
        public async System.Threading.Tasks.Task<CompileScriptResponse> CompileScriptAsync(string expression, string sourceURL, bool persistScript, int? executionContextId = null)
        {
            ValidateCompileScript(expression, sourceURL, persistScript, executionContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("expression", expression);
            dict.Add("sourceURL", sourceURL);
            dict.Add("persistScript", persistScript);
            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.compileScript", dict);
            return methodResult.DeserializeJson<CompileScriptResponse>();
        }

        /// <summary>
        /// Disables reporting of execution contexts creation.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.disable", dict);
            return methodResult;
        }

        /// <summary>
        /// Discards collected exceptions and console API calls.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> DiscardConsoleEntriesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.discardConsoleEntries", dict);
            return methodResult;
        }

        /// <summary>
        /// Enables reporting of execution contexts creation by means of `executionContextCreated` event.
        /// When the reporting gets enabled the event will be sent immediately for each existing execution
        /// context.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.enable", dict);
            return methodResult;
        }

        partial void ValidateEvaluate(string expression, string objectGroup = null, bool? includeCommandLineAPI = null, bool? silent = null, int? contextId = null, bool? returnByValue = null, bool? generatePreview = null, bool? userGesture = null, bool? awaitPromise = null, bool? throwOnSideEffect = null, long? timeout = null, bool? disableBreaks = null, bool? replMode = null, bool? allowUnsafeEvalBlockedByCSP = null);
        /// <summary>
        /// Evaluates expression on global object.
        /// </summary>
        /// <param name = "expression">Expression to evaluate.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects.</param>
        /// <param name = "includeCommandLineAPI">Determines whether Command Line API should be available during the evaluation.</param>
        /// <param name = "silent">In silent mode exceptions thrown during evaluation are not reported and do not pauseexecution. Overrides `setPauseOnException` state.</param>
        /// <param name = "contextId">Specifies in which execution context to perform evaluation. If the parameter is omitted theevaluation will be performed in the context of the inspected page.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <param name = "userGesture">Whether execution should be treated as initiated by user in the UI.</param>
        /// <param name = "awaitPromise">Whether execution should `await` for resulting value and return once awaited promise isresolved.</param>
        /// <param name = "throwOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.This implies `disableBreaks` below.</param>
        /// <param name = "timeout">Terminate execution after timing out (number of milliseconds).</param>
        /// <param name = "disableBreaks">Disable breakpoints during execution.</param>
        /// <param name = "replMode">Setting this flag to true enables `let` re-declaration and top-level `await`.Note that `let` variables can only be re-declared if they originate from`replMode` themselves.</param>
        /// <param name = "allowUnsafeEvalBlockedByCSP">The Content Security Policy (CSP) for the target might block 'unsafe-eval'which includes eval(), Function(), setTimeout() and setInterval()when called with non-callable arguments. This flag bypasses CSP for thisevaluation and allows unsafe-eval. Defaults to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;EvaluateResponse&gt;</returns>
        public async System.Threading.Tasks.Task<EvaluateResponse> EvaluateAsync(string expression, string objectGroup = null, bool? includeCommandLineAPI = null, bool? silent = null, int? contextId = null, bool? returnByValue = null, bool? generatePreview = null, bool? userGesture = null, bool? awaitPromise = null, bool? throwOnSideEffect = null, long? timeout = null, bool? disableBreaks = null, bool? replMode = null, bool? allowUnsafeEvalBlockedByCSP = null)
        {
            ValidateEvaluate(expression, objectGroup, includeCommandLineAPI, silent, contextId, returnByValue, generatePreview, userGesture, awaitPromise, throwOnSideEffect, timeout, disableBreaks, replMode, allowUnsafeEvalBlockedByCSP);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("expression", expression);
            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (includeCommandLineAPI.HasValue)
            {
                dict.Add("includeCommandLineAPI", includeCommandLineAPI.Value);
            }

            if (silent.HasValue)
            {
                dict.Add("silent", silent.Value);
            }

            if (contextId.HasValue)
            {
                dict.Add("contextId", contextId.Value);
            }

            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (userGesture.HasValue)
            {
                dict.Add("userGesture", userGesture.Value);
            }

            if (awaitPromise.HasValue)
            {
                dict.Add("awaitPromise", awaitPromise.Value);
            }

            if (throwOnSideEffect.HasValue)
            {
                dict.Add("throwOnSideEffect", throwOnSideEffect.Value);
            }

            if (timeout.HasValue)
            {
                dict.Add("timeout", timeout.Value);
            }

            if (disableBreaks.HasValue)
            {
                dict.Add("disableBreaks", disableBreaks.Value);
            }

            if (replMode.HasValue)
            {
                dict.Add("replMode", replMode.Value);
            }

            if (allowUnsafeEvalBlockedByCSP.HasValue)
            {
                dict.Add("allowUnsafeEvalBlockedByCSP", allowUnsafeEvalBlockedByCSP.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.evaluate", dict);
            return methodResult.DeserializeJson<EvaluateResponse>();
        }

        /// <summary>
        /// Returns the isolate id.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetIsolateIdResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetIsolateIdResponse> GetIsolateIdAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.getIsolateId", dict);
            return methodResult.DeserializeJson<GetIsolateIdResponse>();
        }

        /// <summary>
        /// Returns the JavaScript heap usage.
        /// It is the total usage of the corresponding isolate not scoped to a particular Runtime.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHeapUsageResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetHeapUsageResponse> GetHeapUsageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.getHeapUsage", dict);
            return methodResult.DeserializeJson<GetHeapUsageResponse>();
        }

        partial void ValidateGetProperties(string objectId, bool? ownProperties = null, bool? accessorPropertiesOnly = null, bool? generatePreview = null);
        /// <summary>
        /// Returns properties of a given object. Object group of the result is inherited from the target
        /// object.
        /// </summary>
        /// <param name = "objectId">Identifier of the object to return properties for.</param>
        /// <param name = "ownProperties">If true, returns properties belonging only to the element itself, not to its prototypechain.</param>
        /// <param name = "accessorPropertiesOnly">If true, returns accessor properties (with getter/setter) only; internal properties are notreturned either.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the results.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPropertiesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GetPropertiesResponse> GetPropertiesAsync(string objectId, bool? ownProperties = null, bool? accessorPropertiesOnly = null, bool? generatePreview = null)
        {
            ValidateGetProperties(objectId, ownProperties, accessorPropertiesOnly, generatePreview);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            if (ownProperties.HasValue)
            {
                dict.Add("ownProperties", ownProperties.Value);
            }

            if (accessorPropertiesOnly.HasValue)
            {
                dict.Add("accessorPropertiesOnly", accessorPropertiesOnly.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.getProperties", dict);
            return methodResult.DeserializeJson<GetPropertiesResponse>();
        }

        partial void ValidateGlobalLexicalScopeNames(int? executionContextId = null);
        /// <summary>
        /// Returns all let, const and class variables from global scope.
        /// </summary>
        /// <param name = "executionContextId">Specifies in which execution context to lookup global scope variables.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GlobalLexicalScopeNamesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<GlobalLexicalScopeNamesResponse> GlobalLexicalScopeNamesAsync(int? executionContextId = null)
        {
            ValidateGlobalLexicalScopeNames(executionContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.globalLexicalScopeNames", dict);
            return methodResult.DeserializeJson<GlobalLexicalScopeNamesResponse>();
        }

        partial void ValidateQueryObjects(string prototypeObjectId, string objectGroup = null);
        /// <summary>
        /// QueryObjects
        /// </summary>
        /// <param name = "prototypeObjectId">Identifier of the prototype to return objects for.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release the results.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;QueryObjectsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<QueryObjectsResponse> QueryObjectsAsync(string prototypeObjectId, string objectGroup = null)
        {
            ValidateQueryObjects(prototypeObjectId, objectGroup);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("prototypeObjectId", prototypeObjectId);
            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.queryObjects", dict);
            return methodResult.DeserializeJson<QueryObjectsResponse>();
        }

        partial void ValidateReleaseObject(string objectId);
        /// <summary>
        /// Releases remote object with given id.
        /// </summary>
        /// <param name = "objectId">Identifier of the object to release.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ReleaseObjectAsync(string objectId)
        {
            ValidateReleaseObject(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.releaseObject", dict);
            return methodResult;
        }

        partial void ValidateReleaseObjectGroup(string objectGroup);
        /// <summary>
        /// Releases all remote objects that belong to a given group.
        /// </summary>
        /// <param name = "objectGroup">Symbolic object group name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> ReleaseObjectGroupAsync(string objectGroup)
        {
            ValidateReleaseObjectGroup(objectGroup);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectGroup", objectGroup);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.releaseObjectGroup", dict);
            return methodResult;
        }

        /// <summary>
        /// Tells inspected instance to run if it was waiting for debugger to attach.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RunIfWaitingForDebuggerAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.runIfWaitingForDebugger", dict);
            return methodResult;
        }

        partial void ValidateRunScript(string scriptId, int? executionContextId = null, string objectGroup = null, bool? silent = null, bool? includeCommandLineAPI = null, bool? returnByValue = null, bool? generatePreview = null, bool? awaitPromise = null);
        /// <summary>
        /// Runs script with given id in a given context.
        /// </summary>
        /// <param name = "scriptId">Id of the script to run.</param>
        /// <param name = "executionContextId">Specifies in which execution context to perform script run. If the parameter is omitted theevaluation will be performed in the context of the inspected page.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects.</param>
        /// <param name = "silent">In silent mode exceptions thrown during evaluation are not reported and do not pauseexecution. Overrides `setPauseOnException` state.</param>
        /// <param name = "includeCommandLineAPI">Determines whether Command Line API should be available during the evaluation.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object which should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <param name = "awaitPromise">Whether execution should `await` for resulting value and return once awaited promise isresolved.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RunScriptResponse&gt;</returns>
        public async System.Threading.Tasks.Task<RunScriptResponse> RunScriptAsync(string scriptId, int? executionContextId = null, string objectGroup = null, bool? silent = null, bool? includeCommandLineAPI = null, bool? returnByValue = null, bool? generatePreview = null, bool? awaitPromise = null)
        {
            ValidateRunScript(scriptId, executionContextId, objectGroup, silent, includeCommandLineAPI, returnByValue, generatePreview, awaitPromise);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (silent.HasValue)
            {
                dict.Add("silent", silent.Value);
            }

            if (includeCommandLineAPI.HasValue)
            {
                dict.Add("includeCommandLineAPI", includeCommandLineAPI.Value);
            }

            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (awaitPromise.HasValue)
            {
                dict.Add("awaitPromise", awaitPromise.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.runScript", dict);
            return methodResult.DeserializeJson<RunScriptResponse>();
        }

        partial void ValidateSetAsyncCallStackDepth(int maxDepth);
        /// <summary>
        /// Enables or disables async call stacks tracking.
        /// </summary>
        /// <param name = "maxDepth">Maximum depth of async call stacks. Setting to `0` will effectively disable collecting asynccall stacks (default).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetAsyncCallStackDepthAsync(int maxDepth)
        {
            ValidateSetAsyncCallStackDepth(maxDepth);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("maxDepth", maxDepth);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.setAsyncCallStackDepth", dict);
            return methodResult;
        }

        partial void ValidateSetCustomObjectFormatterEnabled(bool enabled);
        /// <summary>
        /// SetCustomObjectFormatterEnabled
        /// </summary>
        /// <param name = "enabled">enabled</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetCustomObjectFormatterEnabledAsync(bool enabled)
        {
            ValidateSetCustomObjectFormatterEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.setCustomObjectFormatterEnabled", dict);
            return methodResult;
        }

        partial void ValidateSetMaxCallStackSizeToCapture(int size);
        /// <summary>
        /// SetMaxCallStackSizeToCapture
        /// </summary>
        /// <param name = "size">size</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> SetMaxCallStackSizeToCaptureAsync(int size)
        {
            ValidateSetMaxCallStackSizeToCapture(size);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("size", size);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.setMaxCallStackSizeToCapture", dict);
            return methodResult;
        }

        /// <summary>
        /// Terminate current or next JavaScript execution.
        /// Will cancel the termination when the outer-most script execution ends.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> TerminateExecutionAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.terminateExecution", dict);
            return methodResult;
        }

        partial void ValidateAddBinding(string name, int? executionContextId = null);
        /// <summary>
        /// If executionContextId is empty, adds binding with the given name on the
        /// global objects of all inspected contexts, including those created later,
        /// bindings survive reloads.
        /// If executionContextId is specified, adds binding only on global object of
        /// given execution context.
        /// Binding function takes exactly one argument, this argument should be string,
        /// in case of any other input, function throws an exception.
        /// Each binding function call produces Runtime.bindingCalled notification.
        /// </summary>
        /// <param name = "name">name</param>
        /// <param name = "executionContextId">executionContextId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> AddBindingAsync(string name, int? executionContextId = null)
        {
            ValidateAddBinding(name, executionContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.addBinding", dict);
            return methodResult;
        }

        partial void ValidateRemoveBinding(string name);
        /// <summary>
        /// This method does not remove binding function from global object but
        /// unsubscribes current runtime agent from Runtime.bindingCalled notifications.
        /// </summary>
        /// <param name = "name">name</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public async System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveBindingAsync(string name)
        {
            ValidateRemoveBinding(name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            var methodResult = await _client.ExecuteDevToolsMethodAsync("Runtime.removeBinding", dict);
            return methodResult;
        }
    }
}

namespace CefSharp.DevTools
{
    /// <summary>
    /// Generated DevToolsClient methods
    /// </summary>
    public partial class DevToolsClient
    {
        private CefSharp.DevTools.Accessibility.AccessibilityClient _Accessibility;
        public CefSharp.DevTools.Accessibility.AccessibilityClient Accessibility
        {
            get
            {
                if ((_Accessibility) == (null))
                {
                    _Accessibility = (new CefSharp.DevTools.Accessibility.AccessibilityClient(this));
                }

                return _Accessibility;
            }
        }

        private CefSharp.DevTools.Animation.AnimationClient _Animation;
        public CefSharp.DevTools.Animation.AnimationClient Animation
        {
            get
            {
                if ((_Animation) == (null))
                {
                    _Animation = (new CefSharp.DevTools.Animation.AnimationClient(this));
                }

                return _Animation;
            }
        }

        private CefSharp.DevTools.ApplicationCache.ApplicationCacheClient _ApplicationCache;
        public CefSharp.DevTools.ApplicationCache.ApplicationCacheClient ApplicationCache
        {
            get
            {
                if ((_ApplicationCache) == (null))
                {
                    _ApplicationCache = (new CefSharp.DevTools.ApplicationCache.ApplicationCacheClient(this));
                }

                return _ApplicationCache;
            }
        }

        private CefSharp.DevTools.Audits.AuditsClient _Audits;
        public CefSharp.DevTools.Audits.AuditsClient Audits
        {
            get
            {
                if ((_Audits) == (null))
                {
                    _Audits = (new CefSharp.DevTools.Audits.AuditsClient(this));
                }

                return _Audits;
            }
        }

        private CefSharp.DevTools.BackgroundService.BackgroundServiceClient _BackgroundService;
        public CefSharp.DevTools.BackgroundService.BackgroundServiceClient BackgroundService
        {
            get
            {
                if ((_BackgroundService) == (null))
                {
                    _BackgroundService = (new CefSharp.DevTools.BackgroundService.BackgroundServiceClient(this));
                }

                return _BackgroundService;
            }
        }

        private CefSharp.DevTools.Browser.BrowserClient _Browser;
        public CefSharp.DevTools.Browser.BrowserClient Browser
        {
            get
            {
                if ((_Browser) == (null))
                {
                    _Browser = (new CefSharp.DevTools.Browser.BrowserClient(this));
                }

                return _Browser;
            }
        }

        private CefSharp.DevTools.CSS.CSSClient _CSS;
        public CefSharp.DevTools.CSS.CSSClient CSS
        {
            get
            {
                if ((_CSS) == (null))
                {
                    _CSS = (new CefSharp.DevTools.CSS.CSSClient(this));
                }

                return _CSS;
            }
        }

        private CefSharp.DevTools.CacheStorage.CacheStorageClient _CacheStorage;
        public CefSharp.DevTools.CacheStorage.CacheStorageClient CacheStorage
        {
            get
            {
                if ((_CacheStorage) == (null))
                {
                    _CacheStorage = (new CefSharp.DevTools.CacheStorage.CacheStorageClient(this));
                }

                return _CacheStorage;
            }
        }

        private CefSharp.DevTools.Cast.CastClient _Cast;
        public CefSharp.DevTools.Cast.CastClient Cast
        {
            get
            {
                if ((_Cast) == (null))
                {
                    _Cast = (new CefSharp.DevTools.Cast.CastClient(this));
                }

                return _Cast;
            }
        }

        private CefSharp.DevTools.DOM.DOMClient _DOM;
        public CefSharp.DevTools.DOM.DOMClient DOM
        {
            get
            {
                if ((_DOM) == (null))
                {
                    _DOM = (new CefSharp.DevTools.DOM.DOMClient(this));
                }

                return _DOM;
            }
        }

        private CefSharp.DevTools.DOMDebugger.DOMDebuggerClient _DOMDebugger;
        public CefSharp.DevTools.DOMDebugger.DOMDebuggerClient DOMDebugger
        {
            get
            {
                if ((_DOMDebugger) == (null))
                {
                    _DOMDebugger = (new CefSharp.DevTools.DOMDebugger.DOMDebuggerClient(this));
                }

                return _DOMDebugger;
            }
        }

        private CefSharp.DevTools.DOMSnapshot.DOMSnapshotClient _DOMSnapshot;
        public CefSharp.DevTools.DOMSnapshot.DOMSnapshotClient DOMSnapshot
        {
            get
            {
                if ((_DOMSnapshot) == (null))
                {
                    _DOMSnapshot = (new CefSharp.DevTools.DOMSnapshot.DOMSnapshotClient(this));
                }

                return _DOMSnapshot;
            }
        }

        private CefSharp.DevTools.DOMStorage.DOMStorageClient _DOMStorage;
        public CefSharp.DevTools.DOMStorage.DOMStorageClient DOMStorage
        {
            get
            {
                if ((_DOMStorage) == (null))
                {
                    _DOMStorage = (new CefSharp.DevTools.DOMStorage.DOMStorageClient(this));
                }

                return _DOMStorage;
            }
        }

        private CefSharp.DevTools.Database.DatabaseClient _Database;
        public CefSharp.DevTools.Database.DatabaseClient Database
        {
            get
            {
                if ((_Database) == (null))
                {
                    _Database = (new CefSharp.DevTools.Database.DatabaseClient(this));
                }

                return _Database;
            }
        }

        private CefSharp.DevTools.DeviceOrientation.DeviceOrientationClient _DeviceOrientation;
        public CefSharp.DevTools.DeviceOrientation.DeviceOrientationClient DeviceOrientation
        {
            get
            {
                if ((_DeviceOrientation) == (null))
                {
                    _DeviceOrientation = (new CefSharp.DevTools.DeviceOrientation.DeviceOrientationClient(this));
                }

                return _DeviceOrientation;
            }
        }

        private CefSharp.DevTools.Emulation.EmulationClient _Emulation;
        public CefSharp.DevTools.Emulation.EmulationClient Emulation
        {
            get
            {
                if ((_Emulation) == (null))
                {
                    _Emulation = (new CefSharp.DevTools.Emulation.EmulationClient(this));
                }

                return _Emulation;
            }
        }

        private CefSharp.DevTools.HeadlessExperimental.HeadlessExperimentalClient _HeadlessExperimental;
        public CefSharp.DevTools.HeadlessExperimental.HeadlessExperimentalClient HeadlessExperimental
        {
            get
            {
                if ((_HeadlessExperimental) == (null))
                {
                    _HeadlessExperimental = (new CefSharp.DevTools.HeadlessExperimental.HeadlessExperimentalClient(this));
                }

                return _HeadlessExperimental;
            }
        }

        private CefSharp.DevTools.IO.IOClient _IO;
        public CefSharp.DevTools.IO.IOClient IO
        {
            get
            {
                if ((_IO) == (null))
                {
                    _IO = (new CefSharp.DevTools.IO.IOClient(this));
                }

                return _IO;
            }
        }

        private CefSharp.DevTools.IndexedDB.IndexedDBClient _IndexedDB;
        public CefSharp.DevTools.IndexedDB.IndexedDBClient IndexedDB
        {
            get
            {
                if ((_IndexedDB) == (null))
                {
                    _IndexedDB = (new CefSharp.DevTools.IndexedDB.IndexedDBClient(this));
                }

                return _IndexedDB;
            }
        }

        private CefSharp.DevTools.Input.InputClient _Input;
        public CefSharp.DevTools.Input.InputClient Input
        {
            get
            {
                if ((_Input) == (null))
                {
                    _Input = (new CefSharp.DevTools.Input.InputClient(this));
                }

                return _Input;
            }
        }

        private CefSharp.DevTools.Inspector.InspectorClient _Inspector;
        public CefSharp.DevTools.Inspector.InspectorClient Inspector
        {
            get
            {
                if ((_Inspector) == (null))
                {
                    _Inspector = (new CefSharp.DevTools.Inspector.InspectorClient(this));
                }

                return _Inspector;
            }
        }

        private CefSharp.DevTools.LayerTree.LayerTreeClient _LayerTree;
        public CefSharp.DevTools.LayerTree.LayerTreeClient LayerTree
        {
            get
            {
                if ((_LayerTree) == (null))
                {
                    _LayerTree = (new CefSharp.DevTools.LayerTree.LayerTreeClient(this));
                }

                return _LayerTree;
            }
        }

        private CefSharp.DevTools.Log.LogClient _Log;
        public CefSharp.DevTools.Log.LogClient Log
        {
            get
            {
                if ((_Log) == (null))
                {
                    _Log = (new CefSharp.DevTools.Log.LogClient(this));
                }

                return _Log;
            }
        }

        private CefSharp.DevTools.Memory.MemoryClient _Memory;
        public CefSharp.DevTools.Memory.MemoryClient Memory
        {
            get
            {
                if ((_Memory) == (null))
                {
                    _Memory = (new CefSharp.DevTools.Memory.MemoryClient(this));
                }

                return _Memory;
            }
        }

        private CefSharp.DevTools.Network.NetworkClient _Network;
        public CefSharp.DevTools.Network.NetworkClient Network
        {
            get
            {
                if ((_Network) == (null))
                {
                    _Network = (new CefSharp.DevTools.Network.NetworkClient(this));
                }

                return _Network;
            }
        }

        private CefSharp.DevTools.Overlay.OverlayClient _Overlay;
        public CefSharp.DevTools.Overlay.OverlayClient Overlay
        {
            get
            {
                if ((_Overlay) == (null))
                {
                    _Overlay = (new CefSharp.DevTools.Overlay.OverlayClient(this));
                }

                return _Overlay;
            }
        }

        private CefSharp.DevTools.Page.PageClient _Page;
        public CefSharp.DevTools.Page.PageClient Page
        {
            get
            {
                if ((_Page) == (null))
                {
                    _Page = (new CefSharp.DevTools.Page.PageClient(this));
                }

                return _Page;
            }
        }

        private CefSharp.DevTools.Performance.PerformanceClient _Performance;
        public CefSharp.DevTools.Performance.PerformanceClient Performance
        {
            get
            {
                if ((_Performance) == (null))
                {
                    _Performance = (new CefSharp.DevTools.Performance.PerformanceClient(this));
                }

                return _Performance;
            }
        }

        private CefSharp.DevTools.Security.SecurityClient _Security;
        public CefSharp.DevTools.Security.SecurityClient Security
        {
            get
            {
                if ((_Security) == (null))
                {
                    _Security = (new CefSharp.DevTools.Security.SecurityClient(this));
                }

                return _Security;
            }
        }

        private CefSharp.DevTools.ServiceWorker.ServiceWorkerClient _ServiceWorker;
        public CefSharp.DevTools.ServiceWorker.ServiceWorkerClient ServiceWorker
        {
            get
            {
                if ((_ServiceWorker) == (null))
                {
                    _ServiceWorker = (new CefSharp.DevTools.ServiceWorker.ServiceWorkerClient(this));
                }

                return _ServiceWorker;
            }
        }

        private CefSharp.DevTools.Storage.StorageClient _Storage;
        public CefSharp.DevTools.Storage.StorageClient Storage
        {
            get
            {
                if ((_Storage) == (null))
                {
                    _Storage = (new CefSharp.DevTools.Storage.StorageClient(this));
                }

                return _Storage;
            }
        }

        private CefSharp.DevTools.SystemInfo.SystemInfoClient _SystemInfo;
        public CefSharp.DevTools.SystemInfo.SystemInfoClient SystemInfo
        {
            get
            {
                if ((_SystemInfo) == (null))
                {
                    _SystemInfo = (new CefSharp.DevTools.SystemInfo.SystemInfoClient(this));
                }

                return _SystemInfo;
            }
        }

        private CefSharp.DevTools.Target.TargetClient _Target;
        public CefSharp.DevTools.Target.TargetClient Target
        {
            get
            {
                if ((_Target) == (null))
                {
                    _Target = (new CefSharp.DevTools.Target.TargetClient(this));
                }

                return _Target;
            }
        }

        private CefSharp.DevTools.Tethering.TetheringClient _Tethering;
        public CefSharp.DevTools.Tethering.TetheringClient Tethering
        {
            get
            {
                if ((_Tethering) == (null))
                {
                    _Tethering = (new CefSharp.DevTools.Tethering.TetheringClient(this));
                }

                return _Tethering;
            }
        }

        private CefSharp.DevTools.Tracing.TracingClient _Tracing;
        public CefSharp.DevTools.Tracing.TracingClient Tracing
        {
            get
            {
                if ((_Tracing) == (null))
                {
                    _Tracing = (new CefSharp.DevTools.Tracing.TracingClient(this));
                }

                return _Tracing;
            }
        }

        private CefSharp.DevTools.Fetch.FetchClient _Fetch;
        public CefSharp.DevTools.Fetch.FetchClient Fetch
        {
            get
            {
                if ((_Fetch) == (null))
                {
                    _Fetch = (new CefSharp.DevTools.Fetch.FetchClient(this));
                }

                return _Fetch;
            }
        }

        private CefSharp.DevTools.WebAudio.WebAudioClient _WebAudio;
        public CefSharp.DevTools.WebAudio.WebAudioClient WebAudio
        {
            get
            {
                if ((_WebAudio) == (null))
                {
                    _WebAudio = (new CefSharp.DevTools.WebAudio.WebAudioClient(this));
                }

                return _WebAudio;
            }
        }

        private CefSharp.DevTools.WebAuthn.WebAuthnClient _WebAuthn;
        public CefSharp.DevTools.WebAuthn.WebAuthnClient WebAuthn
        {
            get
            {
                if ((_WebAuthn) == (null))
                {
                    _WebAuthn = (new CefSharp.DevTools.WebAuthn.WebAuthnClient(this));
                }

                return _WebAuthn;
            }
        }

        private CefSharp.DevTools.Media.MediaClient _Media;
        public CefSharp.DevTools.Media.MediaClient Media
        {
            get
            {
                if ((_Media) == (null))
                {
                    _Media = (new CefSharp.DevTools.Media.MediaClient(this));
                }

                return _Media;
            }
        }

        private CefSharp.DevTools.Debugger.DebuggerClient _Debugger;
        public CefSharp.DevTools.Debugger.DebuggerClient Debugger
        {
            get
            {
                if ((_Debugger) == (null))
                {
                    _Debugger = (new CefSharp.DevTools.Debugger.DebuggerClient(this));
                }

                return _Debugger;
            }
        }

        private CefSharp.DevTools.HeapProfiler.HeapProfilerClient _HeapProfiler;
        public CefSharp.DevTools.HeapProfiler.HeapProfilerClient HeapProfiler
        {
            get
            {
                if ((_HeapProfiler) == (null))
                {
                    _HeapProfiler = (new CefSharp.DevTools.HeapProfiler.HeapProfilerClient(this));
                }

                return _HeapProfiler;
            }
        }

        private CefSharp.DevTools.Profiler.ProfilerClient _Profiler;
        public CefSharp.DevTools.Profiler.ProfilerClient Profiler
        {
            get
            {
                if ((_Profiler) == (null))
                {
                    _Profiler = (new CefSharp.DevTools.Profiler.ProfilerClient(this));
                }

                return _Profiler;
            }
        }

        private CefSharp.DevTools.Runtime.RuntimeClient _Runtime;
        public CefSharp.DevTools.Runtime.RuntimeClient Runtime
        {
            get
            {
                if ((_Runtime) == (null))
                {
                    _Runtime = (new CefSharp.DevTools.Runtime.RuntimeClient(this));
                }

                return _Runtime;
            }
        }
    }
}