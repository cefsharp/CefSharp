// Copyright Â© 2020 The CefSharp Authors. All rights reserved.
//
// Use of this source code is governed by a BSD-style license that can be found in the LICENSE file.
//
// **This code was generated by a tool, do not change directly**
// CHROMIUM VERSION 114.0.5735.110
using System.Text.Json.Serialization;

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// Enum of possible property types.
    /// </summary>
    public enum AXValueType
    {
        /// <summary>
        /// boolean
        /// </summary>
        [JsonPropertyName("boolean")]
        Boolean,
        /// <summary>
        /// tristate
        /// </summary>
        [JsonPropertyName("tristate")]
        Tristate,
        /// <summary>
        /// booleanOrUndefined
        /// </summary>
        [JsonPropertyName("booleanOrUndefined")]
        BooleanOrUndefined,
        /// <summary>
        /// idref
        /// </summary>
        [JsonPropertyName("idref")]
        Idref,
        /// <summary>
        /// idrefList
        /// </summary>
        [JsonPropertyName("idrefList")]
        IdrefList,
        /// <summary>
        /// integer
        /// </summary>
        [JsonPropertyName("integer")]
        Integer,
        /// <summary>
        /// node
        /// </summary>
        [JsonPropertyName("node")]
        Node,
        /// <summary>
        /// nodeList
        /// </summary>
        [JsonPropertyName("nodeList")]
        NodeList,
        /// <summary>
        /// number
        /// </summary>
        [JsonPropertyName("number")]
        Number,
        /// <summary>
        /// string
        /// </summary>
        [JsonPropertyName("string")]
        String,
        /// <summary>
        /// computedString
        /// </summary>
        [JsonPropertyName("computedString")]
        ComputedString,
        /// <summary>
        /// token
        /// </summary>
        [JsonPropertyName("token")]
        Token,
        /// <summary>
        /// tokenList
        /// </summary>
        [JsonPropertyName("tokenList")]
        TokenList,
        /// <summary>
        /// domRelation
        /// </summary>
        [JsonPropertyName("domRelation")]
        DomRelation,
        /// <summary>
        /// role
        /// </summary>
        [JsonPropertyName("role")]
        Role,
        /// <summary>
        /// internalRole
        /// </summary>
        [JsonPropertyName("internalRole")]
        InternalRole,
        /// <summary>
        /// valueUndefined
        /// </summary>
        [JsonPropertyName("valueUndefined")]
        ValueUndefined
    }

    /// <summary>
    /// Enum of possible property sources.
    /// </summary>
    public enum AXValueSourceType
    {
        /// <summary>
        /// attribute
        /// </summary>
        [JsonPropertyName("attribute")]
        Attribute,
        /// <summary>
        /// implicit
        /// </summary>
        [JsonPropertyName("implicit")]
        Implicit,
        /// <summary>
        /// style
        /// </summary>
        [JsonPropertyName("style")]
        Style,
        /// <summary>
        /// contents
        /// </summary>
        [JsonPropertyName("contents")]
        Contents,
        /// <summary>
        /// placeholder
        /// </summary>
        [JsonPropertyName("placeholder")]
        Placeholder,
        /// <summary>
        /// relatedElement
        /// </summary>
        [JsonPropertyName("relatedElement")]
        RelatedElement
    }

    /// <summary>
    /// Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
    /// </summary>
    public enum AXValueNativeSourceType
    {
        /// <summary>
        /// description
        /// </summary>
        [JsonPropertyName("description")]
        Description,
        /// <summary>
        /// figcaption
        /// </summary>
        [JsonPropertyName("figcaption")]
        Figcaption,
        /// <summary>
        /// label
        /// </summary>
        [JsonPropertyName("label")]
        Label,
        /// <summary>
        /// labelfor
        /// </summary>
        [JsonPropertyName("labelfor")]
        Labelfor,
        /// <summary>
        /// labelwrapped
        /// </summary>
        [JsonPropertyName("labelwrapped")]
        Labelwrapped,
        /// <summary>
        /// legend
        /// </summary>
        [JsonPropertyName("legend")]
        Legend,
        /// <summary>
        /// rubyannotation
        /// </summary>
        [JsonPropertyName("rubyannotation")]
        Rubyannotation,
        /// <summary>
        /// tablecaption
        /// </summary>
        [JsonPropertyName("tablecaption")]
        Tablecaption,
        /// <summary>
        /// title
        /// </summary>
        [JsonPropertyName("title")]
        Title,
        /// <summary>
        /// other
        /// </summary>
        [JsonPropertyName("other")]
        Other
    }

    /// <summary>
    /// A single source for a computed AX property.
    /// </summary>
    public partial class AXValueSource : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// What type of source this is.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Accessibility.AXValueSourceType Type
        {
            get;
            set;
        }

        /// <summary>
        /// The value of this property source.
        /// </summary>
        [JsonPropertyName("value")]
        public CefSharp.DevTools.Accessibility.AXValue Value
        {
            get;
            set;
        }

        /// <summary>
        /// The name of the relevant attribute, if any.
        /// </summary>
        [JsonPropertyName("attribute")]
        public string Attribute
        {
            get;
            set;
        }

        /// <summary>
        /// The value of the relevant attribute, if any.
        /// </summary>
        [JsonPropertyName("attributeValue")]
        public CefSharp.DevTools.Accessibility.AXValue AttributeValue
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this source is superseded by a higher priority source.
        /// </summary>
        [JsonPropertyName("superseded")]
        public bool? Superseded
        {
            get;
            set;
        }

        /// <summary>
        /// The native markup source for this value, e.g. a &lt;label&gt; element.
        /// </summary>
        [JsonPropertyName("nativeSource")]
        public CefSharp.DevTools.Accessibility.AXValueNativeSourceType? NativeSource
        {
            get;
            set;
        }

        /// <summary>
        /// The value, such as a node or node list, of the native source.
        /// </summary>
        [JsonPropertyName("nativeSourceValue")]
        public CefSharp.DevTools.Accessibility.AXValue NativeSourceValue
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the value for this property is invalid.
        /// </summary>
        [JsonPropertyName("invalid")]
        public bool? Invalid
        {
            get;
            set;
        }

        /// <summary>
        /// Reason for the value being invalid, if it is.
        /// </summary>
        [JsonPropertyName("invalidReason")]
        public string InvalidReason
        {
            get;
            set;
        }
    }

    /// <summary>
    /// AXRelatedNode
    /// </summary>
    public partial class AXRelatedNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The BackendNodeId of the related DOM node.
        /// </summary>
        [JsonPropertyName("backendDOMNodeId")]
        public int BackendDOMNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// The IDRef value provided, if any.
        /// </summary>
        [JsonPropertyName("idref")]
        public string Idref
        {
            get;
            set;
        }

        /// <summary>
        /// The text alternative of this node in the current context.
        /// </summary>
        [JsonPropertyName("text")]
        public string Text
        {
            get;
            set;
        }
    }

    /// <summary>
    /// AXProperty
    /// </summary>
    public partial class AXProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The name of this property.
        /// </summary>
        [JsonPropertyName("name")]
        public CefSharp.DevTools.Accessibility.AXPropertyName Name
        {
            get;
            set;
        }

        /// <summary>
        /// The value of this property.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Accessibility.AXValue Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A single computed AX property.
    /// </summary>
    public partial class AXValue : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The type of this value.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Accessibility.AXValueType Type
        {
            get;
            set;
        }

        /// <summary>
        /// The computed value of this property.
        /// </summary>
        [JsonPropertyName("value")]
        public object Value
        {
            get;
            set;
        }

        /// <summary>
        /// One or more related nodes, if applicable.
        /// </summary>
        [JsonPropertyName("relatedNodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXRelatedNode> RelatedNodes
        {
            get;
            set;
        }

        /// <summary>
        /// The sources which contributed to the computation of this property.
        /// </summary>
        [JsonPropertyName("sources")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXValueSource> Sources
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Values of AXProperty name:
    /// - from &apos;busy&apos; to &apos;roledescription&apos;: states which apply to every AX node
    /// - from &apos;live&apos; to &apos;root&apos;: attributes which apply to nodes in live regions
    /// - from &apos;autocomplete&apos; to &apos;valuetext&apos;: attributes which apply to widgets
    /// - from &apos;checked&apos; to &apos;selected&apos;: states which apply to widgets
    /// - from &apos;activedescendant&apos; to &apos;owns&apos; - relationships between elements other than parent/child/sibling.
    /// </summary>
    public enum AXPropertyName
    {
        /// <summary>
        /// busy
        /// </summary>
        [JsonPropertyName("busy")]
        Busy,
        /// <summary>
        /// disabled
        /// </summary>
        [JsonPropertyName("disabled")]
        Disabled,
        /// <summary>
        /// editable
        /// </summary>
        [JsonPropertyName("editable")]
        Editable,
        /// <summary>
        /// focusable
        /// </summary>
        [JsonPropertyName("focusable")]
        Focusable,
        /// <summary>
        /// focused
        /// </summary>
        [JsonPropertyName("focused")]
        Focused,
        /// <summary>
        /// hidden
        /// </summary>
        [JsonPropertyName("hidden")]
        Hidden,
        /// <summary>
        /// hiddenRoot
        /// </summary>
        [JsonPropertyName("hiddenRoot")]
        HiddenRoot,
        /// <summary>
        /// invalid
        /// </summary>
        [JsonPropertyName("invalid")]
        Invalid,
        /// <summary>
        /// keyshortcuts
        /// </summary>
        [JsonPropertyName("keyshortcuts")]
        Keyshortcuts,
        /// <summary>
        /// settable
        /// </summary>
        [JsonPropertyName("settable")]
        Settable,
        /// <summary>
        /// roledescription
        /// </summary>
        [JsonPropertyName("roledescription")]
        Roledescription,
        /// <summary>
        /// live
        /// </summary>
        [JsonPropertyName("live")]
        Live,
        /// <summary>
        /// atomic
        /// </summary>
        [JsonPropertyName("atomic")]
        Atomic,
        /// <summary>
        /// relevant
        /// </summary>
        [JsonPropertyName("relevant")]
        Relevant,
        /// <summary>
        /// root
        /// </summary>
        [JsonPropertyName("root")]
        Root,
        /// <summary>
        /// autocomplete
        /// </summary>
        [JsonPropertyName("autocomplete")]
        Autocomplete,
        /// <summary>
        /// hasPopup
        /// </summary>
        [JsonPropertyName("hasPopup")]
        HasPopup,
        /// <summary>
        /// level
        /// </summary>
        [JsonPropertyName("level")]
        Level,
        /// <summary>
        /// multiselectable
        /// </summary>
        [JsonPropertyName("multiselectable")]
        Multiselectable,
        /// <summary>
        /// orientation
        /// </summary>
        [JsonPropertyName("orientation")]
        Orientation,
        /// <summary>
        /// multiline
        /// </summary>
        [JsonPropertyName("multiline")]
        Multiline,
        /// <summary>
        /// readonly
        /// </summary>
        [JsonPropertyName("readonly")]
        Readonly,
        /// <summary>
        /// required
        /// </summary>
        [JsonPropertyName("required")]
        Required,
        /// <summary>
        /// valuemin
        /// </summary>
        [JsonPropertyName("valuemin")]
        Valuemin,
        /// <summary>
        /// valuemax
        /// </summary>
        [JsonPropertyName("valuemax")]
        Valuemax,
        /// <summary>
        /// valuetext
        /// </summary>
        [JsonPropertyName("valuetext")]
        Valuetext,
        /// <summary>
        /// checked
        /// </summary>
        [JsonPropertyName("checked")]
        Checked,
        /// <summary>
        /// expanded
        /// </summary>
        [JsonPropertyName("expanded")]
        Expanded,
        /// <summary>
        /// modal
        /// </summary>
        [JsonPropertyName("modal")]
        Modal,
        /// <summary>
        /// pressed
        /// </summary>
        [JsonPropertyName("pressed")]
        Pressed,
        /// <summary>
        /// selected
        /// </summary>
        [JsonPropertyName("selected")]
        Selected,
        /// <summary>
        /// activedescendant
        /// </summary>
        [JsonPropertyName("activedescendant")]
        Activedescendant,
        /// <summary>
        /// controls
        /// </summary>
        [JsonPropertyName("controls")]
        Controls,
        /// <summary>
        /// describedby
        /// </summary>
        [JsonPropertyName("describedby")]
        Describedby,
        /// <summary>
        /// details
        /// </summary>
        [JsonPropertyName("details")]
        Details,
        /// <summary>
        /// errormessage
        /// </summary>
        [JsonPropertyName("errormessage")]
        Errormessage,
        /// <summary>
        /// flowto
        /// </summary>
        [JsonPropertyName("flowto")]
        Flowto,
        /// <summary>
        /// labelledby
        /// </summary>
        [JsonPropertyName("labelledby")]
        Labelledby,
        /// <summary>
        /// owns
        /// </summary>
        [JsonPropertyName("owns")]
        Owns
    }

    /// <summary>
    /// A node in the accessibility tree.
    /// </summary>
    public partial class AXNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Unique identifier for this node.
        /// </summary>
        [JsonPropertyName("nodeId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this node is ignored for accessibility
        /// </summary>
        [JsonPropertyName("ignored")]
        public bool Ignored
        {
            get;
            set;
        }

        /// <summary>
        /// Collection of reasons why this node is hidden.
        /// </summary>
        [JsonPropertyName("ignoredReasons")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXProperty> IgnoredReasons
        {
            get;
            set;
        }

        /// <summary>
        /// This `Node`&apos;s role, whether explicit or implicit.
        /// </summary>
        [JsonPropertyName("role")]
        public CefSharp.DevTools.Accessibility.AXValue Role
        {
            get;
            set;
        }

        /// <summary>
        /// This `Node`&apos;s Chrome raw role.
        /// </summary>
        [JsonPropertyName("chromeRole")]
        public CefSharp.DevTools.Accessibility.AXValue ChromeRole
        {
            get;
            set;
        }

        /// <summary>
        /// The accessible name for this `Node`.
        /// </summary>
        [JsonPropertyName("name")]
        public CefSharp.DevTools.Accessibility.AXValue Name
        {
            get;
            set;
        }

        /// <summary>
        /// The accessible description for this `Node`.
        /// </summary>
        [JsonPropertyName("description")]
        public CefSharp.DevTools.Accessibility.AXValue Description
        {
            get;
            set;
        }

        /// <summary>
        /// The value for this `Node`.
        /// </summary>
        [JsonPropertyName("value")]
        public CefSharp.DevTools.Accessibility.AXValue Value
        {
            get;
            set;
        }

        /// <summary>
        /// All other properties
        /// </summary>
        [JsonPropertyName("properties")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXProperty> Properties
        {
            get;
            set;
        }

        /// <summary>
        /// ID for this node&apos;s parent.
        /// </summary>
        [JsonPropertyName("parentId")]
        public string ParentId
        {
            get;
            set;
        }

        /// <summary>
        /// IDs for each of this node&apos;s child nodes.
        /// </summary>
        [JsonPropertyName("childIds")]
        public string[] ChildIds
        {
            get;
            set;
        }

        /// <summary>
        /// The backend ID for the associated DOM node, if any.
        /// </summary>
        [JsonPropertyName("backendDOMNodeId")]
        public int? BackendDOMNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// The frame ID for the frame associated with this nodes document.
        /// </summary>
        [JsonPropertyName("frameId")]
        public string FrameId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The loadComplete event mirrors the load complete event sent by the browser to assistive
    /// technology when the web page has finished loading.
    /// </summary>
    public class LoadCompleteEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// New document root node.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("root")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Accessibility.AXNode Root
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// The nodesUpdated event is sent every time a previously requested node has changed the in tree.
    /// </summary>
    public class NodesUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Updated node data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// Animation type of `Animation`.
    /// </summary>
    public enum AnimationType
    {
        /// <summary>
        /// CSSTransition
        /// </summary>
        [JsonPropertyName("CSSTransition")]
        CSSTransition,
        /// <summary>
        /// CSSAnimation
        /// </summary>
        [JsonPropertyName("CSSAnimation")]
        CSSAnimation,
        /// <summary>
        /// WebAnimation
        /// </summary>
        [JsonPropertyName("WebAnimation")]
        WebAnimation
    }

    /// <summary>
    /// Animation instance.
    /// </summary>
    public partial class Animation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `Animation`&apos;s id.
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s internal paused state.
        /// </summary>
        [JsonPropertyName("pausedState")]
        public bool PausedState
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s play state.
        /// </summary>
        [JsonPropertyName("playState")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlayState
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s playback rate.
        /// </summary>
        [JsonPropertyName("playbackRate")]
        public double PlaybackRate
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s start time.
        /// </summary>
        [JsonPropertyName("startTime")]
        public double StartTime
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s current time.
        /// </summary>
        [JsonPropertyName("currentTime")]
        public double CurrentTime
        {
            get;
            set;
        }

        /// <summary>
        /// Animation type of `Animation`.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Animation.AnimationType Type
        {
            get;
            set;
        }

        /// <summary>
        /// `Animation`&apos;s source animation node.
        /// </summary>
        [JsonPropertyName("source")]
        public CefSharp.DevTools.Animation.AnimationEffect Source
        {
            get;
            set;
        }

        /// <summary>
        /// A unique ID for `Animation` representing the sources that triggered this CSS
        /// animation/transition.
        /// </summary>
        [JsonPropertyName("cssId")]
        public string CssId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// AnimationEffect instance
    /// </summary>
    public partial class AnimationEffect : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `AnimationEffect`&apos;s delay.
        /// </summary>
        [JsonPropertyName("delay")]
        public double Delay
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s end delay.
        /// </summary>
        [JsonPropertyName("endDelay")]
        public double EndDelay
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s iteration start.
        /// </summary>
        [JsonPropertyName("iterationStart")]
        public double IterationStart
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s iterations.
        /// </summary>
        [JsonPropertyName("iterations")]
        public double Iterations
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s iteration duration.
        /// </summary>
        [JsonPropertyName("duration")]
        public double Duration
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s playback direction.
        /// </summary>
        [JsonPropertyName("direction")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Direction
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s fill mode.
        /// </summary>
        [JsonPropertyName("fill")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Fill
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s target node.
        /// </summary>
        [JsonPropertyName("backendNodeId")]
        public int? BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s keyframes.
        /// </summary>
        [JsonPropertyName("keyframesRule")]
        public CefSharp.DevTools.Animation.KeyframesRule KeyframesRule
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s timing function.
        /// </summary>
        [JsonPropertyName("easing")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Easing
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Keyframes Rule
    /// </summary>
    public partial class KeyframesRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CSS keyframed animation&apos;s name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// List of animation keyframes.
        /// </summary>
        [JsonPropertyName("keyframes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Animation.KeyframeStyle> Keyframes
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Keyframe Style
    /// </summary>
    public partial class KeyframeStyle : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Keyframe&apos;s time offset.
        /// </summary>
        [JsonPropertyName("offset")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Offset
        {
            get;
            set;
        }

        /// <summary>
        /// `AnimationEffect`&apos;s timing function.
        /// </summary>
        [JsonPropertyName("easing")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Easing
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Event for when an animation has been cancelled.
    /// </summary>
    public class AnimationCanceledEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the animation that was cancelled.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Event for each animation that has been created.
    /// </summary>
    public class AnimationCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the animation that was created.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Event for animation that has been started.
    /// </summary>
    public class AnimationStartedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Animation that was started.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("animation")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Animation.Animation Animation
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// Information about a cookie that is affected by an inspector issue.
    /// </summary>
    public partial class AffectedCookie : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The following three properties uniquely identify a cookie
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Path
        /// </summary>
        [JsonPropertyName("path")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Path
        {
            get;
            set;
        }

        /// <summary>
        /// Domain
        /// </summary>
        [JsonPropertyName("domain")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Domain
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about a request that is affected by an inspector issue.
    /// </summary>
    public partial class AffectedRequest : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The unique request id.
        /// </summary>
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            set;
        }

        /// <summary>
        /// Url
        /// </summary>
        [JsonPropertyName("url")]
        public string Url
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about the frame affected by an inspector issue.
    /// </summary>
    public partial class AffectedFrame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// FrameId
        /// </summary>
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CookieExclusionReason
    /// </summary>
    public enum CookieExclusionReason
    {
        /// <summary>
        /// ExcludeSameSiteUnspecifiedTreatedAsLax
        /// </summary>
        [JsonPropertyName("ExcludeSameSiteUnspecifiedTreatedAsLax")]
        ExcludeSameSiteUnspecifiedTreatedAsLax,
        /// <summary>
        /// ExcludeSameSiteNoneInsecure
        /// </summary>
        [JsonPropertyName("ExcludeSameSiteNoneInsecure")]
        ExcludeSameSiteNoneInsecure,
        /// <summary>
        /// ExcludeSameSiteLax
        /// </summary>
        [JsonPropertyName("ExcludeSameSiteLax")]
        ExcludeSameSiteLax,
        /// <summary>
        /// ExcludeSameSiteStrict
        /// </summary>
        [JsonPropertyName("ExcludeSameSiteStrict")]
        ExcludeSameSiteStrict,
        /// <summary>
        /// ExcludeInvalidSameParty
        /// </summary>
        [JsonPropertyName("ExcludeInvalidSameParty")]
        ExcludeInvalidSameParty,
        /// <summary>
        /// ExcludeSamePartyCrossPartyContext
        /// </summary>
        [JsonPropertyName("ExcludeSamePartyCrossPartyContext")]
        ExcludeSamePartyCrossPartyContext,
        /// <summary>
        /// ExcludeDomainNonASCII
        /// </summary>
        [JsonPropertyName("ExcludeDomainNonASCII")]
        ExcludeDomainNonASCII,
        /// <summary>
        /// ExcludeThirdPartyCookieBlockedInFirstPartySet
        /// </summary>
        [JsonPropertyName("ExcludeThirdPartyCookieBlockedInFirstPartySet")]
        ExcludeThirdPartyCookieBlockedInFirstPartySet
    }

    /// <summary>
    /// CookieWarningReason
    /// </summary>
    public enum CookieWarningReason
    {
        /// <summary>
        /// WarnSameSiteUnspecifiedCrossSiteContext
        /// </summary>
        [JsonPropertyName("WarnSameSiteUnspecifiedCrossSiteContext")]
        WarnSameSiteUnspecifiedCrossSiteContext,
        /// <summary>
        /// WarnSameSiteNoneInsecure
        /// </summary>
        [JsonPropertyName("WarnSameSiteNoneInsecure")]
        WarnSameSiteNoneInsecure,
        /// <summary>
        /// WarnSameSiteUnspecifiedLaxAllowUnsafe
        /// </summary>
        [JsonPropertyName("WarnSameSiteUnspecifiedLaxAllowUnsafe")]
        WarnSameSiteUnspecifiedLaxAllowUnsafe,
        /// <summary>
        /// WarnSameSiteStrictLaxDowngradeStrict
        /// </summary>
        [JsonPropertyName("WarnSameSiteStrictLaxDowngradeStrict")]
        WarnSameSiteStrictLaxDowngradeStrict,
        /// <summary>
        /// WarnSameSiteStrictCrossDowngradeStrict
        /// </summary>
        [JsonPropertyName("WarnSameSiteStrictCrossDowngradeStrict")]
        WarnSameSiteStrictCrossDowngradeStrict,
        /// <summary>
        /// WarnSameSiteStrictCrossDowngradeLax
        /// </summary>
        [JsonPropertyName("WarnSameSiteStrictCrossDowngradeLax")]
        WarnSameSiteStrictCrossDowngradeLax,
        /// <summary>
        /// WarnSameSiteLaxCrossDowngradeStrict
        /// </summary>
        [JsonPropertyName("WarnSameSiteLaxCrossDowngradeStrict")]
        WarnSameSiteLaxCrossDowngradeStrict,
        /// <summary>
        /// WarnSameSiteLaxCrossDowngradeLax
        /// </summary>
        [JsonPropertyName("WarnSameSiteLaxCrossDowngradeLax")]
        WarnSameSiteLaxCrossDowngradeLax,
        /// <summary>
        /// WarnAttributeValueExceedsMaxSize
        /// </summary>
        [JsonPropertyName("WarnAttributeValueExceedsMaxSize")]
        WarnAttributeValueExceedsMaxSize,
        /// <summary>
        /// WarnDomainNonASCII
        /// </summary>
        [JsonPropertyName("WarnDomainNonASCII")]
        WarnDomainNonASCII
    }

    /// <summary>
    /// CookieOperation
    /// </summary>
    public enum CookieOperation
    {
        /// <summary>
        /// SetCookie
        /// </summary>
        [JsonPropertyName("SetCookie")]
        SetCookie,
        /// <summary>
        /// ReadCookie
        /// </summary>
        [JsonPropertyName("ReadCookie")]
        ReadCookie
    }

    /// <summary>
    /// This information is currently necessary, as the front-end has a difficult
    /// time finding a specific cookie. With this, we can convey specific error
    /// information without the cookie.
    /// </summary>
    public partial class CookieIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// If AffectedCookie is not set then rawCookieLine contains the raw
        /// Set-Cookie header string. This hints at a problem where the
        /// cookie line is syntactically or semantically malformed in a way
        /// that no valid cookie could be created.
        /// </summary>
        [JsonPropertyName("cookie")]
        public CefSharp.DevTools.Audits.AffectedCookie Cookie
        {
            get;
            set;
        }

        /// <summary>
        /// RawCookieLine
        /// </summary>
        [JsonPropertyName("rawCookieLine")]
        public string RawCookieLine
        {
            get;
            set;
        }

        /// <summary>
        /// CookieWarningReasons
        /// </summary>
        [JsonPropertyName("cookieWarningReasons")]
        public CefSharp.DevTools.Audits.CookieWarningReason[] CookieWarningReasons
        {
            get;
            set;
        }

        /// <summary>
        /// CookieExclusionReasons
        /// </summary>
        [JsonPropertyName("cookieExclusionReasons")]
        public CefSharp.DevTools.Audits.CookieExclusionReason[] CookieExclusionReasons
        {
            get;
            set;
        }

        /// <summary>
        /// Optionally identifies the site-for-cookies and the cookie url, which
        /// may be used by the front-end as additional context.
        /// </summary>
        [JsonPropertyName("operation")]
        public CefSharp.DevTools.Audits.CookieOperation Operation
        {
            get;
            set;
        }

        /// <summary>
        /// SiteForCookies
        /// </summary>
        [JsonPropertyName("siteForCookies")]
        public string SiteForCookies
        {
            get;
            set;
        }

        /// <summary>
        /// CookieUrl
        /// </summary>
        [JsonPropertyName("cookieUrl")]
        public string CookieUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Request
        /// </summary>
        [JsonPropertyName("request")]
        public CefSharp.DevTools.Audits.AffectedRequest Request
        {
            get;
            set;
        }
    }

    /// <summary>
    /// MixedContentResolutionStatus
    /// </summary>
    public enum MixedContentResolutionStatus
    {
        /// <summary>
        /// MixedContentBlocked
        /// </summary>
        [JsonPropertyName("MixedContentBlocked")]
        MixedContentBlocked,
        /// <summary>
        /// MixedContentAutomaticallyUpgraded
        /// </summary>
        [JsonPropertyName("MixedContentAutomaticallyUpgraded")]
        MixedContentAutomaticallyUpgraded,
        /// <summary>
        /// MixedContentWarning
        /// </summary>
        [JsonPropertyName("MixedContentWarning")]
        MixedContentWarning
    }

    /// <summary>
    /// MixedContentResourceType
    /// </summary>
    public enum MixedContentResourceType
    {
        /// <summary>
        /// AttributionSrc
        /// </summary>
        [JsonPropertyName("AttributionSrc")]
        AttributionSrc,
        /// <summary>
        /// Audio
        /// </summary>
        [JsonPropertyName("Audio")]
        Audio,
        /// <summary>
        /// Beacon
        /// </summary>
        [JsonPropertyName("Beacon")]
        Beacon,
        /// <summary>
        /// CSPReport
        /// </summary>
        [JsonPropertyName("CSPReport")]
        CSPReport,
        /// <summary>
        /// Download
        /// </summary>
        [JsonPropertyName("Download")]
        Download,
        /// <summary>
        /// EventSource
        /// </summary>
        [JsonPropertyName("EventSource")]
        EventSource,
        /// <summary>
        /// Favicon
        /// </summary>
        [JsonPropertyName("Favicon")]
        Favicon,
        /// <summary>
        /// Font
        /// </summary>
        [JsonPropertyName("Font")]
        Font,
        /// <summary>
        /// Form
        /// </summary>
        [JsonPropertyName("Form")]
        Form,
        /// <summary>
        /// Frame
        /// </summary>
        [JsonPropertyName("Frame")]
        Frame,
        /// <summary>
        /// Image
        /// </summary>
        [JsonPropertyName("Image")]
        Image,
        /// <summary>
        /// Import
        /// </summary>
        [JsonPropertyName("Import")]
        Import,
        /// <summary>
        /// Manifest
        /// </summary>
        [JsonPropertyName("Manifest")]
        Manifest,
        /// <summary>
        /// Ping
        /// </summary>
        [JsonPropertyName("Ping")]
        Ping,
        /// <summary>
        /// PluginData
        /// </summary>
        [JsonPropertyName("PluginData")]
        PluginData,
        /// <summary>
        /// PluginResource
        /// </summary>
        [JsonPropertyName("PluginResource")]
        PluginResource,
        /// <summary>
        /// Prefetch
        /// </summary>
        [JsonPropertyName("Prefetch")]
        Prefetch,
        /// <summary>
        /// Resource
        /// </summary>
        [JsonPropertyName("Resource")]
        Resource,
        /// <summary>
        /// Script
        /// </summary>
        [JsonPropertyName("Script")]
        Script,
        /// <summary>
        /// ServiceWorker
        /// </summary>
        [JsonPropertyName("ServiceWorker")]
        ServiceWorker,
        /// <summary>
        /// SharedWorker
        /// </summary>
        [JsonPropertyName("SharedWorker")]
        SharedWorker,
        /// <summary>
        /// Stylesheet
        /// </summary>
        [JsonPropertyName("Stylesheet")]
        Stylesheet,
        /// <summary>
        /// Track
        /// </summary>
        [JsonPropertyName("Track")]
        Track,
        /// <summary>
        /// Video
        /// </summary>
        [JsonPropertyName("Video")]
        Video,
        /// <summary>
        /// Worker
        /// </summary>
        [JsonPropertyName("Worker")]
        Worker,
        /// <summary>
        /// XMLHttpRequest
        /// </summary>
        [JsonPropertyName("XMLHttpRequest")]
        XMLHttpRequest,
        /// <summary>
        /// XSLT
        /// </summary>
        [JsonPropertyName("XSLT")]
        XSLT
    }

    /// <summary>
    /// MixedContentIssueDetails
    /// </summary>
    public partial class MixedContentIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The type of resource causing the mixed content issue (css, js, iframe,
        /// form,...). Marked as optional because it is mapped to from
        /// blink::mojom::RequestContextType, which will be replaced
        /// by network::mojom::RequestDestination
        /// </summary>
        [JsonPropertyName("resourceType")]
        public CefSharp.DevTools.Audits.MixedContentResourceType? ResourceType
        {
            get;
            set;
        }

        /// <summary>
        /// The way the mixed content issue is being resolved.
        /// </summary>
        [JsonPropertyName("resolutionStatus")]
        public CefSharp.DevTools.Audits.MixedContentResolutionStatus ResolutionStatus
        {
            get;
            set;
        }

        /// <summary>
        /// The unsafe http url causing the mixed content issue.
        /// </summary>
        [JsonPropertyName("insecureURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InsecureURL
        {
            get;
            set;
        }

        /// <summary>
        /// The url responsible for the call to an unsafe url.
        /// </summary>
        [JsonPropertyName("mainResourceURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MainResourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// The mixed content request.
        /// Does not always exist (e.g. for unsafe form submission urls).
        /// </summary>
        [JsonPropertyName("request")]
        public CefSharp.DevTools.Audits.AffectedRequest Request
        {
            get;
            set;
        }

        /// <summary>
        /// Optional because not every mixed content issue is necessarily linked to a frame.
        /// </summary>
        [JsonPropertyName("frame")]
        public CefSharp.DevTools.Audits.AffectedFrame Frame
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Enum indicating the reason a response has been blocked. These reasons are
    /// refinements of the net error BLOCKED_BY_RESPONSE.
    /// </summary>
    public enum BlockedByResponseReason
    {
        /// <summary>
        /// CoepFrameResourceNeedsCoepHeader
        /// </summary>
        [JsonPropertyName("CoepFrameResourceNeedsCoepHeader")]
        CoepFrameResourceNeedsCoepHeader,
        /// <summary>
        /// CoopSandboxedIFrameCannotNavigateToCoopPage
        /// </summary>
        [JsonPropertyName("CoopSandboxedIFrameCannotNavigateToCoopPage")]
        CoopSandboxedIFrameCannotNavigateToCoopPage,
        /// <summary>
        /// CorpNotSameOrigin
        /// </summary>
        [JsonPropertyName("CorpNotSameOrigin")]
        CorpNotSameOrigin,
        /// <summary>
        /// CorpNotSameOriginAfterDefaultedToSameOriginByCoep
        /// </summary>
        [JsonPropertyName("CorpNotSameOriginAfterDefaultedToSameOriginByCoep")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        /// <summary>
        /// CorpNotSameSite
        /// </summary>
        [JsonPropertyName("CorpNotSameSite")]
        CorpNotSameSite
    }

    /// <summary>
    /// Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
    /// code. Currently only used for COEP/COOP, but may be extended to include
    /// some CSP errors in the future.
    /// </summary>
    public partial class BlockedByResponseIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Request
        /// </summary>
        [JsonPropertyName("request")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.AffectedRequest Request
        {
            get;
            set;
        }

        /// <summary>
        /// ParentFrame
        /// </summary>
        [JsonPropertyName("parentFrame")]
        public CefSharp.DevTools.Audits.AffectedFrame ParentFrame
        {
            get;
            set;
        }

        /// <summary>
        /// BlockedFrame
        /// </summary>
        [JsonPropertyName("blockedFrame")]
        public CefSharp.DevTools.Audits.AffectedFrame BlockedFrame
        {
            get;
            set;
        }

        /// <summary>
        /// Reason
        /// </summary>
        [JsonPropertyName("reason")]
        public CefSharp.DevTools.Audits.BlockedByResponseReason Reason
        {
            get;
            set;
        }
    }

    /// <summary>
    /// HeavyAdResolutionStatus
    /// </summary>
    public enum HeavyAdResolutionStatus
    {
        /// <summary>
        /// HeavyAdBlocked
        /// </summary>
        [JsonPropertyName("HeavyAdBlocked")]
        HeavyAdBlocked,
        /// <summary>
        /// HeavyAdWarning
        /// </summary>
        [JsonPropertyName("HeavyAdWarning")]
        HeavyAdWarning
    }

    /// <summary>
    /// HeavyAdReason
    /// </summary>
    public enum HeavyAdReason
    {
        /// <summary>
        /// NetworkTotalLimit
        /// </summary>
        [JsonPropertyName("NetworkTotalLimit")]
        NetworkTotalLimit,
        /// <summary>
        /// CpuTotalLimit
        /// </summary>
        [JsonPropertyName("CpuTotalLimit")]
        CpuTotalLimit,
        /// <summary>
        /// CpuPeakLimit
        /// </summary>
        [JsonPropertyName("CpuPeakLimit")]
        CpuPeakLimit
    }

    /// <summary>
    /// HeavyAdIssueDetails
    /// </summary>
    public partial class HeavyAdIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The resolution status, either blocking the content or warning.
        /// </summary>
        [JsonPropertyName("resolution")]
        public CefSharp.DevTools.Audits.HeavyAdResolutionStatus Resolution
        {
            get;
            set;
        }

        /// <summary>
        /// The reason the ad was blocked, total network or cpu or peak cpu.
        /// </summary>
        [JsonPropertyName("reason")]
        public CefSharp.DevTools.Audits.HeavyAdReason Reason
        {
            get;
            set;
        }

        /// <summary>
        /// The frame that was blocked.
        /// </summary>
        [JsonPropertyName("frame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.AffectedFrame Frame
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ContentSecurityPolicyViolationType
    /// </summary>
    public enum ContentSecurityPolicyViolationType
    {
        /// <summary>
        /// kInlineViolation
        /// </summary>
        [JsonPropertyName("kInlineViolation")]
        KInlineViolation,
        /// <summary>
        /// kEvalViolation
        /// </summary>
        [JsonPropertyName("kEvalViolation")]
        KEvalViolation,
        /// <summary>
        /// kURLViolation
        /// </summary>
        [JsonPropertyName("kURLViolation")]
        KURLViolation,
        /// <summary>
        /// kTrustedTypesSinkViolation
        /// </summary>
        [JsonPropertyName("kTrustedTypesSinkViolation")]
        KTrustedTypesSinkViolation,
        /// <summary>
        /// kTrustedTypesPolicyViolation
        /// </summary>
        [JsonPropertyName("kTrustedTypesPolicyViolation")]
        KTrustedTypesPolicyViolation,
        /// <summary>
        /// kWasmEvalViolation
        /// </summary>
        [JsonPropertyName("kWasmEvalViolation")]
        KWasmEvalViolation
    }

    /// <summary>
    /// SourceCodeLocation
    /// </summary>
    public partial class SourceCodeLocation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ScriptId
        /// </summary>
        [JsonPropertyName("scriptId")]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Url
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// LineNumber
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// ColumnNumber
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ContentSecurityPolicyIssueDetails
    /// </summary>
    public partial class ContentSecurityPolicyIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The url not included in allowed sources.
        /// </summary>
        [JsonPropertyName("blockedURL")]
        public string BlockedURL
        {
            get;
            set;
        }

        /// <summary>
        /// Specific directive that is violated, causing the CSP issue.
        /// </summary>
        [JsonPropertyName("violatedDirective")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ViolatedDirective
        {
            get;
            set;
        }

        /// <summary>
        /// IsReportOnly
        /// </summary>
        [JsonPropertyName("isReportOnly")]
        public bool IsReportOnly
        {
            get;
            set;
        }

        /// <summary>
        /// ContentSecurityPolicyViolationType
        /// </summary>
        [JsonPropertyName("contentSecurityPolicyViolationType")]
        public CefSharp.DevTools.Audits.ContentSecurityPolicyViolationType ContentSecurityPolicyViolationType
        {
            get;
            set;
        }

        /// <summary>
        /// FrameAncestor
        /// </summary>
        [JsonPropertyName("frameAncestor")]
        public CefSharp.DevTools.Audits.AffectedFrame FrameAncestor
        {
            get;
            set;
        }

        /// <summary>
        /// SourceCodeLocation
        /// </summary>
        [JsonPropertyName("sourceCodeLocation")]
        public CefSharp.DevTools.Audits.SourceCodeLocation SourceCodeLocation
        {
            get;
            set;
        }

        /// <summary>
        /// ViolatingNodeId
        /// </summary>
        [JsonPropertyName("violatingNodeId")]
        public int? ViolatingNodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// SharedArrayBufferIssueType
    /// </summary>
    public enum SharedArrayBufferIssueType
    {
        /// <summary>
        /// TransferIssue
        /// </summary>
        [JsonPropertyName("TransferIssue")]
        TransferIssue,
        /// <summary>
        /// CreationIssue
        /// </summary>
        [JsonPropertyName("CreationIssue")]
        CreationIssue
    }

    /// <summary>
    /// Details for a issue arising from an SAB being instantiated in, or
    /// transferred to a context that is not cross-origin isolated.
    /// </summary>
    public partial class SharedArrayBufferIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// SourceCodeLocation
        /// </summary>
        [JsonPropertyName("sourceCodeLocation")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.SourceCodeLocation SourceCodeLocation
        {
            get;
            set;
        }

        /// <summary>
        /// IsWarning
        /// </summary>
        [JsonPropertyName("isWarning")]
        public bool IsWarning
        {
            get;
            set;
        }

        /// <summary>
        /// Type
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Audits.SharedArrayBufferIssueType Type
        {
            get;
            set;
        }
    }

    /// <summary>
    /// TwaQualityEnforcementViolationType
    /// </summary>
    public enum TwaQualityEnforcementViolationType
    {
        /// <summary>
        /// kHttpError
        /// </summary>
        [JsonPropertyName("kHttpError")]
        KHttpError,
        /// <summary>
        /// kUnavailableOffline
        /// </summary>
        [JsonPropertyName("kUnavailableOffline")]
        KUnavailableOffline,
        /// <summary>
        /// kDigitalAssetLinks
        /// </summary>
        [JsonPropertyName("kDigitalAssetLinks")]
        KDigitalAssetLinks
    }

    /// <summary>
    /// TrustedWebActivityIssueDetails
    /// </summary>
    public partial class TrustedWebActivityIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The url that triggers the violation.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// ViolationType
        /// </summary>
        [JsonPropertyName("violationType")]
        public CefSharp.DevTools.Audits.TwaQualityEnforcementViolationType ViolationType
        {
            get;
            set;
        }

        /// <summary>
        /// HttpStatusCode
        /// </summary>
        [JsonPropertyName("httpStatusCode")]
        public int? HttpStatusCode
        {
            get;
            set;
        }

        /// <summary>
        /// The package name of the Trusted Web Activity client app. This field is
        /// only used when violation type is kDigitalAssetLinks.
        /// </summary>
        [JsonPropertyName("packageName")]
        public string PackageName
        {
            get;
            set;
        }

        /// <summary>
        /// The signature of the Trusted Web Activity client app. This field is only
        /// used when violation type is kDigitalAssetLinks.
        /// </summary>
        [JsonPropertyName("signature")]
        public string Signature
        {
            get;
            set;
        }
    }

    /// <summary>
    /// LowTextContrastIssueDetails
    /// </summary>
    public partial class LowTextContrastIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ViolatingNodeId
        /// </summary>
        [JsonPropertyName("violatingNodeId")]
        public int ViolatingNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// ViolatingNodeSelector
        /// </summary>
        [JsonPropertyName("violatingNodeSelector")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ViolatingNodeSelector
        {
            get;
            set;
        }

        /// <summary>
        /// ContrastRatio
        /// </summary>
        [JsonPropertyName("contrastRatio")]
        public double ContrastRatio
        {
            get;
            set;
        }

        /// <summary>
        /// ThresholdAA
        /// </summary>
        [JsonPropertyName("thresholdAA")]
        public double ThresholdAA
        {
            get;
            set;
        }

        /// <summary>
        /// ThresholdAAA
        /// </summary>
        [JsonPropertyName("thresholdAAA")]
        public double ThresholdAAA
        {
            get;
            set;
        }

        /// <summary>
        /// FontSize
        /// </summary>
        [JsonPropertyName("fontSize")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontSize
        {
            get;
            set;
        }

        /// <summary>
        /// FontWeight
        /// </summary>
        [JsonPropertyName("fontWeight")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontWeight
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Details for a CORS related issue, e.g. a warning or error related to
    /// CORS RFC1918 enforcement.
    /// </summary>
    public partial class CorsIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CorsErrorStatus
        /// </summary>
        [JsonPropertyName("corsErrorStatus")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.CorsErrorStatus CorsErrorStatus
        {
            get;
            set;
        }

        /// <summary>
        /// IsWarning
        /// </summary>
        [JsonPropertyName("isWarning")]
        public bool IsWarning
        {
            get;
            set;
        }

        /// <summary>
        /// Request
        /// </summary>
        [JsonPropertyName("request")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.AffectedRequest Request
        {
            get;
            set;
        }

        /// <summary>
        /// Location
        /// </summary>
        [JsonPropertyName("location")]
        public CefSharp.DevTools.Audits.SourceCodeLocation Location
        {
            get;
            set;
        }

        /// <summary>
        /// InitiatorOrigin
        /// </summary>
        [JsonPropertyName("initiatorOrigin")]
        public string InitiatorOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// ResourceIPAddressSpace
        /// </summary>
        [JsonPropertyName("resourceIPAddressSpace")]
        public CefSharp.DevTools.Network.IPAddressSpace? ResourceIPAddressSpace
        {
            get;
            set;
        }

        /// <summary>
        /// ClientSecurityState
        /// </summary>
        [JsonPropertyName("clientSecurityState")]
        public CefSharp.DevTools.Network.ClientSecurityState ClientSecurityState
        {
            get;
            set;
        }
    }

    /// <summary>
    /// AttributionReportingIssueType
    /// </summary>
    public enum AttributionReportingIssueType
    {
        /// <summary>
        /// PermissionPolicyDisabled
        /// </summary>
        [JsonPropertyName("PermissionPolicyDisabled")]
        PermissionPolicyDisabled,
        /// <summary>
        /// UntrustworthyReportingOrigin
        /// </summary>
        [JsonPropertyName("UntrustworthyReportingOrigin")]
        UntrustworthyReportingOrigin,
        /// <summary>
        /// InsecureContext
        /// </summary>
        [JsonPropertyName("InsecureContext")]
        InsecureContext,
        /// <summary>
        /// InvalidHeader
        /// </summary>
        [JsonPropertyName("InvalidHeader")]
        InvalidHeader,
        /// <summary>
        /// InvalidRegisterTriggerHeader
        /// </summary>
        [JsonPropertyName("InvalidRegisterTriggerHeader")]
        InvalidRegisterTriggerHeader,
        /// <summary>
        /// InvalidEligibleHeader
        /// </summary>
        [JsonPropertyName("InvalidEligibleHeader")]
        InvalidEligibleHeader,
        /// <summary>
        /// SourceAndTriggerHeaders
        /// </summary>
        [JsonPropertyName("SourceAndTriggerHeaders")]
        SourceAndTriggerHeaders,
        /// <summary>
        /// SourceIgnored
        /// </summary>
        [JsonPropertyName("SourceIgnored")]
        SourceIgnored,
        /// <summary>
        /// TriggerIgnored
        /// </summary>
        [JsonPropertyName("TriggerIgnored")]
        TriggerIgnored,
        /// <summary>
        /// OsSourceIgnored
        /// </summary>
        [JsonPropertyName("OsSourceIgnored")]
        OsSourceIgnored,
        /// <summary>
        /// OsTriggerIgnored
        /// </summary>
        [JsonPropertyName("OsTriggerIgnored")]
        OsTriggerIgnored,
        /// <summary>
        /// InvalidRegisterOsSourceHeader
        /// </summary>
        [JsonPropertyName("InvalidRegisterOsSourceHeader")]
        InvalidRegisterOsSourceHeader,
        /// <summary>
        /// InvalidRegisterOsTriggerHeader
        /// </summary>
        [JsonPropertyName("InvalidRegisterOsTriggerHeader")]
        InvalidRegisterOsTriggerHeader,
        /// <summary>
        /// WebAndOsHeaders
        /// </summary>
        [JsonPropertyName("WebAndOsHeaders")]
        WebAndOsHeaders,
        /// <summary>
        /// NoWebOrOsSupport
        /// </summary>
        [JsonPropertyName("NoWebOrOsSupport")]
        NoWebOrOsSupport
    }

    /// <summary>
    /// Details for issues around &quot;Attribution Reporting API&quot; usage.
    /// Explainer: https://github.com/WICG/attribution-reporting-api
    /// </summary>
    public partial class AttributionReportingIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ViolationType
        /// </summary>
        [JsonPropertyName("violationType")]
        public CefSharp.DevTools.Audits.AttributionReportingIssueType ViolationType
        {
            get;
            set;
        }

        /// <summary>
        /// Request
        /// </summary>
        [JsonPropertyName("request")]
        public CefSharp.DevTools.Audits.AffectedRequest Request
        {
            get;
            set;
        }

        /// <summary>
        /// ViolatingNodeId
        /// </summary>
        [JsonPropertyName("violatingNodeId")]
        public int? ViolatingNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// InvalidParameter
        /// </summary>
        [JsonPropertyName("invalidParameter")]
        public string InvalidParameter
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Details for issues about documents in Quirks Mode
    /// or Limited Quirks Mode that affects page layouting.
    /// </summary>
    public partial class QuirksModeIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// If false, it means the document&apos;s mode is &quot;quirks&quot;
        /// instead of &quot;limited-quirks&quot;.
        /// </summary>
        [JsonPropertyName("isLimitedQuirksMode")]
        public bool IsLimitedQuirksMode
        {
            get;
            set;
        }

        /// <summary>
        /// DocumentNodeId
        /// </summary>
        [JsonPropertyName("documentNodeId")]
        public int DocumentNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Url
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// FrameId
        /// </summary>
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// LoaderId
        /// </summary>
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// NavigatorUserAgentIssueDetails
    /// </summary>
    public partial class NavigatorUserAgentIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Url
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Location
        /// </summary>
        [JsonPropertyName("location")]
        public CefSharp.DevTools.Audits.SourceCodeLocation Location
        {
            get;
            set;
        }
    }

    /// <summary>
    /// GenericIssueErrorType
    /// </summary>
    public enum GenericIssueErrorType
    {
        /// <summary>
        /// CrossOriginPortalPostMessageError
        /// </summary>
        [JsonPropertyName("CrossOriginPortalPostMessageError")]
        CrossOriginPortalPostMessageError,
        /// <summary>
        /// FormLabelForNameError
        /// </summary>
        [JsonPropertyName("FormLabelForNameError")]
        FormLabelForNameError,
        /// <summary>
        /// FormDuplicateIdForInputError
        /// </summary>
        [JsonPropertyName("FormDuplicateIdForInputError")]
        FormDuplicateIdForInputError,
        /// <summary>
        /// FormInputWithNoLabelError
        /// </summary>
        [JsonPropertyName("FormInputWithNoLabelError")]
        FormInputWithNoLabelError,
        /// <summary>
        /// FormAutocompleteAttributeEmptyError
        /// </summary>
        [JsonPropertyName("FormAutocompleteAttributeEmptyError")]
        FormAutocompleteAttributeEmptyError,
        /// <summary>
        /// FormEmptyIdAndNameAttributesForInputError
        /// </summary>
        [JsonPropertyName("FormEmptyIdAndNameAttributesForInputError")]
        FormEmptyIdAndNameAttributesForInputError,
        /// <summary>
        /// FormAriaLabelledByToNonExistingId
        /// </summary>
        [JsonPropertyName("FormAriaLabelledByToNonExistingId")]
        FormAriaLabelledByToNonExistingId,
        /// <summary>
        /// FormInputAssignedAutocompleteValueToIdOrNameAttributeError
        /// </summary>
        [JsonPropertyName("FormInputAssignedAutocompleteValueToIdOrNameAttributeError")]
        FormInputAssignedAutocompleteValueToIdOrNameAttributeError,
        /// <summary>
        /// FormLabelHasNeitherForNorNestedInput
        /// </summary>
        [JsonPropertyName("FormLabelHasNeitherForNorNestedInput")]
        FormLabelHasNeitherForNorNestedInput,
        /// <summary>
        /// FormLabelForMatchesNonExistingIdError
        /// </summary>
        [JsonPropertyName("FormLabelForMatchesNonExistingIdError")]
        FormLabelForMatchesNonExistingIdError,
        /// <summary>
        /// FormInputHasWrongButWellIntendedAutocompleteValueError
        /// </summary>
        [JsonPropertyName("FormInputHasWrongButWellIntendedAutocompleteValueError")]
        FormInputHasWrongButWellIntendedAutocompleteValueError
    }

    /// <summary>
    /// Depending on the concrete errorType, different properties are set.
    /// </summary>
    public partial class GenericIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Issues with the same errorType are aggregated in the frontend.
        /// </summary>
        [JsonPropertyName("errorType")]
        public CefSharp.DevTools.Audits.GenericIssueErrorType ErrorType
        {
            get;
            set;
        }

        /// <summary>
        /// FrameId
        /// </summary>
        [JsonPropertyName("frameId")]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// ViolatingNodeId
        /// </summary>
        [JsonPropertyName("violatingNodeId")]
        public int? ViolatingNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// ViolatingNodeAttribute
        /// </summary>
        [JsonPropertyName("violatingNodeAttribute")]
        public string ViolatingNodeAttribute
        {
            get;
            set;
        }
    }

    /// <summary>
    /// This issue tracks information needed to print a deprecation message.
    /// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
    /// </summary>
    public partial class DeprecationIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// AffectedFrame
        /// </summary>
        [JsonPropertyName("affectedFrame")]
        public CefSharp.DevTools.Audits.AffectedFrame AffectedFrame
        {
            get;
            set;
        }

        /// <summary>
        /// SourceCodeLocation
        /// </summary>
        [JsonPropertyName("sourceCodeLocation")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.SourceCodeLocation SourceCodeLocation
        {
            get;
            set;
        }

        /// <summary>
        /// One of the deprecation names from third_party/blink/renderer/core/frame/deprecation/deprecation.json5
        /// </summary>
        [JsonPropertyName("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }
    }

    /// <summary>
    /// This issue warns about sites in the redirect chain of a finished navigation
    /// that may be flagged as trackers and have their state cleared if they don&apos;t
    /// receive a user interaction. Note that in this context &apos;site&apos; means eTLD+1.
    /// For example, if the URL `https://example.test:80/bounce` was in the
    /// redirect chain, the site reported would be `example.test`.
    /// </summary>
    public partial class BounceTrackingIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// TrackingSites
        /// </summary>
        [JsonPropertyName("trackingSites")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] TrackingSites
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ClientHintIssueReason
    /// </summary>
    public enum ClientHintIssueReason
    {
        /// <summary>
        /// MetaTagAllowListInvalidOrigin
        /// </summary>
        [JsonPropertyName("MetaTagAllowListInvalidOrigin")]
        MetaTagAllowListInvalidOrigin,
        /// <summary>
        /// MetaTagModifiedHTML
        /// </summary>
        [JsonPropertyName("MetaTagModifiedHTML")]
        MetaTagModifiedHTML
    }

    /// <summary>
    /// FederatedAuthRequestIssueDetails
    /// </summary>
    public partial class FederatedAuthRequestIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// FederatedAuthRequestIssueReason
        /// </summary>
        [JsonPropertyName("federatedAuthRequestIssueReason")]
        public CefSharp.DevTools.Audits.FederatedAuthRequestIssueReason FederatedAuthRequestIssueReason
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Represents the failure reason when a federated authentication reason fails.
    /// Should be updated alongside RequestIdTokenStatus in
    /// third_party/blink/public/mojom/devtools/inspector_issue.mojom to include
    /// all cases except for success.
    /// </summary>
    public enum FederatedAuthRequestIssueReason
    {
        /// <summary>
        /// ShouldEmbargo
        /// </summary>
        [JsonPropertyName("ShouldEmbargo")]
        ShouldEmbargo,
        /// <summary>
        /// TooManyRequests
        /// </summary>
        [JsonPropertyName("TooManyRequests")]
        TooManyRequests,
        /// <summary>
        /// WellKnownHttpNotFound
        /// </summary>
        [JsonPropertyName("WellKnownHttpNotFound")]
        WellKnownHttpNotFound,
        /// <summary>
        /// WellKnownNoResponse
        /// </summary>
        [JsonPropertyName("WellKnownNoResponse")]
        WellKnownNoResponse,
        /// <summary>
        /// WellKnownInvalidResponse
        /// </summary>
        [JsonPropertyName("WellKnownInvalidResponse")]
        WellKnownInvalidResponse,
        /// <summary>
        /// WellKnownListEmpty
        /// </summary>
        [JsonPropertyName("WellKnownListEmpty")]
        WellKnownListEmpty,
        /// <summary>
        /// WellKnownInvalidContentType
        /// </summary>
        [JsonPropertyName("WellKnownInvalidContentType")]
        WellKnownInvalidContentType,
        /// <summary>
        /// ConfigNotInWellKnown
        /// </summary>
        [JsonPropertyName("ConfigNotInWellKnown")]
        ConfigNotInWellKnown,
        /// <summary>
        /// WellKnownTooBig
        /// </summary>
        [JsonPropertyName("WellKnownTooBig")]
        WellKnownTooBig,
        /// <summary>
        /// ConfigHttpNotFound
        /// </summary>
        [JsonPropertyName("ConfigHttpNotFound")]
        ConfigHttpNotFound,
        /// <summary>
        /// ConfigNoResponse
        /// </summary>
        [JsonPropertyName("ConfigNoResponse")]
        ConfigNoResponse,
        /// <summary>
        /// ConfigInvalidResponse
        /// </summary>
        [JsonPropertyName("ConfigInvalidResponse")]
        ConfigInvalidResponse,
        /// <summary>
        /// ConfigInvalidContentType
        /// </summary>
        [JsonPropertyName("ConfigInvalidContentType")]
        ConfigInvalidContentType,
        /// <summary>
        /// ClientMetadataHttpNotFound
        /// </summary>
        [JsonPropertyName("ClientMetadataHttpNotFound")]
        ClientMetadataHttpNotFound,
        /// <summary>
        /// ClientMetadataNoResponse
        /// </summary>
        [JsonPropertyName("ClientMetadataNoResponse")]
        ClientMetadataNoResponse,
        /// <summary>
        /// ClientMetadataInvalidResponse
        /// </summary>
        [JsonPropertyName("ClientMetadataInvalidResponse")]
        ClientMetadataInvalidResponse,
        /// <summary>
        /// ClientMetadataInvalidContentType
        /// </summary>
        [JsonPropertyName("ClientMetadataInvalidContentType")]
        ClientMetadataInvalidContentType,
        /// <summary>
        /// DisabledInSettings
        /// </summary>
        [JsonPropertyName("DisabledInSettings")]
        DisabledInSettings,
        /// <summary>
        /// ErrorFetchingSignin
        /// </summary>
        [JsonPropertyName("ErrorFetchingSignin")]
        ErrorFetchingSignin,
        /// <summary>
        /// InvalidSigninResponse
        /// </summary>
        [JsonPropertyName("InvalidSigninResponse")]
        InvalidSigninResponse,
        /// <summary>
        /// AccountsHttpNotFound
        /// </summary>
        [JsonPropertyName("AccountsHttpNotFound")]
        AccountsHttpNotFound,
        /// <summary>
        /// AccountsNoResponse
        /// </summary>
        [JsonPropertyName("AccountsNoResponse")]
        AccountsNoResponse,
        /// <summary>
        /// AccountsInvalidResponse
        /// </summary>
        [JsonPropertyName("AccountsInvalidResponse")]
        AccountsInvalidResponse,
        /// <summary>
        /// AccountsListEmpty
        /// </summary>
        [JsonPropertyName("AccountsListEmpty")]
        AccountsListEmpty,
        /// <summary>
        /// AccountsInvalidContentType
        /// </summary>
        [JsonPropertyName("AccountsInvalidContentType")]
        AccountsInvalidContentType,
        /// <summary>
        /// IdTokenHttpNotFound
        /// </summary>
        [JsonPropertyName("IdTokenHttpNotFound")]
        IdTokenHttpNotFound,
        /// <summary>
        /// IdTokenNoResponse
        /// </summary>
        [JsonPropertyName("IdTokenNoResponse")]
        IdTokenNoResponse,
        /// <summary>
        /// IdTokenInvalidResponse
        /// </summary>
        [JsonPropertyName("IdTokenInvalidResponse")]
        IdTokenInvalidResponse,
        /// <summary>
        /// IdTokenInvalidRequest
        /// </summary>
        [JsonPropertyName("IdTokenInvalidRequest")]
        IdTokenInvalidRequest,
        /// <summary>
        /// IdTokenInvalidContentType
        /// </summary>
        [JsonPropertyName("IdTokenInvalidContentType")]
        IdTokenInvalidContentType,
        /// <summary>
        /// ErrorIdToken
        /// </summary>
        [JsonPropertyName("ErrorIdToken")]
        ErrorIdToken,
        /// <summary>
        /// Canceled
        /// </summary>
        [JsonPropertyName("Canceled")]
        Canceled,
        /// <summary>
        /// RpPageNotVisible
        /// </summary>
        [JsonPropertyName("RpPageNotVisible")]
        RpPageNotVisible
    }

    /// <summary>
    /// This issue tracks client hints related issues. It&apos;s used to deprecate old
    /// features, encourage the use of new ones, and provide general guidance.
    /// </summary>
    public partial class ClientHintIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// SourceCodeLocation
        /// </summary>
        [JsonPropertyName("sourceCodeLocation")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.SourceCodeLocation SourceCodeLocation
        {
            get;
            set;
        }

        /// <summary>
        /// ClientHintIssueReason
        /// </summary>
        [JsonPropertyName("clientHintIssueReason")]
        public CefSharp.DevTools.Audits.ClientHintIssueReason ClientHintIssueReason
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A unique identifier for the type of issue. Each type may use one of the
    /// optional fields in InspectorIssueDetails to convey more specific
    /// information about the kind of issue.
    /// </summary>
    public enum InspectorIssueCode
    {
        /// <summary>
        /// CookieIssue
        /// </summary>
        [JsonPropertyName("CookieIssue")]
        CookieIssue,
        /// <summary>
        /// MixedContentIssue
        /// </summary>
        [JsonPropertyName("MixedContentIssue")]
        MixedContentIssue,
        /// <summary>
        /// BlockedByResponseIssue
        /// </summary>
        [JsonPropertyName("BlockedByResponseIssue")]
        BlockedByResponseIssue,
        /// <summary>
        /// HeavyAdIssue
        /// </summary>
        [JsonPropertyName("HeavyAdIssue")]
        HeavyAdIssue,
        /// <summary>
        /// ContentSecurityPolicyIssue
        /// </summary>
        [JsonPropertyName("ContentSecurityPolicyIssue")]
        ContentSecurityPolicyIssue,
        /// <summary>
        /// SharedArrayBufferIssue
        /// </summary>
        [JsonPropertyName("SharedArrayBufferIssue")]
        SharedArrayBufferIssue,
        /// <summary>
        /// TrustedWebActivityIssue
        /// </summary>
        [JsonPropertyName("TrustedWebActivityIssue")]
        TrustedWebActivityIssue,
        /// <summary>
        /// LowTextContrastIssue
        /// </summary>
        [JsonPropertyName("LowTextContrastIssue")]
        LowTextContrastIssue,
        /// <summary>
        /// CorsIssue
        /// </summary>
        [JsonPropertyName("CorsIssue")]
        CorsIssue,
        /// <summary>
        /// AttributionReportingIssue
        /// </summary>
        [JsonPropertyName("AttributionReportingIssue")]
        AttributionReportingIssue,
        /// <summary>
        /// QuirksModeIssue
        /// </summary>
        [JsonPropertyName("QuirksModeIssue")]
        QuirksModeIssue,
        /// <summary>
        /// NavigatorUserAgentIssue
        /// </summary>
        [JsonPropertyName("NavigatorUserAgentIssue")]
        NavigatorUserAgentIssue,
        /// <summary>
        /// GenericIssue
        /// </summary>
        [JsonPropertyName("GenericIssue")]
        GenericIssue,
        /// <summary>
        /// DeprecationIssue
        /// </summary>
        [JsonPropertyName("DeprecationIssue")]
        DeprecationIssue,
        /// <summary>
        /// ClientHintIssue
        /// </summary>
        [JsonPropertyName("ClientHintIssue")]
        ClientHintIssue,
        /// <summary>
        /// FederatedAuthRequestIssue
        /// </summary>
        [JsonPropertyName("FederatedAuthRequestIssue")]
        FederatedAuthRequestIssue,
        /// <summary>
        /// BounceTrackingIssue
        /// </summary>
        [JsonPropertyName("BounceTrackingIssue")]
        BounceTrackingIssue
    }

    /// <summary>
    /// This struct holds a list of optional fields with additional information
    /// specific to the kind of issue. When adding a new issue code, please also
    /// add a new optional field to this type.
    /// </summary>
    public partial class InspectorIssueDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CookieIssueDetails
        /// </summary>
        [JsonPropertyName("cookieIssueDetails")]
        public CefSharp.DevTools.Audits.CookieIssueDetails CookieIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// MixedContentIssueDetails
        /// </summary>
        [JsonPropertyName("mixedContentIssueDetails")]
        public CefSharp.DevTools.Audits.MixedContentIssueDetails MixedContentIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// BlockedByResponseIssueDetails
        /// </summary>
        [JsonPropertyName("blockedByResponseIssueDetails")]
        public CefSharp.DevTools.Audits.BlockedByResponseIssueDetails BlockedByResponseIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// HeavyAdIssueDetails
        /// </summary>
        [JsonPropertyName("heavyAdIssueDetails")]
        public CefSharp.DevTools.Audits.HeavyAdIssueDetails HeavyAdIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// ContentSecurityPolicyIssueDetails
        /// </summary>
        [JsonPropertyName("contentSecurityPolicyIssueDetails")]
        public CefSharp.DevTools.Audits.ContentSecurityPolicyIssueDetails ContentSecurityPolicyIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// SharedArrayBufferIssueDetails
        /// </summary>
        [JsonPropertyName("sharedArrayBufferIssueDetails")]
        public CefSharp.DevTools.Audits.SharedArrayBufferIssueDetails SharedArrayBufferIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// TwaQualityEnforcementDetails
        /// </summary>
        [JsonPropertyName("twaQualityEnforcementDetails")]
        public CefSharp.DevTools.Audits.TrustedWebActivityIssueDetails TwaQualityEnforcementDetails
        {
            get;
            set;
        }

        /// <summary>
        /// LowTextContrastIssueDetails
        /// </summary>
        [JsonPropertyName("lowTextContrastIssueDetails")]
        public CefSharp.DevTools.Audits.LowTextContrastIssueDetails LowTextContrastIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// CorsIssueDetails
        /// </summary>
        [JsonPropertyName("corsIssueDetails")]
        public CefSharp.DevTools.Audits.CorsIssueDetails CorsIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// AttributionReportingIssueDetails
        /// </summary>
        [JsonPropertyName("attributionReportingIssueDetails")]
        public CefSharp.DevTools.Audits.AttributionReportingIssueDetails AttributionReportingIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// QuirksModeIssueDetails
        /// </summary>
        [JsonPropertyName("quirksModeIssueDetails")]
        public CefSharp.DevTools.Audits.QuirksModeIssueDetails QuirksModeIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// NavigatorUserAgentIssueDetails
        /// </summary>
        [JsonPropertyName("navigatorUserAgentIssueDetails")]
        public CefSharp.DevTools.Audits.NavigatorUserAgentIssueDetails NavigatorUserAgentIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// GenericIssueDetails
        /// </summary>
        [JsonPropertyName("genericIssueDetails")]
        public CefSharp.DevTools.Audits.GenericIssueDetails GenericIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// DeprecationIssueDetails
        /// </summary>
        [JsonPropertyName("deprecationIssueDetails")]
        public CefSharp.DevTools.Audits.DeprecationIssueDetails DeprecationIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// ClientHintIssueDetails
        /// </summary>
        [JsonPropertyName("clientHintIssueDetails")]
        public CefSharp.DevTools.Audits.ClientHintIssueDetails ClientHintIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// FederatedAuthRequestIssueDetails
        /// </summary>
        [JsonPropertyName("federatedAuthRequestIssueDetails")]
        public CefSharp.DevTools.Audits.FederatedAuthRequestIssueDetails FederatedAuthRequestIssueDetails
        {
            get;
            set;
        }

        /// <summary>
        /// BounceTrackingIssueDetails
        /// </summary>
        [JsonPropertyName("bounceTrackingIssueDetails")]
        public CefSharp.DevTools.Audits.BounceTrackingIssueDetails BounceTrackingIssueDetails
        {
            get;
            set;
        }
    }

    /// <summary>
    /// An inspector issue reported from the back-end.
    /// </summary>
    public partial class InspectorIssue : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Code
        /// </summary>
        [JsonPropertyName("code")]
        public CefSharp.DevTools.Audits.InspectorIssueCode Code
        {
            get;
            set;
        }

        /// <summary>
        /// Details
        /// </summary>
        [JsonPropertyName("details")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.InspectorIssueDetails Details
        {
            get;
            set;
        }

        /// <summary>
        /// A unique id for this issue. May be omitted if no other entity (e.g.
        /// exception, CDP message, etc.) is referencing this issue.
        /// </summary>
        [JsonPropertyName("issueId")]
        public string IssueId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// issueAdded
    /// </summary>
    public class IssueAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Issue
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("issue")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Audits.InspectorIssue Issue
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.BackgroundService
{
    /// <summary>
    /// The Background Service that will be associated with the commands/events.
    /// Every Background Service operates independently, but they share the same
    /// API.
    /// </summary>
    public enum ServiceName
    {
        /// <summary>
        /// backgroundFetch
        /// </summary>
        [JsonPropertyName("backgroundFetch")]
        BackgroundFetch,
        /// <summary>
        /// backgroundSync
        /// </summary>
        [JsonPropertyName("backgroundSync")]
        BackgroundSync,
        /// <summary>
        /// pushMessaging
        /// </summary>
        [JsonPropertyName("pushMessaging")]
        PushMessaging,
        /// <summary>
        /// notifications
        /// </summary>
        [JsonPropertyName("notifications")]
        Notifications,
        /// <summary>
        /// paymentHandler
        /// </summary>
        [JsonPropertyName("paymentHandler")]
        PaymentHandler,
        /// <summary>
        /// periodicBackgroundSync
        /// </summary>
        [JsonPropertyName("periodicBackgroundSync")]
        PeriodicBackgroundSync
    }

    /// <summary>
    /// A key-value pair for additional event information to pass along.
    /// </summary>
    public partial class EventMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key
        /// </summary>
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Key
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// BackgroundServiceEvent
    /// </summary>
    public partial class BackgroundServiceEvent : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Timestamp of the event (in seconds).
        /// </summary>
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// The origin this event belongs to.
        /// </summary>
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// The Service Worker ID that initiated the event.
        /// </summary>
        [JsonPropertyName("serviceWorkerRegistrationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ServiceWorkerRegistrationId
        {
            get;
            set;
        }

        /// <summary>
        /// The Background Service this event belongs to.
        /// </summary>
        [JsonPropertyName("service")]
        public CefSharp.DevTools.BackgroundService.ServiceName Service
        {
            get;
            set;
        }

        /// <summary>
        /// A description of the event.
        /// </summary>
        [JsonPropertyName("eventName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string EventName
        {
            get;
            set;
        }

        /// <summary>
        /// An identifier that groups related events together.
        /// </summary>
        [JsonPropertyName("instanceId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InstanceId
        {
            get;
            set;
        }

        /// <summary>
        /// A list of event-specific information.
        /// </summary>
        [JsonPropertyName("eventMetadata")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.BackgroundService.EventMetadata> EventMetadata
        {
            get;
            set;
        }

        /// <summary>
        /// Storage key this event belongs to.
        /// </summary>
        [JsonPropertyName("storageKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StorageKey
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Called when the recording state for the service has been updated.
    /// </summary>
    public class RecordingStateChangedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// IsRecording
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("isRecording")]
        public bool IsRecording
        {
            get;
            private set;
        }

        /// <summary>
        /// Service
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("service")]
        public CefSharp.DevTools.BackgroundService.ServiceName Service
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Called with all existing backgroundServiceEvents when enabled, and all new
    /// events afterwards if enabled and recording.
    /// </summary>
    public class BackgroundServiceEventReceivedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// BackgroundServiceEvent
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("backgroundServiceEvent")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.BackgroundService.BackgroundServiceEvent BackgroundServiceEvent
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// The state of the browser window.
    /// </summary>
    public enum WindowState
    {
        /// <summary>
        /// normal
        /// </summary>
        [JsonPropertyName("normal")]
        Normal,
        /// <summary>
        /// minimized
        /// </summary>
        [JsonPropertyName("minimized")]
        Minimized,
        /// <summary>
        /// maximized
        /// </summary>
        [JsonPropertyName("maximized")]
        Maximized,
        /// <summary>
        /// fullscreen
        /// </summary>
        [JsonPropertyName("fullscreen")]
        Fullscreen
    }

    /// <summary>
    /// Browser window bounds information
    /// </summary>
    public partial class Bounds : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The offset from the left edge of the screen to the window in pixels.
        /// </summary>
        [JsonPropertyName("left")]
        public int? Left
        {
            get;
            set;
        }

        /// <summary>
        /// The offset from the top edge of the screen to the window in pixels.
        /// </summary>
        [JsonPropertyName("top")]
        public int? Top
        {
            get;
            set;
        }

        /// <summary>
        /// The window width in pixels.
        /// </summary>
        [JsonPropertyName("width")]
        public int? Width
        {
            get;
            set;
        }

        /// <summary>
        /// The window height in pixels.
        /// </summary>
        [JsonPropertyName("height")]
        public int? Height
        {
            get;
            set;
        }

        /// <summary>
        /// The window state. Default to normal.
        /// </summary>
        [JsonPropertyName("windowState")]
        public CefSharp.DevTools.Browser.WindowState? WindowState
        {
            get;
            set;
        }
    }

    /// <summary>
    /// PermissionType
    /// </summary>
    public enum PermissionType
    {
        /// <summary>
        /// accessibilityEvents
        /// </summary>
        [JsonPropertyName("accessibilityEvents")]
        AccessibilityEvents,
        /// <summary>
        /// audioCapture
        /// </summary>
        [JsonPropertyName("audioCapture")]
        AudioCapture,
        /// <summary>
        /// backgroundSync
        /// </summary>
        [JsonPropertyName("backgroundSync")]
        BackgroundSync,
        /// <summary>
        /// backgroundFetch
        /// </summary>
        [JsonPropertyName("backgroundFetch")]
        BackgroundFetch,
        /// <summary>
        /// clipboardReadWrite
        /// </summary>
        [JsonPropertyName("clipboardReadWrite")]
        ClipboardReadWrite,
        /// <summary>
        /// clipboardSanitizedWrite
        /// </summary>
        [JsonPropertyName("clipboardSanitizedWrite")]
        ClipboardSanitizedWrite,
        /// <summary>
        /// displayCapture
        /// </summary>
        [JsonPropertyName("displayCapture")]
        DisplayCapture,
        /// <summary>
        /// durableStorage
        /// </summary>
        [JsonPropertyName("durableStorage")]
        DurableStorage,
        /// <summary>
        /// flash
        /// </summary>
        [JsonPropertyName("flash")]
        Flash,
        /// <summary>
        /// geolocation
        /// </summary>
        [JsonPropertyName("geolocation")]
        Geolocation,
        /// <summary>
        /// idleDetection
        /// </summary>
        [JsonPropertyName("idleDetection")]
        IdleDetection,
        /// <summary>
        /// localFonts
        /// </summary>
        [JsonPropertyName("localFonts")]
        LocalFonts,
        /// <summary>
        /// midi
        /// </summary>
        [JsonPropertyName("midi")]
        Midi,
        /// <summary>
        /// midiSysex
        /// </summary>
        [JsonPropertyName("midiSysex")]
        MidiSysex,
        /// <summary>
        /// nfc
        /// </summary>
        [JsonPropertyName("nfc")]
        Nfc,
        /// <summary>
        /// notifications
        /// </summary>
        [JsonPropertyName("notifications")]
        Notifications,
        /// <summary>
        /// paymentHandler
        /// </summary>
        [JsonPropertyName("paymentHandler")]
        PaymentHandler,
        /// <summary>
        /// periodicBackgroundSync
        /// </summary>
        [JsonPropertyName("periodicBackgroundSync")]
        PeriodicBackgroundSync,
        /// <summary>
        /// protectedMediaIdentifier
        /// </summary>
        [JsonPropertyName("protectedMediaIdentifier")]
        ProtectedMediaIdentifier,
        /// <summary>
        /// sensors
        /// </summary>
        [JsonPropertyName("sensors")]
        Sensors,
        /// <summary>
        /// storageAccess
        /// </summary>
        [JsonPropertyName("storageAccess")]
        StorageAccess,
        /// <summary>
        /// topLevelStorageAccess
        /// </summary>
        [JsonPropertyName("topLevelStorageAccess")]
        TopLevelStorageAccess,
        /// <summary>
        /// videoCapture
        /// </summary>
        [JsonPropertyName("videoCapture")]
        VideoCapture,
        /// <summary>
        /// videoCapturePanTiltZoom
        /// </summary>
        [JsonPropertyName("videoCapturePanTiltZoom")]
        VideoCapturePanTiltZoom,
        /// <summary>
        /// wakeLockScreen
        /// </summary>
        [JsonPropertyName("wakeLockScreen")]
        WakeLockScreen,
        /// <summary>
        /// wakeLockSystem
        /// </summary>
        [JsonPropertyName("wakeLockSystem")]
        WakeLockSystem,
        /// <summary>
        /// windowManagement
        /// </summary>
        [JsonPropertyName("windowManagement")]
        WindowManagement
    }

    /// <summary>
    /// PermissionSetting
    /// </summary>
    public enum PermissionSetting
    {
        /// <summary>
        /// granted
        /// </summary>
        [JsonPropertyName("granted")]
        Granted,
        /// <summary>
        /// denied
        /// </summary>
        [JsonPropertyName("denied")]
        Denied,
        /// <summary>
        /// prompt
        /// </summary>
        [JsonPropertyName("prompt")]
        Prompt
    }

    /// <summary>
    /// Definition of PermissionDescriptor defined in the Permissions API:
    /// https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
    /// </summary>
    public partial class PermissionDescriptor : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name of permission.
        /// See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// For &quot;midi&quot; permission, may also specify sysex control.
        /// </summary>
        [JsonPropertyName("sysex")]
        public bool? Sysex
        {
            get;
            set;
        }

        /// <summary>
        /// For &quot;push&quot; permission, may specify userVisibleOnly.
        /// Note that userVisibleOnly = true is the only currently supported type.
        /// </summary>
        [JsonPropertyName("userVisibleOnly")]
        public bool? UserVisibleOnly
        {
            get;
            set;
        }

        /// <summary>
        /// For &quot;clipboard&quot; permission, may specify allowWithoutSanitization.
        /// </summary>
        [JsonPropertyName("allowWithoutSanitization")]
        public bool? AllowWithoutSanitization
        {
            get;
            set;
        }

        /// <summary>
        /// For &quot;camera&quot; permission, may specify panTiltZoom.
        /// </summary>
        [JsonPropertyName("panTiltZoom")]
        public bool? PanTiltZoom
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Browser command ids used by executeBrowserCommand.
    /// </summary>
    public enum BrowserCommandId
    {
        /// <summary>
        /// openTabSearch
        /// </summary>
        [JsonPropertyName("openTabSearch")]
        OpenTabSearch,
        /// <summary>
        /// closeTabSearch
        /// </summary>
        [JsonPropertyName("closeTabSearch")]
        CloseTabSearch
    }

    /// <summary>
    /// Chrome histogram bucket.
    /// </summary>
    public partial class Bucket : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Minimum value (inclusive).
        /// </summary>
        [JsonPropertyName("low")]
        public int Low
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum value (exclusive).
        /// </summary>
        [JsonPropertyName("high")]
        public int High
        {
            get;
            set;
        }

        /// <summary>
        /// Number of samples.
        /// </summary>
        [JsonPropertyName("count")]
        public int Count
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Chrome histogram.
    /// </summary>
    public partial class Histogram : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Sum of sample values.
        /// </summary>
        [JsonPropertyName("sum")]
        public int Sum
        {
            get;
            set;
        }

        /// <summary>
        /// Total number of samples.
        /// </summary>
        [JsonPropertyName("count")]
        public int Count
        {
            get;
            set;
        }

        /// <summary>
        /// Buckets.
        /// </summary>
        [JsonPropertyName("buckets")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Browser.Bucket> Buckets
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Fired when page is about to start a download.
    /// </summary>
    public class DownloadWillBeginEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that caused the download to begin.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Global unique identifier of the download.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("guid")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Guid
        {
            get;
            private set;
        }

        /// <summary>
        /// URL of the resource being downloaded.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Suggested file name of the resource (the actual name of the file saved on disk may differ).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("suggestedFilename")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SuggestedFilename
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Download status.
    /// </summary>
    public enum DownloadProgressState
    {
        /// <summary>
        /// inProgress
        /// </summary>
        [JsonPropertyName("inProgress")]
        InProgress,
        /// <summary>
        /// completed
        /// </summary>
        [JsonPropertyName("completed")]
        Completed,
        /// <summary>
        /// canceled
        /// </summary>
        [JsonPropertyName("canceled")]
        Canceled
    }

    /// <summary>
    /// Fired when download makes progress. Last call has |done| == true.
    /// </summary>
    public class DownloadProgressEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Global unique identifier of the download.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("guid")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Guid
        {
            get;
            private set;
        }

        /// <summary>
        /// Total expected bytes to download.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("totalBytes")]
        public double TotalBytes
        {
            get;
            private set;
        }

        /// <summary>
        /// Total bytes received.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("receivedBytes")]
        public double ReceivedBytes
        {
            get;
            private set;
        }

        /// <summary>
        /// Download status.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("state")]
        public CefSharp.DevTools.Browser.DownloadProgressState State
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// Stylesheet type: &quot;injected&quot; for stylesheets injected via extension, &quot;user-agent&quot; for user-agent
    /// stylesheets, &quot;inspector&quot; for stylesheets created by the inspector (i.e. those holding the &quot;via
    /// inspector&quot; rules), &quot;regular&quot; for regular stylesheets.
    /// </summary>
    public enum StyleSheetOrigin
    {
        /// <summary>
        /// injected
        /// </summary>
        [JsonPropertyName("injected")]
        Injected,
        /// <summary>
        /// user-agent
        /// </summary>
        [JsonPropertyName("user-agent")]
        UserAgent,
        /// <summary>
        /// inspector
        /// </summary>
        [JsonPropertyName("inspector")]
        Inspector,
        /// <summary>
        /// regular
        /// </summary>
        [JsonPropertyName("regular")]
        Regular
    }

    /// <summary>
    /// CSS rule collection for a single pseudo style.
    /// </summary>
    public partial class PseudoElementMatches : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Pseudo element type.
        /// </summary>
        [JsonPropertyName("pseudoType")]
        public CefSharp.DevTools.DOM.PseudoType PseudoType
        {
            get;
            set;
        }

        /// <summary>
        /// Pseudo element custom ident.
        /// </summary>
        [JsonPropertyName("pseudoIdentifier")]
        public string PseudoIdentifier
        {
            get;
            set;
        }

        /// <summary>
        /// Matches of CSS rules applicable to the pseudo style.
        /// </summary>
        [JsonPropertyName("matches")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleMatch> Matches
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Inherited CSS rule collection from ancestor node.
    /// </summary>
    public partial class InheritedStyleEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The ancestor node&apos;s inline style, if any, in the style inheritance chain.
        /// </summary>
        [JsonPropertyName("inlineStyle")]
        public CefSharp.DevTools.CSS.CSSStyle InlineStyle
        {
            get;
            set;
        }

        /// <summary>
        /// Matches of CSS rules matching the ancestor node in the style inheritance chain.
        /// </summary>
        [JsonPropertyName("matchedCSSRules")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleMatch> MatchedCSSRules
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Inherited pseudo element matches from pseudos of an ancestor node.
    /// </summary>
    public partial class InheritedPseudoElementMatches : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Matches of pseudo styles from the pseudos of an ancestor node.
        /// </summary>
        [JsonPropertyName("pseudoElements")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.PseudoElementMatches> PseudoElements
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Match data for a CSS rule.
    /// </summary>
    public partial class RuleMatch : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CSS rule in the match.
        /// </summary>
        [JsonPropertyName("rule")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.CSSRule Rule
        {
            get;
            set;
        }

        /// <summary>
        /// Matching selector indices in the rule&apos;s selectorList selectors (0-based).
        /// </summary>
        [JsonPropertyName("matchingSelectors")]
        public int[] MatchingSelectors
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Data for a simple selector (these are delimited by commas in a selector list).
    /// </summary>
    public partial class Value : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Value text.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Value range in the underlying resource (if available).
        /// </summary>
        [JsonPropertyName("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Selector list data.
    /// </summary>
    public partial class SelectorList : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Selectors in the list.
        /// </summary>
        [JsonPropertyName("selectors")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.Value> Selectors
        {
            get;
            set;
        }

        /// <summary>
        /// Rule selector text.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS stylesheet metainformation.
    /// </summary>
    public partial class CSSStyleSheetHeader : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The stylesheet identifier.
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Owner frame identifier.
        /// </summary>
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// Stylesheet resource URL. Empty if this is a constructed stylesheet created using
        /// new CSSStyleSheet() (but non-empty if this is a constructed sylesheet imported
        /// as a CSS module script).
        /// </summary>
        [JsonPropertyName("sourceURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// URL of source map associated with the stylesheet (if any).
        /// </summary>
        [JsonPropertyName("sourceMapURL")]
        public string SourceMapURL
        {
            get;
            set;
        }

        /// <summary>
        /// Stylesheet origin.
        /// </summary>
        [JsonPropertyName("origin")]
        public CefSharp.DevTools.CSS.StyleSheetOrigin Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Stylesheet title.
        /// </summary>
        [JsonPropertyName("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// The backend id for the owner node of the stylesheet.
        /// </summary>
        [JsonPropertyName("ownerNode")]
        public int? OwnerNode
        {
            get;
            set;
        }

        /// <summary>
        /// Denotes whether the stylesheet is disabled.
        /// </summary>
        [JsonPropertyName("disabled")]
        public bool Disabled
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the sourceURL field value comes from the sourceURL comment.
        /// </summary>
        [JsonPropertyName("hasSourceURL")]
        public bool? HasSourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
        /// document.written STYLE tags.
        /// </summary>
        [JsonPropertyName("isInline")]
        public bool IsInline
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this stylesheet is mutable. Inline stylesheets become mutable
        /// after they have been modified via CSSOM API.
        /// &lt;link&gt; element&apos;s stylesheets become mutable only if DevTools modifies them.
        /// Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
        /// </summary>
        [JsonPropertyName("isMutable")]
        public bool IsMutable
        {
            get;
            set;
        }

        /// <summary>
        /// True if this stylesheet is created through new CSSStyleSheet() or imported as a
        /// CSS module script.
        /// </summary>
        [JsonPropertyName("isConstructed")]
        public bool IsConstructed
        {
            get;
            set;
        }

        /// <summary>
        /// Line offset of the stylesheet within the resource (zero based).
        /// </summary>
        [JsonPropertyName("startLine")]
        public double StartLine
        {
            get;
            set;
        }

        /// <summary>
        /// Column offset of the stylesheet within the resource (zero based).
        /// </summary>
        [JsonPropertyName("startColumn")]
        public double StartColumn
        {
            get;
            set;
        }

        /// <summary>
        /// Size of the content (in characters).
        /// </summary>
        [JsonPropertyName("length")]
        public double Length
        {
            get;
            set;
        }

        /// <summary>
        /// Line offset of the end of the stylesheet within the resource (zero based).
        /// </summary>
        [JsonPropertyName("endLine")]
        public double EndLine
        {
            get;
            set;
        }

        /// <summary>
        /// Column offset of the end of the stylesheet within the resource (zero based).
        /// </summary>
        [JsonPropertyName("endColumn")]
        public double EndColumn
        {
            get;
            set;
        }

        /// <summary>
        /// If the style sheet was loaded from a network resource, this indicates when the resource failed to load
        /// </summary>
        [JsonPropertyName("loadingFailed")]
        public bool? LoadingFailed
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS rule representation.
    /// </summary>
    public partial class CSSRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Rule selector data.
        /// </summary>
        [JsonPropertyName("selectorList")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.SelectorList SelectorList
        {
            get;
            set;
        }

        /// <summary>
        /// Array of selectors from ancestor style rules, sorted by distance from the current rule.
        /// </summary>
        [JsonPropertyName("nestingSelectors")]
        public string[] NestingSelectors
        {
            get;
            set;
        }

        /// <summary>
        /// Parent stylesheet&apos;s origin.
        /// </summary>
        [JsonPropertyName("origin")]
        public CefSharp.DevTools.CSS.StyleSheetOrigin Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Associated style declaration.
        /// </summary>
        [JsonPropertyName("style")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.CSSStyle Style
        {
            get;
            set;
        }

        /// <summary>
        /// Media list array (for rules involving media queries). The array enumerates media queries
        /// starting with the innermost one, going outwards.
        /// </summary>
        [JsonPropertyName("media")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSMedia> Media
        {
            get;
            set;
        }

        /// <summary>
        /// Container query list array (for rules involving container queries).
        /// The array enumerates container queries starting with the innermost one, going outwards.
        /// </summary>
        [JsonPropertyName("containerQueries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSContainerQuery> ContainerQueries
        {
            get;
            set;
        }

        /// <summary>
        /// @supports CSS at-rule array.
        /// The array enumerates @supports at-rules starting with the innermost one, going outwards.
        /// </summary>
        [JsonPropertyName("supports")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSSupports> Supports
        {
            get;
            set;
        }

        /// <summary>
        /// Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
        /// with the innermost layer and going outwards.
        /// </summary>
        [JsonPropertyName("layers")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSLayer> Layers
        {
            get;
            set;
        }

        /// <summary>
        /// @scope CSS at-rule array.
        /// The array enumerates @scope at-rules starting with the innermost one, going outwards.
        /// </summary>
        [JsonPropertyName("scopes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSScope> Scopes
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS coverage information.
    /// </summary>
    public partial class RuleUsage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Offset of the start of the rule (including selector) from the beginning of the stylesheet.
        /// </summary>
        [JsonPropertyName("startOffset")]
        public double StartOffset
        {
            get;
            set;
        }

        /// <summary>
        /// Offset of the end of the rule body from the beginning of the stylesheet.
        /// </summary>
        [JsonPropertyName("endOffset")]
        public double EndOffset
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the rule was actually used by some element in the page.
        /// </summary>
        [JsonPropertyName("used")]
        public bool Used
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Text range within a resource. All numbers are zero-based.
    /// </summary>
    public partial class SourceRange : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Start line of range.
        /// </summary>
        [JsonPropertyName("startLine")]
        public int StartLine
        {
            get;
            set;
        }

        /// <summary>
        /// Start column of range (inclusive).
        /// </summary>
        [JsonPropertyName("startColumn")]
        public int StartColumn
        {
            get;
            set;
        }

        /// <summary>
        /// End line of range
        /// </summary>
        [JsonPropertyName("endLine")]
        public int EndLine
        {
            get;
            set;
        }

        /// <summary>
        /// End column of range (exclusive).
        /// </summary>
        [JsonPropertyName("endColumn")]
        public int EndColumn
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ShorthandEntry
    /// </summary>
    public partial class ShorthandEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Shorthand name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Shorthand value.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property has &quot;!important&quot; annotation (implies `false` if absent).
        /// </summary>
        [JsonPropertyName("important")]
        public bool? Important
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSSComputedStyleProperty
    /// </summary>
    public partial class CSSComputedStyleProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Computed style property name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Computed style property value.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS style representation.
    /// </summary>
    public partial class CSSStyle : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// CSS properties in the style.
        /// </summary>
        [JsonPropertyName("cssProperties")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSProperty> CssProperties
        {
            get;
            set;
        }

        /// <summary>
        /// Computed values for all shorthands found in the style.
        /// </summary>
        [JsonPropertyName("shorthandEntries")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.ShorthandEntry> ShorthandEntries
        {
            get;
            set;
        }

        /// <summary>
        /// Style declaration text (if available).
        /// </summary>
        [JsonPropertyName("cssText")]
        public string CssText
        {
            get;
            set;
        }

        /// <summary>
        /// Style declaration range in the enclosing stylesheet (if available).
        /// </summary>
        [JsonPropertyName("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS property declaration data.
    /// </summary>
    public partial class CSSProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The property name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The property value.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property has &quot;!important&quot; annotation (implies `false` if absent).
        /// </summary>
        [JsonPropertyName("important")]
        public bool? Important
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property is implicit (implies `false` if absent).
        /// </summary>
        [JsonPropertyName("implicit")]
        public bool? Implicit
        {
            get;
            set;
        }

        /// <summary>
        /// The full property text as specified in the style.
        /// </summary>
        [JsonPropertyName("text")]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property is understood by the browser (implies `true` if absent).
        /// </summary>
        [JsonPropertyName("parsedOk")]
        public bool? ParsedOk
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the property is disabled by the user (present for source-based properties only).
        /// </summary>
        [JsonPropertyName("disabled")]
        public bool? Disabled
        {
            get;
            set;
        }

        /// <summary>
        /// The entire property range in the enclosing style declaration (if available).
        /// </summary>
        [JsonPropertyName("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// Parsed longhand components of this property if it is a shorthand.
        /// This field will be empty if the given property is not a shorthand.
        /// </summary>
        [JsonPropertyName("longhandProperties")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSProperty> LonghandProperties
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Source of the media query: &quot;mediaRule&quot; if specified by a @media rule, &quot;importRule&quot; if
    /// specified by an @import rule, &quot;linkedSheet&quot; if specified by a &quot;media&quot; attribute in a linked
    /// stylesheet&apos;s LINK tag, &quot;inlineSheet&quot; if specified by a &quot;media&quot; attribute in an inline
    /// stylesheet&apos;s STYLE tag.
    /// </summary>
    public enum CSSMediaSource
    {
        /// <summary>
        /// mediaRule
        /// </summary>
        [JsonPropertyName("mediaRule")]
        MediaRule,
        /// <summary>
        /// importRule
        /// </summary>
        [JsonPropertyName("importRule")]
        ImportRule,
        /// <summary>
        /// linkedSheet
        /// </summary>
        [JsonPropertyName("linkedSheet")]
        LinkedSheet,
        /// <summary>
        /// inlineSheet
        /// </summary>
        [JsonPropertyName("inlineSheet")]
        InlineSheet
    }

    /// <summary>
    /// CSS media rule descriptor.
    /// </summary>
    public partial class CSSMedia : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Media query text.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Source of the media query: &quot;mediaRule&quot; if specified by a @media rule, &quot;importRule&quot; if
        /// specified by an @import rule, &quot;linkedSheet&quot; if specified by a &quot;media&quot; attribute in a linked
        /// stylesheet&apos;s LINK tag, &quot;inlineSheet&quot; if specified by a &quot;media&quot; attribute in an inline
        /// stylesheet&apos;s STYLE tag.
        /// </summary>
        [JsonPropertyName("source")]
        public CefSharp.DevTools.CSS.CSSMediaSource Source
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the document containing the media query description.
        /// </summary>
        [JsonPropertyName("sourceURL")]
        public string SourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// The associated rule (@media or @import) header range in the enclosing stylesheet (if
        /// available).
        /// </summary>
        [JsonPropertyName("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the stylesheet containing this object (if exists).
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Array of media queries.
        /// </summary>
        [JsonPropertyName("mediaList")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.MediaQuery> MediaList
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Media query descriptor.
    /// </summary>
    public partial class MediaQuery : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Array of media query expressions.
        /// </summary>
        [JsonPropertyName("expressions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.MediaQueryExpression> Expressions
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the media query condition is satisfied.
        /// </summary>
        [JsonPropertyName("active")]
        public bool Active
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Media query expression descriptor.
    /// </summary>
    public partial class MediaQueryExpression : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Media query expression value.
        /// </summary>
        [JsonPropertyName("value")]
        public double Value
        {
            get;
            set;
        }

        /// <summary>
        /// Media query expression units.
        /// </summary>
        [JsonPropertyName("unit")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Unit
        {
            get;
            set;
        }

        /// <summary>
        /// Media query expression feature.
        /// </summary>
        [JsonPropertyName("feature")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Feature
        {
            get;
            set;
        }

        /// <summary>
        /// The associated range of the value text in the enclosing stylesheet (if available).
        /// </summary>
        [JsonPropertyName("valueRange")]
        public CefSharp.DevTools.CSS.SourceRange ValueRange
        {
            get;
            set;
        }

        /// <summary>
        /// Computed length of media query expression (if applicable).
        /// </summary>
        [JsonPropertyName("computedLength")]
        public double? ComputedLength
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS container query rule descriptor.
    /// </summary>
    public partial class CSSContainerQuery : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Container query text.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// The associated rule header range in the enclosing stylesheet (if
        /// available).
        /// </summary>
        [JsonPropertyName("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the stylesheet containing this object (if exists).
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Optional name for the container.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Optional physical axes queried for the container.
        /// </summary>
        [JsonPropertyName("physicalAxes")]
        public CefSharp.DevTools.DOM.PhysicalAxes? PhysicalAxes
        {
            get;
            set;
        }

        /// <summary>
        /// Optional logical axes queried for the container.
        /// </summary>
        [JsonPropertyName("logicalAxes")]
        public CefSharp.DevTools.DOM.LogicalAxes? LogicalAxes
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS Supports at-rule descriptor.
    /// </summary>
    public partial class CSSSupports : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Supports rule text.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the supports condition is satisfied.
        /// </summary>
        [JsonPropertyName("active")]
        public bool Active
        {
            get;
            set;
        }

        /// <summary>
        /// The associated rule header range in the enclosing stylesheet (if
        /// available).
        /// </summary>
        [JsonPropertyName("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the stylesheet containing this object (if exists).
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS Scope at-rule descriptor.
    /// </summary>
    public partial class CSSScope : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Scope rule text.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// The associated rule header range in the enclosing stylesheet (if
        /// available).
        /// </summary>
        [JsonPropertyName("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the stylesheet containing this object (if exists).
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS Layer at-rule descriptor.
    /// </summary>
    public partial class CSSLayer : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Layer name.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// The associated rule header range in the enclosing stylesheet (if
        /// available).
        /// </summary>
        [JsonPropertyName("range")]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the stylesheet containing this object (if exists).
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS Layer data.
    /// </summary>
    public partial class CSSLayerData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Layer name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Direct sub-layers
        /// </summary>
        [JsonPropertyName("subLayers")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSLayerData> SubLayers
        {
            get;
            set;
        }

        /// <summary>
        /// Layer order. The order determines the order of the layer in the cascade order.
        /// A higher number has higher priority in the cascade order.
        /// </summary>
        [JsonPropertyName("order")]
        public double Order
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about amount of glyphs that were rendered with given font.
    /// </summary>
    public partial class PlatformFontUsage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Font&apos;s family name reported by platform.
        /// </summary>
        [JsonPropertyName("familyName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FamilyName
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates if the font was downloaded or resolved locally.
        /// </summary>
        [JsonPropertyName("isCustomFont")]
        public bool IsCustomFont
        {
            get;
            set;
        }

        /// <summary>
        /// Amount of glyphs that were rendered with this font.
        /// </summary>
        [JsonPropertyName("glyphCount")]
        public double GlyphCount
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about font variation axes for variable fonts
    /// </summary>
    public partial class FontVariationAxis : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The font-variation-setting tag (a.k.a. &quot;axis tag&quot;).
        /// </summary>
        [JsonPropertyName("tag")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Tag
        {
            get;
            set;
        }

        /// <summary>
        /// Human-readable variation name in the default language (normally, &quot;en&quot;).
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The minimum value (inclusive) the font supports for this tag.
        /// </summary>
        [JsonPropertyName("minValue")]
        public double MinValue
        {
            get;
            set;
        }

        /// <summary>
        /// The maximum value (inclusive) the font supports for this tag.
        /// </summary>
        [JsonPropertyName("maxValue")]
        public double MaxValue
        {
            get;
            set;
        }

        /// <summary>
        /// The default value.
        /// </summary>
        [JsonPropertyName("defaultValue")]
        public double DefaultValue
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
    /// and additional information such as platformFontFamily and fontVariationAxes.
    /// </summary>
    public partial class FontFace : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The font-family.
        /// </summary>
        [JsonPropertyName("fontFamily")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontFamily
        {
            get;
            set;
        }

        /// <summary>
        /// The font-style.
        /// </summary>
        [JsonPropertyName("fontStyle")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontStyle
        {
            get;
            set;
        }

        /// <summary>
        /// The font-variant.
        /// </summary>
        [JsonPropertyName("fontVariant")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontVariant
        {
            get;
            set;
        }

        /// <summary>
        /// The font-weight.
        /// </summary>
        [JsonPropertyName("fontWeight")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontWeight
        {
            get;
            set;
        }

        /// <summary>
        /// The font-stretch.
        /// </summary>
        [JsonPropertyName("fontStretch")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontStretch
        {
            get;
            set;
        }

        /// <summary>
        /// The font-display.
        /// </summary>
        [JsonPropertyName("fontDisplay")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FontDisplay
        {
            get;
            set;
        }

        /// <summary>
        /// The unicode-range.
        /// </summary>
        [JsonPropertyName("unicodeRange")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string UnicodeRange
        {
            get;
            set;
        }

        /// <summary>
        /// The src.
        /// </summary>
        [JsonPropertyName("src")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Src
        {
            get;
            set;
        }

        /// <summary>
        /// The resolved platform font family
        /// </summary>
        [JsonPropertyName("platformFontFamily")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlatformFontFamily
        {
            get;
            set;
        }

        /// <summary>
        /// Available variation settings (a.k.a. &quot;axes&quot;).
        /// </summary>
        [JsonPropertyName("fontVariationAxes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.FontVariationAxis> FontVariationAxes
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS try rule representation.
    /// </summary>
    public partial class CSSTryRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Parent stylesheet&apos;s origin.
        /// </summary>
        [JsonPropertyName("origin")]
        public CefSharp.DevTools.CSS.StyleSheetOrigin Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Associated style declaration.
        /// </summary>
        [JsonPropertyName("style")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.CSSStyle Style
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS position-fallback rule representation.
    /// </summary>
    public partial class CSSPositionFallbackRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.Value Name
        {
            get;
            set;
        }

        /// <summary>
        /// List of keyframes.
        /// </summary>
        [JsonPropertyName("tryRules")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSTryRule> TryRules
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS keyframes rule representation.
    /// </summary>
    public partial class CSSKeyframesRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Animation name.
        /// </summary>
        [JsonPropertyName("animationName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.Value AnimationName
        {
            get;
            set;
        }

        /// <summary>
        /// List of keyframes.
        /// </summary>
        [JsonPropertyName("keyframes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSKeyframeRule> Keyframes
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS keyframe rule representation.
    /// </summary>
    public partial class CSSKeyframeRule : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified
        /// stylesheet rules) this rule came from.
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// Parent stylesheet&apos;s origin.
        /// </summary>
        [JsonPropertyName("origin")]
        public CefSharp.DevTools.CSS.StyleSheetOrigin Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Associated key text.
        /// </summary>
        [JsonPropertyName("keyText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.Value KeyText
        {
            get;
            set;
        }

        /// <summary>
        /// Associated style declaration.
        /// </summary>
        [JsonPropertyName("style")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.CSSStyle Style
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A descriptor of operation to mutate style declaration text.
    /// </summary>
    public partial class StyleDeclarationEdit : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The css style sheet identifier.
        /// </summary>
        [JsonPropertyName("styleSheetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StyleSheetId
        {
            get;
            set;
        }

        /// <summary>
        /// The range of the style text in the enclosing stylesheet.
        /// </summary>
        [JsonPropertyName("range")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.SourceRange Range
        {
            get;
            set;
        }

        /// <summary>
        /// New style text.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
    /// web font.
    /// </summary>
    public class FontsUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// The web font that has loaded.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("font")]
        public CefSharp.DevTools.CSS.FontFace Font
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired whenever an active document stylesheet is added.
    /// </summary>
    public class StyleSheetAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Added stylesheet metainfo.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("header")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.CSS.CSSStyleSheetHeader Header
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired whenever a stylesheet is changed as a result of the client operation.
    /// </summary>
    public class StyleSheetChangedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// StyleSheetId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("styleSheetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StyleSheetId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired whenever an active document stylesheet is removed.
    /// </summary>
    public class StyleSheetRemovedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Identifier of the removed stylesheet.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("styleSheetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StyleSheetId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// type of HTTP response cached
    /// </summary>
    public enum CachedResponseType
    {
        /// <summary>
        /// basic
        /// </summary>
        [JsonPropertyName("basic")]
        Basic,
        /// <summary>
        /// cors
        /// </summary>
        [JsonPropertyName("cors")]
        Cors,
        /// <summary>
        /// default
        /// </summary>
        [JsonPropertyName("default")]
        Default,
        /// <summary>
        /// error
        /// </summary>
        [JsonPropertyName("error")]
        Error,
        /// <summary>
        /// opaqueResponse
        /// </summary>
        [JsonPropertyName("opaqueResponse")]
        OpaqueResponse,
        /// <summary>
        /// opaqueRedirect
        /// </summary>
        [JsonPropertyName("opaqueRedirect")]
        OpaqueRedirect
    }

    /// <summary>
    /// Data entry.
    /// </summary>
    public partial class DataEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Request URL.
        /// </summary>
        [JsonPropertyName("requestURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestURL
        {
            get;
            set;
        }

        /// <summary>
        /// Request method.
        /// </summary>
        [JsonPropertyName("requestMethod")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestMethod
        {
            get;
            set;
        }

        /// <summary>
        /// Request headers
        /// </summary>
        [JsonPropertyName("requestHeaders")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Header> RequestHeaders
        {
            get;
            set;
        }

        /// <summary>
        /// Number of seconds since epoch.
        /// </summary>
        [JsonPropertyName("responseTime")]
        public double ResponseTime
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status code.
        /// </summary>
        [JsonPropertyName("responseStatus")]
        public int ResponseStatus
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status text.
        /// </summary>
        [JsonPropertyName("responseStatusText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ResponseStatusText
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response type
        /// </summary>
        [JsonPropertyName("responseType")]
        public CefSharp.DevTools.CacheStorage.CachedResponseType ResponseType
        {
            get;
            set;
        }

        /// <summary>
        /// Response headers
        /// </summary>
        [JsonPropertyName("responseHeaders")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Header> ResponseHeaders
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Cache identifier.
    /// </summary>
    public partial class Cache : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// An opaque unique id of the cache.
        /// </summary>
        [JsonPropertyName("cacheId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CacheId
        {
            get;
            set;
        }

        /// <summary>
        /// Security origin of the cache.
        /// </summary>
        [JsonPropertyName("securityOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SecurityOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// Storage key of the cache.
        /// </summary>
        [JsonPropertyName("storageKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StorageKey
        {
            get;
            set;
        }

        /// <summary>
        /// The name of the cache.
        /// </summary>
        [JsonPropertyName("cacheName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CacheName
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Header
    /// </summary>
    public partial class Header : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Cached response
    /// </summary>
    public partial class CachedResponse : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Entry content, base64-encoded.
        /// </summary>
        [JsonPropertyName("body")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] Body
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Cast
{
    /// <summary>
    /// Sink
    /// </summary>
    public partial class Sink : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Id
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Text describing the current session. Present only if there is an active
        /// session on the sink.
        /// </summary>
        [JsonPropertyName("session")]
        public string Session
        {
            get;
            set;
        }
    }

    /// <summary>
    /// This is fired whenever the list of available sinks changes. A sink is a
    /// device or a software surface that you can cast to.
    /// </summary>
    public class SinksUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Sinks
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sinks")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Cast.Sink> Sinks
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// This is fired whenever the outstanding issue/error message changes.
    /// |issueMessage| is empty if there is no issue.
    /// </summary>
    public class IssueUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// IssueMessage
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("issueMessage")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string IssueMessage
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// Backend node with a friendly name.
    /// </summary>
    public partial class BackendNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `Node`&apos;s nodeType.
        /// </summary>
        [JsonPropertyName("nodeType")]
        public int NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeName.
        /// </summary>
        [JsonPropertyName("nodeName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeName
        {
            get;
            set;
        }

        /// <summary>
        /// BackendNodeId
        /// </summary>
        [JsonPropertyName("backendNodeId")]
        public int BackendNodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Pseudo element type.
    /// </summary>
    public enum PseudoType
    {
        /// <summary>
        /// first-line
        /// </summary>
        [JsonPropertyName("first-line")]
        FirstLine,
        /// <summary>
        /// first-letter
        /// </summary>
        [JsonPropertyName("first-letter")]
        FirstLetter,
        /// <summary>
        /// before
        /// </summary>
        [JsonPropertyName("before")]
        Before,
        /// <summary>
        /// after
        /// </summary>
        [JsonPropertyName("after")]
        After,
        /// <summary>
        /// marker
        /// </summary>
        [JsonPropertyName("marker")]
        Marker,
        /// <summary>
        /// backdrop
        /// </summary>
        [JsonPropertyName("backdrop")]
        Backdrop,
        /// <summary>
        /// selection
        /// </summary>
        [JsonPropertyName("selection")]
        Selection,
        /// <summary>
        /// target-text
        /// </summary>
        [JsonPropertyName("target-text")]
        TargetText,
        /// <summary>
        /// spelling-error
        /// </summary>
        [JsonPropertyName("spelling-error")]
        SpellingError,
        /// <summary>
        /// grammar-error
        /// </summary>
        [JsonPropertyName("grammar-error")]
        GrammarError,
        /// <summary>
        /// highlight
        /// </summary>
        [JsonPropertyName("highlight")]
        Highlight,
        /// <summary>
        /// first-line-inherited
        /// </summary>
        [JsonPropertyName("first-line-inherited")]
        FirstLineInherited,
        /// <summary>
        /// scrollbar
        /// </summary>
        [JsonPropertyName("scrollbar")]
        Scrollbar,
        /// <summary>
        /// scrollbar-thumb
        /// </summary>
        [JsonPropertyName("scrollbar-thumb")]
        ScrollbarThumb,
        /// <summary>
        /// scrollbar-button
        /// </summary>
        [JsonPropertyName("scrollbar-button")]
        ScrollbarButton,
        /// <summary>
        /// scrollbar-track
        /// </summary>
        [JsonPropertyName("scrollbar-track")]
        ScrollbarTrack,
        /// <summary>
        /// scrollbar-track-piece
        /// </summary>
        [JsonPropertyName("scrollbar-track-piece")]
        ScrollbarTrackPiece,
        /// <summary>
        /// scrollbar-corner
        /// </summary>
        [JsonPropertyName("scrollbar-corner")]
        ScrollbarCorner,
        /// <summary>
        /// resizer
        /// </summary>
        [JsonPropertyName("resizer")]
        Resizer,
        /// <summary>
        /// input-list-button
        /// </summary>
        [JsonPropertyName("input-list-button")]
        InputListButton,
        /// <summary>
        /// view-transition
        /// </summary>
        [JsonPropertyName("view-transition")]
        ViewTransition,
        /// <summary>
        /// view-transition-group
        /// </summary>
        [JsonPropertyName("view-transition-group")]
        ViewTransitionGroup,
        /// <summary>
        /// view-transition-image-pair
        /// </summary>
        [JsonPropertyName("view-transition-image-pair")]
        ViewTransitionImagePair,
        /// <summary>
        /// view-transition-old
        /// </summary>
        [JsonPropertyName("view-transition-old")]
        ViewTransitionOld,
        /// <summary>
        /// view-transition-new
        /// </summary>
        [JsonPropertyName("view-transition-new")]
        ViewTransitionNew
    }

    /// <summary>
    /// Shadow root type.
    /// </summary>
    public enum ShadowRootType
    {
        /// <summary>
        /// user-agent
        /// </summary>
        [JsonPropertyName("user-agent")]
        UserAgent,
        /// <summary>
        /// open
        /// </summary>
        [JsonPropertyName("open")]
        Open,
        /// <summary>
        /// closed
        /// </summary>
        [JsonPropertyName("closed")]
        Closed
    }

    /// <summary>
    /// Document compatibility mode.
    /// </summary>
    public enum CompatibilityMode
    {
        /// <summary>
        /// QuirksMode
        /// </summary>
        [JsonPropertyName("QuirksMode")]
        QuirksMode,
        /// <summary>
        /// LimitedQuirksMode
        /// </summary>
        [JsonPropertyName("LimitedQuirksMode")]
        LimitedQuirksMode,
        /// <summary>
        /// NoQuirksMode
        /// </summary>
        [JsonPropertyName("NoQuirksMode")]
        NoQuirksMode
    }

    /// <summary>
    /// ContainerSelector physical axes
    /// </summary>
    public enum PhysicalAxes
    {
        /// <summary>
        /// Horizontal
        /// </summary>
        [JsonPropertyName("Horizontal")]
        Horizontal,
        /// <summary>
        /// Vertical
        /// </summary>
        [JsonPropertyName("Vertical")]
        Vertical,
        /// <summary>
        /// Both
        /// </summary>
        [JsonPropertyName("Both")]
        Both
    }

    /// <summary>
    /// ContainerSelector logical axes
    /// </summary>
    public enum LogicalAxes
    {
        /// <summary>
        /// Inline
        /// </summary>
        [JsonPropertyName("Inline")]
        Inline,
        /// <summary>
        /// Block
        /// </summary>
        [JsonPropertyName("Block")]
        Block,
        /// <summary>
        /// Both
        /// </summary>
        [JsonPropertyName("Both")]
        Both
    }

    /// <summary>
    /// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
    /// DOMNode is a base node mirror type.
    /// </summary>
    public partial class Node : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
        /// will only push node with given `id` once. It is aware of all requested nodes and will only
        /// fire DOM events for nodes known to the client.
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// The id of the parent node if any.
        /// </summary>
        [JsonPropertyName("parentId")]
        public int? ParentId
        {
            get;
            set;
        }

        /// <summary>
        /// The BackendNodeId for this node.
        /// </summary>
        [JsonPropertyName("backendNodeId")]
        public int BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeType.
        /// </summary>
        [JsonPropertyName("nodeType")]
        public int NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeName.
        /// </summary>
        [JsonPropertyName("nodeName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeName
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s localName.
        /// </summary>
        [JsonPropertyName("localName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LocalName
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeValue.
        /// </summary>
        [JsonPropertyName("nodeValue")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeValue
        {
            get;
            set;
        }

        /// <summary>
        /// Child count for `Container` nodes.
        /// </summary>
        [JsonPropertyName("childNodeCount")]
        public int? ChildNodeCount
        {
            get;
            set;
        }

        /// <summary>
        /// Child nodes of this node when requested with children.
        /// </summary>
        [JsonPropertyName("children")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.Node> Children
        {
            get;
            set;
        }

        /// <summary>
        /// Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
        /// </summary>
        [JsonPropertyName("attributes")]
        public string[] Attributes
        {
            get;
            set;
        }

        /// <summary>
        /// Document URL that `Document` or `FrameOwner` node points to.
        /// </summary>
        [JsonPropertyName("documentURL")]
        public string DocumentURL
        {
            get;
            set;
        }

        /// <summary>
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        /// </summary>
        [JsonPropertyName("baseURL")]
        public string BaseURL
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType`&apos;s publicId.
        /// </summary>
        [JsonPropertyName("publicId")]
        public string PublicId
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType`&apos;s systemId.
        /// </summary>
        [JsonPropertyName("systemId")]
        public string SystemId
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType`&apos;s internalSubset.
        /// </summary>
        [JsonPropertyName("internalSubset")]
        public string InternalSubset
        {
            get;
            set;
        }

        /// <summary>
        /// `Document`&apos;s XML version in case of XML documents.
        /// </summary>
        [JsonPropertyName("xmlVersion")]
        public string XmlVersion
        {
            get;
            set;
        }

        /// <summary>
        /// `Attr`&apos;s name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// `Attr`&apos;s value.
        /// </summary>
        [JsonPropertyName("value")]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Pseudo element type for this node.
        /// </summary>
        [JsonPropertyName("pseudoType")]
        public CefSharp.DevTools.DOM.PseudoType? PseudoType
        {
            get;
            set;
        }

        /// <summary>
        /// Pseudo element identifier for this node. Only present if there is a
        /// valid pseudoType.
        /// </summary>
        [JsonPropertyName("pseudoIdentifier")]
        public string PseudoIdentifier
        {
            get;
            set;
        }

        /// <summary>
        /// Shadow root type.
        /// </summary>
        [JsonPropertyName("shadowRootType")]
        public CefSharp.DevTools.DOM.ShadowRootType? ShadowRootType
        {
            get;
            set;
        }

        /// <summary>
        /// Frame ID for frame owner elements.
        /// </summary>
        [JsonPropertyName("frameId")]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// Content document for frame owner elements.
        /// </summary>
        [JsonPropertyName("contentDocument")]
        public CefSharp.DevTools.DOM.Node ContentDocument
        {
            get;
            set;
        }

        /// <summary>
        /// Shadow root list for given element host.
        /// </summary>
        [JsonPropertyName("shadowRoots")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.Node> ShadowRoots
        {
            get;
            set;
        }

        /// <summary>
        /// Content document fragment for template elements.
        /// </summary>
        [JsonPropertyName("templateContent")]
        public CefSharp.DevTools.DOM.Node TemplateContent
        {
            get;
            set;
        }

        /// <summary>
        /// Pseudo elements associated with this node.
        /// </summary>
        [JsonPropertyName("pseudoElements")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.Node> PseudoElements
        {
            get;
            set;
        }

        /// <summary>
        /// Deprecated, as the HTML Imports API has been removed (crbug.com/937746).
        /// This property used to return the imported document for the HTMLImport links.
        /// The property is always undefined now.
        /// </summary>
        [JsonPropertyName("importedDocument")]
        public CefSharp.DevTools.DOM.Node ImportedDocument
        {
            get;
            set;
        }

        /// <summary>
        /// Distributed nodes for given insertion point.
        /// </summary>
        [JsonPropertyName("distributedNodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.BackendNode> DistributedNodes
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the node is SVG.
        /// </summary>
        [JsonPropertyName("isSVG")]
        public bool? IsSVG
        {
            get;
            set;
        }

        /// <summary>
        /// CompatibilityMode
        /// </summary>
        [JsonPropertyName("compatibilityMode")]
        public CefSharp.DevTools.DOM.CompatibilityMode? CompatibilityMode
        {
            get;
            set;
        }

        /// <summary>
        /// AssignedSlot
        /// </summary>
        [JsonPropertyName("assignedSlot")]
        public CefSharp.DevTools.DOM.BackendNode AssignedSlot
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A structure holding an RGBA color.
    /// </summary>
    public partial class RGBA : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The red component, in the [0-255] range.
        /// </summary>
        [JsonPropertyName("r")]
        public int R
        {
            get;
            set;
        }

        /// <summary>
        /// The green component, in the [0-255] range.
        /// </summary>
        [JsonPropertyName("g")]
        public int G
        {
            get;
            set;
        }

        /// <summary>
        /// The blue component, in the [0-255] range.
        /// </summary>
        [JsonPropertyName("b")]
        public int B
        {
            get;
            set;
        }

        /// <summary>
        /// The alpha component, in the [0-1] range (default: 1).
        /// </summary>
        [JsonPropertyName("a")]
        public double? A
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Box model.
    /// </summary>
    public partial class BoxModel : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Content box
        /// </summary>
        [JsonPropertyName("content")]
        public double[] Content
        {
            get;
            set;
        }

        /// <summary>
        /// Padding box
        /// </summary>
        [JsonPropertyName("padding")]
        public double[] Padding
        {
            get;
            set;
        }

        /// <summary>
        /// Border box
        /// </summary>
        [JsonPropertyName("border")]
        public double[] Border
        {
            get;
            set;
        }

        /// <summary>
        /// Margin box
        /// </summary>
        [JsonPropertyName("margin")]
        public double[] Margin
        {
            get;
            set;
        }

        /// <summary>
        /// Node width
        /// </summary>
        [JsonPropertyName("width")]
        public int Width
        {
            get;
            set;
        }

        /// <summary>
        /// Node height
        /// </summary>
        [JsonPropertyName("height")]
        public int Height
        {
            get;
            set;
        }

        /// <summary>
        /// Shape outside coordinates
        /// </summary>
        [JsonPropertyName("shapeOutside")]
        public CefSharp.DevTools.DOM.ShapeOutsideInfo ShapeOutside
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSS Shape Outside details.
    /// </summary>
    public partial class ShapeOutsideInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Shape bounds
        /// </summary>
        [JsonPropertyName("bounds")]
        public double[] Bounds
        {
            get;
            set;
        }

        /// <summary>
        /// Shape coordinate details
        /// </summary>
        [JsonPropertyName("shape")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public object[] Shape
        {
            get;
            set;
        }

        /// <summary>
        /// Margin shape bounds
        /// </summary>
        [JsonPropertyName("marginShape")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public object[] MarginShape
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Rectangle.
    /// </summary>
    public partial class Rect : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// X coordinate
        /// </summary>
        [JsonPropertyName("x")]
        public double X
        {
            get;
            set;
        }

        /// <summary>
        /// Y coordinate
        /// </summary>
        [JsonPropertyName("y")]
        public double Y
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangle width
        /// </summary>
        [JsonPropertyName("width")]
        public double Width
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangle height
        /// </summary>
        [JsonPropertyName("height")]
        public double Height
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CSSComputedStyleProperty
    /// </summary>
    public partial class CSSComputedStyleProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Computed style property name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Computed style property value.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Fired when `Element`&apos;s attribute is modified.
    /// </summary>
    public class AttributeModifiedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the node that has changed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// Attribute name.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            private set;
        }

        /// <summary>
        /// Attribute value.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when `Element`&apos;s attribute is removed.
    /// </summary>
    public class AttributeRemovedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the node that has changed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// A ttribute name.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Mirrors `DOMCharacterDataModified` event.
    /// </summary>
    public class CharacterDataModifiedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the node that has changed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// New text value.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("characterData")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CharacterData
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when `Container`&apos;s child node count has changed.
    /// </summary>
    public class ChildNodeCountUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the node that has changed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// New node count.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("childNodeCount")]
        public int ChildNodeCount
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Mirrors `DOMNodeInserted` event.
    /// </summary>
    public class ChildNodeInsertedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the node that has changed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("parentNodeId")]
        public int ParentNodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// Id of the previous sibling.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("previousNodeId")]
        public int PreviousNodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// Inserted node data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("node")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Node Node
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Mirrors `DOMNodeRemoved` event.
    /// </summary>
    public class ChildNodeRemovedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Parent id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("parentNodeId")]
        public int ParentNodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// Id of the node that has been removed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Called when distribution is changed.
    /// </summary>
    public class DistributedNodesUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Insertion point where distributed nodes were updated.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("insertionPointId")]
        public int InsertionPointId
        {
            get;
            private set;
        }

        /// <summary>
        /// Distributed nodes for given insertion point.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("distributedNodes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.BackendNode> DistributedNodes
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when `Element`&apos;s inline style is modified via a CSS property modification.
    /// </summary>
    public class InlineStyleInvalidatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Ids of the nodes for which the inline styles have been invalidated.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Called when a pseudo element is added to an element.
    /// </summary>
    public class PseudoElementAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Pseudo element&apos;s parent element id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("parentId")]
        public int ParentId
        {
            get;
            private set;
        }

        /// <summary>
        /// The added pseudo element.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("pseudoElement")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Node PseudoElement
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Called when a pseudo element is removed from an element.
    /// </summary>
    public class PseudoElementRemovedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Pseudo element&apos;s parent element id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("parentId")]
        public int ParentId
        {
            get;
            private set;
        }

        /// <summary>
        /// The removed pseudo element id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("pseudoElementId")]
        public int PseudoElementId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when backend wants to provide client with the missing DOM structure. This happens upon
    /// most of the calls requesting node ids.
    /// </summary>
    public class SetChildNodesEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Parent node id to populate with children.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("parentId")]
        public int ParentId
        {
            get;
            private set;
        }

        /// <summary>
        /// Child nodes array.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOM.Node> Nodes
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Called when shadow root is popped from the element.
    /// </summary>
    public class ShadowRootPoppedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Host element id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hostId")]
        public int HostId
        {
            get;
            private set;
        }

        /// <summary>
        /// Shadow root id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("rootId")]
        public int RootId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Called when shadow root is pushed into the element.
    /// </summary>
    public class ShadowRootPushedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Host element id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hostId")]
        public int HostId
        {
            get;
            private set;
        }

        /// <summary>
        /// Shadow root.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("root")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Node Root
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOMDebugger
{
    /// <summary>
    /// DOM breakpoint type.
    /// </summary>
    public enum DOMBreakpointType
    {
        /// <summary>
        /// subtree-modified
        /// </summary>
        [JsonPropertyName("subtree-modified")]
        SubtreeModified,
        /// <summary>
        /// attribute-modified
        /// </summary>
        [JsonPropertyName("attribute-modified")]
        AttributeModified,
        /// <summary>
        /// node-removed
        /// </summary>
        [JsonPropertyName("node-removed")]
        NodeRemoved
    }

    /// <summary>
    /// CSP Violation type.
    /// </summary>
    public enum CSPViolationType
    {
        /// <summary>
        /// trustedtype-sink-violation
        /// </summary>
        [JsonPropertyName("trustedtype-sink-violation")]
        TrustedtypeSinkViolation,
        /// <summary>
        /// trustedtype-policy-violation
        /// </summary>
        [JsonPropertyName("trustedtype-policy-violation")]
        TrustedtypePolicyViolation
    }

    /// <summary>
    /// Object event listener.
    /// </summary>
    public partial class EventListener : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `EventListener`&apos;s type.
        /// </summary>
        [JsonPropertyName("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// `EventListener`&apos;s useCapture.
        /// </summary>
        [JsonPropertyName("useCapture")]
        public bool UseCapture
        {
            get;
            set;
        }

        /// <summary>
        /// `EventListener`&apos;s passive flag.
        /// </summary>
        [JsonPropertyName("passive")]
        public bool Passive
        {
            get;
            set;
        }

        /// <summary>
        /// `EventListener`&apos;s once flag.
        /// </summary>
        [JsonPropertyName("once")]
        public bool Once
        {
            get;
            set;
        }

        /// <summary>
        /// Script id of the handler code.
        /// </summary>
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Line number in the script (0-based).
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Column number in the script (0-based).
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Event handler function value.
        /// </summary>
        [JsonPropertyName("handler")]
        public CefSharp.DevTools.Runtime.RemoteObject Handler
        {
            get;
            set;
        }

        /// <summary>
        /// Event original handler function value.
        /// </summary>
        [JsonPropertyName("originalHandler")]
        public CefSharp.DevTools.Runtime.RemoteObject OriginalHandler
        {
            get;
            set;
        }

        /// <summary>
        /// Node the listener is added to (if any).
        /// </summary>
        [JsonPropertyName("backendNodeId")]
        public int? BackendNodeId
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// A Node in the DOM tree.
    /// </summary>
    public partial class DOMNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// `Node`&apos;s nodeType.
        /// </summary>
        [JsonPropertyName("nodeType")]
        public int NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeName.
        /// </summary>
        [JsonPropertyName("nodeName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeName
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeValue.
        /// </summary>
        [JsonPropertyName("nodeValue")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for textarea elements, contains the text value.
        /// </summary>
        [JsonPropertyName("textValue")]
        public string TextValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for input elements, contains the input&apos;s associated text value.
        /// </summary>
        [JsonPropertyName("inputValue")]
        public string InputValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for radio and checkbox input elements, indicates if the element has been checked
        /// </summary>
        [JsonPropertyName("inputChecked")]
        public bool? InputChecked
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for option elements, indicates if the element has been selected
        /// </summary>
        [JsonPropertyName("optionSelected")]
        public bool? OptionSelected
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s id, corresponds to DOM.Node.backendNodeId.
        /// </summary>
        [JsonPropertyName("backendNodeId")]
        public int BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// The indexes of the node&apos;s child nodes in the `domNodes` array returned by `getSnapshot`, if
        /// any.
        /// </summary>
        [JsonPropertyName("childNodeIndexes")]
        public int[] ChildNodeIndexes
        {
            get;
            set;
        }

        /// <summary>
        /// Attributes of an `Element` node.
        /// </summary>
        [JsonPropertyName("attributes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMSnapshot.NameValue> Attributes
        {
            get;
            set;
        }

        /// <summary>
        /// Indexes of pseudo elements associated with this node in the `domNodes` array returned by
        /// `getSnapshot`, if any.
        /// </summary>
        [JsonPropertyName("pseudoElementIndexes")]
        public int[] PseudoElementIndexes
        {
            get;
            set;
        }

        /// <summary>
        /// The index of the node&apos;s related layout tree node in the `layoutTreeNodes` array returned by
        /// `getSnapshot`, if any.
        /// </summary>
        [JsonPropertyName("layoutNodeIndex")]
        public int? LayoutNodeIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Document URL that `Document` or `FrameOwner` node points to.
        /// </summary>
        [JsonPropertyName("documentURL")]
        public string DocumentURL
        {
            get;
            set;
        }

        /// <summary>
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        /// </summary>
        [JsonPropertyName("baseURL")]
        public string BaseURL
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for documents, contains the document&apos;s content language.
        /// </summary>
        [JsonPropertyName("contentLanguage")]
        public string ContentLanguage
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for documents, contains the document&apos;s character set encoding.
        /// </summary>
        [JsonPropertyName("documentEncoding")]
        public string DocumentEncoding
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType` node&apos;s publicId.
        /// </summary>
        [JsonPropertyName("publicId")]
        public string PublicId
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType` node&apos;s systemId.
        /// </summary>
        [JsonPropertyName("systemId")]
        public string SystemId
        {
            get;
            set;
        }

        /// <summary>
        /// Frame ID for frame owner elements and also for the document node.
        /// </summary>
        [JsonPropertyName("frameId")]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// The index of a frame owner element&apos;s content document in the `domNodes` array returned by
        /// `getSnapshot`, if any.
        /// </summary>
        [JsonPropertyName("contentDocumentIndex")]
        public int? ContentDocumentIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Type of a pseudo element node.
        /// </summary>
        [JsonPropertyName("pseudoType")]
        public CefSharp.DevTools.DOM.PseudoType? PseudoType
        {
            get;
            set;
        }

        /// <summary>
        /// Shadow root type.
        /// </summary>
        [JsonPropertyName("shadowRootType")]
        public CefSharp.DevTools.DOM.ShadowRootType? ShadowRootType
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this DOM node responds to mouse clicks. This includes nodes that have had click
        /// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
        /// clicked.
        /// </summary>
        [JsonPropertyName("isClickable")]
        public bool? IsClickable
        {
            get;
            set;
        }

        /// <summary>
        /// Details of the node&apos;s event listeners, if any.
        /// </summary>
        [JsonPropertyName("eventListeners")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMDebugger.EventListener> EventListeners
        {
            get;
            set;
        }

        /// <summary>
        /// The selected url for nodes with a srcset attribute.
        /// </summary>
        [JsonPropertyName("currentSourceURL")]
        public string CurrentSourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// The url of the script (if any) that generates this node.
        /// </summary>
        [JsonPropertyName("originURL")]
        public string OriginURL
        {
            get;
            set;
        }

        /// <summary>
        /// Scroll offsets, set when this node is a Document.
        /// </summary>
        [JsonPropertyName("scrollOffsetX")]
        public double? ScrollOffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// ScrollOffsetY
        /// </summary>
        [JsonPropertyName("scrollOffsetY")]
        public double? ScrollOffsetY
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Details of post layout rendered text positions. The exact layout should not be regarded as
    /// stable and may change between versions.
    /// </summary>
    public partial class InlineTextBox : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
        /// </summary>
        [JsonPropertyName("boundingBox")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect BoundingBox
        {
            get;
            set;
        }

        /// <summary>
        /// The starting index in characters, for this post layout textbox substring. Characters that
        /// would be represented as a surrogate pair in UTF-16 have length 2.
        /// </summary>
        [JsonPropertyName("startCharacterIndex")]
        public int StartCharacterIndex
        {
            get;
            set;
        }

        /// <summary>
        /// The number of characters in this post layout textbox substring. Characters that would be
        /// represented as a surrogate pair in UTF-16 have length 2.
        /// </summary>
        [JsonPropertyName("numCharacters")]
        public int NumCharacters
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Details of an element in the DOM tree with a LayoutObject.
    /// </summary>
    public partial class LayoutTreeNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
        /// </summary>
        [JsonPropertyName("domNodeIndex")]
        public int DomNodeIndex
        {
            get;
            set;
        }

        /// <summary>
        /// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
        /// </summary>
        [JsonPropertyName("boundingBox")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect BoundingBox
        {
            get;
            set;
        }

        /// <summary>
        /// Contents of the LayoutText, if any.
        /// </summary>
        [JsonPropertyName("layoutText")]
        public string LayoutText
        {
            get;
            set;
        }

        /// <summary>
        /// The post-layout inline text nodes, if any.
        /// </summary>
        [JsonPropertyName("inlineTextNodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMSnapshot.InlineTextBox> InlineTextNodes
        {
            get;
            set;
        }

        /// <summary>
        /// Index into the `computedStyles` array returned by `getSnapshot`.
        /// </summary>
        [JsonPropertyName("styleIndex")]
        public int? StyleIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Global paint order index, which is determined by the stacking order of the nodes. Nodes
        /// that are painted together will have the same index. Only provided if includePaintOrder in
        /// getSnapshot was true.
        /// </summary>
        [JsonPropertyName("paintOrder")]
        public int? PaintOrder
        {
            get;
            set;
        }

        /// <summary>
        /// Set to true to indicate the element begins a new stacking context.
        /// </summary>
        [JsonPropertyName("isStackingContext")]
        public bool? IsStackingContext
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A subset of the full ComputedStyle as defined by the request whitelist.
    /// </summary>
    public partial class ComputedStyle : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name/value pairs of computed style properties.
        /// </summary>
        [JsonPropertyName("properties")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMSnapshot.NameValue> Properties
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A name/value pair.
    /// </summary>
    public partial class NameValue : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Attribute/property name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Attribute/property value.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Data that is only present on rare nodes.
    /// </summary>
    public partial class RareStringData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index
        /// </summary>
        [JsonPropertyName("index")]
        public int[] Index
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        public int[] Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// RareBooleanData
    /// </summary>
    public partial class RareBooleanData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index
        /// </summary>
        [JsonPropertyName("index")]
        public int[] Index
        {
            get;
            set;
        }
    }

    /// <summary>
    /// RareIntegerData
    /// </summary>
    public partial class RareIntegerData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index
        /// </summary>
        [JsonPropertyName("index")]
        public int[] Index
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        public int[] Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Document snapshot.
    /// </summary>
    public partial class DocumentSnapshot : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Document URL that `Document` or `FrameOwner` node points to.
        /// </summary>
        [JsonPropertyName("documentURL")]
        public int DocumentURL
        {
            get;
            set;
        }

        /// <summary>
        /// Document title.
        /// </summary>
        [JsonPropertyName("title")]
        public int Title
        {
            get;
            set;
        }

        /// <summary>
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        /// </summary>
        [JsonPropertyName("baseURL")]
        public int BaseURL
        {
            get;
            set;
        }

        /// <summary>
        /// Contains the document&apos;s content language.
        /// </summary>
        [JsonPropertyName("contentLanguage")]
        public int ContentLanguage
        {
            get;
            set;
        }

        /// <summary>
        /// Contains the document&apos;s character set encoding.
        /// </summary>
        [JsonPropertyName("encodingName")]
        public int EncodingName
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType` node&apos;s publicId.
        /// </summary>
        [JsonPropertyName("publicId")]
        public int PublicId
        {
            get;
            set;
        }

        /// <summary>
        /// `DocumentType` node&apos;s systemId.
        /// </summary>
        [JsonPropertyName("systemId")]
        public int SystemId
        {
            get;
            set;
        }

        /// <summary>
        /// Frame ID for frame owner elements and also for the document node.
        /// </summary>
        [JsonPropertyName("frameId")]
        public int FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// A table with dom nodes.
        /// </summary>
        [JsonPropertyName("nodes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMSnapshot.NodeTreeSnapshot Nodes
        {
            get;
            set;
        }

        /// <summary>
        /// The nodes in the layout tree.
        /// </summary>
        [JsonPropertyName("layout")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMSnapshot.LayoutTreeSnapshot Layout
        {
            get;
            set;
        }

        /// <summary>
        /// The post-layout inline text nodes.
        /// </summary>
        [JsonPropertyName("textBoxes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMSnapshot.TextBoxSnapshot TextBoxes
        {
            get;
            set;
        }

        /// <summary>
        /// Horizontal scroll offset.
        /// </summary>
        [JsonPropertyName("scrollOffsetX")]
        public double? ScrollOffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// Vertical scroll offset.
        /// </summary>
        [JsonPropertyName("scrollOffsetY")]
        public double? ScrollOffsetY
        {
            get;
            set;
        }

        /// <summary>
        /// Document content width.
        /// </summary>
        [JsonPropertyName("contentWidth")]
        public double? ContentWidth
        {
            get;
            set;
        }

        /// <summary>
        /// Document content height.
        /// </summary>
        [JsonPropertyName("contentHeight")]
        public double? ContentHeight
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Table containing nodes.
    /// </summary>
    public partial class NodeTreeSnapshot : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Parent node index.
        /// </summary>
        [JsonPropertyName("parentIndex")]
        public int[] ParentIndex
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeType.
        /// </summary>
        [JsonPropertyName("nodeType")]
        public int[] NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum.
        /// </summary>
        [JsonPropertyName("shadowRootType")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData ShadowRootType
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeName.
        /// </summary>
        [JsonPropertyName("nodeName")]
        public int[] NodeName
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s nodeValue.
        /// </summary>
        [JsonPropertyName("nodeValue")]
        public int[] NodeValue
        {
            get;
            set;
        }

        /// <summary>
        /// `Node`&apos;s id, corresponds to DOM.Node.backendNodeId.
        /// </summary>
        [JsonPropertyName("backendNodeId")]
        public int[] BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Attributes of an `Element` node. Flatten name, value pairs.
        /// </summary>
        [JsonPropertyName("attributes")]
        public int[] Attributes
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for textarea elements, contains the text value.
        /// </summary>
        [JsonPropertyName("textValue")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData TextValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for input elements, contains the input&apos;s associated text value.
        /// </summary>
        [JsonPropertyName("inputValue")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData InputValue
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for radio and checkbox input elements, indicates if the element has been checked
        /// </summary>
        [JsonPropertyName("inputChecked")]
        public CefSharp.DevTools.DOMSnapshot.RareBooleanData InputChecked
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for option elements, indicates if the element has been selected
        /// </summary>
        [JsonPropertyName("optionSelected")]
        public CefSharp.DevTools.DOMSnapshot.RareBooleanData OptionSelected
        {
            get;
            set;
        }

        /// <summary>
        /// The index of the document in the list of the snapshot documents.
        /// </summary>
        [JsonPropertyName("contentDocumentIndex")]
        public CefSharp.DevTools.DOMSnapshot.RareIntegerData ContentDocumentIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Type of a pseudo element node.
        /// </summary>
        [JsonPropertyName("pseudoType")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData PseudoType
        {
            get;
            set;
        }

        /// <summary>
        /// Pseudo element identifier for this node. Only present if there is a
        /// valid pseudoType.
        /// </summary>
        [JsonPropertyName("pseudoIdentifier")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData PseudoIdentifier
        {
            get;
            set;
        }

        /// <summary>
        /// Whether this DOM node responds to mouse clicks. This includes nodes that have had click
        /// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
        /// clicked.
        /// </summary>
        [JsonPropertyName("isClickable")]
        public CefSharp.DevTools.DOMSnapshot.RareBooleanData IsClickable
        {
            get;
            set;
        }

        /// <summary>
        /// The selected url for nodes with a srcset attribute.
        /// </summary>
        [JsonPropertyName("currentSourceURL")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData CurrentSourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// The url of the script (if any) that generates this node.
        /// </summary>
        [JsonPropertyName("originURL")]
        public CefSharp.DevTools.DOMSnapshot.RareStringData OriginURL
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Table of details of an element in the DOM tree with a LayoutObject.
    /// </summary>
    public partial class LayoutTreeSnapshot : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
        /// </summary>
        [JsonPropertyName("nodeIndex")]
        public int[] NodeIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
        /// </summary>
        [JsonPropertyName("styles")]
        public int[] Styles
        {
            get;
            set;
        }

        /// <summary>
        /// The absolute position bounding box.
        /// </summary>
        [JsonPropertyName("bounds")]
        public double[] Bounds
        {
            get;
            set;
        }

        /// <summary>
        /// Contents of the LayoutText, if any.
        /// </summary>
        [JsonPropertyName("text")]
        public int[] Text
        {
            get;
            set;
        }

        /// <summary>
        /// Stacking context information.
        /// </summary>
        [JsonPropertyName("stackingContexts")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMSnapshot.RareBooleanData StackingContexts
        {
            get;
            set;
        }

        /// <summary>
        /// Global paint order index, which is determined by the stacking order of the nodes. Nodes
        /// that are painted together will have the same index. Only provided if includePaintOrder in
        /// captureSnapshot was true.
        /// </summary>
        [JsonPropertyName("paintOrders")]
        public int[] PaintOrders
        {
            get;
            set;
        }

        /// <summary>
        /// The offset rect of nodes. Only available when includeDOMRects is set to true
        /// </summary>
        [JsonPropertyName("offsetRects")]
        public double[] OffsetRects
        {
            get;
            set;
        }

        /// <summary>
        /// The scroll rect of nodes. Only available when includeDOMRects is set to true
        /// </summary>
        [JsonPropertyName("scrollRects")]
        public double[] ScrollRects
        {
            get;
            set;
        }

        /// <summary>
        /// The client rect of nodes. Only available when includeDOMRects is set to true
        /// </summary>
        [JsonPropertyName("clientRects")]
        public double[] ClientRects
        {
            get;
            set;
        }

        /// <summary>
        /// The list of background colors that are blended with colors of overlapping elements.
        /// </summary>
        [JsonPropertyName("blendedBackgroundColors")]
        public int[] BlendedBackgroundColors
        {
            get;
            set;
        }

        /// <summary>
        /// The list of computed text opacities.
        /// </summary>
        [JsonPropertyName("textColorOpacities")]
        public double[] TextColorOpacities
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Table of details of the post layout rendered text positions. The exact layout should not be regarded as
    /// stable and may change between versions.
    /// </summary>
    public partial class TextBoxSnapshot : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index of the layout tree node that owns this box collection.
        /// </summary>
        [JsonPropertyName("layoutIndex")]
        public int[] LayoutIndex
        {
            get;
            set;
        }

        /// <summary>
        /// The absolute position bounding box.
        /// </summary>
        [JsonPropertyName("bounds")]
        public double[] Bounds
        {
            get;
            set;
        }

        /// <summary>
        /// The starting index in characters, for this post layout textbox substring. Characters that
        /// would be represented as a surrogate pair in UTF-16 have length 2.
        /// </summary>
        [JsonPropertyName("start")]
        public int[] Start
        {
            get;
            set;
        }

        /// <summary>
        /// The number of characters in this post layout textbox substring. Characters that would be
        /// represented as a surrogate pair in UTF-16 have length 2.
        /// </summary>
        [JsonPropertyName("length")]
        public int[] Length
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.DOMStorage
{
    /// <summary>
    /// DOM Storage identifier.
    /// </summary>
    public partial class StorageId : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Security origin for the storage.
        /// </summary>
        [JsonPropertyName("securityOrigin")]
        public string SecurityOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// Represents a key by which DOM Storage keys its CachedStorageAreas
        /// </summary>
        [JsonPropertyName("storageKey")]
        public string StorageKey
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the storage is local storage (not session storage).
        /// </summary>
        [JsonPropertyName("isLocalStorage")]
        public bool IsLocalStorage
        {
            get;
            set;
        }
    }

    /// <summary>
    /// domStorageItemAdded
    /// </summary>
    public class DomStorageItemAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// StorageId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMStorage.StorageId StorageId
        {
            get;
            private set;
        }

        /// <summary>
        /// Key
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Key
        {
            get;
            private set;
        }

        /// <summary>
        /// NewValue
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("newValue")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NewValue
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// domStorageItemRemoved
    /// </summary>
    public class DomStorageItemRemovedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// StorageId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMStorage.StorageId StorageId
        {
            get;
            private set;
        }

        /// <summary>
        /// Key
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Key
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// domStorageItemUpdated
    /// </summary>
    public class DomStorageItemUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// StorageId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMStorage.StorageId StorageId
        {
            get;
            private set;
        }

        /// <summary>
        /// Key
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Key
        {
            get;
            private set;
        }

        /// <summary>
        /// OldValue
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("oldValue")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string OldValue
        {
            get;
            private set;
        }

        /// <summary>
        /// NewValue
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("newValue")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NewValue
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// domStorageItemsCleared
    /// </summary>
    public class DomStorageItemsClearedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// StorageId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOMStorage.StorageId StorageId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Database
{
    /// <summary>
    /// Database object.
    /// </summary>
    public partial class Database : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Database ID.
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Database domain.
        /// </summary>
        [JsonPropertyName("domain")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Domain
        {
            get;
            set;
        }

        /// <summary>
        /// Database name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Database version.
        /// </summary>
        [JsonPropertyName("version")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Version
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Database error.
    /// </summary>
    public partial class Error : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Error message.
        /// </summary>
        [JsonPropertyName("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            set;
        }

        /// <summary>
        /// Error code.
        /// </summary>
        [JsonPropertyName("code")]
        public int Code
        {
            get;
            set;
        }
    }

    /// <summary>
    /// addDatabase
    /// </summary>
    public class AddDatabaseEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Database
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("database")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Database.Database Database
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// Orientation type.
    /// </summary>
    public enum ScreenOrientationType
    {
        /// <summary>
        /// portraitPrimary
        /// </summary>
        [JsonPropertyName("portraitPrimary")]
        PortraitPrimary,
        /// <summary>
        /// portraitSecondary
        /// </summary>
        [JsonPropertyName("portraitSecondary")]
        PortraitSecondary,
        /// <summary>
        /// landscapePrimary
        /// </summary>
        [JsonPropertyName("landscapePrimary")]
        LandscapePrimary,
        /// <summary>
        /// landscapeSecondary
        /// </summary>
        [JsonPropertyName("landscapeSecondary")]
        LandscapeSecondary
    }

    /// <summary>
    /// Screen orientation.
    /// </summary>
    public partial class ScreenOrientation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Orientation type.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Emulation.ScreenOrientationType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Orientation angle.
        /// </summary>
        [JsonPropertyName("angle")]
        public int Angle
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Orientation of a display feature in relation to screen
    /// </summary>
    public enum DisplayFeatureOrientation
    {
        /// <summary>
        /// vertical
        /// </summary>
        [JsonPropertyName("vertical")]
        Vertical,
        /// <summary>
        /// horizontal
        /// </summary>
        [JsonPropertyName("horizontal")]
        Horizontal
    }

    /// <summary>
    /// DisplayFeature
    /// </summary>
    public partial class DisplayFeature : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Orientation of a display feature in relation to screen
        /// </summary>
        [JsonPropertyName("orientation")]
        public CefSharp.DevTools.Emulation.DisplayFeatureOrientation Orientation
        {
            get;
            set;
        }

        /// <summary>
        /// The offset from the screen origin in either the x (for vertical
        /// orientation) or y (for horizontal orientation) direction.
        /// </summary>
        [JsonPropertyName("offset")]
        public int Offset
        {
            get;
            set;
        }

        /// <summary>
        /// A display feature may mask content such that it is not physically
        /// displayed - this length along with the offset describes this area.
        /// A display feature that only splits content will have a 0 mask_length.
        /// </summary>
        [JsonPropertyName("maskLength")]
        public int MaskLength
        {
            get;
            set;
        }
    }

    /// <summary>
    /// MediaFeature
    /// </summary>
    public partial class MediaFeature : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
    /// allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
    /// pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
    /// resource fetches.
    /// </summary>
    public enum VirtualTimePolicy
    {
        /// <summary>
        /// advance
        /// </summary>
        [JsonPropertyName("advance")]
        Advance,
        /// <summary>
        /// pause
        /// </summary>
        [JsonPropertyName("pause")]
        Pause,
        /// <summary>
        /// pauseIfNetworkFetchesPending
        /// </summary>
        [JsonPropertyName("pauseIfNetworkFetchesPending")]
        PauseIfNetworkFetchesPending
    }

    /// <summary>
    /// Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
    /// </summary>
    public partial class UserAgentBrandVersion : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Brand
        /// </summary>
        [JsonPropertyName("brand")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Brand
        {
            get;
            set;
        }

        /// <summary>
        /// Version
        /// </summary>
        [JsonPropertyName("version")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Version
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
    /// Missing optional values will be filled in by the target with what it would normally use.
    /// </summary>
    public partial class UserAgentMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Brands appearing in Sec-CH-UA.
        /// </summary>
        [JsonPropertyName("brands")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Emulation.UserAgentBrandVersion> Brands
        {
            get;
            set;
        }

        /// <summary>
        /// Brands appearing in Sec-CH-UA-Full-Version-List.
        /// </summary>
        [JsonPropertyName("fullVersionList")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Emulation.UserAgentBrandVersion> FullVersionList
        {
            get;
            set;
        }

        /// <summary>
        /// FullVersion
        /// </summary>
        [JsonPropertyName("fullVersion")]
        public string FullVersion
        {
            get;
            set;
        }

        /// <summary>
        /// Platform
        /// </summary>
        [JsonPropertyName("platform")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Platform
        {
            get;
            set;
        }

        /// <summary>
        /// PlatformVersion
        /// </summary>
        [JsonPropertyName("platformVersion")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlatformVersion
        {
            get;
            set;
        }

        /// <summary>
        /// Architecture
        /// </summary>
        [JsonPropertyName("architecture")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Architecture
        {
            get;
            set;
        }

        /// <summary>
        /// Model
        /// </summary>
        [JsonPropertyName("model")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Model
        {
            get;
            set;
        }

        /// <summary>
        /// Mobile
        /// </summary>
        [JsonPropertyName("mobile")]
        public bool Mobile
        {
            get;
            set;
        }

        /// <summary>
        /// Bitness
        /// </summary>
        [JsonPropertyName("bitness")]
        public string Bitness
        {
            get;
            set;
        }

        /// <summary>
        /// Wow64
        /// </summary>
        [JsonPropertyName("wow64")]
        public bool? Wow64
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Enum of image types that can be disabled.
    /// </summary>
    public enum DisabledImageType
    {
        /// <summary>
        /// avif
        /// </summary>
        [JsonPropertyName("avif")]
        Avif,
        /// <summary>
        /// webp
        /// </summary>
        [JsonPropertyName("webp")]
        Webp
    }
}

namespace CefSharp.DevTools.HeadlessExperimental
{
    /// <summary>
    /// Image compression format (defaults to png).
    /// </summary>
    public enum ScreenshotParamsFormat
    {
        /// <summary>
        /// jpeg
        /// </summary>
        [JsonPropertyName("jpeg")]
        Jpeg,
        /// <summary>
        /// png
        /// </summary>
        [JsonPropertyName("png")]
        Png,
        /// <summary>
        /// webp
        /// </summary>
        [JsonPropertyName("webp")]
        Webp
    }

    /// <summary>
    /// Encoding options for a screenshot.
    /// </summary>
    public partial class ScreenshotParams : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Image compression format (defaults to png).
        /// </summary>
        [JsonPropertyName("format")]
        public CefSharp.DevTools.HeadlessExperimental.ScreenshotParamsFormat? Format
        {
            get;
            set;
        }

        /// <summary>
        /// Compression quality from range [0..100] (jpeg only).
        /// </summary>
        [JsonPropertyName("quality")]
        public int? Quality
        {
            get;
            set;
        }

        /// <summary>
        /// Optimize image encoding for speed, not for resulting size (defaults to false)
        /// </summary>
        [JsonPropertyName("optimizeForSpeed")]
        public bool? OptimizeForSpeed
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// Database with an array of object stores.
    /// </summary>
    public partial class DatabaseWithObjectStores : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Database name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Database version (type is not &apos;integer&apos;, as the standard
        /// requires the version number to be &apos;unsigned long long&apos;)
        /// </summary>
        [JsonPropertyName("version")]
        public double Version
        {
            get;
            set;
        }

        /// <summary>
        /// Object stores in this database.
        /// </summary>
        [JsonPropertyName("objectStores")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.IndexedDB.ObjectStore> ObjectStores
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Object store.
    /// </summary>
    public partial class ObjectStore : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Object store name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Object store key path.
        /// </summary>
        [JsonPropertyName("keyPath")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.IndexedDB.KeyPath KeyPath
        {
            get;
            set;
        }

        /// <summary>
        /// If true, object store has auto increment flag set.
        /// </summary>
        [JsonPropertyName("autoIncrement")]
        public bool AutoIncrement
        {
            get;
            set;
        }

        /// <summary>
        /// Indexes in this object store.
        /// </summary>
        [JsonPropertyName("indexes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.IndexedDB.ObjectStoreIndex> Indexes
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Object store index.
    /// </summary>
    public partial class ObjectStoreIndex : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Index name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Index key path.
        /// </summary>
        [JsonPropertyName("keyPath")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.IndexedDB.KeyPath KeyPath
        {
            get;
            set;
        }

        /// <summary>
        /// If true, index is unique.
        /// </summary>
        [JsonPropertyName("unique")]
        public bool Unique
        {
            get;
            set;
        }

        /// <summary>
        /// If true, index allows multiple entries for a key.
        /// </summary>
        [JsonPropertyName("multiEntry")]
        public bool MultiEntry
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Key type.
    /// </summary>
    public enum KeyType
    {
        /// <summary>
        /// number
        /// </summary>
        [JsonPropertyName("number")]
        Number,
        /// <summary>
        /// string
        /// </summary>
        [JsonPropertyName("string")]
        String,
        /// <summary>
        /// date
        /// </summary>
        [JsonPropertyName("date")]
        Date,
        /// <summary>
        /// array
        /// </summary>
        [JsonPropertyName("array")]
        Array
    }

    /// <summary>
    /// Key.
    /// </summary>
    public partial class Key : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key type.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.IndexedDB.KeyType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Number value.
        /// </summary>
        [JsonPropertyName("number")]
        public double? Number
        {
            get;
            set;
        }

        /// <summary>
        /// String value.
        /// </summary>
        [JsonPropertyName("string")]
        public string String
        {
            get;
            set;
        }

        /// <summary>
        /// Date value.
        /// </summary>
        [JsonPropertyName("date")]
        public double? Date
        {
            get;
            set;
        }

        /// <summary>
        /// Array value.
        /// </summary>
        [JsonPropertyName("array")]
        public System.Collections.Generic.IList<CefSharp.DevTools.IndexedDB.Key> Array
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Key range.
    /// </summary>
    public partial class KeyRange : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Lower bound.
        /// </summary>
        [JsonPropertyName("lower")]
        public CefSharp.DevTools.IndexedDB.Key Lower
        {
            get;
            set;
        }

        /// <summary>
        /// Upper bound.
        /// </summary>
        [JsonPropertyName("upper")]
        public CefSharp.DevTools.IndexedDB.Key Upper
        {
            get;
            set;
        }

        /// <summary>
        /// If true lower bound is open.
        /// </summary>
        [JsonPropertyName("lowerOpen")]
        public bool LowerOpen
        {
            get;
            set;
        }

        /// <summary>
        /// If true upper bound is open.
        /// </summary>
        [JsonPropertyName("upperOpen")]
        public bool UpperOpen
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Data entry.
    /// </summary>
    public partial class DataEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key object.
        /// </summary>
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject Key
        {
            get;
            set;
        }

        /// <summary>
        /// Primary key object.
        /// </summary>
        [JsonPropertyName("primaryKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject PrimaryKey
        {
            get;
            set;
        }

        /// <summary>
        /// Value object.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Key path type.
    /// </summary>
    public enum KeyPathType
    {
        /// <summary>
        /// null
        /// </summary>
        [JsonPropertyName("null")]
        Null,
        /// <summary>
        /// string
        /// </summary>
        [JsonPropertyName("string")]
        String,
        /// <summary>
        /// array
        /// </summary>
        [JsonPropertyName("array")]
        Array
    }

    /// <summary>
    /// Key path.
    /// </summary>
    public partial class KeyPath : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key path type.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.IndexedDB.KeyPathType Type
        {
            get;
            set;
        }

        /// <summary>
        /// String value.
        /// </summary>
        [JsonPropertyName("string")]
        public string String
        {
            get;
            set;
        }

        /// <summary>
        /// Array value.
        /// </summary>
        [JsonPropertyName("array")]
        public string[] Array
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Input
{
    /// <summary>
    /// TouchPoint
    /// </summary>
    public partial class TouchPoint : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// X coordinate of the event relative to the main frame&apos;s viewport in CSS pixels.
        /// </summary>
        [JsonPropertyName("x")]
        public double X
        {
            get;
            set;
        }

        /// <summary>
        /// Y coordinate of the event relative to the main frame&apos;s viewport in CSS pixels. 0 refers to
        /// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        /// </summary>
        [JsonPropertyName("y")]
        public double Y
        {
            get;
            set;
        }

        /// <summary>
        /// X radius of the touch area (default: 1.0).
        /// </summary>
        [JsonPropertyName("radiusX")]
        public double? RadiusX
        {
            get;
            set;
        }

        /// <summary>
        /// Y radius of the touch area (default: 1.0).
        /// </summary>
        [JsonPropertyName("radiusY")]
        public double? RadiusY
        {
            get;
            set;
        }

        /// <summary>
        /// Rotation angle (default: 0.0).
        /// </summary>
        [JsonPropertyName("rotationAngle")]
        public double? RotationAngle
        {
            get;
            set;
        }

        /// <summary>
        /// Force (default: 1.0).
        /// </summary>
        [JsonPropertyName("force")]
        public double? Force
        {
            get;
            set;
        }

        /// <summary>
        /// The normalized tangential pressure, which has a range of [-1,1] (default: 0).
        /// </summary>
        [JsonPropertyName("tangentialPressure")]
        public double? TangentialPressure
        {
            get;
            set;
        }

        /// <summary>
        /// The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
        /// </summary>
        [JsonPropertyName("tiltX")]
        public int? TiltX
        {
            get;
            set;
        }

        /// <summary>
        /// The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
        /// </summary>
        [JsonPropertyName("tiltY")]
        public int? TiltY
        {
            get;
            set;
        }

        /// <summary>
        /// The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
        /// </summary>
        [JsonPropertyName("twist")]
        public int? Twist
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier used to track touch sources between events, must be unique within an event.
        /// </summary>
        [JsonPropertyName("id")]
        public double? Id
        {
            get;
            set;
        }
    }

    /// <summary>
    /// GestureSourceType
    /// </summary>
    public enum GestureSourceType
    {
        /// <summary>
        /// default
        /// </summary>
        [JsonPropertyName("default")]
        Default,
        /// <summary>
        /// touch
        /// </summary>
        [JsonPropertyName("touch")]
        Touch,
        /// <summary>
        /// mouse
        /// </summary>
        [JsonPropertyName("mouse")]
        Mouse
    }

    /// <summary>
    /// MouseButton
    /// </summary>
    public enum MouseButton
    {
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None,
        /// <summary>
        /// left
        /// </summary>
        [JsonPropertyName("left")]
        Left,
        /// <summary>
        /// middle
        /// </summary>
        [JsonPropertyName("middle")]
        Middle,
        /// <summary>
        /// right
        /// </summary>
        [JsonPropertyName("right")]
        Right,
        /// <summary>
        /// back
        /// </summary>
        [JsonPropertyName("back")]
        Back,
        /// <summary>
        /// forward
        /// </summary>
        [JsonPropertyName("forward")]
        Forward
    }

    /// <summary>
    /// DragDataItem
    /// </summary>
    public partial class DragDataItem : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Mime type of the dragged data.
        /// </summary>
        [JsonPropertyName("mimeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MimeType
        {
            get;
            set;
        }

        /// <summary>
        /// Depending of the value of `mimeType`, it contains the dragged link,
        /// text, HTML markup or any other data.
        /// </summary>
        [JsonPropertyName("data")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Data
        {
            get;
            set;
        }

        /// <summary>
        /// Title associated with a link. Only valid when `mimeType` == &quot;text/uri-list&quot;.
        /// </summary>
        [JsonPropertyName("title")]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// Stores the base URL for the contained markup. Only valid when `mimeType`
        /// == &quot;text/html&quot;.
        /// </summary>
        [JsonPropertyName("baseURL")]
        public string BaseURL
        {
            get;
            set;
        }
    }

    /// <summary>
    /// DragData
    /// </summary>
    public partial class DragData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Items
        /// </summary>
        [JsonPropertyName("items")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Input.DragDataItem> Items
        {
            get;
            set;
        }

        /// <summary>
        /// List of filenames that should be included when dropping
        /// </summary>
        [JsonPropertyName("files")]
        public string[] Files
        {
            get;
            set;
        }

        /// <summary>
        /// Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16
        /// </summary>
        [JsonPropertyName("dragOperationsMask")]
        public int DragOperationsMask
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
    /// restore normal drag and drop behavior.
    /// </summary>
    public class DragInterceptedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Data
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Input.DragData Data
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Inspector
{
    /// <summary>
    /// Fired when remote debugging connection is about to be terminated. Contains detach reason.
    /// </summary>
    public class DetachedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// The reason why connection has been terminated.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("reason")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Reason
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// Reason for rectangle to force scrolling on the main thread
    /// </summary>
    public enum ScrollRectType
    {
        /// <summary>
        /// RepaintsOnScroll
        /// </summary>
        [JsonPropertyName("RepaintsOnScroll")]
        RepaintsOnScroll,
        /// <summary>
        /// TouchEventHandler
        /// </summary>
        [JsonPropertyName("TouchEventHandler")]
        TouchEventHandler,
        /// <summary>
        /// WheelEventHandler
        /// </summary>
        [JsonPropertyName("WheelEventHandler")]
        WheelEventHandler
    }

    /// <summary>
    /// Rectangle where scrolling happens on the main thread.
    /// </summary>
    public partial class ScrollRect : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Rectangle itself.
        /// </summary>
        [JsonPropertyName("rect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect Rect
        {
            get;
            set;
        }

        /// <summary>
        /// Reason for rectangle to force scrolling on the main thread
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.LayerTree.ScrollRectType Type
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Sticky position constraints.
    /// </summary>
    public partial class StickyPositionConstraint : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Layout rectangle of the sticky element before being shifted
        /// </summary>
        [JsonPropertyName("stickyBoxRect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect StickyBoxRect
        {
            get;
            set;
        }

        /// <summary>
        /// Layout rectangle of the containing block of the sticky element
        /// </summary>
        [JsonPropertyName("containingBlockRect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect ContainingBlockRect
        {
            get;
            set;
        }

        /// <summary>
        /// The nearest sticky layer that shifts the sticky box
        /// </summary>
        [JsonPropertyName("nearestLayerShiftingStickyBox")]
        public string NearestLayerShiftingStickyBox
        {
            get;
            set;
        }

        /// <summary>
        /// The nearest sticky layer that shifts the containing block
        /// </summary>
        [JsonPropertyName("nearestLayerShiftingContainingBlock")]
        public string NearestLayerShiftingContainingBlock
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Serialized fragment of layer picture along with its offset within the layer.
    /// </summary>
    public partial class PictureTile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Offset from owning layer left boundary
        /// </summary>
        [JsonPropertyName("x")]
        public double X
        {
            get;
            set;
        }

        /// <summary>
        /// Offset from owning layer top boundary
        /// </summary>
        [JsonPropertyName("y")]
        public double Y
        {
            get;
            set;
        }

        /// <summary>
        /// Base64-encoded snapshot data.
        /// </summary>
        [JsonPropertyName("picture")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] Picture
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about a compositing layer.
    /// </summary>
    public partial class Layer : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The unique id for this layer.
        /// </summary>
        [JsonPropertyName("layerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LayerId
        {
            get;
            set;
        }

        /// <summary>
        /// The id of parent (not present for root).
        /// </summary>
        [JsonPropertyName("parentLayerId")]
        public string ParentLayerId
        {
            get;
            set;
        }

        /// <summary>
        /// The backend id for the node associated with this layer.
        /// </summary>
        [JsonPropertyName("backendNodeId")]
        public int? BackendNodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Offset from parent layer, X coordinate.
        /// </summary>
        [JsonPropertyName("offsetX")]
        public double OffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// Offset from parent layer, Y coordinate.
        /// </summary>
        [JsonPropertyName("offsetY")]
        public double OffsetY
        {
            get;
            set;
        }

        /// <summary>
        /// Layer width.
        /// </summary>
        [JsonPropertyName("width")]
        public double Width
        {
            get;
            set;
        }

        /// <summary>
        /// Layer height.
        /// </summary>
        [JsonPropertyName("height")]
        public double Height
        {
            get;
            set;
        }

        /// <summary>
        /// Transformation matrix for layer, default is identity matrix
        /// </summary>
        [JsonPropertyName("transform")]
        public double[] Transform
        {
            get;
            set;
        }

        /// <summary>
        /// Transform anchor point X, absent if no transform specified
        /// </summary>
        [JsonPropertyName("anchorX")]
        public double? AnchorX
        {
            get;
            set;
        }

        /// <summary>
        /// Transform anchor point Y, absent if no transform specified
        /// </summary>
        [JsonPropertyName("anchorY")]
        public double? AnchorY
        {
            get;
            set;
        }

        /// <summary>
        /// Transform anchor point Z, absent if no transform specified
        /// </summary>
        [JsonPropertyName("anchorZ")]
        public double? AnchorZ
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates how many time this layer has painted.
        /// </summary>
        [JsonPropertyName("paintCount")]
        public int PaintCount
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this layer hosts any content, rather than being used for
        /// transform/scrolling purposes only.
        /// </summary>
        [JsonPropertyName("drawsContent")]
        public bool DrawsContent
        {
            get;
            set;
        }

        /// <summary>
        /// Set if layer is not visible.
        /// </summary>
        [JsonPropertyName("invisible")]
        public bool? Invisible
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangles scrolling on main thread only.
        /// </summary>
        [JsonPropertyName("scrollRects")]
        public System.Collections.Generic.IList<CefSharp.DevTools.LayerTree.ScrollRect> ScrollRects
        {
            get;
            set;
        }

        /// <summary>
        /// Sticky position constraint information
        /// </summary>
        [JsonPropertyName("stickyPositionConstraint")]
        public CefSharp.DevTools.LayerTree.StickyPositionConstraint StickyPositionConstraint
        {
            get;
            set;
        }
    }

    /// <summary>
    /// layerPainted
    /// </summary>
    public class LayerPaintedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// The id of the painted layer.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("layerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LayerId
        {
            get;
            private set;
        }

        /// <summary>
        /// Clip rectangle.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("clip")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect Clip
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// layerTreeDidChange
    /// </summary>
    public class LayerTreeDidChangeEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Layer tree, absent if not in the comspositing mode.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("layers")]
        public System.Collections.Generic.IList<CefSharp.DevTools.LayerTree.Layer> Layers
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Log
{
    /// <summary>
    /// Log entry source.
    /// </summary>
    public enum LogEntrySource
    {
        /// <summary>
        /// xml
        /// </summary>
        [JsonPropertyName("xml")]
        Xml,
        /// <summary>
        /// javascript
        /// </summary>
        [JsonPropertyName("javascript")]
        Javascript,
        /// <summary>
        /// network
        /// </summary>
        [JsonPropertyName("network")]
        Network,
        /// <summary>
        /// storage
        /// </summary>
        [JsonPropertyName("storage")]
        Storage,
        /// <summary>
        /// appcache
        /// </summary>
        [JsonPropertyName("appcache")]
        Appcache,
        /// <summary>
        /// rendering
        /// </summary>
        [JsonPropertyName("rendering")]
        Rendering,
        /// <summary>
        /// security
        /// </summary>
        [JsonPropertyName("security")]
        Security,
        /// <summary>
        /// deprecation
        /// </summary>
        [JsonPropertyName("deprecation")]
        Deprecation,
        /// <summary>
        /// worker
        /// </summary>
        [JsonPropertyName("worker")]
        Worker,
        /// <summary>
        /// violation
        /// </summary>
        [JsonPropertyName("violation")]
        Violation,
        /// <summary>
        /// intervention
        /// </summary>
        [JsonPropertyName("intervention")]
        Intervention,
        /// <summary>
        /// recommendation
        /// </summary>
        [JsonPropertyName("recommendation")]
        Recommendation,
        /// <summary>
        /// other
        /// </summary>
        [JsonPropertyName("other")]
        Other
    }

    /// <summary>
    /// Log entry severity.
    /// </summary>
    public enum LogEntryLevel
    {
        /// <summary>
        /// verbose
        /// </summary>
        [JsonPropertyName("verbose")]
        Verbose,
        /// <summary>
        /// info
        /// </summary>
        [JsonPropertyName("info")]
        Info,
        /// <summary>
        /// warning
        /// </summary>
        [JsonPropertyName("warning")]
        Warning,
        /// <summary>
        /// error
        /// </summary>
        [JsonPropertyName("error")]
        Error
    }

    /// <summary>
    /// LogEntryCategory
    /// </summary>
    public enum LogEntryCategory
    {
        /// <summary>
        /// cors
        /// </summary>
        [JsonPropertyName("cors")]
        Cors
    }

    /// <summary>
    /// Log entry.
    /// </summary>
    public partial class LogEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Log entry source.
        /// </summary>
        [JsonPropertyName("source")]
        public CefSharp.DevTools.Log.LogEntrySource Source
        {
            get;
            set;
        }

        /// <summary>
        /// Log entry severity.
        /// </summary>
        [JsonPropertyName("level")]
        public CefSharp.DevTools.Log.LogEntryLevel Level
        {
            get;
            set;
        }

        /// <summary>
        /// Logged text.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Category
        /// </summary>
        [JsonPropertyName("category")]
        public CefSharp.DevTools.Log.LogEntryCategory? Category
        {
            get;
            set;
        }

        /// <summary>
        /// Timestamp when this entry was added.
        /// </summary>
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the resource if known.
        /// </summary>
        [JsonPropertyName("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Line number in the resource.
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int? LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript stack trace.
        /// </summary>
        [JsonPropertyName("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the network request associated with this entry.
        /// </summary>
        [JsonPropertyName("networkRequestId")]
        public string NetworkRequestId
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the worker associated with this entry.
        /// </summary>
        [JsonPropertyName("workerId")]
        public string WorkerId
        {
            get;
            set;
        }

        /// <summary>
        /// Call arguments.
        /// </summary>
        [JsonPropertyName("args")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.RemoteObject> Args
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Violation type.
    /// </summary>
    public enum ViolationSettingName
    {
        /// <summary>
        /// longTask
        /// </summary>
        [JsonPropertyName("longTask")]
        LongTask,
        /// <summary>
        /// longLayout
        /// </summary>
        [JsonPropertyName("longLayout")]
        LongLayout,
        /// <summary>
        /// blockedEvent
        /// </summary>
        [JsonPropertyName("blockedEvent")]
        BlockedEvent,
        /// <summary>
        /// blockedParser
        /// </summary>
        [JsonPropertyName("blockedParser")]
        BlockedParser,
        /// <summary>
        /// discouragedAPIUse
        /// </summary>
        [JsonPropertyName("discouragedAPIUse")]
        DiscouragedAPIUse,
        /// <summary>
        /// handler
        /// </summary>
        [JsonPropertyName("handler")]
        Handler,
        /// <summary>
        /// recurringHandler
        /// </summary>
        [JsonPropertyName("recurringHandler")]
        RecurringHandler
    }

    /// <summary>
    /// Violation configuration setting.
    /// </summary>
    public partial class ViolationSetting : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Violation type.
        /// </summary>
        [JsonPropertyName("name")]
        public CefSharp.DevTools.Log.ViolationSettingName Name
        {
            get;
            set;
        }

        /// <summary>
        /// Time threshold to trigger upon.
        /// </summary>
        [JsonPropertyName("threshold")]
        public double Threshold
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Issued when new message was logged.
    /// </summary>
    public class EntryAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// The entry.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("entry")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Log.LogEntry Entry
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// Memory pressure level.
    /// </summary>
    public enum PressureLevel
    {
        /// <summary>
        /// moderate
        /// </summary>
        [JsonPropertyName("moderate")]
        Moderate,
        /// <summary>
        /// critical
        /// </summary>
        [JsonPropertyName("critical")]
        Critical
    }

    /// <summary>
    /// Heap profile sample.
    /// </summary>
    public partial class SamplingProfileNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Size of the sampled allocation.
        /// </summary>
        [JsonPropertyName("size")]
        public double Size
        {
            get;
            set;
        }

        /// <summary>
        /// Total bytes attributed to this sample.
        /// </summary>
        [JsonPropertyName("total")]
        public double Total
        {
            get;
            set;
        }

        /// <summary>
        /// Execution stack at the point of allocation.
        /// </summary>
        [JsonPropertyName("stack")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Stack
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Array of heap profile samples.
    /// </summary>
    public partial class SamplingProfile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Samples
        /// </summary>
        [JsonPropertyName("samples")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Memory.SamplingProfileNode> Samples
        {
            get;
            set;
        }

        /// <summary>
        /// Modules
        /// </summary>
        [JsonPropertyName("modules")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Memory.Module> Modules
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Executable module information
    /// </summary>
    public partial class Module : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name of the module.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// UUID of the module.
        /// </summary>
        [JsonPropertyName("uuid")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Uuid
        {
            get;
            set;
        }

        /// <summary>
        /// Base address where the module is loaded into memory. Encoded as a decimal
        /// or hexadecimal (0x prefixed) string.
        /// </summary>
        [JsonPropertyName("baseAddress")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string BaseAddress
        {
            get;
            set;
        }

        /// <summary>
        /// Size of the module in bytes.
        /// </summary>
        [JsonPropertyName("size")]
        public double Size
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// Resource type as it was perceived by the rendering engine.
    /// </summary>
    public enum ResourceType
    {
        /// <summary>
        /// Document
        /// </summary>
        [JsonPropertyName("Document")]
        Document,
        /// <summary>
        /// Stylesheet
        /// </summary>
        [JsonPropertyName("Stylesheet")]
        Stylesheet,
        /// <summary>
        /// Image
        /// </summary>
        [JsonPropertyName("Image")]
        Image,
        /// <summary>
        /// Media
        /// </summary>
        [JsonPropertyName("Media")]
        Media,
        /// <summary>
        /// Font
        /// </summary>
        [JsonPropertyName("Font")]
        Font,
        /// <summary>
        /// Script
        /// </summary>
        [JsonPropertyName("Script")]
        Script,
        /// <summary>
        /// TextTrack
        /// </summary>
        [JsonPropertyName("TextTrack")]
        TextTrack,
        /// <summary>
        /// XHR
        /// </summary>
        [JsonPropertyName("XHR")]
        XHR,
        /// <summary>
        /// Fetch
        /// </summary>
        [JsonPropertyName("Fetch")]
        Fetch,
        /// <summary>
        /// Prefetch
        /// </summary>
        [JsonPropertyName("Prefetch")]
        Prefetch,
        /// <summary>
        /// EventSource
        /// </summary>
        [JsonPropertyName("EventSource")]
        EventSource,
        /// <summary>
        /// WebSocket
        /// </summary>
        [JsonPropertyName("WebSocket")]
        WebSocket,
        /// <summary>
        /// Manifest
        /// </summary>
        [JsonPropertyName("Manifest")]
        Manifest,
        /// <summary>
        /// SignedExchange
        /// </summary>
        [JsonPropertyName("SignedExchange")]
        SignedExchange,
        /// <summary>
        /// Ping
        /// </summary>
        [JsonPropertyName("Ping")]
        Ping,
        /// <summary>
        /// CSPViolationReport
        /// </summary>
        [JsonPropertyName("CSPViolationReport")]
        CSPViolationReport,
        /// <summary>
        /// Preflight
        /// </summary>
        [JsonPropertyName("Preflight")]
        Preflight,
        /// <summary>
        /// Other
        /// </summary>
        [JsonPropertyName("Other")]
        Other
    }

    /// <summary>
    /// Network level fetch failure reason.
    /// </summary>
    public enum ErrorReason
    {
        /// <summary>
        /// Failed
        /// </summary>
        [JsonPropertyName("Failed")]
        Failed,
        /// <summary>
        /// Aborted
        /// </summary>
        [JsonPropertyName("Aborted")]
        Aborted,
        /// <summary>
        /// TimedOut
        /// </summary>
        [JsonPropertyName("TimedOut")]
        TimedOut,
        /// <summary>
        /// AccessDenied
        /// </summary>
        [JsonPropertyName("AccessDenied")]
        AccessDenied,
        /// <summary>
        /// ConnectionClosed
        /// </summary>
        [JsonPropertyName("ConnectionClosed")]
        ConnectionClosed,
        /// <summary>
        /// ConnectionReset
        /// </summary>
        [JsonPropertyName("ConnectionReset")]
        ConnectionReset,
        /// <summary>
        /// ConnectionRefused
        /// </summary>
        [JsonPropertyName("ConnectionRefused")]
        ConnectionRefused,
        /// <summary>
        /// ConnectionAborted
        /// </summary>
        [JsonPropertyName("ConnectionAborted")]
        ConnectionAborted,
        /// <summary>
        /// ConnectionFailed
        /// </summary>
        [JsonPropertyName("ConnectionFailed")]
        ConnectionFailed,
        /// <summary>
        /// NameNotResolved
        /// </summary>
        [JsonPropertyName("NameNotResolved")]
        NameNotResolved,
        /// <summary>
        /// InternetDisconnected
        /// </summary>
        [JsonPropertyName("InternetDisconnected")]
        InternetDisconnected,
        /// <summary>
        /// AddressUnreachable
        /// </summary>
        [JsonPropertyName("AddressUnreachable")]
        AddressUnreachable,
        /// <summary>
        /// BlockedByClient
        /// </summary>
        [JsonPropertyName("BlockedByClient")]
        BlockedByClient,
        /// <summary>
        /// BlockedByResponse
        /// </summary>
        [JsonPropertyName("BlockedByResponse")]
        BlockedByResponse
    }

    /// <summary>
    /// The underlying connection technology that the browser is supposedly using.
    /// </summary>
    public enum ConnectionType
    {
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None,
        /// <summary>
        /// cellular2g
        /// </summary>
        [JsonPropertyName("cellular2g")]
        Cellular2g,
        /// <summary>
        /// cellular3g
        /// </summary>
        [JsonPropertyName("cellular3g")]
        Cellular3g,
        /// <summary>
        /// cellular4g
        /// </summary>
        [JsonPropertyName("cellular4g")]
        Cellular4g,
        /// <summary>
        /// bluetooth
        /// </summary>
        [JsonPropertyName("bluetooth")]
        Bluetooth,
        /// <summary>
        /// ethernet
        /// </summary>
        [JsonPropertyName("ethernet")]
        Ethernet,
        /// <summary>
        /// wifi
        /// </summary>
        [JsonPropertyName("wifi")]
        Wifi,
        /// <summary>
        /// wimax
        /// </summary>
        [JsonPropertyName("wimax")]
        Wimax,
        /// <summary>
        /// other
        /// </summary>
        [JsonPropertyName("other")]
        Other
    }

    /// <summary>
    /// Represents the cookie&apos;s &apos;SameSite&apos; status:
    /// https://tools.ietf.org/html/draft-west-first-party-cookies
    /// </summary>
    public enum CookieSameSite
    {
        /// <summary>
        /// Strict
        /// </summary>
        [JsonPropertyName("Strict")]
        Strict,
        /// <summary>
        /// Lax
        /// </summary>
        [JsonPropertyName("Lax")]
        Lax,
        /// <summary>
        /// None
        /// </summary>
        [JsonPropertyName("None")]
        None
    }

    /// <summary>
    /// Represents the cookie&apos;s &apos;Priority&apos; status:
    /// https://tools.ietf.org/html/draft-west-cookie-priority-00
    /// </summary>
    public enum CookiePriority
    {
        /// <summary>
        /// Low
        /// </summary>
        [JsonPropertyName("Low")]
        Low,
        /// <summary>
        /// Medium
        /// </summary>
        [JsonPropertyName("Medium")]
        Medium,
        /// <summary>
        /// High
        /// </summary>
        [JsonPropertyName("High")]
        High
    }

    /// <summary>
    /// Represents the source scheme of the origin that originally set the cookie.
    /// A value of &quot;Unset&quot; allows protocol clients to emulate legacy cookie scope for the scheme.
    /// This is a temporary ability and it will be removed in the future.
    /// </summary>
    public enum CookieSourceScheme
    {
        /// <summary>
        /// Unset
        /// </summary>
        [JsonPropertyName("Unset")]
        Unset,
        /// <summary>
        /// NonSecure
        /// </summary>
        [JsonPropertyName("NonSecure")]
        NonSecure,
        /// <summary>
        /// Secure
        /// </summary>
        [JsonPropertyName("Secure")]
        Secure
    }

    /// <summary>
    /// Timing information for the request.
    /// </summary>
    public partial class ResourceTiming : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Timing&apos;s requestTime is a baseline in seconds, while the other numbers are ticks in
        /// milliseconds relatively to this requestTime.
        /// </summary>
        [JsonPropertyName("requestTime")]
        public double RequestTime
        {
            get;
            set;
        }

        /// <summary>
        /// Started resolving proxy.
        /// </summary>
        [JsonPropertyName("proxyStart")]
        public double ProxyStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished resolving proxy.
        /// </summary>
        [JsonPropertyName("proxyEnd")]
        public double ProxyEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Started DNS address resolve.
        /// </summary>
        [JsonPropertyName("dnsStart")]
        public double DnsStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished DNS address resolve.
        /// </summary>
        [JsonPropertyName("dnsEnd")]
        public double DnsEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Started connecting to the remote host.
        /// </summary>
        [JsonPropertyName("connectStart")]
        public double ConnectStart
        {
            get;
            set;
        }

        /// <summary>
        /// Connected to the remote host.
        /// </summary>
        [JsonPropertyName("connectEnd")]
        public double ConnectEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Started SSL handshake.
        /// </summary>
        [JsonPropertyName("sslStart")]
        public double SslStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished SSL handshake.
        /// </summary>
        [JsonPropertyName("sslEnd")]
        public double SslEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Started running ServiceWorker.
        /// </summary>
        [JsonPropertyName("workerStart")]
        public double WorkerStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished Starting ServiceWorker.
        /// </summary>
        [JsonPropertyName("workerReady")]
        public double WorkerReady
        {
            get;
            set;
        }

        /// <summary>
        /// Started fetch event.
        /// </summary>
        [JsonPropertyName("workerFetchStart")]
        public double WorkerFetchStart
        {
            get;
            set;
        }

        /// <summary>
        /// Settled fetch event respondWith promise.
        /// </summary>
        [JsonPropertyName("workerRespondWithSettled")]
        public double WorkerRespondWithSettled
        {
            get;
            set;
        }

        /// <summary>
        /// Started sending request.
        /// </summary>
        [JsonPropertyName("sendStart")]
        public double SendStart
        {
            get;
            set;
        }

        /// <summary>
        /// Finished sending request.
        /// </summary>
        [JsonPropertyName("sendEnd")]
        public double SendEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Time the server started pushing request.
        /// </summary>
        [JsonPropertyName("pushStart")]
        public double PushStart
        {
            get;
            set;
        }

        /// <summary>
        /// Time the server finished pushing request.
        /// </summary>
        [JsonPropertyName("pushEnd")]
        public double PushEnd
        {
            get;
            set;
        }

        /// <summary>
        /// Finished receiving response headers.
        /// </summary>
        [JsonPropertyName("receiveHeadersEnd")]
        public double ReceiveHeadersEnd
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Loading priority of a resource request.
    /// </summary>
    public enum ResourcePriority
    {
        /// <summary>
        /// VeryLow
        /// </summary>
        [JsonPropertyName("VeryLow")]
        VeryLow,
        /// <summary>
        /// Low
        /// </summary>
        [JsonPropertyName("Low")]
        Low,
        /// <summary>
        /// Medium
        /// </summary>
        [JsonPropertyName("Medium")]
        Medium,
        /// <summary>
        /// High
        /// </summary>
        [JsonPropertyName("High")]
        High,
        /// <summary>
        /// VeryHigh
        /// </summary>
        [JsonPropertyName("VeryHigh")]
        VeryHigh
    }

    /// <summary>
    /// Post data entry for HTTP request
    /// </summary>
    public partial class PostDataEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Bytes
        /// </summary>
        [JsonPropertyName("bytes")]
        public byte[] Bytes
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
    /// </summary>
    public enum RequestReferrerPolicy
    {
        /// <summary>
        /// unsafe-url
        /// </summary>
        [JsonPropertyName("unsafe-url")]
        UnsafeUrl,
        /// <summary>
        /// no-referrer-when-downgrade
        /// </summary>
        [JsonPropertyName("no-referrer-when-downgrade")]
        NoReferrerWhenDowngrade,
        /// <summary>
        /// no-referrer
        /// </summary>
        [JsonPropertyName("no-referrer")]
        NoReferrer,
        /// <summary>
        /// origin
        /// </summary>
        [JsonPropertyName("origin")]
        Origin,
        /// <summary>
        /// origin-when-cross-origin
        /// </summary>
        [JsonPropertyName("origin-when-cross-origin")]
        OriginWhenCrossOrigin,
        /// <summary>
        /// same-origin
        /// </summary>
        [JsonPropertyName("same-origin")]
        SameOrigin,
        /// <summary>
        /// strict-origin
        /// </summary>
        [JsonPropertyName("strict-origin")]
        StrictOrigin,
        /// <summary>
        /// strict-origin-when-cross-origin
        /// </summary>
        [JsonPropertyName("strict-origin-when-cross-origin")]
        StrictOriginWhenCrossOrigin
    }

    /// <summary>
    /// HTTP request data.
    /// </summary>
    public partial class Request : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Request URL (without fragment).
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Fragment of the requested URL starting with hash, if present.
        /// </summary>
        [JsonPropertyName("urlFragment")]
        public string UrlFragment
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request method.
        /// </summary>
        [JsonPropertyName("method")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Method
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request headers.
        /// </summary>
        [JsonPropertyName("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP POST request data.
        /// </summary>
        [JsonPropertyName("postData")]
        public string PostData
        {
            get;
            set;
        }

        /// <summary>
        /// True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
        /// </summary>
        [JsonPropertyName("hasPostData")]
        public bool? HasPostData
        {
            get;
            set;
        }

        /// <summary>
        /// Request body elements. This will be converted from base64 to binary
        /// </summary>
        [JsonPropertyName("postDataEntries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.PostDataEntry> PostDataEntries
        {
            get;
            set;
        }

        /// <summary>
        /// The mixed content type of the request.
        /// </summary>
        [JsonPropertyName("mixedContentType")]
        public CefSharp.DevTools.Security.MixedContentType? MixedContentType
        {
            get;
            set;
        }

        /// <summary>
        /// Priority of the resource request at the time request is sent.
        /// </summary>
        [JsonPropertyName("initialPriority")]
        public CefSharp.DevTools.Network.ResourcePriority InitialPriority
        {
            get;
            set;
        }

        /// <summary>
        /// The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
        /// </summary>
        [JsonPropertyName("referrerPolicy")]
        public CefSharp.DevTools.Network.RequestReferrerPolicy ReferrerPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// Whether is loaded via link preload.
        /// </summary>
        [JsonPropertyName("isLinkPreload")]
        public bool? IsLinkPreload
        {
            get;
            set;
        }

        /// <summary>
        /// Set for requests when the TrustToken API is used. Contains the parameters
        /// passed by the developer (e.g. via &quot;fetch&quot;) as understood by the backend.
        /// </summary>
        [JsonPropertyName("trustTokenParams")]
        public CefSharp.DevTools.Network.TrustTokenParams TrustTokenParams
        {
            get;
            set;
        }

        /// <summary>
        /// True if this resource request is considered to be the &apos;same site&apos; as the
        /// request correspondinfg to the main frame.
        /// </summary>
        [JsonPropertyName("isSameSite")]
        public bool? IsSameSite
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Details of a signed certificate timestamp (SCT).
    /// </summary>
    public partial class SignedCertificateTimestamp : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Validation status.
        /// </summary>
        [JsonPropertyName("status")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Status
        {
            get;
            set;
        }

        /// <summary>
        /// Origin.
        /// </summary>
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Log name / description.
        /// </summary>
        [JsonPropertyName("logDescription")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LogDescription
        {
            get;
            set;
        }

        /// <summary>
        /// Log ID.
        /// </summary>
        [JsonPropertyName("logId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LogId
        {
            get;
            set;
        }

        /// <summary>
        /// Issuance date. Unlike TimeSinceEpoch, this contains the number of
        /// milliseconds since January 1, 1970, UTC, not the number of seconds.
        /// </summary>
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// Hash algorithm.
        /// </summary>
        [JsonPropertyName("hashAlgorithm")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string HashAlgorithm
        {
            get;
            set;
        }

        /// <summary>
        /// Signature algorithm.
        /// </summary>
        [JsonPropertyName("signatureAlgorithm")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SignatureAlgorithm
        {
            get;
            set;
        }

        /// <summary>
        /// Signature data.
        /// </summary>
        [JsonPropertyName("signatureData")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SignatureData
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Security details about a request.
    /// </summary>
    public partial class SecurityDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Protocol name (e.g. &quot;TLS 1.2&quot; or &quot;QUIC&quot;).
        /// </summary>
        [JsonPropertyName("protocol")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Protocol
        {
            get;
            set;
        }

        /// <summary>
        /// Key Exchange used by the connection, or the empty string if not applicable.
        /// </summary>
        [JsonPropertyName("keyExchange")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string KeyExchange
        {
            get;
            set;
        }

        /// <summary>
        /// (EC)DH group used by the connection, if applicable.
        /// </summary>
        [JsonPropertyName("keyExchangeGroup")]
        public string KeyExchangeGroup
        {
            get;
            set;
        }

        /// <summary>
        /// Cipher name.
        /// </summary>
        [JsonPropertyName("cipher")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Cipher
        {
            get;
            set;
        }

        /// <summary>
        /// TLS MAC. Note that AEAD ciphers do not have separate MACs.
        /// </summary>
        [JsonPropertyName("mac")]
        public string Mac
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate ID value.
        /// </summary>
        [JsonPropertyName("certificateId")]
        public int CertificateId
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate subject name.
        /// </summary>
        [JsonPropertyName("subjectName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SubjectName
        {
            get;
            set;
        }

        /// <summary>
        /// Subject Alternative Name (SAN) DNS names and IP addresses.
        /// </summary>
        [JsonPropertyName("sanList")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] SanList
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the issuing CA.
        /// </summary>
        [JsonPropertyName("issuer")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Issuer
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate valid from date.
        /// </summary>
        [JsonPropertyName("validFrom")]
        public double ValidFrom
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate valid to (expiration) date
        /// </summary>
        [JsonPropertyName("validTo")]
        public double ValidTo
        {
            get;
            set;
        }

        /// <summary>
        /// List of signed certificate timestamps (SCTs).
        /// </summary>
        [JsonPropertyName("signedCertificateTimestampList")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.SignedCertificateTimestamp> SignedCertificateTimestampList
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the request complied with Certificate Transparency policy
        /// </summary>
        [JsonPropertyName("certificateTransparencyCompliance")]
        public CefSharp.DevTools.Network.CertificateTransparencyCompliance CertificateTransparencyCompliance
        {
            get;
            set;
        }

        /// <summary>
        /// The signature algorithm used by the server in the TLS server signature,
        /// represented as a TLS SignatureScheme code point. Omitted if not
        /// applicable or not known.
        /// </summary>
        [JsonPropertyName("serverSignatureAlgorithm")]
        public int? ServerSignatureAlgorithm
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the connection used Encrypted ClientHello
        /// </summary>
        [JsonPropertyName("encryptedClientHello")]
        public bool EncryptedClientHello
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Whether the request complied with Certificate Transparency policy.
    /// </summary>
    public enum CertificateTransparencyCompliance
    {
        /// <summary>
        /// unknown
        /// </summary>
        [JsonPropertyName("unknown")]
        Unknown,
        /// <summary>
        /// not-compliant
        /// </summary>
        [JsonPropertyName("not-compliant")]
        NotCompliant,
        /// <summary>
        /// compliant
        /// </summary>
        [JsonPropertyName("compliant")]
        Compliant
    }

    /// <summary>
    /// The reason why request was blocked.
    /// </summary>
    public enum BlockedReason
    {
        /// <summary>
        /// other
        /// </summary>
        [JsonPropertyName("other")]
        Other,
        /// <summary>
        /// csp
        /// </summary>
        [JsonPropertyName("csp")]
        Csp,
        /// <summary>
        /// mixed-content
        /// </summary>
        [JsonPropertyName("mixed-content")]
        MixedContent,
        /// <summary>
        /// origin
        /// </summary>
        [JsonPropertyName("origin")]
        Origin,
        /// <summary>
        /// inspector
        /// </summary>
        [JsonPropertyName("inspector")]
        Inspector,
        /// <summary>
        /// subresource-filter
        /// </summary>
        [JsonPropertyName("subresource-filter")]
        SubresourceFilter,
        /// <summary>
        /// content-type
        /// </summary>
        [JsonPropertyName("content-type")]
        ContentType,
        /// <summary>
        /// coep-frame-resource-needs-coep-header
        /// </summary>
        [JsonPropertyName("coep-frame-resource-needs-coep-header")]
        CoepFrameResourceNeedsCoepHeader,
        /// <summary>
        /// coop-sandboxed-iframe-cannot-navigate-to-coop-page
        /// </summary>
        [JsonPropertyName("coop-sandboxed-iframe-cannot-navigate-to-coop-page")]
        CoopSandboxedIframeCannotNavigateToCoopPage,
        /// <summary>
        /// corp-not-same-origin
        /// </summary>
        [JsonPropertyName("corp-not-same-origin")]
        CorpNotSameOrigin,
        /// <summary>
        /// corp-not-same-origin-after-defaulted-to-same-origin-by-coep
        /// </summary>
        [JsonPropertyName("corp-not-same-origin-after-defaulted-to-same-origin-by-coep")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        /// <summary>
        /// corp-not-same-site
        /// </summary>
        [JsonPropertyName("corp-not-same-site")]
        CorpNotSameSite
    }

    /// <summary>
    /// The reason why request was blocked.
    /// </summary>
    public enum CorsError
    {
        /// <summary>
        /// DisallowedByMode
        /// </summary>
        [JsonPropertyName("DisallowedByMode")]
        DisallowedByMode,
        /// <summary>
        /// InvalidResponse
        /// </summary>
        [JsonPropertyName("InvalidResponse")]
        InvalidResponse,
        /// <summary>
        /// WildcardOriginNotAllowed
        /// </summary>
        [JsonPropertyName("WildcardOriginNotAllowed")]
        WildcardOriginNotAllowed,
        /// <summary>
        /// MissingAllowOriginHeader
        /// </summary>
        [JsonPropertyName("MissingAllowOriginHeader")]
        MissingAllowOriginHeader,
        /// <summary>
        /// MultipleAllowOriginValues
        /// </summary>
        [JsonPropertyName("MultipleAllowOriginValues")]
        MultipleAllowOriginValues,
        /// <summary>
        /// InvalidAllowOriginValue
        /// </summary>
        [JsonPropertyName("InvalidAllowOriginValue")]
        InvalidAllowOriginValue,
        /// <summary>
        /// AllowOriginMismatch
        /// </summary>
        [JsonPropertyName("AllowOriginMismatch")]
        AllowOriginMismatch,
        /// <summary>
        /// InvalidAllowCredentials
        /// </summary>
        [JsonPropertyName("InvalidAllowCredentials")]
        InvalidAllowCredentials,
        /// <summary>
        /// CorsDisabledScheme
        /// </summary>
        [JsonPropertyName("CorsDisabledScheme")]
        CorsDisabledScheme,
        /// <summary>
        /// PreflightInvalidStatus
        /// </summary>
        [JsonPropertyName("PreflightInvalidStatus")]
        PreflightInvalidStatus,
        /// <summary>
        /// PreflightDisallowedRedirect
        /// </summary>
        [JsonPropertyName("PreflightDisallowedRedirect")]
        PreflightDisallowedRedirect,
        /// <summary>
        /// PreflightWildcardOriginNotAllowed
        /// </summary>
        [JsonPropertyName("PreflightWildcardOriginNotAllowed")]
        PreflightWildcardOriginNotAllowed,
        /// <summary>
        /// PreflightMissingAllowOriginHeader
        /// </summary>
        [JsonPropertyName("PreflightMissingAllowOriginHeader")]
        PreflightMissingAllowOriginHeader,
        /// <summary>
        /// PreflightMultipleAllowOriginValues
        /// </summary>
        [JsonPropertyName("PreflightMultipleAllowOriginValues")]
        PreflightMultipleAllowOriginValues,
        /// <summary>
        /// PreflightInvalidAllowOriginValue
        /// </summary>
        [JsonPropertyName("PreflightInvalidAllowOriginValue")]
        PreflightInvalidAllowOriginValue,
        /// <summary>
        /// PreflightAllowOriginMismatch
        /// </summary>
        [JsonPropertyName("PreflightAllowOriginMismatch")]
        PreflightAllowOriginMismatch,
        /// <summary>
        /// PreflightInvalidAllowCredentials
        /// </summary>
        [JsonPropertyName("PreflightInvalidAllowCredentials")]
        PreflightInvalidAllowCredentials,
        /// <summary>
        /// PreflightMissingAllowExternal
        /// </summary>
        [JsonPropertyName("PreflightMissingAllowExternal")]
        PreflightMissingAllowExternal,
        /// <summary>
        /// PreflightInvalidAllowExternal
        /// </summary>
        [JsonPropertyName("PreflightInvalidAllowExternal")]
        PreflightInvalidAllowExternal,
        /// <summary>
        /// PreflightMissingAllowPrivateNetwork
        /// </summary>
        [JsonPropertyName("PreflightMissingAllowPrivateNetwork")]
        PreflightMissingAllowPrivateNetwork,
        /// <summary>
        /// PreflightInvalidAllowPrivateNetwork
        /// </summary>
        [JsonPropertyName("PreflightInvalidAllowPrivateNetwork")]
        PreflightInvalidAllowPrivateNetwork,
        /// <summary>
        /// InvalidAllowMethodsPreflightResponse
        /// </summary>
        [JsonPropertyName("InvalidAllowMethodsPreflightResponse")]
        InvalidAllowMethodsPreflightResponse,
        /// <summary>
        /// InvalidAllowHeadersPreflightResponse
        /// </summary>
        [JsonPropertyName("InvalidAllowHeadersPreflightResponse")]
        InvalidAllowHeadersPreflightResponse,
        /// <summary>
        /// MethodDisallowedByPreflightResponse
        /// </summary>
        [JsonPropertyName("MethodDisallowedByPreflightResponse")]
        MethodDisallowedByPreflightResponse,
        /// <summary>
        /// HeaderDisallowedByPreflightResponse
        /// </summary>
        [JsonPropertyName("HeaderDisallowedByPreflightResponse")]
        HeaderDisallowedByPreflightResponse,
        /// <summary>
        /// RedirectContainsCredentials
        /// </summary>
        [JsonPropertyName("RedirectContainsCredentials")]
        RedirectContainsCredentials,
        /// <summary>
        /// InsecurePrivateNetwork
        /// </summary>
        [JsonPropertyName("InsecurePrivateNetwork")]
        InsecurePrivateNetwork,
        /// <summary>
        /// InvalidPrivateNetworkAccess
        /// </summary>
        [JsonPropertyName("InvalidPrivateNetworkAccess")]
        InvalidPrivateNetworkAccess,
        /// <summary>
        /// UnexpectedPrivateNetworkAccess
        /// </summary>
        [JsonPropertyName("UnexpectedPrivateNetworkAccess")]
        UnexpectedPrivateNetworkAccess,
        /// <summary>
        /// NoCorsRedirectModeNotFollow
        /// </summary>
        [JsonPropertyName("NoCorsRedirectModeNotFollow")]
        NoCorsRedirectModeNotFollow
    }

    /// <summary>
    /// CorsErrorStatus
    /// </summary>
    public partial class CorsErrorStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CorsError
        /// </summary>
        [JsonPropertyName("corsError")]
        public CefSharp.DevTools.Network.CorsError CorsError
        {
            get;
            set;
        }

        /// <summary>
        /// FailedParameter
        /// </summary>
        [JsonPropertyName("failedParameter")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FailedParameter
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Source of serviceworker response.
    /// </summary>
    public enum ServiceWorkerResponseSource
    {
        /// <summary>
        /// cache-storage
        /// </summary>
        [JsonPropertyName("cache-storage")]
        CacheStorage,
        /// <summary>
        /// http-cache
        /// </summary>
        [JsonPropertyName("http-cache")]
        HttpCache,
        /// <summary>
        /// fallback-code
        /// </summary>
        [JsonPropertyName("fallback-code")]
        FallbackCode,
        /// <summary>
        /// network
        /// </summary>
        [JsonPropertyName("network")]
        Network
    }

    /// <summary>
    /// Only set for &quot;token-redemption&quot; operation and determine whether
    /// to request a fresh SRR or use a still valid cached SRR.
    /// </summary>
    public enum TrustTokenParamsRefreshPolicy
    {
        /// <summary>
        /// UseCached
        /// </summary>
        [JsonPropertyName("UseCached")]
        UseCached,
        /// <summary>
        /// Refresh
        /// </summary>
        [JsonPropertyName("Refresh")]
        Refresh
    }

    /// <summary>
    /// Determines what type of Trust Token operation is executed and
    /// depending on the type, some additional parameters. The values
    /// are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
    /// </summary>
    public partial class TrustTokenParams : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Operation
        /// </summary>
        [JsonPropertyName("operation")]
        public CefSharp.DevTools.Network.TrustTokenOperationType Operation
        {
            get;
            set;
        }

        /// <summary>
        /// Only set for &quot;token-redemption&quot; operation and determine whether
        /// to request a fresh SRR or use a still valid cached SRR.
        /// </summary>
        [JsonPropertyName("refreshPolicy")]
        public CefSharp.DevTools.Network.TrustTokenParamsRefreshPolicy RefreshPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// Origins of issuers from whom to request tokens or redemption
        /// records.
        /// </summary>
        [JsonPropertyName("issuers")]
        public string[] Issuers
        {
            get;
            set;
        }
    }

    /// <summary>
    /// TrustTokenOperationType
    /// </summary>
    public enum TrustTokenOperationType
    {
        /// <summary>
        /// Issuance
        /// </summary>
        [JsonPropertyName("Issuance")]
        Issuance,
        /// <summary>
        /// Redemption
        /// </summary>
        [JsonPropertyName("Redemption")]
        Redemption,
        /// <summary>
        /// Signing
        /// </summary>
        [JsonPropertyName("Signing")]
        Signing
    }

    /// <summary>
    /// The reason why Chrome uses a specific transport protocol for HTTP semantics.
    /// </summary>
    public enum AlternateProtocolUsage
    {
        /// <summary>
        /// alternativeJobWonWithoutRace
        /// </summary>
        [JsonPropertyName("alternativeJobWonWithoutRace")]
        AlternativeJobWonWithoutRace,
        /// <summary>
        /// alternativeJobWonRace
        /// </summary>
        [JsonPropertyName("alternativeJobWonRace")]
        AlternativeJobWonRace,
        /// <summary>
        /// mainJobWonRace
        /// </summary>
        [JsonPropertyName("mainJobWonRace")]
        MainJobWonRace,
        /// <summary>
        /// mappingMissing
        /// </summary>
        [JsonPropertyName("mappingMissing")]
        MappingMissing,
        /// <summary>
        /// broken
        /// </summary>
        [JsonPropertyName("broken")]
        Broken,
        /// <summary>
        /// dnsAlpnH3JobWonWithoutRace
        /// </summary>
        [JsonPropertyName("dnsAlpnH3JobWonWithoutRace")]
        DnsAlpnH3JobWonWithoutRace,
        /// <summary>
        /// dnsAlpnH3JobWonRace
        /// </summary>
        [JsonPropertyName("dnsAlpnH3JobWonRace")]
        DnsAlpnH3JobWonRace,
        /// <summary>
        /// unspecifiedReason
        /// </summary>
        [JsonPropertyName("unspecifiedReason")]
        UnspecifiedReason
    }

    /// <summary>
    /// HTTP response data.
    /// </summary>
    public partial class Response : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Response URL. This URL can be different from CachedResource.url in case of redirect.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status code.
        /// </summary>
        [JsonPropertyName("status")]
        public int Status
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status text.
        /// </summary>
        [JsonPropertyName("statusText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StatusText
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response headers.
        /// </summary>
        [JsonPropertyName("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.
        /// </summary>
        [JsonPropertyName("headersText")]
        public string HeadersText
        {
            get;
            set;
        }

        /// <summary>
        /// Resource mimeType as determined by the browser.
        /// </summary>
        [JsonPropertyName("mimeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MimeType
        {
            get;
            set;
        }

        /// <summary>
        /// Refined HTTP request headers that were actually transmitted over the network.
        /// </summary>
        [JsonPropertyName("requestHeaders")]
        public CefSharp.DevTools.Network.Headers RequestHeaders
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.
        /// </summary>
        [JsonPropertyName("requestHeadersText")]
        public string RequestHeadersText
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies whether physical connection was actually reused for this request.
        /// </summary>
        [JsonPropertyName("connectionReused")]
        public bool ConnectionReused
        {
            get;
            set;
        }

        /// <summary>
        /// Physical connection id that was actually used for this request.
        /// </summary>
        [JsonPropertyName("connectionId")]
        public double ConnectionId
        {
            get;
            set;
        }

        /// <summary>
        /// Remote IP address.
        /// </summary>
        [JsonPropertyName("remoteIPAddress")]
        public string RemoteIPAddress
        {
            get;
            set;
        }

        /// <summary>
        /// Remote port.
        /// </summary>
        [JsonPropertyName("remotePort")]
        public int? RemotePort
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies that the request was served from the disk cache.
        /// </summary>
        [JsonPropertyName("fromDiskCache")]
        public bool? FromDiskCache
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies that the request was served from the ServiceWorker.
        /// </summary>
        [JsonPropertyName("fromServiceWorker")]
        public bool? FromServiceWorker
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies that the request was served from the prefetch cache.
        /// </summary>
        [JsonPropertyName("fromPrefetchCache")]
        public bool? FromPrefetchCache
        {
            get;
            set;
        }

        /// <summary>
        /// Total number of bytes received for this request so far.
        /// </summary>
        [JsonPropertyName("encodedDataLength")]
        public double EncodedDataLength
        {
            get;
            set;
        }

        /// <summary>
        /// Timing information for the given request.
        /// </summary>
        [JsonPropertyName("timing")]
        public CefSharp.DevTools.Network.ResourceTiming Timing
        {
            get;
            set;
        }

        /// <summary>
        /// Response source of response from ServiceWorker.
        /// </summary>
        [JsonPropertyName("serviceWorkerResponseSource")]
        public CefSharp.DevTools.Network.ServiceWorkerResponseSource? ServiceWorkerResponseSource
        {
            get;
            set;
        }

        /// <summary>
        /// The time at which the returned response was generated.
        /// </summary>
        [JsonPropertyName("responseTime")]
        public double? ResponseTime
        {
            get;
            set;
        }

        /// <summary>
        /// Cache Storage Cache Name.
        /// </summary>
        [JsonPropertyName("cacheStorageCacheName")]
        public string CacheStorageCacheName
        {
            get;
            set;
        }

        /// <summary>
        /// Protocol used to fetch this request.
        /// </summary>
        [JsonPropertyName("protocol")]
        public string Protocol
        {
            get;
            set;
        }

        /// <summary>
        /// The reason why Chrome uses a specific transport protocol for HTTP semantics.
        /// </summary>
        [JsonPropertyName("alternateProtocolUsage")]
        public CefSharp.DevTools.Network.AlternateProtocolUsage? AlternateProtocolUsage
        {
            get;
            set;
        }

        /// <summary>
        /// Security state of the request resource.
        /// </summary>
        [JsonPropertyName("securityState")]
        public CefSharp.DevTools.Security.SecurityState SecurityState
        {
            get;
            set;
        }

        /// <summary>
        /// Security details for the request.
        /// </summary>
        [JsonPropertyName("securityDetails")]
        public CefSharp.DevTools.Network.SecurityDetails SecurityDetails
        {
            get;
            set;
        }
    }

    /// <summary>
    /// WebSocket request data.
    /// </summary>
    public partial class WebSocketRequest : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// HTTP request headers.
        /// </summary>
        [JsonPropertyName("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }
    }

    /// <summary>
    /// WebSocket response data.
    /// </summary>
    public partial class WebSocketResponse : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// HTTP response status code.
        /// </summary>
        [JsonPropertyName("status")]
        public int Status
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response status text.
        /// </summary>
        [JsonPropertyName("statusText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StatusText
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response headers.
        /// </summary>
        [JsonPropertyName("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP response headers text.
        /// </summary>
        [JsonPropertyName("headersText")]
        public string HeadersText
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request headers.
        /// </summary>
        [JsonPropertyName("requestHeaders")]
        public CefSharp.DevTools.Network.Headers RequestHeaders
        {
            get;
            set;
        }

        /// <summary>
        /// HTTP request headers text.
        /// </summary>
        [JsonPropertyName("requestHeadersText")]
        public string RequestHeadersText
        {
            get;
            set;
        }
    }

    /// <summary>
    /// WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
    /// </summary>
    public partial class WebSocketFrame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// WebSocket message opcode.
        /// </summary>
        [JsonPropertyName("opcode")]
        public double Opcode
        {
            get;
            set;
        }

        /// <summary>
        /// WebSocket message mask.
        /// </summary>
        [JsonPropertyName("mask")]
        public bool Mask
        {
            get;
            set;
        }

        /// <summary>
        /// WebSocket message payload data.
        /// If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
        /// If the opcode isn&apos;t 1, then payloadData is a base64 encoded string representing binary data.
        /// </summary>
        [JsonPropertyName("payloadData")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PayloadData
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about the cached resource.
    /// </summary>
    public partial class CachedResource : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Resource URL. This is the url of the original network request.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Type of this resource.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Network.ResourceType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Cached response data.
        /// </summary>
        [JsonPropertyName("response")]
        public CefSharp.DevTools.Network.Response Response
        {
            get;
            set;
        }

        /// <summary>
        /// Cached response body size.
        /// </summary>
        [JsonPropertyName("bodySize")]
        public double BodySize
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Type of this initiator.
    /// </summary>
    public enum InitiatorType
    {
        /// <summary>
        /// parser
        /// </summary>
        [JsonPropertyName("parser")]
        Parser,
        /// <summary>
        /// script
        /// </summary>
        [JsonPropertyName("script")]
        Script,
        /// <summary>
        /// preload
        /// </summary>
        [JsonPropertyName("preload")]
        Preload,
        /// <summary>
        /// SignedExchange
        /// </summary>
        [JsonPropertyName("SignedExchange")]
        SignedExchange,
        /// <summary>
        /// preflight
        /// </summary>
        [JsonPropertyName("preflight")]
        Preflight,
        /// <summary>
        /// other
        /// </summary>
        [JsonPropertyName("other")]
        Other
    }

    /// <summary>
    /// Information about the request initiator.
    /// </summary>
    public partial class Initiator : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Type of this initiator.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Network.InitiatorType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Initiator JavaScript stack trace, set for Script only.
        /// </summary>
        [JsonPropertyName("stack")]
        public CefSharp.DevTools.Runtime.StackTrace Stack
        {
            get;
            set;
        }

        /// <summary>
        /// Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
        /// </summary>
        [JsonPropertyName("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Initiator line number, set for Parser type or for Script type (when script is importing
        /// module) (0-based).
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public double? LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Initiator column number, set for Parser type or for Script type (when script is importing
        /// module) (0-based).
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public double? ColumnNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Set if another request triggered this request (e.g. preflight).
        /// </summary>
        [JsonPropertyName("requestId")]
        public string RequestId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Cookie object
    /// </summary>
    public partial class Cookie : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Cookie name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie value.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie domain.
        /// </summary>
        [JsonPropertyName("domain")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Domain
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie path.
        /// </summary>
        [JsonPropertyName("path")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Path
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie expiration date as the number of seconds since the UNIX epoch.
        /// </summary>
        [JsonPropertyName("expires")]
        public double Expires
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie size.
        /// </summary>
        [JsonPropertyName("size")]
        public int Size
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is http-only.
        /// </summary>
        [JsonPropertyName("httpOnly")]
        public bool HttpOnly
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is secure.
        /// </summary>
        [JsonPropertyName("secure")]
        public bool Secure
        {
            get;
            set;
        }

        /// <summary>
        /// True in case of session cookie.
        /// </summary>
        [JsonPropertyName("session")]
        public bool Session
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie SameSite type.
        /// </summary>
        [JsonPropertyName("sameSite")]
        public CefSharp.DevTools.Network.CookieSameSite? SameSite
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie Priority
        /// </summary>
        [JsonPropertyName("priority")]
        public CefSharp.DevTools.Network.CookiePriority Priority
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is SameParty.
        /// </summary>
        [JsonPropertyName("sameParty")]
        public bool SameParty
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie source scheme type.
        /// </summary>
        [JsonPropertyName("sourceScheme")]
        public CefSharp.DevTools.Network.CookieSourceScheme SourceScheme
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
        /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
        /// This is a temporary ability and it will be removed in the future.
        /// </summary>
        [JsonPropertyName("sourcePort")]
        public int SourcePort
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie partition key. The site of the top-level URL the browser was visiting at the start
        /// of the request to the endpoint that set the cookie.
        /// </summary>
        [JsonPropertyName("partitionKey")]
        public string PartitionKey
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie partition key is opaque.
        /// </summary>
        [JsonPropertyName("partitionKeyOpaque")]
        public bool? PartitionKeyOpaque
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Types of reasons why a cookie may not be stored from a response.
    /// </summary>
    public enum SetCookieBlockedReason
    {
        /// <summary>
        /// SecureOnly
        /// </summary>
        [JsonPropertyName("SecureOnly")]
        SecureOnly,
        /// <summary>
        /// SameSiteStrict
        /// </summary>
        [JsonPropertyName("SameSiteStrict")]
        SameSiteStrict,
        /// <summary>
        /// SameSiteLax
        /// </summary>
        [JsonPropertyName("SameSiteLax")]
        SameSiteLax,
        /// <summary>
        /// SameSiteUnspecifiedTreatedAsLax
        /// </summary>
        [JsonPropertyName("SameSiteUnspecifiedTreatedAsLax")]
        SameSiteUnspecifiedTreatedAsLax,
        /// <summary>
        /// SameSiteNoneInsecure
        /// </summary>
        [JsonPropertyName("SameSiteNoneInsecure")]
        SameSiteNoneInsecure,
        /// <summary>
        /// UserPreferences
        /// </summary>
        [JsonPropertyName("UserPreferences")]
        UserPreferences,
        /// <summary>
        /// ThirdPartyBlockedInFirstPartySet
        /// </summary>
        [JsonPropertyName("ThirdPartyBlockedInFirstPartySet")]
        ThirdPartyBlockedInFirstPartySet,
        /// <summary>
        /// SyntaxError
        /// </summary>
        [JsonPropertyName("SyntaxError")]
        SyntaxError,
        /// <summary>
        /// SchemeNotSupported
        /// </summary>
        [JsonPropertyName("SchemeNotSupported")]
        SchemeNotSupported,
        /// <summary>
        /// OverwriteSecure
        /// </summary>
        [JsonPropertyName("OverwriteSecure")]
        OverwriteSecure,
        /// <summary>
        /// InvalidDomain
        /// </summary>
        [JsonPropertyName("InvalidDomain")]
        InvalidDomain,
        /// <summary>
        /// InvalidPrefix
        /// </summary>
        [JsonPropertyName("InvalidPrefix")]
        InvalidPrefix,
        /// <summary>
        /// UnknownError
        /// </summary>
        [JsonPropertyName("UnknownError")]
        UnknownError,
        /// <summary>
        /// SchemefulSameSiteStrict
        /// </summary>
        [JsonPropertyName("SchemefulSameSiteStrict")]
        SchemefulSameSiteStrict,
        /// <summary>
        /// SchemefulSameSiteLax
        /// </summary>
        [JsonPropertyName("SchemefulSameSiteLax")]
        SchemefulSameSiteLax,
        /// <summary>
        /// SchemefulSameSiteUnspecifiedTreatedAsLax
        /// </summary>
        [JsonPropertyName("SchemefulSameSiteUnspecifiedTreatedAsLax")]
        SchemefulSameSiteUnspecifiedTreatedAsLax,
        /// <summary>
        /// SamePartyFromCrossPartyContext
        /// </summary>
        [JsonPropertyName("SamePartyFromCrossPartyContext")]
        SamePartyFromCrossPartyContext,
        /// <summary>
        /// SamePartyConflictsWithOtherAttributes
        /// </summary>
        [JsonPropertyName("SamePartyConflictsWithOtherAttributes")]
        SamePartyConflictsWithOtherAttributes,
        /// <summary>
        /// NameValuePairExceedsMaxSize
        /// </summary>
        [JsonPropertyName("NameValuePairExceedsMaxSize")]
        NameValuePairExceedsMaxSize
    }

    /// <summary>
    /// Types of reasons why a cookie may not be sent with a request.
    /// </summary>
    public enum CookieBlockedReason
    {
        /// <summary>
        /// SecureOnly
        /// </summary>
        [JsonPropertyName("SecureOnly")]
        SecureOnly,
        /// <summary>
        /// NotOnPath
        /// </summary>
        [JsonPropertyName("NotOnPath")]
        NotOnPath,
        /// <summary>
        /// DomainMismatch
        /// </summary>
        [JsonPropertyName("DomainMismatch")]
        DomainMismatch,
        /// <summary>
        /// SameSiteStrict
        /// </summary>
        [JsonPropertyName("SameSiteStrict")]
        SameSiteStrict,
        /// <summary>
        /// SameSiteLax
        /// </summary>
        [JsonPropertyName("SameSiteLax")]
        SameSiteLax,
        /// <summary>
        /// SameSiteUnspecifiedTreatedAsLax
        /// </summary>
        [JsonPropertyName("SameSiteUnspecifiedTreatedAsLax")]
        SameSiteUnspecifiedTreatedAsLax,
        /// <summary>
        /// SameSiteNoneInsecure
        /// </summary>
        [JsonPropertyName("SameSiteNoneInsecure")]
        SameSiteNoneInsecure,
        /// <summary>
        /// UserPreferences
        /// </summary>
        [JsonPropertyName("UserPreferences")]
        UserPreferences,
        /// <summary>
        /// ThirdPartyBlockedInFirstPartySet
        /// </summary>
        [JsonPropertyName("ThirdPartyBlockedInFirstPartySet")]
        ThirdPartyBlockedInFirstPartySet,
        /// <summary>
        /// UnknownError
        /// </summary>
        [JsonPropertyName("UnknownError")]
        UnknownError,
        /// <summary>
        /// SchemefulSameSiteStrict
        /// </summary>
        [JsonPropertyName("SchemefulSameSiteStrict")]
        SchemefulSameSiteStrict,
        /// <summary>
        /// SchemefulSameSiteLax
        /// </summary>
        [JsonPropertyName("SchemefulSameSiteLax")]
        SchemefulSameSiteLax,
        /// <summary>
        /// SchemefulSameSiteUnspecifiedTreatedAsLax
        /// </summary>
        [JsonPropertyName("SchemefulSameSiteUnspecifiedTreatedAsLax")]
        SchemefulSameSiteUnspecifiedTreatedAsLax,
        /// <summary>
        /// SamePartyFromCrossPartyContext
        /// </summary>
        [JsonPropertyName("SamePartyFromCrossPartyContext")]
        SamePartyFromCrossPartyContext,
        /// <summary>
        /// NameValuePairExceedsMaxSize
        /// </summary>
        [JsonPropertyName("NameValuePairExceedsMaxSize")]
        NameValuePairExceedsMaxSize
    }

    /// <summary>
    /// A cookie which was not stored from a response with the corresponding reason.
    /// </summary>
    public partial class BlockedSetCookieWithReason : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The reason(s) this cookie was blocked.
        /// </summary>
        [JsonPropertyName("blockedReasons")]
        public CefSharp.DevTools.Network.SetCookieBlockedReason[] BlockedReasons
        {
            get;
            set;
        }

        /// <summary>
        /// The string representing this individual cookie as it would appear in the header.
        /// This is not the entire &quot;cookie&quot; or &quot;set-cookie&quot; header which could have multiple cookies.
        /// </summary>
        [JsonPropertyName("cookieLine")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CookieLine
        {
            get;
            set;
        }

        /// <summary>
        /// The cookie object which represents the cookie which was not stored. It is optional because
        /// sometimes complete cookie information is not available, such as in the case of parsing
        /// errors.
        /// </summary>
        [JsonPropertyName("cookie")]
        public CefSharp.DevTools.Network.Cookie Cookie
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A cookie with was not sent with a request with the corresponding reason.
    /// </summary>
    public partial class BlockedCookieWithReason : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The reason(s) the cookie was blocked.
        /// </summary>
        [JsonPropertyName("blockedReasons")]
        public CefSharp.DevTools.Network.CookieBlockedReason[] BlockedReasons
        {
            get;
            set;
        }

        /// <summary>
        /// The cookie object representing the cookie which was not sent.
        /// </summary>
        [JsonPropertyName("cookie")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Cookie Cookie
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Cookie parameter object
    /// </summary>
    public partial class CookieParam : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Cookie name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie value.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// The request-URI to associate with the setting of the cookie. This value can affect the
        /// default domain, path, source port, and source scheme values of the created cookie.
        /// </summary>
        [JsonPropertyName("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie domain.
        /// </summary>
        [JsonPropertyName("domain")]
        public string Domain
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie path.
        /// </summary>
        [JsonPropertyName("path")]
        public string Path
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is secure.
        /// </summary>
        [JsonPropertyName("secure")]
        public bool? Secure
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is http-only.
        /// </summary>
        [JsonPropertyName("httpOnly")]
        public bool? HttpOnly
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie SameSite type.
        /// </summary>
        [JsonPropertyName("sameSite")]
        public CefSharp.DevTools.Network.CookieSameSite? SameSite
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie expiration date, session cookie if not set
        /// </summary>
        [JsonPropertyName("expires")]
        public double? Expires
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie Priority.
        /// </summary>
        [JsonPropertyName("priority")]
        public CefSharp.DevTools.Network.CookiePriority? Priority
        {
            get;
            set;
        }

        /// <summary>
        /// True if cookie is SameParty.
        /// </summary>
        [JsonPropertyName("sameParty")]
        public bool? SameParty
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie source scheme type.
        /// </summary>
        [JsonPropertyName("sourceScheme")]
        public CefSharp.DevTools.Network.CookieSourceScheme? SourceScheme
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
        /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
        /// This is a temporary ability and it will be removed in the future.
        /// </summary>
        [JsonPropertyName("sourcePort")]
        public int? SourcePort
        {
            get;
            set;
        }

        /// <summary>
        /// Cookie partition key. The site of the top-level URL the browser was visiting at the start
        /// of the request to the endpoint that set the cookie.
        /// If not set, the cookie will be set as not partitioned.
        /// </summary>
        [JsonPropertyName("partitionKey")]
        public string PartitionKey
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Source of the authentication challenge.
    /// </summary>
    public enum AuthChallengeSource
    {
        /// <summary>
        /// Server
        /// </summary>
        [JsonPropertyName("Server")]
        Server,
        /// <summary>
        /// Proxy
        /// </summary>
        [JsonPropertyName("Proxy")]
        Proxy
    }

    /// <summary>
    /// Authorization challenge for HTTP status code 401 or 407.
    /// </summary>
    public partial class AuthChallenge : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Source of the authentication challenge.
        /// </summary>
        [JsonPropertyName("source")]
        public CefSharp.DevTools.Network.AuthChallengeSource? Source
        {
            get;
            set;
        }

        /// <summary>
        /// Origin of the challenger.
        /// </summary>
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// The authentication scheme used, such as basic or digest
        /// </summary>
        [JsonPropertyName("scheme")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Scheme
        {
            get;
            set;
        }

        /// <summary>
        /// The realm of the challenge. May be empty.
        /// </summary>
        [JsonPropertyName("realm")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Realm
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The decision on what to do in response to the authorization challenge.  Default means
    /// deferring to the default behavior of the net stack, which will likely either the Cancel
    /// authentication or display a popup dialog box.
    /// </summary>
    public enum AuthChallengeResponseResponse
    {
        /// <summary>
        /// Default
        /// </summary>
        [JsonPropertyName("Default")]
        Default,
        /// <summary>
        /// CancelAuth
        /// </summary>
        [JsonPropertyName("CancelAuth")]
        CancelAuth,
        /// <summary>
        /// ProvideCredentials
        /// </summary>
        [JsonPropertyName("ProvideCredentials")]
        ProvideCredentials
    }

    /// <summary>
    /// Response to an AuthChallenge.
    /// </summary>
    public partial class AuthChallengeResponse : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The decision on what to do in response to the authorization challenge.  Default means
        /// deferring to the default behavior of the net stack, which will likely either the Cancel
        /// authentication or display a popup dialog box.
        /// </summary>
        [JsonPropertyName("response")]
        public CefSharp.DevTools.Network.AuthChallengeResponseResponse Response
        {
            get;
            set;
        }

        /// <summary>
        /// The username to provide, possibly empty. Should only be set if response is
        /// ProvideCredentials.
        /// </summary>
        [JsonPropertyName("username")]
        public string Username
        {
            get;
            set;
        }

        /// <summary>
        /// The password to provide, possibly empty. Should only be set if response is
        /// ProvideCredentials.
        /// </summary>
        [JsonPropertyName("password")]
        public string Password
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Stages of the interception to begin intercepting. Request will intercept before the request is
    /// sent. Response will intercept after the response is received.
    /// </summary>
    public enum InterceptionStage
    {
        /// <summary>
        /// Request
        /// </summary>
        [JsonPropertyName("Request")]
        Request,
        /// <summary>
        /// HeadersReceived
        /// </summary>
        [JsonPropertyName("HeadersReceived")]
        HeadersReceived
    }

    /// <summary>
    /// Request pattern for interception.
    /// </summary>
    public partial class RequestPattern : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Wildcards (`&apos;*&apos;` -&gt; zero or more, `&apos;?&apos;` -&gt; exactly one) are allowed. Escape character is
        /// backslash. Omitting is equivalent to `&quot;*&quot;`.
        /// </summary>
        [JsonPropertyName("urlPattern")]
        public string UrlPattern
        {
            get;
            set;
        }

        /// <summary>
        /// If set, only requests for matching resource types will be intercepted.
        /// </summary>
        [JsonPropertyName("resourceType")]
        public CefSharp.DevTools.Network.ResourceType? ResourceType
        {
            get;
            set;
        }

        /// <summary>
        /// Stage at which to begin intercepting requests. Default is Request.
        /// </summary>
        [JsonPropertyName("interceptionStage")]
        public CefSharp.DevTools.Network.InterceptionStage? InterceptionStage
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about a signed exchange signature.
    /// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
    /// </summary>
    public partial class SignedExchangeSignature : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Signed exchange signature label.
        /// </summary>
        [JsonPropertyName("label")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Label
        {
            get;
            set;
        }

        /// <summary>
        /// The hex string of signed exchange signature.
        /// </summary>
        [JsonPropertyName("signature")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Signature
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature integrity.
        /// </summary>
        [JsonPropertyName("integrity")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Integrity
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature cert Url.
        /// </summary>
        [JsonPropertyName("certUrl")]
        public string CertUrl
        {
            get;
            set;
        }

        /// <summary>
        /// The hex string of signed exchange signature cert sha256.
        /// </summary>
        [JsonPropertyName("certSha256")]
        public string CertSha256
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature validity Url.
        /// </summary>
        [JsonPropertyName("validityUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ValidityUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature date.
        /// </summary>
        [JsonPropertyName("date")]
        public int Date
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange signature expires.
        /// </summary>
        [JsonPropertyName("expires")]
        public int Expires
        {
            get;
            set;
        }

        /// <summary>
        /// The encoded certificates.
        /// </summary>
        [JsonPropertyName("certificates")]
        public string[] Certificates
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about a signed exchange header.
    /// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
    /// </summary>
    public partial class SignedExchangeHeader : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Signed exchange request URL.
        /// </summary>
        [JsonPropertyName("requestUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange response code.
        /// </summary>
        [JsonPropertyName("responseCode")]
        public int ResponseCode
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange response headers.
        /// </summary>
        [JsonPropertyName("responseHeaders")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers ResponseHeaders
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange response signature.
        /// </summary>
        [JsonPropertyName("signatures")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.SignedExchangeSignature> Signatures
        {
            get;
            set;
        }

        /// <summary>
        /// Signed exchange header integrity hash in the form of &quot;sha256-&lt;base64-hash-value&gt; &quot;.
        /// </summary>
        [JsonPropertyName("headerIntegrity")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string HeaderIntegrity
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Field type for a signed exchange related error.
    /// </summary>
    public enum SignedExchangeErrorField
    {
        /// <summary>
        /// signatureSig
        /// </summary>
        [JsonPropertyName("signatureSig")]
        SignatureSig,
        /// <summary>
        /// signatureIntegrity
        /// </summary>
        [JsonPropertyName("signatureIntegrity")]
        SignatureIntegrity,
        /// <summary>
        /// signatureCertUrl
        /// </summary>
        [JsonPropertyName("signatureCertUrl")]
        SignatureCertUrl,
        /// <summary>
        /// signatureCertSha256
        /// </summary>
        [JsonPropertyName("signatureCertSha256")]
        SignatureCertSha256,
        /// <summary>
        /// signatureValidityUrl
        /// </summary>
        [JsonPropertyName("signatureValidityUrl")]
        SignatureValidityUrl,
        /// <summary>
        /// signatureTimestamps
        /// </summary>
        [JsonPropertyName("signatureTimestamps")]
        SignatureTimestamps
    }

    /// <summary>
    /// Information about a signed exchange response.
    /// </summary>
    public partial class SignedExchangeError : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Error message.
        /// </summary>
        [JsonPropertyName("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            set;
        }

        /// <summary>
        /// The index of the signature which caused the error.
        /// </summary>
        [JsonPropertyName("signatureIndex")]
        public int? SignatureIndex
        {
            get;
            set;
        }

        /// <summary>
        /// The field which caused the error.
        /// </summary>
        [JsonPropertyName("errorField")]
        public CefSharp.DevTools.Network.SignedExchangeErrorField? ErrorField
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about a signed exchange response.
    /// </summary>
    public partial class SignedExchangeInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The outer response of signed HTTP exchange which was received from network.
        /// </summary>
        [JsonPropertyName("outerResponse")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Response OuterResponse
        {
            get;
            set;
        }

        /// <summary>
        /// Information about the signed exchange header.
        /// </summary>
        [JsonPropertyName("header")]
        public CefSharp.DevTools.Network.SignedExchangeHeader Header
        {
            get;
            set;
        }

        /// <summary>
        /// Security details for the signed exchange header.
        /// </summary>
        [JsonPropertyName("securityDetails")]
        public CefSharp.DevTools.Network.SecurityDetails SecurityDetails
        {
            get;
            set;
        }

        /// <summary>
        /// Errors occurred while handling the signed exchagne.
        /// </summary>
        [JsonPropertyName("errors")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.SignedExchangeError> Errors
        {
            get;
            set;
        }
    }

    /// <summary>
    /// List of content encodings supported by the backend.
    /// </summary>
    public enum ContentEncoding
    {
        /// <summary>
        /// deflate
        /// </summary>
        [JsonPropertyName("deflate")]
        Deflate,
        /// <summary>
        /// gzip
        /// </summary>
        [JsonPropertyName("gzip")]
        Gzip,
        /// <summary>
        /// br
        /// </summary>
        [JsonPropertyName("br")]
        Br
    }

    /// <summary>
    /// PrivateNetworkRequestPolicy
    /// </summary>
    public enum PrivateNetworkRequestPolicy
    {
        /// <summary>
        /// Allow
        /// </summary>
        [JsonPropertyName("Allow")]
        Allow,
        /// <summary>
        /// BlockFromInsecureToMorePrivate
        /// </summary>
        [JsonPropertyName("BlockFromInsecureToMorePrivate")]
        BlockFromInsecureToMorePrivate,
        /// <summary>
        /// WarnFromInsecureToMorePrivate
        /// </summary>
        [JsonPropertyName("WarnFromInsecureToMorePrivate")]
        WarnFromInsecureToMorePrivate,
        /// <summary>
        /// PreflightBlock
        /// </summary>
        [JsonPropertyName("PreflightBlock")]
        PreflightBlock,
        /// <summary>
        /// PreflightWarn
        /// </summary>
        [JsonPropertyName("PreflightWarn")]
        PreflightWarn
    }

    /// <summary>
    /// IPAddressSpace
    /// </summary>
    public enum IPAddressSpace
    {
        /// <summary>
        /// Local
        /// </summary>
        [JsonPropertyName("Local")]
        Local,
        /// <summary>
        /// Private
        /// </summary>
        [JsonPropertyName("Private")]
        Private,
        /// <summary>
        /// Public
        /// </summary>
        [JsonPropertyName("Public")]
        Public,
        /// <summary>
        /// Unknown
        /// </summary>
        [JsonPropertyName("Unknown")]
        Unknown
    }

    /// <summary>
    /// ConnectTiming
    /// </summary>
    public partial class ConnectTiming : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Timing&apos;s requestTime is a baseline in seconds, while the other numbers are ticks in
        /// milliseconds relatively to this requestTime. Matches ResourceTiming&apos;s requestTime for
        /// the same request (but not for redirected requests).
        /// </summary>
        [JsonPropertyName("requestTime")]
        public double RequestTime
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ClientSecurityState
    /// </summary>
    public partial class ClientSecurityState : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// InitiatorIsSecureContext
        /// </summary>
        [JsonPropertyName("initiatorIsSecureContext")]
        public bool InitiatorIsSecureContext
        {
            get;
            set;
        }

        /// <summary>
        /// InitiatorIPAddressSpace
        /// </summary>
        [JsonPropertyName("initiatorIPAddressSpace")]
        public CefSharp.DevTools.Network.IPAddressSpace InitiatorIPAddressSpace
        {
            get;
            set;
        }

        /// <summary>
        /// PrivateNetworkRequestPolicy
        /// </summary>
        [JsonPropertyName("privateNetworkRequestPolicy")]
        public CefSharp.DevTools.Network.PrivateNetworkRequestPolicy PrivateNetworkRequestPolicy
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CrossOriginOpenerPolicyValue
    /// </summary>
    public enum CrossOriginOpenerPolicyValue
    {
        /// <summary>
        /// SameOrigin
        /// </summary>
        [JsonPropertyName("SameOrigin")]
        SameOrigin,
        /// <summary>
        /// SameOriginAllowPopups
        /// </summary>
        [JsonPropertyName("SameOriginAllowPopups")]
        SameOriginAllowPopups,
        /// <summary>
        /// RestrictProperties
        /// </summary>
        [JsonPropertyName("RestrictProperties")]
        RestrictProperties,
        /// <summary>
        /// UnsafeNone
        /// </summary>
        [JsonPropertyName("UnsafeNone")]
        UnsafeNone,
        /// <summary>
        /// SameOriginPlusCoep
        /// </summary>
        [JsonPropertyName("SameOriginPlusCoep")]
        SameOriginPlusCoep,
        /// <summary>
        /// RestrictPropertiesPlusCoep
        /// </summary>
        [JsonPropertyName("RestrictPropertiesPlusCoep")]
        RestrictPropertiesPlusCoep
    }

    /// <summary>
    /// CrossOriginOpenerPolicyStatus
    /// </summary>
    public partial class CrossOriginOpenerPolicyStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        public CefSharp.DevTools.Network.CrossOriginOpenerPolicyValue Value
        {
            get;
            set;
        }

        /// <summary>
        /// ReportOnlyValue
        /// </summary>
        [JsonPropertyName("reportOnlyValue")]
        public CefSharp.DevTools.Network.CrossOriginOpenerPolicyValue ReportOnlyValue
        {
            get;
            set;
        }

        /// <summary>
        /// ReportingEndpoint
        /// </summary>
        [JsonPropertyName("reportingEndpoint")]
        public string ReportingEndpoint
        {
            get;
            set;
        }

        /// <summary>
        /// ReportOnlyReportingEndpoint
        /// </summary>
        [JsonPropertyName("reportOnlyReportingEndpoint")]
        public string ReportOnlyReportingEndpoint
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CrossOriginEmbedderPolicyValue
    /// </summary>
    public enum CrossOriginEmbedderPolicyValue
    {
        /// <summary>
        /// None
        /// </summary>
        [JsonPropertyName("None")]
        None,
        /// <summary>
        /// Credentialless
        /// </summary>
        [JsonPropertyName("Credentialless")]
        Credentialless,
        /// <summary>
        /// RequireCorp
        /// </summary>
        [JsonPropertyName("RequireCorp")]
        RequireCorp
    }

    /// <summary>
    /// CrossOriginEmbedderPolicyStatus
    /// </summary>
    public partial class CrossOriginEmbedderPolicyStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        public CefSharp.DevTools.Network.CrossOriginEmbedderPolicyValue Value
        {
            get;
            set;
        }

        /// <summary>
        /// ReportOnlyValue
        /// </summary>
        [JsonPropertyName("reportOnlyValue")]
        public CefSharp.DevTools.Network.CrossOriginEmbedderPolicyValue ReportOnlyValue
        {
            get;
            set;
        }

        /// <summary>
        /// ReportingEndpoint
        /// </summary>
        [JsonPropertyName("reportingEndpoint")]
        public string ReportingEndpoint
        {
            get;
            set;
        }

        /// <summary>
        /// ReportOnlyReportingEndpoint
        /// </summary>
        [JsonPropertyName("reportOnlyReportingEndpoint")]
        public string ReportOnlyReportingEndpoint
        {
            get;
            set;
        }
    }

    /// <summary>
    /// SecurityIsolationStatus
    /// </summary>
    public partial class SecurityIsolationStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Coop
        /// </summary>
        [JsonPropertyName("coop")]
        public CefSharp.DevTools.Network.CrossOriginOpenerPolicyStatus Coop
        {
            get;
            set;
        }

        /// <summary>
        /// Coep
        /// </summary>
        [JsonPropertyName("coep")]
        public CefSharp.DevTools.Network.CrossOriginEmbedderPolicyStatus Coep
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The status of a Reporting API report.
    /// </summary>
    public enum ReportStatus
    {
        /// <summary>
        /// Queued
        /// </summary>
        [JsonPropertyName("Queued")]
        Queued,
        /// <summary>
        /// Pending
        /// </summary>
        [JsonPropertyName("Pending")]
        Pending,
        /// <summary>
        /// MarkedForRemoval
        /// </summary>
        [JsonPropertyName("MarkedForRemoval")]
        MarkedForRemoval,
        /// <summary>
        /// Success
        /// </summary>
        [JsonPropertyName("Success")]
        Success
    }

    /// <summary>
    /// An object representing a report generated by the Reporting API.
    /// </summary>
    public partial class ReportingApiReport : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// The URL of the document that triggered the report.
        /// </summary>
        [JsonPropertyName("initiatorUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InitiatorUrl
        {
            get;
            set;
        }

        /// <summary>
        /// The name of the endpoint group that should be used to deliver the report.
        /// </summary>
        [JsonPropertyName("destination")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Destination
        {
            get;
            set;
        }

        /// <summary>
        /// The type of the report (specifies the set of data that is contained in the report body).
        /// </summary>
        [JsonPropertyName("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// When the report was generated.
        /// </summary>
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// How many uploads deep the related request was.
        /// </summary>
        [JsonPropertyName("depth")]
        public int Depth
        {
            get;
            set;
        }

        /// <summary>
        /// The number of delivery attempts made so far, not including an active attempt.
        /// </summary>
        [JsonPropertyName("completedAttempts")]
        public int CompletedAttempts
        {
            get;
            set;
        }

        /// <summary>
        /// Body
        /// </summary>
        [JsonPropertyName("body")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public object Body
        {
            get;
            set;
        }

        /// <summary>
        /// Status
        /// </summary>
        [JsonPropertyName("status")]
        public CefSharp.DevTools.Network.ReportStatus Status
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ReportingApiEndpoint
    /// </summary>
    public partial class ReportingApiEndpoint : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The URL of the endpoint to which reports may be delivered.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the endpoint group.
        /// </summary>
        [JsonPropertyName("groupName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string GroupName
        {
            get;
            set;
        }
    }

    /// <summary>
    /// An object providing the result of a network resource load.
    /// </summary>
    public partial class LoadNetworkResourcePageResult : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Success
        /// </summary>
        [JsonPropertyName("success")]
        public bool Success
        {
            get;
            set;
        }

        /// <summary>
        /// Optional values used for error reporting.
        /// </summary>
        [JsonPropertyName("netError")]
        public double? NetError
        {
            get;
            set;
        }

        /// <summary>
        /// NetErrorName
        /// </summary>
        [JsonPropertyName("netErrorName")]
        public string NetErrorName
        {
            get;
            set;
        }

        /// <summary>
        /// HttpStatusCode
        /// </summary>
        [JsonPropertyName("httpStatusCode")]
        public double? HttpStatusCode
        {
            get;
            set;
        }

        /// <summary>
        /// If successful, one of the following two fields holds the result.
        /// </summary>
        [JsonPropertyName("stream")]
        public string Stream
        {
            get;
            set;
        }

        /// <summary>
        /// Response headers.
        /// </summary>
        [JsonPropertyName("headers")]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            set;
        }
    }

    /// <summary>
    /// An options object that may be extended later to better support CORS,
    /// CORB and streaming.
    /// </summary>
    public partial class LoadNetworkResourceOptions : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// DisableCache
        /// </summary>
        [JsonPropertyName("disableCache")]
        public bool DisableCache
        {
            get;
            set;
        }

        /// <summary>
        /// IncludeCredentials
        /// </summary>
        [JsonPropertyName("includeCredentials")]
        public bool IncludeCredentials
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Fired when data chunk was received over the network.
    /// </summary>
    public class DataReceivedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Data chunk length.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("dataLength")]
        public int DataLength
        {
            get;
            private set;
        }

        /// <summary>
        /// Actual bytes received (might be less than dataLength for compressed encodings).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("encodedDataLength")]
        public int EncodedDataLength
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when EventSource message is received.
    /// </summary>
    public class EventSourceMessageReceivedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Message type.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("eventName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string EventName
        {
            get;
            private set;
        }

        /// <summary>
        /// Message identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("eventId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string EventId
        {
            get;
            private set;
        }

        /// <summary>
        /// Message content.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Data
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when HTTP request has failed to load.
    /// </summary>
    public class LoadingFailedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Resource type.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Network.ResourceType Type
        {
            get;
            private set;
        }

        /// <summary>
        /// User friendly error message.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errorText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorText
        {
            get;
            private set;
        }

        /// <summary>
        /// True if loading was canceled.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("canceled")]
        public bool? Canceled
        {
            get;
            private set;
        }

        /// <summary>
        /// The reason why loading was blocked, if any.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("blockedReason")]
        public CefSharp.DevTools.Network.BlockedReason? BlockedReason
        {
            get;
            private set;
        }

        /// <summary>
        /// The reason why loading was blocked by CORS, if any.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("corsErrorStatus")]
        public CefSharp.DevTools.Network.CorsErrorStatus CorsErrorStatus
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when HTTP request has finished loading.
    /// </summary>
    public class LoadingFinishedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Total number of bytes received for this request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("encodedDataLength")]
        public double EncodedDataLength
        {
            get;
            private set;
        }

        /// <summary>
        /// Set when 1) response was blocked by Cross-Origin Read Blocking and also
        /// 2) this needs to be reported to the DevTools console.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("shouldReportCorbBlocking")]
        public bool? ShouldReportCorbBlocking
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    /// mocked.
    /// Deprecated, use Fetch.requestPaused instead.
    /// </summary>
    public class RequestInterceptedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Each request the page makes will have a unique id, however if any redirects are encountered
        /// while processing that fetch, they will be reported with the same id as the original fetch.
        /// Likewise if HTTP authentication is needed then the same fetch id will be used.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("interceptionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InterceptionId
        {
            get;
            private set;
        }

        /// <summary>
        /// Request
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("request")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Request Request
        {
            get;
            private set;
        }

        /// <summary>
        /// The id of the frame that initiated the request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// How the requested resource will be used.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("resourceType")]
        public CefSharp.DevTools.Network.ResourceType ResourceType
        {
            get;
            private set;
        }

        /// <summary>
        /// Whether this is a navigation request, which can abort the navigation completely.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("isNavigationRequest")]
        public bool IsNavigationRequest
        {
            get;
            private set;
        }

        /// <summary>
        /// Set if the request is a navigation that will result in a download.
        /// Only present after response is received from the server (i.e. HeadersReceived stage).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("isDownload")]
        public bool? IsDownload
        {
            get;
            private set;
        }

        /// <summary>
        /// Redirect location, only sent if a redirect was intercepted.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("redirectUrl")]
        public string RedirectUrl
        {
            get;
            private set;
        }

        /// <summary>
        /// Details of the Authorization Challenge encountered. If this is set then
        /// continueInterceptedRequest must contain an authChallengeResponse.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("authChallenge")]
        public CefSharp.DevTools.Network.AuthChallenge AuthChallenge
        {
            get;
            private set;
        }

        /// <summary>
        /// Response error if intercepted at response stage or if redirect occurred while intercepting
        /// request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("responseErrorReason")]
        public CefSharp.DevTools.Network.ErrorReason? ResponseErrorReason
        {
            get;
            private set;
        }

        /// <summary>
        /// Response code if intercepted at response stage or if redirect occurred while intercepting
        /// request or auth retry occurred.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("responseStatusCode")]
        public int? ResponseStatusCode
        {
            get;
            private set;
        }

        /// <summary>
        /// Response headers if intercepted at the response stage or if redirect occurred while
        /// intercepting request or auth retry occurred.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("responseHeaders")]
        public CefSharp.DevTools.Network.Headers ResponseHeaders
        {
            get;
            private set;
        }

        /// <summary>
        /// If the intercepted request had a corresponding requestWillBeSent event fired for it, then
        /// this requestId will be the same as the requestId present in the requestWillBeSent event.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        public string RequestId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired if request ended up loading from cache.
    /// </summary>
    public class RequestServedFromCacheEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when page is about to send HTTP request.
    /// </summary>
    public class RequestWillBeSentEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Loader identifier. Empty string if the request is fetched from worker.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            private set;
        }

        /// <summary>
        /// URL of the document this request is loaded for.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("documentURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DocumentURL
        {
            get;
            private set;
        }

        /// <summary>
        /// Request data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("request")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Request Request
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("wallTime")]
        public double WallTime
        {
            get;
            private set;
        }

        /// <summary>
        /// Request initiator.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("initiator")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Initiator Initiator
        {
            get;
            private set;
        }

        /// <summary>
        /// In the case that redirectResponse is populated, this flag indicates whether
        /// requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted
        /// for the request which was just redirected.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("redirectHasExtraInfo")]
        public bool RedirectHasExtraInfo
        {
            get;
            private set;
        }

        /// <summary>
        /// Redirect response data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("redirectResponse")]
        public CefSharp.DevTools.Network.Response RedirectResponse
        {
            get;
            private set;
        }

        /// <summary>
        /// Type of this resource.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Network.ResourceType? Type
        {
            get;
            private set;
        }

        /// <summary>
        /// Frame identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Whether the request is initiated by a user gesture. Defaults to false.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hasUserGesture")]
        public bool? HasUserGesture
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when resource loading priority is changed
    /// </summary>
    public class ResourceChangedPriorityEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// New priority
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("newPriority")]
        public CefSharp.DevTools.Network.ResourcePriority NewPriority
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a signed exchange was received over the network
    /// </summary>
    public class SignedExchangeReceivedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Information about the signed exchange response.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("info")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.SignedExchangeInfo Info
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when HTTP response is available.
    /// </summary>
    public class ResponseReceivedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Loader identifier. Empty string if the request is fetched from worker.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Resource type.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Network.ResourceType Type
        {
            get;
            private set;
        }

        /// <summary>
        /// Response data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("response")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Response Response
        {
            get;
            private set;
        }

        /// <summary>
        /// Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be
        /// or were emitted for this request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hasExtraInfo")]
        public bool HasExtraInfo
        {
            get;
            private set;
        }

        /// <summary>
        /// Frame identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        public string FrameId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when WebSocket is closed.
    /// </summary>
    public class WebSocketClosedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired upon WebSocket creation.
    /// </summary>
    public class WebSocketCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// WebSocket request URL.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Request initiator.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("initiator")]
        public CefSharp.DevTools.Network.Initiator Initiator
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when WebSocket message error occurs.
    /// </summary>
    public class WebSocketFrameErrorEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// WebSocket error message.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errorMessage")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorMessage
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when WebSocket message is received.
    /// </summary>
    public class WebSocketFrameReceivedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// WebSocket response data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("response")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.WebSocketFrame Response
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when WebSocket message is sent.
    /// </summary>
    public class WebSocketFrameSentEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// WebSocket response data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("response")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.WebSocketFrame Response
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when WebSocket handshake response becomes available.
    /// </summary>
    public class WebSocketHandshakeResponseReceivedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// WebSocket response data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("response")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.WebSocketResponse Response
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when WebSocket is about to initiate handshake.
    /// </summary>
    public class WebSocketWillSendHandshakeRequestEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// UTC Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("wallTime")]
        public double WallTime
        {
            get;
            private set;
        }

        /// <summary>
        /// WebSocket request data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("request")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.WebSocketRequest Request
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired upon WebTransport creation.
    /// </summary>
    public class WebTransportCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// WebTransport identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("transportId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TransportId
        {
            get;
            private set;
        }

        /// <summary>
        /// WebTransport request URL.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Request initiator.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("initiator")]
        public CefSharp.DevTools.Network.Initiator Initiator
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when WebTransport handshake is finished.
    /// </summary>
    public class WebTransportConnectionEstablishedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// WebTransport identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("transportId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TransportId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when WebTransport is disposed.
    /// </summary>
    public class WebTransportClosedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// WebTransport identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("transportId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TransportId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when additional information about a requestWillBeSent event is available from the
    /// network stack. Not every requestWillBeSent event will have an additional
    /// requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
    /// or requestWillBeSentExtraInfo will be fired first for the same request.
    /// </summary>
    public class RequestWillBeSentExtraInfoEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier. Used to match this information to an existing requestWillBeSent event.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// A list of cookies potentially associated to the requested URL. This includes both cookies sent with
        /// the request and the ones not sent; the latter are distinguished by having blockedReason field set.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("associatedCookies")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.BlockedCookieWithReason> AssociatedCookies
        {
            get;
            private set;
        }

        /// <summary>
        /// Raw request headers as they will be sent over the wire.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            private set;
        }

        /// <summary>
        /// Connection timing information for the request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("connectTiming")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.ConnectTiming ConnectTiming
        {
            get;
            private set;
        }

        /// <summary>
        /// The client security state set for the request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("clientSecurityState")]
        public CefSharp.DevTools.Network.ClientSecurityState ClientSecurityState
        {
            get;
            private set;
        }

        /// <summary>
        /// Whether the site has partitioned cookies stored in a partition different than the current one.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("siteHasCookieInOtherPartition")]
        public bool? SiteHasCookieInOtherPartition
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when additional information about a responseReceived event is available from the network
    /// stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
    /// it, and responseReceivedExtraInfo may be fired before or after responseReceived.
    /// </summary>
    public class ResponseReceivedExtraInfoEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier. Used to match this information to another responseReceived event.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// A list of cookies which were not stored from the response along with the corresponding
        /// reasons for blocking. The cookies here may not be valid due to syntax errors, which
        /// are represented by the invalid cookie line string instead of a proper cookie.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("blockedCookies")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.BlockedSetCookieWithReason> BlockedCookies
        {
            get;
            private set;
        }

        /// <summary>
        /// Raw response headers as they were received over the wire.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("headers")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Headers Headers
        {
            get;
            private set;
        }

        /// <summary>
        /// The IP address space of the resource. The address space can only be determined once the transport
        /// established the connection, so we can&apos;t send it in `requestWillBeSentExtraInfo`.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("resourceIPAddressSpace")]
        public CefSharp.DevTools.Network.IPAddressSpace ResourceIPAddressSpace
        {
            get;
            private set;
        }

        /// <summary>
        /// The status code of the response. This is useful in cases the request failed and no responseReceived
        /// event is triggered, which is the case for, e.g., CORS errors. This is also the correct status code
        /// for cached requests, where the status in responseReceived is a 200 and this will be 304.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("statusCode")]
        public int StatusCode
        {
            get;
            private set;
        }

        /// <summary>
        /// Raw response header text as it was received over the wire. The raw text may not always be
        /// available, such as in the case of HTTP/2 or QUIC.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("headersText")]
        public string HeadersText
        {
            get;
            private set;
        }

        /// <summary>
        /// The cookie partition key that will be used to store partitioned cookies set in this response.
        /// Only sent when partitioned cookies are enabled.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cookiePartitionKey")]
        public string CookiePartitionKey
        {
            get;
            private set;
        }

        /// <summary>
        /// True if partitioned cookies are enabled, but the partition key is not serializeable to string.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cookiePartitionKeyOpaque")]
        public bool? CookiePartitionKeyOpaque
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Detailed success or error status of the operation.
    /// &apos;AlreadyExists&apos; also signifies a successful operation, as the result
    /// of the operation already exists und thus, the operation was abort
    /// preemptively (e.g. a cache hit).
    /// </summary>
    public enum TrustTokenOperationDoneStatus
    {
        /// <summary>
        /// Ok
        /// </summary>
        [JsonPropertyName("Ok")]
        Ok,
        /// <summary>
        /// InvalidArgument
        /// </summary>
        [JsonPropertyName("InvalidArgument")]
        InvalidArgument,
        /// <summary>
        /// FailedPrecondition
        /// </summary>
        [JsonPropertyName("FailedPrecondition")]
        FailedPrecondition,
        /// <summary>
        /// ResourceExhausted
        /// </summary>
        [JsonPropertyName("ResourceExhausted")]
        ResourceExhausted,
        /// <summary>
        /// AlreadyExists
        /// </summary>
        [JsonPropertyName("AlreadyExists")]
        AlreadyExists,
        /// <summary>
        /// Unavailable
        /// </summary>
        [JsonPropertyName("Unavailable")]
        Unavailable,
        /// <summary>
        /// Unauthorized
        /// </summary>
        [JsonPropertyName("Unauthorized")]
        Unauthorized,
        /// <summary>
        /// BadResponse
        /// </summary>
        [JsonPropertyName("BadResponse")]
        BadResponse,
        /// <summary>
        /// InternalError
        /// </summary>
        [JsonPropertyName("InternalError")]
        InternalError,
        /// <summary>
        /// UnknownError
        /// </summary>
        [JsonPropertyName("UnknownError")]
        UnknownError,
        /// <summary>
        /// FulfilledLocally
        /// </summary>
        [JsonPropertyName("FulfilledLocally")]
        FulfilledLocally
    }

    /// <summary>
    /// Fired exactly once for each Trust Token operation. Depending on
    /// the type of the operation and whether the operation succeeded or
    /// failed, the event is fired before the corresponding request was sent
    /// or after the response was received.
    /// </summary>
    public class TrustTokenOperationDoneEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Detailed success or error status of the operation.
        /// &apos;AlreadyExists&apos; also signifies a successful operation, as the result
        /// of the operation already exists und thus, the operation was abort
        /// preemptively (e.g. a cache hit).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("status")]
        public CefSharp.DevTools.Network.TrustTokenOperationDoneStatus Status
        {
            get;
            private set;
        }

        /// <summary>
        /// Type
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Network.TrustTokenOperationType Type
        {
            get;
            private set;
        }

        /// <summary>
        /// RequestId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Top level origin. The context in which the operation was attempted.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("topLevelOrigin")]
        public string TopLevelOrigin
        {
            get;
            private set;
        }

        /// <summary>
        /// Origin of the issuer in case of a &quot;Issuance&quot; or &quot;Redemption&quot; operation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("issuerOrigin")]
        public string IssuerOrigin
        {
            get;
            private set;
        }

        /// <summary>
        /// The number of obtained Trust Tokens on a successful &quot;Issuance&quot; operation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("issuedTokenCount")]
        public int? IssuedTokenCount
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired once when parsing the .wbn file has succeeded.
    /// The event contains the information about the web bundle contents.
    /// </summary>
    public class SubresourceWebBundleMetadataReceivedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier. Used to match this information to another event.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// A list of URLs of resources in the subresource Web Bundle.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("urls")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Urls
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired once when parsing the .wbn file has failed.
    /// </summary>
    public class SubresourceWebBundleMetadataErrorEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier. Used to match this information to another event.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// Error message
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errorMessage")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorMessage
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when handling requests for resources within a .wbn file.
    /// Note: this will only be fired for resources that are requested by the webpage.
    /// </summary>
    public class SubresourceWebBundleInnerResponseParsedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier of the subresource request
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("innerRequestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InnerRequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// URL of the subresource resource.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("innerRequestURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InnerRequestURL
        {
            get;
            private set;
        }

        /// <summary>
        /// Bundle request identifier. Used to match this information to another event.
        /// This made be absent in case when the instrumentation was enabled only
        /// after webbundle was parsed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("bundleRequestId")]
        public string BundleRequestId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when request for resources within a .wbn file failed.
    /// </summary>
    public class SubresourceWebBundleInnerResponseErrorEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Request identifier of the subresource request
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("innerRequestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InnerRequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// URL of the subresource resource.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("innerRequestURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InnerRequestURL
        {
            get;
            private set;
        }

        /// <summary>
        /// Error message
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errorMessage")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorMessage
        {
            get;
            private set;
        }

        /// <summary>
        /// Bundle request identifier. Used to match this information to another event.
        /// This made be absent in case when the instrumentation was enabled only
        /// after webbundle was parsed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("bundleRequestId")]
        public string BundleRequestId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Is sent whenever a new report is added.
    /// And after &apos;enableReportingApi&apos; for all existing reports.
    /// </summary>
    public class ReportingApiReportAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Report
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("report")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.ReportingApiReport Report
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// reportingApiReportUpdated
    /// </summary>
    public class ReportingApiReportUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Report
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("report")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.ReportingApiReport Report
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// reportingApiEndpointsChangedForOrigin
    /// </summary>
    public class ReportingApiEndpointsChangedForOriginEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Origin of the document(s) which configured the endpoints.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            private set;
        }

        /// <summary>
        /// Endpoints
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("endpoints")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.ReportingApiEndpoint> Endpoints
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// Configuration data for drawing the source order of an elements children.
    /// </summary>
    public partial class SourceOrderConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// the color to outline the givent element in.
        /// </summary>
        [JsonPropertyName("parentOutlineColor")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.RGBA ParentOutlineColor
        {
            get;
            set;
        }

        /// <summary>
        /// the color to outline the child elements in.
        /// </summary>
        [JsonPropertyName("childOutlineColor")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.RGBA ChildOutlineColor
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Configuration data for the highlighting of Grid elements.
    /// </summary>
    public partial class GridHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Whether the extension lines from grid cells to the rulers should be shown (default: false).
        /// </summary>
        [JsonPropertyName("showGridExtensionLines")]
        public bool? ShowGridExtensionLines
        {
            get;
            set;
        }

        /// <summary>
        /// Show Positive line number labels (default: false).
        /// </summary>
        [JsonPropertyName("showPositiveLineNumbers")]
        public bool? ShowPositiveLineNumbers
        {
            get;
            set;
        }

        /// <summary>
        /// Show Negative line number labels (default: false).
        /// </summary>
        [JsonPropertyName("showNegativeLineNumbers")]
        public bool? ShowNegativeLineNumbers
        {
            get;
            set;
        }

        /// <summary>
        /// Show area name labels (default: false).
        /// </summary>
        [JsonPropertyName("showAreaNames")]
        public bool? ShowAreaNames
        {
            get;
            set;
        }

        /// <summary>
        /// Show line name labels (default: false).
        /// </summary>
        [JsonPropertyName("showLineNames")]
        public bool? ShowLineNames
        {
            get;
            set;
        }

        /// <summary>
        /// Show track size labels (default: false).
        /// </summary>
        [JsonPropertyName("showTrackSizes")]
        public bool? ShowTrackSizes
        {
            get;
            set;
        }

        /// <summary>
        /// The grid container border highlight color (default: transparent).
        /// </summary>
        [JsonPropertyName("gridBorderColor")]
        public CefSharp.DevTools.DOM.RGBA GridBorderColor
        {
            get;
            set;
        }

        /// <summary>
        /// The cell border color (default: transparent). Deprecated, please use rowLineColor and columnLineColor instead.
        /// </summary>
        [JsonPropertyName("cellBorderColor")]
        public CefSharp.DevTools.DOM.RGBA CellBorderColor
        {
            get;
            set;
        }

        /// <summary>
        /// The row line color (default: transparent).
        /// </summary>
        [JsonPropertyName("rowLineColor")]
        public CefSharp.DevTools.DOM.RGBA RowLineColor
        {
            get;
            set;
        }

        /// <summary>
        /// The column line color (default: transparent).
        /// </summary>
        [JsonPropertyName("columnLineColor")]
        public CefSharp.DevTools.DOM.RGBA ColumnLineColor
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the grid border is dashed (default: false).
        /// </summary>
        [JsonPropertyName("gridBorderDash")]
        public bool? GridBorderDash
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the cell border is dashed (default: false). Deprecated, please us rowLineDash and columnLineDash instead.
        /// </summary>
        [JsonPropertyName("cellBorderDash")]
        public bool? CellBorderDash
        {
            get;
            set;
        }

        /// <summary>
        /// Whether row lines are dashed (default: false).
        /// </summary>
        [JsonPropertyName("rowLineDash")]
        public bool? RowLineDash
        {
            get;
            set;
        }

        /// <summary>
        /// Whether column lines are dashed (default: false).
        /// </summary>
        [JsonPropertyName("columnLineDash")]
        public bool? ColumnLineDash
        {
            get;
            set;
        }

        /// <summary>
        /// The row gap highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("rowGapColor")]
        public CefSharp.DevTools.DOM.RGBA RowGapColor
        {
            get;
            set;
        }

        /// <summary>
        /// The row gap hatching fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("rowHatchColor")]
        public CefSharp.DevTools.DOM.RGBA RowHatchColor
        {
            get;
            set;
        }

        /// <summary>
        /// The column gap highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("columnGapColor")]
        public CefSharp.DevTools.DOM.RGBA ColumnGapColor
        {
            get;
            set;
        }

        /// <summary>
        /// The column gap hatching fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("columnHatchColor")]
        public CefSharp.DevTools.DOM.RGBA ColumnHatchColor
        {
            get;
            set;
        }

        /// <summary>
        /// The named grid areas border color (Default: transparent).
        /// </summary>
        [JsonPropertyName("areaBorderColor")]
        public CefSharp.DevTools.DOM.RGBA AreaBorderColor
        {
            get;
            set;
        }

        /// <summary>
        /// The grid container background color (Default: transparent).
        /// </summary>
        [JsonPropertyName("gridBackgroundColor")]
        public CefSharp.DevTools.DOM.RGBA GridBackgroundColor
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Configuration data for the highlighting of Flex container elements.
    /// </summary>
    public partial class FlexContainerHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The style of the container border
        /// </summary>
        [JsonPropertyName("containerBorder")]
        public CefSharp.DevTools.Overlay.LineStyle ContainerBorder
        {
            get;
            set;
        }

        /// <summary>
        /// The style of the separator between lines
        /// </summary>
        [JsonPropertyName("lineSeparator")]
        public CefSharp.DevTools.Overlay.LineStyle LineSeparator
        {
            get;
            set;
        }

        /// <summary>
        /// The style of the separator between items
        /// </summary>
        [JsonPropertyName("itemSeparator")]
        public CefSharp.DevTools.Overlay.LineStyle ItemSeparator
        {
            get;
            set;
        }

        /// <summary>
        /// Style of content-distribution space on the main axis (justify-content).
        /// </summary>
        [JsonPropertyName("mainDistributedSpace")]
        public CefSharp.DevTools.Overlay.BoxStyle MainDistributedSpace
        {
            get;
            set;
        }

        /// <summary>
        /// Style of content-distribution space on the cross axis (align-content).
        /// </summary>
        [JsonPropertyName("crossDistributedSpace")]
        public CefSharp.DevTools.Overlay.BoxStyle CrossDistributedSpace
        {
            get;
            set;
        }

        /// <summary>
        /// Style of empty space caused by row gaps (gap/row-gap).
        /// </summary>
        [JsonPropertyName("rowGapSpace")]
        public CefSharp.DevTools.Overlay.BoxStyle RowGapSpace
        {
            get;
            set;
        }

        /// <summary>
        /// Style of empty space caused by columns gaps (gap/column-gap).
        /// </summary>
        [JsonPropertyName("columnGapSpace")]
        public CefSharp.DevTools.Overlay.BoxStyle ColumnGapSpace
        {
            get;
            set;
        }

        /// <summary>
        /// Style of the self-alignment line (align-items).
        /// </summary>
        [JsonPropertyName("crossAlignment")]
        public CefSharp.DevTools.Overlay.LineStyle CrossAlignment
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Configuration data for the highlighting of Flex item elements.
    /// </summary>
    public partial class FlexItemHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Style of the box representing the item&apos;s base size
        /// </summary>
        [JsonPropertyName("baseSizeBox")]
        public CefSharp.DevTools.Overlay.BoxStyle BaseSizeBox
        {
            get;
            set;
        }

        /// <summary>
        /// Style of the border around the box representing the item&apos;s base size
        /// </summary>
        [JsonPropertyName("baseSizeBorder")]
        public CefSharp.DevTools.Overlay.LineStyle BaseSizeBorder
        {
            get;
            set;
        }

        /// <summary>
        /// Style of the arrow representing if the item grew or shrank
        /// </summary>
        [JsonPropertyName("flexibilityArrow")]
        public CefSharp.DevTools.Overlay.LineStyle FlexibilityArrow
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The line pattern (default: solid)
    /// </summary>
    public enum LineStylePattern
    {
        /// <summary>
        /// dashed
        /// </summary>
        [JsonPropertyName("dashed")]
        Dashed,
        /// <summary>
        /// dotted
        /// </summary>
        [JsonPropertyName("dotted")]
        Dotted
    }

    /// <summary>
    /// Style information for drawing a line.
    /// </summary>
    public partial class LineStyle : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The color of the line (default: transparent)
        /// </summary>
        [JsonPropertyName("color")]
        public CefSharp.DevTools.DOM.RGBA Color
        {
            get;
            set;
        }

        /// <summary>
        /// The line pattern (default: solid)
        /// </summary>
        [JsonPropertyName("pattern")]
        public CefSharp.DevTools.Overlay.LineStylePattern? Pattern
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Style information for drawing a box.
    /// </summary>
    public partial class BoxStyle : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The background color for the box (default: transparent)
        /// </summary>
        [JsonPropertyName("fillColor")]
        public CefSharp.DevTools.DOM.RGBA FillColor
        {
            get;
            set;
        }

        /// <summary>
        /// The hatching color for the box (default: transparent)
        /// </summary>
        [JsonPropertyName("hatchColor")]
        public CefSharp.DevTools.DOM.RGBA HatchColor
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ContrastAlgorithm
    /// </summary>
    public enum ContrastAlgorithm
    {
        /// <summary>
        /// aa
        /// </summary>
        [JsonPropertyName("aa")]
        Aa,
        /// <summary>
        /// aaa
        /// </summary>
        [JsonPropertyName("aaa")]
        Aaa,
        /// <summary>
        /// apca
        /// </summary>
        [JsonPropertyName("apca")]
        Apca
    }

    /// <summary>
    /// Configuration data for the highlighting of page elements.
    /// </summary>
    public partial class HighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Whether the node info tooltip should be shown (default: false).
        /// </summary>
        [JsonPropertyName("showInfo")]
        public bool? ShowInfo
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the node styles in the tooltip (default: false).
        /// </summary>
        [JsonPropertyName("showStyles")]
        public bool? ShowStyles
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the rulers should be shown (default: false).
        /// </summary>
        [JsonPropertyName("showRulers")]
        public bool? ShowRulers
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the a11y info should be shown (default: true).
        /// </summary>
        [JsonPropertyName("showAccessibilityInfo")]
        public bool? ShowAccessibilityInfo
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the extension lines from node to the rulers should be shown (default: false).
        /// </summary>
        [JsonPropertyName("showExtensionLines")]
        public bool? ShowExtensionLines
        {
            get;
            set;
        }

        /// <summary>
        /// The content box highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("contentColor")]
        public CefSharp.DevTools.DOM.RGBA ContentColor
        {
            get;
            set;
        }

        /// <summary>
        /// The padding highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("paddingColor")]
        public CefSharp.DevTools.DOM.RGBA PaddingColor
        {
            get;
            set;
        }

        /// <summary>
        /// The border highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("borderColor")]
        public CefSharp.DevTools.DOM.RGBA BorderColor
        {
            get;
            set;
        }

        /// <summary>
        /// The margin highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("marginColor")]
        public CefSharp.DevTools.DOM.RGBA MarginColor
        {
            get;
            set;
        }

        /// <summary>
        /// The event target element highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("eventTargetColor")]
        public CefSharp.DevTools.DOM.RGBA EventTargetColor
        {
            get;
            set;
        }

        /// <summary>
        /// The shape outside fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("shapeColor")]
        public CefSharp.DevTools.DOM.RGBA ShapeColor
        {
            get;
            set;
        }

        /// <summary>
        /// The shape margin fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("shapeMarginColor")]
        public CefSharp.DevTools.DOM.RGBA ShapeMarginColor
        {
            get;
            set;
        }

        /// <summary>
        /// The grid layout color (default: transparent).
        /// </summary>
        [JsonPropertyName("cssGridColor")]
        public CefSharp.DevTools.DOM.RGBA CssGridColor
        {
            get;
            set;
        }

        /// <summary>
        /// The color format used to format color styles (default: hex).
        /// </summary>
        [JsonPropertyName("colorFormat")]
        public CefSharp.DevTools.Overlay.ColorFormat? ColorFormat
        {
            get;
            set;
        }

        /// <summary>
        /// The grid layout highlight configuration (default: all transparent).
        /// </summary>
        [JsonPropertyName("gridHighlightConfig")]
        public CefSharp.DevTools.Overlay.GridHighlightConfig GridHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// The flex container highlight configuration (default: all transparent).
        /// </summary>
        [JsonPropertyName("flexContainerHighlightConfig")]
        public CefSharp.DevTools.Overlay.FlexContainerHighlightConfig FlexContainerHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// The flex item highlight configuration (default: all transparent).
        /// </summary>
        [JsonPropertyName("flexItemHighlightConfig")]
        public CefSharp.DevTools.Overlay.FlexItemHighlightConfig FlexItemHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// The contrast algorithm to use for the contrast ratio (default: aa).
        /// </summary>
        [JsonPropertyName("contrastAlgorithm")]
        public CefSharp.DevTools.Overlay.ContrastAlgorithm? ContrastAlgorithm
        {
            get;
            set;
        }

        /// <summary>
        /// The container query container highlight configuration (default: all transparent).
        /// </summary>
        [JsonPropertyName("containerQueryContainerHighlightConfig")]
        public CefSharp.DevTools.Overlay.ContainerQueryContainerHighlightConfig ContainerQueryContainerHighlightConfig
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ColorFormat
    /// </summary>
    public enum ColorFormat
    {
        /// <summary>
        /// rgb
        /// </summary>
        [JsonPropertyName("rgb")]
        Rgb,
        /// <summary>
        /// hsl
        /// </summary>
        [JsonPropertyName("hsl")]
        Hsl,
        /// <summary>
        /// hwb
        /// </summary>
        [JsonPropertyName("hwb")]
        Hwb,
        /// <summary>
        /// hex
        /// </summary>
        [JsonPropertyName("hex")]
        Hex
    }

    /// <summary>
    /// Configurations for Persistent Grid Highlight
    /// </summary>
    public partial class GridNodeHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// A descriptor for the highlight appearance.
        /// </summary>
        [JsonPropertyName("gridHighlightConfig")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Overlay.GridHighlightConfig GridHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the node to highlight.
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// FlexNodeHighlightConfig
    /// </summary>
    public partial class FlexNodeHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// A descriptor for the highlight appearance of flex containers.
        /// </summary>
        [JsonPropertyName("flexContainerHighlightConfig")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Overlay.FlexContainerHighlightConfig FlexContainerHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the node to highlight.
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ScrollSnapContainerHighlightConfig
    /// </summary>
    public partial class ScrollSnapContainerHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The style of the snapport border (default: transparent)
        /// </summary>
        [JsonPropertyName("snapportBorder")]
        public CefSharp.DevTools.Overlay.LineStyle SnapportBorder
        {
            get;
            set;
        }

        /// <summary>
        /// The style of the snap area border (default: transparent)
        /// </summary>
        [JsonPropertyName("snapAreaBorder")]
        public CefSharp.DevTools.Overlay.LineStyle SnapAreaBorder
        {
            get;
            set;
        }

        /// <summary>
        /// The margin highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("scrollMarginColor")]
        public CefSharp.DevTools.DOM.RGBA ScrollMarginColor
        {
            get;
            set;
        }

        /// <summary>
        /// The padding highlight fill color (default: transparent).
        /// </summary>
        [JsonPropertyName("scrollPaddingColor")]
        public CefSharp.DevTools.DOM.RGBA ScrollPaddingColor
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ScrollSnapHighlightConfig
    /// </summary>
    public partial class ScrollSnapHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// A descriptor for the highlight appearance of scroll snap containers.
        /// </summary>
        [JsonPropertyName("scrollSnapContainerHighlightConfig")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Overlay.ScrollSnapContainerHighlightConfig ScrollSnapContainerHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the node to highlight.
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Configuration for dual screen hinge
    /// </summary>
    public partial class HingeConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// A rectangle represent hinge
        /// </summary>
        [JsonPropertyName("rect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect Rect
        {
            get;
            set;
        }

        /// <summary>
        /// The content box highlight fill color (default: a dark color).
        /// </summary>
        [JsonPropertyName("contentColor")]
        public CefSharp.DevTools.DOM.RGBA ContentColor
        {
            get;
            set;
        }

        /// <summary>
        /// The content box highlight outline color (default: transparent).
        /// </summary>
        [JsonPropertyName("outlineColor")]
        public CefSharp.DevTools.DOM.RGBA OutlineColor
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ContainerQueryHighlightConfig
    /// </summary>
    public partial class ContainerQueryHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// A descriptor for the highlight appearance of container query containers.
        /// </summary>
        [JsonPropertyName("containerQueryContainerHighlightConfig")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Overlay.ContainerQueryContainerHighlightConfig ContainerQueryContainerHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the container node to highlight.
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ContainerQueryContainerHighlightConfig
    /// </summary>
    public partial class ContainerQueryContainerHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The style of the container border.
        /// </summary>
        [JsonPropertyName("containerBorder")]
        public CefSharp.DevTools.Overlay.LineStyle ContainerBorder
        {
            get;
            set;
        }

        /// <summary>
        /// The style of the descendants&apos; borders.
        /// </summary>
        [JsonPropertyName("descendantBorder")]
        public CefSharp.DevTools.Overlay.LineStyle DescendantBorder
        {
            get;
            set;
        }
    }

    /// <summary>
    /// IsolatedElementHighlightConfig
    /// </summary>
    public partial class IsolatedElementHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// A descriptor for the highlight appearance of an element in isolation mode.
        /// </summary>
        [JsonPropertyName("isolationModeHighlightConfig")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Overlay.IsolationModeHighlightConfig IsolationModeHighlightConfig
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the isolated element to highlight.
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// IsolationModeHighlightConfig
    /// </summary>
    public partial class IsolationModeHighlightConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The fill color of the resizers (default: transparent).
        /// </summary>
        [JsonPropertyName("resizerColor")]
        public CefSharp.DevTools.DOM.RGBA ResizerColor
        {
            get;
            set;
        }

        /// <summary>
        /// The fill color for resizer handles (default: transparent).
        /// </summary>
        [JsonPropertyName("resizerHandleColor")]
        public CefSharp.DevTools.DOM.RGBA ResizerHandleColor
        {
            get;
            set;
        }

        /// <summary>
        /// The fill color for the mask covering non-isolated elements (default: transparent).
        /// </summary>
        [JsonPropertyName("maskColor")]
        public CefSharp.DevTools.DOM.RGBA MaskColor
        {
            get;
            set;
        }
    }

    /// <summary>
    /// InspectMode
    /// </summary>
    public enum InspectMode
    {
        /// <summary>
        /// searchForNode
        /// </summary>
        [JsonPropertyName("searchForNode")]
        SearchForNode,
        /// <summary>
        /// searchForUAShadowDOM
        /// </summary>
        [JsonPropertyName("searchForUAShadowDOM")]
        SearchForUAShadowDOM,
        /// <summary>
        /// captureAreaScreenshot
        /// </summary>
        [JsonPropertyName("captureAreaScreenshot")]
        CaptureAreaScreenshot,
        /// <summary>
        /// showDistances
        /// </summary>
        [JsonPropertyName("showDistances")]
        ShowDistances,
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None
    }

    /// <summary>
    /// Fired when the node should be inspected. This happens after call to `setInspectMode` or when
    /// user manually inspects an element.
    /// </summary>
    public class InspectNodeRequestedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the node to inspect.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("backendNodeId")]
        public int BackendNodeId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when the node should be highlighted. This happens after call to `setInspectMode`.
    /// </summary>
    public class NodeHighlightRequestedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// NodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when user asks to capture screenshot of some area on the page.
    /// </summary>
    public class ScreenshotRequestedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Viewport to capture, in device independent pixels (dip).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("viewport")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.Viewport Viewport
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// Indicates whether a frame has been identified as an ad.
    /// </summary>
    public enum AdFrameType
    {
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None,
        /// <summary>
        /// child
        /// </summary>
        [JsonPropertyName("child")]
        Child,
        /// <summary>
        /// root
        /// </summary>
        [JsonPropertyName("root")]
        Root
    }

    /// <summary>
    /// AdFrameExplanation
    /// </summary>
    public enum AdFrameExplanation
    {
        /// <summary>
        /// ParentIsAd
        /// </summary>
        [JsonPropertyName("ParentIsAd")]
        ParentIsAd,
        /// <summary>
        /// CreatedByAdScript
        /// </summary>
        [JsonPropertyName("CreatedByAdScript")]
        CreatedByAdScript,
        /// <summary>
        /// MatchedBlockingRule
        /// </summary>
        [JsonPropertyName("MatchedBlockingRule")]
        MatchedBlockingRule
    }

    /// <summary>
    /// Indicates whether a frame has been identified as an ad and why.
    /// </summary>
    public partial class AdFrameStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// AdFrameType
        /// </summary>
        [JsonPropertyName("adFrameType")]
        public CefSharp.DevTools.Page.AdFrameType AdFrameType
        {
            get;
            set;
        }

        /// <summary>
        /// Explanations
        /// </summary>
        [JsonPropertyName("explanations")]
        public CefSharp.DevTools.Page.AdFrameExplanation[] Explanations
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Identifies the bottom-most script which caused the frame to be labelled
    /// as an ad.
    /// </summary>
    public partial class AdScriptId : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Script Id of the bottom-most script which caused the frame to be labelled
        /// as an ad.
        /// </summary>
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Id of adScriptId&apos;s debugger.
        /// </summary>
        [JsonPropertyName("debuggerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DebuggerId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Indicates whether the frame is a secure context and why it is the case.
    /// </summary>
    public enum SecureContextType
    {
        /// <summary>
        /// Secure
        /// </summary>
        [JsonPropertyName("Secure")]
        Secure,
        /// <summary>
        /// SecureLocalhost
        /// </summary>
        [JsonPropertyName("SecureLocalhost")]
        SecureLocalhost,
        /// <summary>
        /// InsecureScheme
        /// </summary>
        [JsonPropertyName("InsecureScheme")]
        InsecureScheme,
        /// <summary>
        /// InsecureAncestor
        /// </summary>
        [JsonPropertyName("InsecureAncestor")]
        InsecureAncestor
    }

    /// <summary>
    /// Indicates whether the frame is cross-origin isolated and why it is the case.
    /// </summary>
    public enum CrossOriginIsolatedContextType
    {
        /// <summary>
        /// Isolated
        /// </summary>
        [JsonPropertyName("Isolated")]
        Isolated,
        /// <summary>
        /// NotIsolated
        /// </summary>
        [JsonPropertyName("NotIsolated")]
        NotIsolated,
        /// <summary>
        /// NotIsolatedFeatureDisabled
        /// </summary>
        [JsonPropertyName("NotIsolatedFeatureDisabled")]
        NotIsolatedFeatureDisabled
    }

    /// <summary>
    /// GatedAPIFeatures
    /// </summary>
    public enum GatedAPIFeatures
    {
        /// <summary>
        /// SharedArrayBuffers
        /// </summary>
        [JsonPropertyName("SharedArrayBuffers")]
        SharedArrayBuffers,
        /// <summary>
        /// SharedArrayBuffersTransferAllowed
        /// </summary>
        [JsonPropertyName("SharedArrayBuffersTransferAllowed")]
        SharedArrayBuffersTransferAllowed,
        /// <summary>
        /// PerformanceMeasureMemory
        /// </summary>
        [JsonPropertyName("PerformanceMeasureMemory")]
        PerformanceMeasureMemory,
        /// <summary>
        /// PerformanceProfile
        /// </summary>
        [JsonPropertyName("PerformanceProfile")]
        PerformanceProfile
    }

    /// <summary>
    /// All Permissions Policy features. This enum should match the one defined
    /// in third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5.
    /// </summary>
    public enum PermissionsPolicyFeature
    {
        /// <summary>
        /// accelerometer
        /// </summary>
        [JsonPropertyName("accelerometer")]
        Accelerometer,
        /// <summary>
        /// ambient-light-sensor
        /// </summary>
        [JsonPropertyName("ambient-light-sensor")]
        AmbientLightSensor,
        /// <summary>
        /// attribution-reporting
        /// </summary>
        [JsonPropertyName("attribution-reporting")]
        AttributionReporting,
        /// <summary>
        /// autoplay
        /// </summary>
        [JsonPropertyName("autoplay")]
        Autoplay,
        /// <summary>
        /// bluetooth
        /// </summary>
        [JsonPropertyName("bluetooth")]
        Bluetooth,
        /// <summary>
        /// browsing-topics
        /// </summary>
        [JsonPropertyName("browsing-topics")]
        BrowsingTopics,
        /// <summary>
        /// camera
        /// </summary>
        [JsonPropertyName("camera")]
        Camera,
        /// <summary>
        /// ch-dpr
        /// </summary>
        [JsonPropertyName("ch-dpr")]
        ChDpr,
        /// <summary>
        /// ch-device-memory
        /// </summary>
        [JsonPropertyName("ch-device-memory")]
        ChDeviceMemory,
        /// <summary>
        /// ch-downlink
        /// </summary>
        [JsonPropertyName("ch-downlink")]
        ChDownlink,
        /// <summary>
        /// ch-ect
        /// </summary>
        [JsonPropertyName("ch-ect")]
        ChEct,
        /// <summary>
        /// ch-prefers-color-scheme
        /// </summary>
        [JsonPropertyName("ch-prefers-color-scheme")]
        ChPrefersColorScheme,
        /// <summary>
        /// ch-prefers-reduced-motion
        /// </summary>
        [JsonPropertyName("ch-prefers-reduced-motion")]
        ChPrefersReducedMotion,
        /// <summary>
        /// ch-rtt
        /// </summary>
        [JsonPropertyName("ch-rtt")]
        ChRtt,
        /// <summary>
        /// ch-save-data
        /// </summary>
        [JsonPropertyName("ch-save-data")]
        ChSaveData,
        /// <summary>
        /// ch-ua
        /// </summary>
        [JsonPropertyName("ch-ua")]
        ChUa,
        /// <summary>
        /// ch-ua-arch
        /// </summary>
        [JsonPropertyName("ch-ua-arch")]
        ChUaArch,
        /// <summary>
        /// ch-ua-bitness
        /// </summary>
        [JsonPropertyName("ch-ua-bitness")]
        ChUaBitness,
        /// <summary>
        /// ch-ua-platform
        /// </summary>
        [JsonPropertyName("ch-ua-platform")]
        ChUaPlatform,
        /// <summary>
        /// ch-ua-model
        /// </summary>
        [JsonPropertyName("ch-ua-model")]
        ChUaModel,
        /// <summary>
        /// ch-ua-mobile
        /// </summary>
        [JsonPropertyName("ch-ua-mobile")]
        ChUaMobile,
        /// <summary>
        /// ch-ua-full
        /// </summary>
        [JsonPropertyName("ch-ua-full")]
        ChUaFull,
        /// <summary>
        /// ch-ua-full-version
        /// </summary>
        [JsonPropertyName("ch-ua-full-version")]
        ChUaFullVersion,
        /// <summary>
        /// ch-ua-full-version-list
        /// </summary>
        [JsonPropertyName("ch-ua-full-version-list")]
        ChUaFullVersionList,
        /// <summary>
        /// ch-ua-platform-version
        /// </summary>
        [JsonPropertyName("ch-ua-platform-version")]
        ChUaPlatformVersion,
        /// <summary>
        /// ch-ua-reduced
        /// </summary>
        [JsonPropertyName("ch-ua-reduced")]
        ChUaReduced,
        /// <summary>
        /// ch-ua-wow64
        /// </summary>
        [JsonPropertyName("ch-ua-wow64")]
        ChUaWow64,
        /// <summary>
        /// ch-viewport-height
        /// </summary>
        [JsonPropertyName("ch-viewport-height")]
        ChViewportHeight,
        /// <summary>
        /// ch-viewport-width
        /// </summary>
        [JsonPropertyName("ch-viewport-width")]
        ChViewportWidth,
        /// <summary>
        /// ch-width
        /// </summary>
        [JsonPropertyName("ch-width")]
        ChWidth,
        /// <summary>
        /// clipboard-read
        /// </summary>
        [JsonPropertyName("clipboard-read")]
        ClipboardRead,
        /// <summary>
        /// clipboard-write
        /// </summary>
        [JsonPropertyName("clipboard-write")]
        ClipboardWrite,
        /// <summary>
        /// compute-pressure
        /// </summary>
        [JsonPropertyName("compute-pressure")]
        ComputePressure,
        /// <summary>
        /// cross-origin-isolated
        /// </summary>
        [JsonPropertyName("cross-origin-isolated")]
        CrossOriginIsolated,
        /// <summary>
        /// direct-sockets
        /// </summary>
        [JsonPropertyName("direct-sockets")]
        DirectSockets,
        /// <summary>
        /// display-capture
        /// </summary>
        [JsonPropertyName("display-capture")]
        DisplayCapture,
        /// <summary>
        /// document-domain
        /// </summary>
        [JsonPropertyName("document-domain")]
        DocumentDomain,
        /// <summary>
        /// encrypted-media
        /// </summary>
        [JsonPropertyName("encrypted-media")]
        EncryptedMedia,
        /// <summary>
        /// execution-while-out-of-viewport
        /// </summary>
        [JsonPropertyName("execution-while-out-of-viewport")]
        ExecutionWhileOutOfViewport,
        /// <summary>
        /// execution-while-not-rendered
        /// </summary>
        [JsonPropertyName("execution-while-not-rendered")]
        ExecutionWhileNotRendered,
        /// <summary>
        /// focus-without-user-activation
        /// </summary>
        [JsonPropertyName("focus-without-user-activation")]
        FocusWithoutUserActivation,
        /// <summary>
        /// fullscreen
        /// </summary>
        [JsonPropertyName("fullscreen")]
        Fullscreen,
        /// <summary>
        /// frobulate
        /// </summary>
        [JsonPropertyName("frobulate")]
        Frobulate,
        /// <summary>
        /// gamepad
        /// </summary>
        [JsonPropertyName("gamepad")]
        Gamepad,
        /// <summary>
        /// geolocation
        /// </summary>
        [JsonPropertyName("geolocation")]
        Geolocation,
        /// <summary>
        /// gyroscope
        /// </summary>
        [JsonPropertyName("gyroscope")]
        Gyroscope,
        /// <summary>
        /// hid
        /// </summary>
        [JsonPropertyName("hid")]
        Hid,
        /// <summary>
        /// identity-credentials-get
        /// </summary>
        [JsonPropertyName("identity-credentials-get")]
        IdentityCredentialsGet,
        /// <summary>
        /// idle-detection
        /// </summary>
        [JsonPropertyName("idle-detection")]
        IdleDetection,
        /// <summary>
        /// interest-cohort
        /// </summary>
        [JsonPropertyName("interest-cohort")]
        InterestCohort,
        /// <summary>
        /// join-ad-interest-group
        /// </summary>
        [JsonPropertyName("join-ad-interest-group")]
        JoinAdInterestGroup,
        /// <summary>
        /// keyboard-map
        /// </summary>
        [JsonPropertyName("keyboard-map")]
        KeyboardMap,
        /// <summary>
        /// local-fonts
        /// </summary>
        [JsonPropertyName("local-fonts")]
        LocalFonts,
        /// <summary>
        /// magnetometer
        /// </summary>
        [JsonPropertyName("magnetometer")]
        Magnetometer,
        /// <summary>
        /// microphone
        /// </summary>
        [JsonPropertyName("microphone")]
        Microphone,
        /// <summary>
        /// midi
        /// </summary>
        [JsonPropertyName("midi")]
        Midi,
        /// <summary>
        /// otp-credentials
        /// </summary>
        [JsonPropertyName("otp-credentials")]
        OtpCredentials,
        /// <summary>
        /// payment
        /// </summary>
        [JsonPropertyName("payment")]
        Payment,
        /// <summary>
        /// picture-in-picture
        /// </summary>
        [JsonPropertyName("picture-in-picture")]
        PictureInPicture,
        /// <summary>
        /// private-aggregation
        /// </summary>
        [JsonPropertyName("private-aggregation")]
        PrivateAggregation,
        /// <summary>
        /// private-state-token-issuance
        /// </summary>
        [JsonPropertyName("private-state-token-issuance")]
        PrivateStateTokenIssuance,
        /// <summary>
        /// private-state-token-redemption
        /// </summary>
        [JsonPropertyName("private-state-token-redemption")]
        PrivateStateTokenRedemption,
        /// <summary>
        /// publickey-credentials-get
        /// </summary>
        [JsonPropertyName("publickey-credentials-get")]
        PublickeyCredentialsGet,
        /// <summary>
        /// run-ad-auction
        /// </summary>
        [JsonPropertyName("run-ad-auction")]
        RunAdAuction,
        /// <summary>
        /// screen-wake-lock
        /// </summary>
        [JsonPropertyName("screen-wake-lock")]
        ScreenWakeLock,
        /// <summary>
        /// serial
        /// </summary>
        [JsonPropertyName("serial")]
        Serial,
        /// <summary>
        /// shared-autofill
        /// </summary>
        [JsonPropertyName("shared-autofill")]
        SharedAutofill,
        /// <summary>
        /// shared-storage
        /// </summary>
        [JsonPropertyName("shared-storage")]
        SharedStorage,
        /// <summary>
        /// shared-storage-select-url
        /// </summary>
        [JsonPropertyName("shared-storage-select-url")]
        SharedStorageSelectUrl,
        /// <summary>
        /// smart-card
        /// </summary>
        [JsonPropertyName("smart-card")]
        SmartCard,
        /// <summary>
        /// storage-access
        /// </summary>
        [JsonPropertyName("storage-access")]
        StorageAccess,
        /// <summary>
        /// sync-xhr
        /// </summary>
        [JsonPropertyName("sync-xhr")]
        SyncXhr,
        /// <summary>
        /// unload
        /// </summary>
        [JsonPropertyName("unload")]
        Unload,
        /// <summary>
        /// usb
        /// </summary>
        [JsonPropertyName("usb")]
        Usb,
        /// <summary>
        /// vertical-scroll
        /// </summary>
        [JsonPropertyName("vertical-scroll")]
        VerticalScroll,
        /// <summary>
        /// web-share
        /// </summary>
        [JsonPropertyName("web-share")]
        WebShare,
        /// <summary>
        /// window-management
        /// </summary>
        [JsonPropertyName("window-management")]
        WindowManagement,
        /// <summary>
        /// window-placement
        /// </summary>
        [JsonPropertyName("window-placement")]
        WindowPlacement,
        /// <summary>
        /// xr-spatial-tracking
        /// </summary>
        [JsonPropertyName("xr-spatial-tracking")]
        XrSpatialTracking
    }

    /// <summary>
    /// Reason for a permissions policy feature to be disabled.
    /// </summary>
    public enum PermissionsPolicyBlockReason
    {
        /// <summary>
        /// Header
        /// </summary>
        [JsonPropertyName("Header")]
        Header,
        /// <summary>
        /// IframeAttribute
        /// </summary>
        [JsonPropertyName("IframeAttribute")]
        IframeAttribute,
        /// <summary>
        /// InFencedFrameTree
        /// </summary>
        [JsonPropertyName("InFencedFrameTree")]
        InFencedFrameTree,
        /// <summary>
        /// InIsolatedApp
        /// </summary>
        [JsonPropertyName("InIsolatedApp")]
        InIsolatedApp
    }

    /// <summary>
    /// PermissionsPolicyBlockLocator
    /// </summary>
    public partial class PermissionsPolicyBlockLocator : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// FrameId
        /// </summary>
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// BlockReason
        /// </summary>
        [JsonPropertyName("blockReason")]
        public CefSharp.DevTools.Page.PermissionsPolicyBlockReason BlockReason
        {
            get;
            set;
        }
    }

    /// <summary>
    /// PermissionsPolicyFeatureState
    /// </summary>
    public partial class PermissionsPolicyFeatureState : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Feature
        /// </summary>
        [JsonPropertyName("feature")]
        public CefSharp.DevTools.Page.PermissionsPolicyFeature Feature
        {
            get;
            set;
        }

        /// <summary>
        /// Allowed
        /// </summary>
        [JsonPropertyName("allowed")]
        public bool Allowed
        {
            get;
            set;
        }

        /// <summary>
        /// Locator
        /// </summary>
        [JsonPropertyName("locator")]
        public CefSharp.DevTools.Page.PermissionsPolicyBlockLocator Locator
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Origin Trial(https://www.chromium.org/blink/origin-trials) support.
    /// Status for an Origin Trial token.
    /// </summary>
    public enum OriginTrialTokenStatus
    {
        /// <summary>
        /// Success
        /// </summary>
        [JsonPropertyName("Success")]
        Success,
        /// <summary>
        /// NotSupported
        /// </summary>
        [JsonPropertyName("NotSupported")]
        NotSupported,
        /// <summary>
        /// Insecure
        /// </summary>
        [JsonPropertyName("Insecure")]
        Insecure,
        /// <summary>
        /// Expired
        /// </summary>
        [JsonPropertyName("Expired")]
        Expired,
        /// <summary>
        /// WrongOrigin
        /// </summary>
        [JsonPropertyName("WrongOrigin")]
        WrongOrigin,
        /// <summary>
        /// InvalidSignature
        /// </summary>
        [JsonPropertyName("InvalidSignature")]
        InvalidSignature,
        /// <summary>
        /// Malformed
        /// </summary>
        [JsonPropertyName("Malformed")]
        Malformed,
        /// <summary>
        /// WrongVersion
        /// </summary>
        [JsonPropertyName("WrongVersion")]
        WrongVersion,
        /// <summary>
        /// FeatureDisabled
        /// </summary>
        [JsonPropertyName("FeatureDisabled")]
        FeatureDisabled,
        /// <summary>
        /// TokenDisabled
        /// </summary>
        [JsonPropertyName("TokenDisabled")]
        TokenDisabled,
        /// <summary>
        /// FeatureDisabledForUser
        /// </summary>
        [JsonPropertyName("FeatureDisabledForUser")]
        FeatureDisabledForUser,
        /// <summary>
        /// UnknownTrial
        /// </summary>
        [JsonPropertyName("UnknownTrial")]
        UnknownTrial
    }

    /// <summary>
    /// Status for an Origin Trial.
    /// </summary>
    public enum OriginTrialStatus
    {
        /// <summary>
        /// Enabled
        /// </summary>
        [JsonPropertyName("Enabled")]
        Enabled,
        /// <summary>
        /// ValidTokenNotProvided
        /// </summary>
        [JsonPropertyName("ValidTokenNotProvided")]
        ValidTokenNotProvided,
        /// <summary>
        /// OSNotSupported
        /// </summary>
        [JsonPropertyName("OSNotSupported")]
        OSNotSupported,
        /// <summary>
        /// TrialNotAllowed
        /// </summary>
        [JsonPropertyName("TrialNotAllowed")]
        TrialNotAllowed
    }

    /// <summary>
    /// OriginTrialUsageRestriction
    /// </summary>
    public enum OriginTrialUsageRestriction
    {
        /// <summary>
        /// None
        /// </summary>
        [JsonPropertyName("None")]
        None,
        /// <summary>
        /// Subset
        /// </summary>
        [JsonPropertyName("Subset")]
        Subset
    }

    /// <summary>
    /// OriginTrialToken
    /// </summary>
    public partial class OriginTrialToken : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Origin
        /// </summary>
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// MatchSubDomains
        /// </summary>
        [JsonPropertyName("matchSubDomains")]
        public bool MatchSubDomains
        {
            get;
            set;
        }

        /// <summary>
        /// TrialName
        /// </summary>
        [JsonPropertyName("trialName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TrialName
        {
            get;
            set;
        }

        /// <summary>
        /// ExpiryTime
        /// </summary>
        [JsonPropertyName("expiryTime")]
        public double ExpiryTime
        {
            get;
            set;
        }

        /// <summary>
        /// IsThirdParty
        /// </summary>
        [JsonPropertyName("isThirdParty")]
        public bool IsThirdParty
        {
            get;
            set;
        }

        /// <summary>
        /// UsageRestriction
        /// </summary>
        [JsonPropertyName("usageRestriction")]
        public CefSharp.DevTools.Page.OriginTrialUsageRestriction UsageRestriction
        {
            get;
            set;
        }
    }

    /// <summary>
    /// OriginTrialTokenWithStatus
    /// </summary>
    public partial class OriginTrialTokenWithStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// RawTokenText
        /// </summary>
        [JsonPropertyName("rawTokenText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RawTokenText
        {
            get;
            set;
        }

        /// <summary>
        /// `parsedToken` is present only when the token is extractable and
        /// parsable.
        /// </summary>
        [JsonPropertyName("parsedToken")]
        public CefSharp.DevTools.Page.OriginTrialToken ParsedToken
        {
            get;
            set;
        }

        /// <summary>
        /// Status
        /// </summary>
        [JsonPropertyName("status")]
        public CefSharp.DevTools.Page.OriginTrialTokenStatus Status
        {
            get;
            set;
        }
    }

    /// <summary>
    /// OriginTrial
    /// </summary>
    public partial class OriginTrial : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// TrialName
        /// </summary>
        [JsonPropertyName("trialName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TrialName
        {
            get;
            set;
        }

        /// <summary>
        /// Status
        /// </summary>
        [JsonPropertyName("status")]
        public CefSharp.DevTools.Page.OriginTrialStatus Status
        {
            get;
            set;
        }

        /// <summary>
        /// TokensWithStatus
        /// </summary>
        [JsonPropertyName("tokensWithStatus")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.OriginTrialTokenWithStatus> TokensWithStatus
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about the Frame on the page.
    /// </summary>
    public partial class Frame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Frame unique identifier.
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Parent frame identifier.
        /// </summary>
        [JsonPropertyName("parentId")]
        public string ParentId
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the loader associated with this frame.
        /// </summary>
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            set;
        }

        /// <summary>
        /// Frame&apos;s name as specified in the tag.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s URL without fragment.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s URL fragment including the &apos;#&apos;.
        /// </summary>
        [JsonPropertyName("urlFragment")]
        public string UrlFragment
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s registered domain, taking the public suffixes list into account.
        /// Extracted from the Frame&apos;s url.
        /// Example URLs: http://www.google.com/file.html -&gt; &quot;google.com&quot;
        ///               http://a.b.co.uk/file.html      -&gt; &quot;b.co.uk&quot;
        /// </summary>
        [JsonPropertyName("domainAndRegistry")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DomainAndRegistry
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s security origin.
        /// </summary>
        [JsonPropertyName("securityOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SecurityOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// Frame document&apos;s mimeType as determined by the browser.
        /// </summary>
        [JsonPropertyName("mimeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MimeType
        {
            get;
            set;
        }

        /// <summary>
        /// If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
        /// </summary>
        [JsonPropertyName("unreachableUrl")]
        public string UnreachableUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this frame was tagged as an ad and why.
        /// </summary>
        [JsonPropertyName("adFrameStatus")]
        public CefSharp.DevTools.Page.AdFrameStatus AdFrameStatus
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the main document is a secure context and explains why that is the case.
        /// </summary>
        [JsonPropertyName("secureContextType")]
        public CefSharp.DevTools.Page.SecureContextType SecureContextType
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this is a cross origin isolated context.
        /// </summary>
        [JsonPropertyName("crossOriginIsolatedContextType")]
        public CefSharp.DevTools.Page.CrossOriginIsolatedContextType CrossOriginIsolatedContextType
        {
            get;
            set;
        }

        /// <summary>
        /// Indicated which gated APIs / features are available.
        /// </summary>
        [JsonPropertyName("gatedAPIFeatures")]
        public CefSharp.DevTools.Page.GatedAPIFeatures[] GatedAPIFeatures
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about the Resource on the page.
    /// </summary>
    public partial class FrameResource : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Resource URL.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Type of this resource.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Network.ResourceType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Resource mimeType as determined by the browser.
        /// </summary>
        [JsonPropertyName("mimeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MimeType
        {
            get;
            set;
        }

        /// <summary>
        /// last-modified timestamp as reported by server.
        /// </summary>
        [JsonPropertyName("lastModified")]
        public double? LastModified
        {
            get;
            set;
        }

        /// <summary>
        /// Resource content size.
        /// </summary>
        [JsonPropertyName("contentSize")]
        public double? ContentSize
        {
            get;
            set;
        }

        /// <summary>
        /// True if the resource failed to load.
        /// </summary>
        [JsonPropertyName("failed")]
        public bool? Failed
        {
            get;
            set;
        }

        /// <summary>
        /// True if the resource was canceled during loading.
        /// </summary>
        [JsonPropertyName("canceled")]
        public bool? Canceled
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about the Frame hierarchy along with their cached resources.
    /// </summary>
    public partial class FrameResourceTree : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Frame information for this tree item.
        /// </summary>
        [JsonPropertyName("frame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.Frame Frame
        {
            get;
            set;
        }

        /// <summary>
        /// Child frames.
        /// </summary>
        [JsonPropertyName("childFrames")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.FrameResourceTree> ChildFrames
        {
            get;
            set;
        }

        /// <summary>
        /// Information about frame resources.
        /// </summary>
        [JsonPropertyName("resources")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.FrameResource> Resources
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about the Frame hierarchy.
    /// </summary>
    public partial class FrameTree : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Frame information for this tree item.
        /// </summary>
        [JsonPropertyName("frame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.Frame Frame
        {
            get;
            set;
        }

        /// <summary>
        /// Child frames.
        /// </summary>
        [JsonPropertyName("childFrames")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.FrameTree> ChildFrames
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Transition type.
    /// </summary>
    public enum TransitionType
    {
        /// <summary>
        /// link
        /// </summary>
        [JsonPropertyName("link")]
        Link,
        /// <summary>
        /// typed
        /// </summary>
        [JsonPropertyName("typed")]
        Typed,
        /// <summary>
        /// address_bar
        /// </summary>
        [JsonPropertyName("address_bar")]
        AddressBar,
        /// <summary>
        /// auto_bookmark
        /// </summary>
        [JsonPropertyName("auto_bookmark")]
        AutoBookmark,
        /// <summary>
        /// auto_subframe
        /// </summary>
        [JsonPropertyName("auto_subframe")]
        AutoSubframe,
        /// <summary>
        /// manual_subframe
        /// </summary>
        [JsonPropertyName("manual_subframe")]
        ManualSubframe,
        /// <summary>
        /// generated
        /// </summary>
        [JsonPropertyName("generated")]
        Generated,
        /// <summary>
        /// auto_toplevel
        /// </summary>
        [JsonPropertyName("auto_toplevel")]
        AutoToplevel,
        /// <summary>
        /// form_submit
        /// </summary>
        [JsonPropertyName("form_submit")]
        FormSubmit,
        /// <summary>
        /// reload
        /// </summary>
        [JsonPropertyName("reload")]
        Reload,
        /// <summary>
        /// keyword
        /// </summary>
        [JsonPropertyName("keyword")]
        Keyword,
        /// <summary>
        /// keyword_generated
        /// </summary>
        [JsonPropertyName("keyword_generated")]
        KeywordGenerated,
        /// <summary>
        /// other
        /// </summary>
        [JsonPropertyName("other")]
        Other
    }

    /// <summary>
    /// Navigation history entry.
    /// </summary>
    public partial class NavigationEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Unique id of the navigation history entry.
        /// </summary>
        [JsonPropertyName("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the navigation history entry.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// URL that the user typed in the url bar.
        /// </summary>
        [JsonPropertyName("userTypedURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string UserTypedURL
        {
            get;
            set;
        }

        /// <summary>
        /// Title of the navigation history entry.
        /// </summary>
        [JsonPropertyName("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// Transition type.
        /// </summary>
        [JsonPropertyName("transitionType")]
        public CefSharp.DevTools.Page.TransitionType TransitionType
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Screencast frame metadata.
    /// </summary>
    public partial class ScreencastFrameMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Top offset in DIP.
        /// </summary>
        [JsonPropertyName("offsetTop")]
        public double OffsetTop
        {
            get;
            set;
        }

        /// <summary>
        /// Page scale factor.
        /// </summary>
        [JsonPropertyName("pageScaleFactor")]
        public double PageScaleFactor
        {
            get;
            set;
        }

        /// <summary>
        /// Device screen width in DIP.
        /// </summary>
        [JsonPropertyName("deviceWidth")]
        public double DeviceWidth
        {
            get;
            set;
        }

        /// <summary>
        /// Device screen height in DIP.
        /// </summary>
        [JsonPropertyName("deviceHeight")]
        public double DeviceHeight
        {
            get;
            set;
        }

        /// <summary>
        /// Position of horizontal scroll in CSS pixels.
        /// </summary>
        [JsonPropertyName("scrollOffsetX")]
        public double ScrollOffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// Position of vertical scroll in CSS pixels.
        /// </summary>
        [JsonPropertyName("scrollOffsetY")]
        public double ScrollOffsetY
        {
            get;
            set;
        }

        /// <summary>
        /// Frame swap timestamp.
        /// </summary>
        [JsonPropertyName("timestamp")]
        public double? Timestamp
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Javascript dialog type.
    /// </summary>
    public enum DialogType
    {
        /// <summary>
        /// alert
        /// </summary>
        [JsonPropertyName("alert")]
        Alert,
        /// <summary>
        /// confirm
        /// </summary>
        [JsonPropertyName("confirm")]
        Confirm,
        /// <summary>
        /// prompt
        /// </summary>
        [JsonPropertyName("prompt")]
        Prompt,
        /// <summary>
        /// beforeunload
        /// </summary>
        [JsonPropertyName("beforeunload")]
        Beforeunload
    }

    /// <summary>
    /// Error while paring app manifest.
    /// </summary>
    public partial class AppManifestError : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Error message.
        /// </summary>
        [JsonPropertyName("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            set;
        }

        /// <summary>
        /// If criticial, this is a non-recoverable parse error.
        /// </summary>
        [JsonPropertyName("critical")]
        public int Critical
        {
            get;
            set;
        }

        /// <summary>
        /// Error line.
        /// </summary>
        [JsonPropertyName("line")]
        public int Line
        {
            get;
            set;
        }

        /// <summary>
        /// Error column.
        /// </summary>
        [JsonPropertyName("column")]
        public int Column
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Parsed app manifest properties.
    /// </summary>
    public partial class AppManifestParsedProperties : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Computed scope value
        /// </summary>
        [JsonPropertyName("scope")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Scope
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Layout viewport position and dimensions.
    /// </summary>
    public partial class LayoutViewport : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Horizontal offset relative to the document (CSS pixels).
        /// </summary>
        [JsonPropertyName("pageX")]
        public int PageX
        {
            get;
            set;
        }

        /// <summary>
        /// Vertical offset relative to the document (CSS pixels).
        /// </summary>
        [JsonPropertyName("pageY")]
        public int PageY
        {
            get;
            set;
        }

        /// <summary>
        /// Width (CSS pixels), excludes scrollbar if present.
        /// </summary>
        [JsonPropertyName("clientWidth")]
        public int ClientWidth
        {
            get;
            set;
        }

        /// <summary>
        /// Height (CSS pixels), excludes scrollbar if present.
        /// </summary>
        [JsonPropertyName("clientHeight")]
        public int ClientHeight
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Visual viewport position, dimensions, and scale.
    /// </summary>
    public partial class VisualViewport : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Horizontal offset relative to the layout viewport (CSS pixels).
        /// </summary>
        [JsonPropertyName("offsetX")]
        public double OffsetX
        {
            get;
            set;
        }

        /// <summary>
        /// Vertical offset relative to the layout viewport (CSS pixels).
        /// </summary>
        [JsonPropertyName("offsetY")]
        public double OffsetY
        {
            get;
            set;
        }

        /// <summary>
        /// Horizontal offset relative to the document (CSS pixels).
        /// </summary>
        [JsonPropertyName("pageX")]
        public double PageX
        {
            get;
            set;
        }

        /// <summary>
        /// Vertical offset relative to the document (CSS pixels).
        /// </summary>
        [JsonPropertyName("pageY")]
        public double PageY
        {
            get;
            set;
        }

        /// <summary>
        /// Width (CSS pixels), excludes scrollbar if present.
        /// </summary>
        [JsonPropertyName("clientWidth")]
        public double ClientWidth
        {
            get;
            set;
        }

        /// <summary>
        /// Height (CSS pixels), excludes scrollbar if present.
        /// </summary>
        [JsonPropertyName("clientHeight")]
        public double ClientHeight
        {
            get;
            set;
        }

        /// <summary>
        /// Scale relative to the ideal viewport (size at width=device-width).
        /// </summary>
        [JsonPropertyName("scale")]
        public double Scale
        {
            get;
            set;
        }

        /// <summary>
        /// Page zoom factor (CSS to device independent pixels ratio).
        /// </summary>
        [JsonPropertyName("zoom")]
        public double? Zoom
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Viewport for capturing screenshot.
    /// </summary>
    public partial class Viewport : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// X offset in device independent pixels (dip).
        /// </summary>
        [JsonPropertyName("x")]
        public double X
        {
            get;
            set;
        }

        /// <summary>
        /// Y offset in device independent pixels (dip).
        /// </summary>
        [JsonPropertyName("y")]
        public double Y
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangle width in device independent pixels (dip).
        /// </summary>
        [JsonPropertyName("width")]
        public double Width
        {
            get;
            set;
        }

        /// <summary>
        /// Rectangle height in device independent pixels (dip).
        /// </summary>
        [JsonPropertyName("height")]
        public double Height
        {
            get;
            set;
        }

        /// <summary>
        /// Page scale factor.
        /// </summary>
        [JsonPropertyName("scale")]
        public double Scale
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Generic font families collection.
    /// </summary>
    public partial class FontFamilies : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The standard font-family.
        /// </summary>
        [JsonPropertyName("standard")]
        public string Standard
        {
            get;
            set;
        }

        /// <summary>
        /// The fixed font-family.
        /// </summary>
        [JsonPropertyName("fixed")]
        public string Fixed
        {
            get;
            set;
        }

        /// <summary>
        /// The serif font-family.
        /// </summary>
        [JsonPropertyName("serif")]
        public string Serif
        {
            get;
            set;
        }

        /// <summary>
        /// The sansSerif font-family.
        /// </summary>
        [JsonPropertyName("sansSerif")]
        public string SansSerif
        {
            get;
            set;
        }

        /// <summary>
        /// The cursive font-family.
        /// </summary>
        [JsonPropertyName("cursive")]
        public string Cursive
        {
            get;
            set;
        }

        /// <summary>
        /// The fantasy font-family.
        /// </summary>
        [JsonPropertyName("fantasy")]
        public string Fantasy
        {
            get;
            set;
        }

        /// <summary>
        /// The math font-family.
        /// </summary>
        [JsonPropertyName("math")]
        public string Math
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Font families collection for a script.
    /// </summary>
    public partial class ScriptFontFamilies : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name of the script which these font families are defined for.
        /// </summary>
        [JsonPropertyName("script")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Script
        {
            get;
            set;
        }

        /// <summary>
        /// Generic font families collection for the script.
        /// </summary>
        [JsonPropertyName("fontFamilies")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.FontFamilies FontFamilies
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Default font sizes.
    /// </summary>
    public partial class FontSizes : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Default standard font size.
        /// </summary>
        [JsonPropertyName("standard")]
        public int? Standard
        {
            get;
            set;
        }

        /// <summary>
        /// Default fixed font size.
        /// </summary>
        [JsonPropertyName("fixed")]
        public int? Fixed
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ClientNavigationReason
    /// </summary>
    public enum ClientNavigationReason
    {
        /// <summary>
        /// formSubmissionGet
        /// </summary>
        [JsonPropertyName("formSubmissionGet")]
        FormSubmissionGet,
        /// <summary>
        /// formSubmissionPost
        /// </summary>
        [JsonPropertyName("formSubmissionPost")]
        FormSubmissionPost,
        /// <summary>
        /// httpHeaderRefresh
        /// </summary>
        [JsonPropertyName("httpHeaderRefresh")]
        HttpHeaderRefresh,
        /// <summary>
        /// scriptInitiated
        /// </summary>
        [JsonPropertyName("scriptInitiated")]
        ScriptInitiated,
        /// <summary>
        /// metaTagRefresh
        /// </summary>
        [JsonPropertyName("metaTagRefresh")]
        MetaTagRefresh,
        /// <summary>
        /// pageBlockInterstitial
        /// </summary>
        [JsonPropertyName("pageBlockInterstitial")]
        PageBlockInterstitial,
        /// <summary>
        /// reload
        /// </summary>
        [JsonPropertyName("reload")]
        Reload,
        /// <summary>
        /// anchorClick
        /// </summary>
        [JsonPropertyName("anchorClick")]
        AnchorClick
    }

    /// <summary>
    /// ClientNavigationDisposition
    /// </summary>
    public enum ClientNavigationDisposition
    {
        /// <summary>
        /// currentTab
        /// </summary>
        [JsonPropertyName("currentTab")]
        CurrentTab,
        /// <summary>
        /// newTab
        /// </summary>
        [JsonPropertyName("newTab")]
        NewTab,
        /// <summary>
        /// newWindow
        /// </summary>
        [JsonPropertyName("newWindow")]
        NewWindow,
        /// <summary>
        /// download
        /// </summary>
        [JsonPropertyName("download")]
        Download
    }

    /// <summary>
    /// InstallabilityErrorArgument
    /// </summary>
    public partial class InstallabilityErrorArgument : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Argument name (e.g. name:&apos;minimum-icon-size-in-pixels&apos;).
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Argument value (e.g. value:&apos;64&apos;).
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The installability error
    /// </summary>
    public partial class InstallabilityError : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The error id (e.g. &apos;manifest-missing-suitable-icon&apos;).
        /// </summary>
        [JsonPropertyName("errorId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorId
        {
            get;
            set;
        }

        /// <summary>
        /// The list of error arguments (e.g. {name:&apos;minimum-icon-size-in-pixels&apos;, value:&apos;64&apos;}).
        /// </summary>
        [JsonPropertyName("errorArguments")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.InstallabilityErrorArgument> ErrorArguments
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The referring-policy used for the navigation.
    /// </summary>
    public enum ReferrerPolicy
    {
        /// <summary>
        /// noReferrer
        /// </summary>
        [JsonPropertyName("noReferrer")]
        NoReferrer,
        /// <summary>
        /// noReferrerWhenDowngrade
        /// </summary>
        [JsonPropertyName("noReferrerWhenDowngrade")]
        NoReferrerWhenDowngrade,
        /// <summary>
        /// origin
        /// </summary>
        [JsonPropertyName("origin")]
        Origin,
        /// <summary>
        /// originWhenCrossOrigin
        /// </summary>
        [JsonPropertyName("originWhenCrossOrigin")]
        OriginWhenCrossOrigin,
        /// <summary>
        /// sameOrigin
        /// </summary>
        [JsonPropertyName("sameOrigin")]
        SameOrigin,
        /// <summary>
        /// strictOrigin
        /// </summary>
        [JsonPropertyName("strictOrigin")]
        StrictOrigin,
        /// <summary>
        /// strictOriginWhenCrossOrigin
        /// </summary>
        [JsonPropertyName("strictOriginWhenCrossOrigin")]
        StrictOriginWhenCrossOrigin,
        /// <summary>
        /// unsafeUrl
        /// </summary>
        [JsonPropertyName("unsafeUrl")]
        UnsafeUrl
    }

    /// <summary>
    /// Per-script compilation cache parameters for `Page.produceCompilationCache`
    /// </summary>
    public partial class CompilationCacheParams : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The URL of the script to produce a compilation cache entry for.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// A hint to the backend whether eager compilation is recommended.
        /// (the actual compilation mode used is upon backend discretion).
        /// </summary>
        [JsonPropertyName("eager")]
        public bool? Eager
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Enum of possible auto-reponse for permisison / prompt dialogs.
    /// </summary>
    public enum AutoResponseMode
    {
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None,
        /// <summary>
        /// autoAccept
        /// </summary>
        [JsonPropertyName("autoAccept")]
        AutoAccept,
        /// <summary>
        /// autoReject
        /// </summary>
        [JsonPropertyName("autoReject")]
        AutoReject,
        /// <summary>
        /// autoOptOut
        /// </summary>
        [JsonPropertyName("autoOptOut")]
        AutoOptOut
    }

    /// <summary>
    /// The type of a frameNavigated event.
    /// </summary>
    public enum NavigationType
    {
        /// <summary>
        /// Navigation
        /// </summary>
        [JsonPropertyName("Navigation")]
        Navigation,
        /// <summary>
        /// BackForwardCacheRestore
        /// </summary>
        [JsonPropertyName("BackForwardCacheRestore")]
        BackForwardCacheRestore
    }

    /// <summary>
    /// List of not restored reasons for back-forward cache.
    /// </summary>
    public enum BackForwardCacheNotRestoredReason
    {
        /// <summary>
        /// NotPrimaryMainFrame
        /// </summary>
        [JsonPropertyName("NotPrimaryMainFrame")]
        NotPrimaryMainFrame,
        /// <summary>
        /// BackForwardCacheDisabled
        /// </summary>
        [JsonPropertyName("BackForwardCacheDisabled")]
        BackForwardCacheDisabled,
        /// <summary>
        /// RelatedActiveContentsExist
        /// </summary>
        [JsonPropertyName("RelatedActiveContentsExist")]
        RelatedActiveContentsExist,
        /// <summary>
        /// HTTPStatusNotOK
        /// </summary>
        [JsonPropertyName("HTTPStatusNotOK")]
        HTTPStatusNotOK,
        /// <summary>
        /// SchemeNotHTTPOrHTTPS
        /// </summary>
        [JsonPropertyName("SchemeNotHTTPOrHTTPS")]
        SchemeNotHTTPOrHTTPS,
        /// <summary>
        /// Loading
        /// </summary>
        [JsonPropertyName("Loading")]
        Loading,
        /// <summary>
        /// WasGrantedMediaAccess
        /// </summary>
        [JsonPropertyName("WasGrantedMediaAccess")]
        WasGrantedMediaAccess,
        /// <summary>
        /// DisableForRenderFrameHostCalled
        /// </summary>
        [JsonPropertyName("DisableForRenderFrameHostCalled")]
        DisableForRenderFrameHostCalled,
        /// <summary>
        /// DomainNotAllowed
        /// </summary>
        [JsonPropertyName("DomainNotAllowed")]
        DomainNotAllowed,
        /// <summary>
        /// HTTPMethodNotGET
        /// </summary>
        [JsonPropertyName("HTTPMethodNotGET")]
        HTTPMethodNotGET,
        /// <summary>
        /// SubframeIsNavigating
        /// </summary>
        [JsonPropertyName("SubframeIsNavigating")]
        SubframeIsNavigating,
        /// <summary>
        /// Timeout
        /// </summary>
        [JsonPropertyName("Timeout")]
        Timeout,
        /// <summary>
        /// CacheLimit
        /// </summary>
        [JsonPropertyName("CacheLimit")]
        CacheLimit,
        /// <summary>
        /// JavaScriptExecution
        /// </summary>
        [JsonPropertyName("JavaScriptExecution")]
        JavaScriptExecution,
        /// <summary>
        /// RendererProcessKilled
        /// </summary>
        [JsonPropertyName("RendererProcessKilled")]
        RendererProcessKilled,
        /// <summary>
        /// RendererProcessCrashed
        /// </summary>
        [JsonPropertyName("RendererProcessCrashed")]
        RendererProcessCrashed,
        /// <summary>
        /// SchedulerTrackedFeatureUsed
        /// </summary>
        [JsonPropertyName("SchedulerTrackedFeatureUsed")]
        SchedulerTrackedFeatureUsed,
        /// <summary>
        /// ConflictingBrowsingInstance
        /// </summary>
        [JsonPropertyName("ConflictingBrowsingInstance")]
        ConflictingBrowsingInstance,
        /// <summary>
        /// CacheFlushed
        /// </summary>
        [JsonPropertyName("CacheFlushed")]
        CacheFlushed,
        /// <summary>
        /// ServiceWorkerVersionActivation
        /// </summary>
        [JsonPropertyName("ServiceWorkerVersionActivation")]
        ServiceWorkerVersionActivation,
        /// <summary>
        /// SessionRestored
        /// </summary>
        [JsonPropertyName("SessionRestored")]
        SessionRestored,
        /// <summary>
        /// ServiceWorkerPostMessage
        /// </summary>
        [JsonPropertyName("ServiceWorkerPostMessage")]
        ServiceWorkerPostMessage,
        /// <summary>
        /// EnteredBackForwardCacheBeforeServiceWorkerHostAdded
        /// </summary>
        [JsonPropertyName("EnteredBackForwardCacheBeforeServiceWorkerHostAdded")]
        EnteredBackForwardCacheBeforeServiceWorkerHostAdded,
        /// <summary>
        /// RenderFrameHostReused_SameSite
        /// </summary>
        [JsonPropertyName("RenderFrameHostReused_SameSite")]
        RenderFrameHostReusedSameSite,
        /// <summary>
        /// RenderFrameHostReused_CrossSite
        /// </summary>
        [JsonPropertyName("RenderFrameHostReused_CrossSite")]
        RenderFrameHostReusedCrossSite,
        /// <summary>
        /// ServiceWorkerClaim
        /// </summary>
        [JsonPropertyName("ServiceWorkerClaim")]
        ServiceWorkerClaim,
        /// <summary>
        /// IgnoreEventAndEvict
        /// </summary>
        [JsonPropertyName("IgnoreEventAndEvict")]
        IgnoreEventAndEvict,
        /// <summary>
        /// HaveInnerContents
        /// </summary>
        [JsonPropertyName("HaveInnerContents")]
        HaveInnerContents,
        /// <summary>
        /// TimeoutPuttingInCache
        /// </summary>
        [JsonPropertyName("TimeoutPuttingInCache")]
        TimeoutPuttingInCache,
        /// <summary>
        /// BackForwardCacheDisabledByLowMemory
        /// </summary>
        [JsonPropertyName("BackForwardCacheDisabledByLowMemory")]
        BackForwardCacheDisabledByLowMemory,
        /// <summary>
        /// BackForwardCacheDisabledByCommandLine
        /// </summary>
        [JsonPropertyName("BackForwardCacheDisabledByCommandLine")]
        BackForwardCacheDisabledByCommandLine,
        /// <summary>
        /// NetworkRequestDatapipeDrainedAsBytesConsumer
        /// </summary>
        [JsonPropertyName("NetworkRequestDatapipeDrainedAsBytesConsumer")]
        NetworkRequestDatapipeDrainedAsBytesConsumer,
        /// <summary>
        /// NetworkRequestRedirected
        /// </summary>
        [JsonPropertyName("NetworkRequestRedirected")]
        NetworkRequestRedirected,
        /// <summary>
        /// NetworkRequestTimeout
        /// </summary>
        [JsonPropertyName("NetworkRequestTimeout")]
        NetworkRequestTimeout,
        /// <summary>
        /// NetworkExceedsBufferLimit
        /// </summary>
        [JsonPropertyName("NetworkExceedsBufferLimit")]
        NetworkExceedsBufferLimit,
        /// <summary>
        /// NavigationCancelledWhileRestoring
        /// </summary>
        [JsonPropertyName("NavigationCancelledWhileRestoring")]
        NavigationCancelledWhileRestoring,
        /// <summary>
        /// NotMostRecentNavigationEntry
        /// </summary>
        [JsonPropertyName("NotMostRecentNavigationEntry")]
        NotMostRecentNavigationEntry,
        /// <summary>
        /// BackForwardCacheDisabledForPrerender
        /// </summary>
        [JsonPropertyName("BackForwardCacheDisabledForPrerender")]
        BackForwardCacheDisabledForPrerender,
        /// <summary>
        /// UserAgentOverrideDiffers
        /// </summary>
        [JsonPropertyName("UserAgentOverrideDiffers")]
        UserAgentOverrideDiffers,
        /// <summary>
        /// ForegroundCacheLimit
        /// </summary>
        [JsonPropertyName("ForegroundCacheLimit")]
        ForegroundCacheLimit,
        /// <summary>
        /// BrowsingInstanceNotSwapped
        /// </summary>
        [JsonPropertyName("BrowsingInstanceNotSwapped")]
        BrowsingInstanceNotSwapped,
        /// <summary>
        /// BackForwardCacheDisabledForDelegate
        /// </summary>
        [JsonPropertyName("BackForwardCacheDisabledForDelegate")]
        BackForwardCacheDisabledForDelegate,
        /// <summary>
        /// UnloadHandlerExistsInMainFrame
        /// </summary>
        [JsonPropertyName("UnloadHandlerExistsInMainFrame")]
        UnloadHandlerExistsInMainFrame,
        /// <summary>
        /// UnloadHandlerExistsInSubFrame
        /// </summary>
        [JsonPropertyName("UnloadHandlerExistsInSubFrame")]
        UnloadHandlerExistsInSubFrame,
        /// <summary>
        /// ServiceWorkerUnregistration
        /// </summary>
        [JsonPropertyName("ServiceWorkerUnregistration")]
        ServiceWorkerUnregistration,
        /// <summary>
        /// CacheControlNoStore
        /// </summary>
        [JsonPropertyName("CacheControlNoStore")]
        CacheControlNoStore,
        /// <summary>
        /// CacheControlNoStoreCookieModified
        /// </summary>
        [JsonPropertyName("CacheControlNoStoreCookieModified")]
        CacheControlNoStoreCookieModified,
        /// <summary>
        /// CacheControlNoStoreHTTPOnlyCookieModified
        /// </summary>
        [JsonPropertyName("CacheControlNoStoreHTTPOnlyCookieModified")]
        CacheControlNoStoreHTTPOnlyCookieModified,
        /// <summary>
        /// NoResponseHead
        /// </summary>
        [JsonPropertyName("NoResponseHead")]
        NoResponseHead,
        /// <summary>
        /// Unknown
        /// </summary>
        [JsonPropertyName("Unknown")]
        Unknown,
        /// <summary>
        /// ActivationNavigationsDisallowedForBug1234857
        /// </summary>
        [JsonPropertyName("ActivationNavigationsDisallowedForBug1234857")]
        ActivationNavigationsDisallowedForBug1234857,
        /// <summary>
        /// ErrorDocument
        /// </summary>
        [JsonPropertyName("ErrorDocument")]
        ErrorDocument,
        /// <summary>
        /// FencedFramesEmbedder
        /// </summary>
        [JsonPropertyName("FencedFramesEmbedder")]
        FencedFramesEmbedder,
        /// <summary>
        /// WebSocket
        /// </summary>
        [JsonPropertyName("WebSocket")]
        WebSocket,
        /// <summary>
        /// WebTransport
        /// </summary>
        [JsonPropertyName("WebTransport")]
        WebTransport,
        /// <summary>
        /// WebRTC
        /// </summary>
        [JsonPropertyName("WebRTC")]
        WebRTC,
        /// <summary>
        /// MainResourceHasCacheControlNoStore
        /// </summary>
        [JsonPropertyName("MainResourceHasCacheControlNoStore")]
        MainResourceHasCacheControlNoStore,
        /// <summary>
        /// MainResourceHasCacheControlNoCache
        /// </summary>
        [JsonPropertyName("MainResourceHasCacheControlNoCache")]
        MainResourceHasCacheControlNoCache,
        /// <summary>
        /// SubresourceHasCacheControlNoStore
        /// </summary>
        [JsonPropertyName("SubresourceHasCacheControlNoStore")]
        SubresourceHasCacheControlNoStore,
        /// <summary>
        /// SubresourceHasCacheControlNoCache
        /// </summary>
        [JsonPropertyName("SubresourceHasCacheControlNoCache")]
        SubresourceHasCacheControlNoCache,
        /// <summary>
        /// ContainsPlugins
        /// </summary>
        [JsonPropertyName("ContainsPlugins")]
        ContainsPlugins,
        /// <summary>
        /// DocumentLoaded
        /// </summary>
        [JsonPropertyName("DocumentLoaded")]
        DocumentLoaded,
        /// <summary>
        /// DedicatedWorkerOrWorklet
        /// </summary>
        [JsonPropertyName("DedicatedWorkerOrWorklet")]
        DedicatedWorkerOrWorklet,
        /// <summary>
        /// OutstandingNetworkRequestOthers
        /// </summary>
        [JsonPropertyName("OutstandingNetworkRequestOthers")]
        OutstandingNetworkRequestOthers,
        /// <summary>
        /// OutstandingIndexedDBTransaction
        /// </summary>
        [JsonPropertyName("OutstandingIndexedDBTransaction")]
        OutstandingIndexedDBTransaction,
        /// <summary>
        /// RequestedMIDIPermission
        /// </summary>
        [JsonPropertyName("RequestedMIDIPermission")]
        RequestedMIDIPermission,
        /// <summary>
        /// RequestedAudioCapturePermission
        /// </summary>
        [JsonPropertyName("RequestedAudioCapturePermission")]
        RequestedAudioCapturePermission,
        /// <summary>
        /// RequestedVideoCapturePermission
        /// </summary>
        [JsonPropertyName("RequestedVideoCapturePermission")]
        RequestedVideoCapturePermission,
        /// <summary>
        /// RequestedBackForwardCacheBlockedSensors
        /// </summary>
        [JsonPropertyName("RequestedBackForwardCacheBlockedSensors")]
        RequestedBackForwardCacheBlockedSensors,
        /// <summary>
        /// RequestedBackgroundWorkPermission
        /// </summary>
        [JsonPropertyName("RequestedBackgroundWorkPermission")]
        RequestedBackgroundWorkPermission,
        /// <summary>
        /// BroadcastChannel
        /// </summary>
        [JsonPropertyName("BroadcastChannel")]
        BroadcastChannel,
        /// <summary>
        /// IndexedDBConnection
        /// </summary>
        [JsonPropertyName("IndexedDBConnection")]
        IndexedDBConnection,
        /// <summary>
        /// WebXR
        /// </summary>
        [JsonPropertyName("WebXR")]
        WebXR,
        /// <summary>
        /// SharedWorker
        /// </summary>
        [JsonPropertyName("SharedWorker")]
        SharedWorker,
        /// <summary>
        /// WebLocks
        /// </summary>
        [JsonPropertyName("WebLocks")]
        WebLocks,
        /// <summary>
        /// WebHID
        /// </summary>
        [JsonPropertyName("WebHID")]
        WebHID,
        /// <summary>
        /// WebShare
        /// </summary>
        [JsonPropertyName("WebShare")]
        WebShare,
        /// <summary>
        /// RequestedStorageAccessGrant
        /// </summary>
        [JsonPropertyName("RequestedStorageAccessGrant")]
        RequestedStorageAccessGrant,
        /// <summary>
        /// WebNfc
        /// </summary>
        [JsonPropertyName("WebNfc")]
        WebNfc,
        /// <summary>
        /// OutstandingNetworkRequestFetch
        /// </summary>
        [JsonPropertyName("OutstandingNetworkRequestFetch")]
        OutstandingNetworkRequestFetch,
        /// <summary>
        /// OutstandingNetworkRequestXHR
        /// </summary>
        [JsonPropertyName("OutstandingNetworkRequestXHR")]
        OutstandingNetworkRequestXHR,
        /// <summary>
        /// AppBanner
        /// </summary>
        [JsonPropertyName("AppBanner")]
        AppBanner,
        /// <summary>
        /// Printing
        /// </summary>
        [JsonPropertyName("Printing")]
        Printing,
        /// <summary>
        /// WebDatabase
        /// </summary>
        [JsonPropertyName("WebDatabase")]
        WebDatabase,
        /// <summary>
        /// PictureInPicture
        /// </summary>
        [JsonPropertyName("PictureInPicture")]
        PictureInPicture,
        /// <summary>
        /// Portal
        /// </summary>
        [JsonPropertyName("Portal")]
        Portal,
        /// <summary>
        /// SpeechRecognizer
        /// </summary>
        [JsonPropertyName("SpeechRecognizer")]
        SpeechRecognizer,
        /// <summary>
        /// IdleManager
        /// </summary>
        [JsonPropertyName("IdleManager")]
        IdleManager,
        /// <summary>
        /// PaymentManager
        /// </summary>
        [JsonPropertyName("PaymentManager")]
        PaymentManager,
        /// <summary>
        /// SpeechSynthesis
        /// </summary>
        [JsonPropertyName("SpeechSynthesis")]
        SpeechSynthesis,
        /// <summary>
        /// KeyboardLock
        /// </summary>
        [JsonPropertyName("KeyboardLock")]
        KeyboardLock,
        /// <summary>
        /// WebOTPService
        /// </summary>
        [JsonPropertyName("WebOTPService")]
        WebOTPService,
        /// <summary>
        /// OutstandingNetworkRequestDirectSocket
        /// </summary>
        [JsonPropertyName("OutstandingNetworkRequestDirectSocket")]
        OutstandingNetworkRequestDirectSocket,
        /// <summary>
        /// InjectedJavascript
        /// </summary>
        [JsonPropertyName("InjectedJavascript")]
        InjectedJavascript,
        /// <summary>
        /// InjectedStyleSheet
        /// </summary>
        [JsonPropertyName("InjectedStyleSheet")]
        InjectedStyleSheet,
        /// <summary>
        /// KeepaliveRequest
        /// </summary>
        [JsonPropertyName("KeepaliveRequest")]
        KeepaliveRequest,
        /// <summary>
        /// IndexedDBEvent
        /// </summary>
        [JsonPropertyName("IndexedDBEvent")]
        IndexedDBEvent,
        /// <summary>
        /// Dummy
        /// </summary>
        [JsonPropertyName("Dummy")]
        Dummy,
        /// <summary>
        /// AuthorizationHeader
        /// </summary>
        [JsonPropertyName("AuthorizationHeader")]
        AuthorizationHeader,
        /// <summary>
        /// ContentSecurityHandler
        /// </summary>
        [JsonPropertyName("ContentSecurityHandler")]
        ContentSecurityHandler,
        /// <summary>
        /// ContentWebAuthenticationAPI
        /// </summary>
        [JsonPropertyName("ContentWebAuthenticationAPI")]
        ContentWebAuthenticationAPI,
        /// <summary>
        /// ContentFileChooser
        /// </summary>
        [JsonPropertyName("ContentFileChooser")]
        ContentFileChooser,
        /// <summary>
        /// ContentSerial
        /// </summary>
        [JsonPropertyName("ContentSerial")]
        ContentSerial,
        /// <summary>
        /// ContentFileSystemAccess
        /// </summary>
        [JsonPropertyName("ContentFileSystemAccess")]
        ContentFileSystemAccess,
        /// <summary>
        /// ContentMediaDevicesDispatcherHost
        /// </summary>
        [JsonPropertyName("ContentMediaDevicesDispatcherHost")]
        ContentMediaDevicesDispatcherHost,
        /// <summary>
        /// ContentWebBluetooth
        /// </summary>
        [JsonPropertyName("ContentWebBluetooth")]
        ContentWebBluetooth,
        /// <summary>
        /// ContentWebUSB
        /// </summary>
        [JsonPropertyName("ContentWebUSB")]
        ContentWebUSB,
        /// <summary>
        /// ContentMediaSessionService
        /// </summary>
        [JsonPropertyName("ContentMediaSessionService")]
        ContentMediaSessionService,
        /// <summary>
        /// ContentScreenReader
        /// </summary>
        [JsonPropertyName("ContentScreenReader")]
        ContentScreenReader,
        /// <summary>
        /// EmbedderPopupBlockerTabHelper
        /// </summary>
        [JsonPropertyName("EmbedderPopupBlockerTabHelper")]
        EmbedderPopupBlockerTabHelper,
        /// <summary>
        /// EmbedderSafeBrowsingTriggeredPopupBlocker
        /// </summary>
        [JsonPropertyName("EmbedderSafeBrowsingTriggeredPopupBlocker")]
        EmbedderSafeBrowsingTriggeredPopupBlocker,
        /// <summary>
        /// EmbedderSafeBrowsingThreatDetails
        /// </summary>
        [JsonPropertyName("EmbedderSafeBrowsingThreatDetails")]
        EmbedderSafeBrowsingThreatDetails,
        /// <summary>
        /// EmbedderAppBannerManager
        /// </summary>
        [JsonPropertyName("EmbedderAppBannerManager")]
        EmbedderAppBannerManager,
        /// <summary>
        /// EmbedderDomDistillerViewerSource
        /// </summary>
        [JsonPropertyName("EmbedderDomDistillerViewerSource")]
        EmbedderDomDistillerViewerSource,
        /// <summary>
        /// EmbedderDomDistillerSelfDeletingRequestDelegate
        /// </summary>
        [JsonPropertyName("EmbedderDomDistillerSelfDeletingRequestDelegate")]
        EmbedderDomDistillerSelfDeletingRequestDelegate,
        /// <summary>
        /// EmbedderOomInterventionTabHelper
        /// </summary>
        [JsonPropertyName("EmbedderOomInterventionTabHelper")]
        EmbedderOomInterventionTabHelper,
        /// <summary>
        /// EmbedderOfflinePage
        /// </summary>
        [JsonPropertyName("EmbedderOfflinePage")]
        EmbedderOfflinePage,
        /// <summary>
        /// EmbedderChromePasswordManagerClientBindCredentialManager
        /// </summary>
        [JsonPropertyName("EmbedderChromePasswordManagerClientBindCredentialManager")]
        EmbedderChromePasswordManagerClientBindCredentialManager,
        /// <summary>
        /// EmbedderPermissionRequestManager
        /// </summary>
        [JsonPropertyName("EmbedderPermissionRequestManager")]
        EmbedderPermissionRequestManager,
        /// <summary>
        /// EmbedderModalDialog
        /// </summary>
        [JsonPropertyName("EmbedderModalDialog")]
        EmbedderModalDialog,
        /// <summary>
        /// EmbedderExtensions
        /// </summary>
        [JsonPropertyName("EmbedderExtensions")]
        EmbedderExtensions,
        /// <summary>
        /// EmbedderExtensionMessaging
        /// </summary>
        [JsonPropertyName("EmbedderExtensionMessaging")]
        EmbedderExtensionMessaging,
        /// <summary>
        /// EmbedderExtensionMessagingForOpenPort
        /// </summary>
        [JsonPropertyName("EmbedderExtensionMessagingForOpenPort")]
        EmbedderExtensionMessagingForOpenPort,
        /// <summary>
        /// EmbedderExtensionSentMessageToCachedFrame
        /// </summary>
        [JsonPropertyName("EmbedderExtensionSentMessageToCachedFrame")]
        EmbedderExtensionSentMessageToCachedFrame
    }

    /// <summary>
    /// Types of not restored reasons for back-forward cache.
    /// </summary>
    public enum BackForwardCacheNotRestoredReasonType
    {
        /// <summary>
        /// SupportPending
        /// </summary>
        [JsonPropertyName("SupportPending")]
        SupportPending,
        /// <summary>
        /// PageSupportNeeded
        /// </summary>
        [JsonPropertyName("PageSupportNeeded")]
        PageSupportNeeded,
        /// <summary>
        /// Circumstantial
        /// </summary>
        [JsonPropertyName("Circumstantial")]
        Circumstantial
    }

    /// <summary>
    /// BackForwardCacheNotRestoredExplanation
    /// </summary>
    public partial class BackForwardCacheNotRestoredExplanation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Type of the reason
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Page.BackForwardCacheNotRestoredReasonType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Not restored reason
        /// </summary>
        [JsonPropertyName("reason")]
        public CefSharp.DevTools.Page.BackForwardCacheNotRestoredReason Reason
        {
            get;
            set;
        }

        /// <summary>
        /// Context associated with the reason. The meaning of this context is
        /// dependent on the reason:
        /// - EmbedderExtensionSentMessageToCachedFrame: the extension ID.
        /// </summary>
        [JsonPropertyName("context")]
        public string Context
        {
            get;
            set;
        }
    }

    /// <summary>
    /// BackForwardCacheNotRestoredExplanationTree
    /// </summary>
    public partial class BackForwardCacheNotRestoredExplanationTree : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// URL of each frame
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Not restored reasons of each frame
        /// </summary>
        [JsonPropertyName("explanations")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.BackForwardCacheNotRestoredExplanation> Explanations
        {
            get;
            set;
        }

        /// <summary>
        /// Array of children frame
        /// </summary>
        [JsonPropertyName("children")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.BackForwardCacheNotRestoredExplanationTree> Children
        {
            get;
            set;
        }
    }

    /// <summary>
    /// domContentEventFired
    /// </summary>
    public class DomContentEventFiredEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Timestamp
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Input mode.
    /// </summary>
    public enum FileChooserOpenedMode
    {
        /// <summary>
        /// selectSingle
        /// </summary>
        [JsonPropertyName("selectSingle")]
        SelectSingle,
        /// <summary>
        /// selectMultiple
        /// </summary>
        [JsonPropertyName("selectMultiple")]
        SelectMultiple
    }

    /// <summary>
    /// Emitted only when `page.interceptFileChooser` is enabled.
    /// </summary>
    public class FileChooserOpenedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame containing input node.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Input mode.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("mode")]
        public CefSharp.DevTools.Page.FileChooserOpenedMode Mode
        {
            get;
            private set;
        }

        /// <summary>
        /// Input node id. Only present for file choosers opened via an &lt;input type=&quot;file&quot; &gt; element.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("backendNodeId")]
        public int? BackendNodeId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when frame has been attached to its parent.
    /// </summary>
    public class FrameAttachedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that has been attached.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Parent frame identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("parentFrameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ParentFrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// JavaScript stack trace of when frame was attached, only set if frame initiated from script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stack")]
        public CefSharp.DevTools.Runtime.StackTrace Stack
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when frame no longer has a scheduled navigation.
    /// </summary>
    public class FrameClearedScheduledNavigationEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that has cleared its scheduled navigation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// FrameDetachedReason
    /// </summary>
    public enum FrameDetachedReason
    {
        /// <summary>
        /// remove
        /// </summary>
        [JsonPropertyName("remove")]
        Remove,
        /// <summary>
        /// swap
        /// </summary>
        [JsonPropertyName("swap")]
        Swap
    }

    /// <summary>
    /// Fired when frame has been detached from its parent.
    /// </summary>
    public class FrameDetachedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that has been detached.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Reason
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("reason")]
        public CefSharp.DevTools.Page.FrameDetachedReason Reason
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired once navigation of the frame has completed. Frame is now associated with the new loader.
    /// </summary>
    public class FrameNavigatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Frame object.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.Frame Frame
        {
            get;
            private set;
        }

        /// <summary>
        /// Type
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Page.NavigationType Type
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when opening document to write to.
    /// </summary>
    public class DocumentOpenedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Frame object.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.Frame Frame
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a renderer-initiated navigation is requested.
    /// Navigation may still be cancelled after the event is issued.
    /// </summary>
    public class FrameRequestedNavigationEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that is being navigated.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// The reason for the navigation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("reason")]
        public CefSharp.DevTools.Page.ClientNavigationReason Reason
        {
            get;
            private set;
        }

        /// <summary>
        /// The destination URL for the requested navigation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// The disposition for the navigation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("disposition")]
        public CefSharp.DevTools.Page.ClientNavigationDisposition Disposition
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when frame schedules a potential navigation.
    /// </summary>
    public class FrameScheduledNavigationEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that has scheduled a navigation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Delay (in seconds) until the navigation is scheduled to begin. The navigation is not
        /// guaranteed to start.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("delay")]
        public double Delay
        {
            get;
            private set;
        }

        /// <summary>
        /// The reason for the navigation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("reason")]
        public CefSharp.DevTools.Page.ClientNavigationReason Reason
        {
            get;
            private set;
        }

        /// <summary>
        /// The destination URL for the scheduled navigation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when frame has started loading.
    /// </summary>
    public class FrameStartedLoadingEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that has started loading.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when frame has stopped loading.
    /// </summary>
    public class FrameStoppedLoadingEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that has stopped loading.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when page is about to start a download.
    /// Deprecated. Use Browser.downloadWillBegin instead.
    /// </summary>
    public class DownloadWillBeginEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame that caused download to begin.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Global unique identifier of the download.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("guid")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Guid
        {
            get;
            private set;
        }

        /// <summary>
        /// URL of the resource being downloaded.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Suggested file name of the resource (the actual name of the file saved on disk may differ).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("suggestedFilename")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SuggestedFilename
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Download status.
    /// </summary>
    public enum DownloadProgressState
    {
        /// <summary>
        /// inProgress
        /// </summary>
        [JsonPropertyName("inProgress")]
        InProgress,
        /// <summary>
        /// completed
        /// </summary>
        [JsonPropertyName("completed")]
        Completed,
        /// <summary>
        /// canceled
        /// </summary>
        [JsonPropertyName("canceled")]
        Canceled
    }

    /// <summary>
    /// Fired when download makes progress. Last call has |done| == true.
    /// Deprecated. Use Browser.downloadProgress instead.
    /// </summary>
    public class DownloadProgressEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Global unique identifier of the download.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("guid")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Guid
        {
            get;
            private set;
        }

        /// <summary>
        /// Total expected bytes to download.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("totalBytes")]
        public double TotalBytes
        {
            get;
            private set;
        }

        /// <summary>
        /// Total bytes received.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("receivedBytes")]
        public double ReceivedBytes
        {
            get;
            private set;
        }

        /// <summary>
        /// Download status.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("state")]
        public CefSharp.DevTools.Page.DownloadProgressState State
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
    /// closed.
    /// </summary>
    public class JavascriptDialogClosedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Whether dialog was confirmed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public bool Result
        {
            get;
            private set;
        }

        /// <summary>
        /// User input in case of prompt.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("userInput")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string UserInput
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
    /// open.
    /// </summary>
    public class JavascriptDialogOpeningEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Frame url.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Message that will be displayed by the dialog.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            private set;
        }

        /// <summary>
        /// Dialog type.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Page.DialogType Type
        {
            get;
            private set;
        }

        /// <summary>
        /// True iff browser is capable showing or acting on the given dialog. When browser has no
        /// dialog handler for given target, calling alert while Page domain is engaged will stall
        /// the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hasBrowserHandler")]
        public bool HasBrowserHandler
        {
            get;
            private set;
        }

        /// <summary>
        /// Default dialog prompt.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("defaultPrompt")]
        public string DefaultPrompt
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired for top level page lifecycle events such as navigation, load, paint, etc.
    /// </summary>
    public class LifecycleEventEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Loader identifier. Empty string if the request is fetched from worker.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            private set;
        }

        /// <summary>
        /// Name
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
    /// not assume any ordering with the Page.frameNavigated event. This event is fired only for
    /// main-frame history navigation where the document changes (non-same-document navigations),
    /// when bfcache navigation fails.
    /// </summary>
    public class BackForwardCacheNotUsedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// The loader id for the associated navgation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            private set;
        }

        /// <summary>
        /// The frame id of the associated frame.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Array of reasons why the page could not be cached. This must not be empty.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("notRestoredExplanations")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.BackForwardCacheNotRestoredExplanation> NotRestoredExplanations
        {
            get;
            private set;
        }

        /// <summary>
        /// Tree structure of reasons why the page could not be cached for each frame.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("notRestoredExplanationsTree")]
        public CefSharp.DevTools.Page.BackForwardCacheNotRestoredExplanationTree NotRestoredExplanationsTree
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// loadEventFired
    /// </summary>
    public class LoadEventFiredEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Timestamp
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
    /// </summary>
    public class NavigatedWithinDocumentEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the frame.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Frame&apos;s new url.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Compressed image data requested by the `startScreencast`.
    /// </summary>
    public class ScreencastFrameEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Base64-encoded compressed image.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] Data
        {
            get;
            private set;
        }

        /// <summary>
        /// Screencast frame metadata.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("metadata")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Page.ScreencastFrameMetadata Metadata
        {
            get;
            private set;
        }

        /// <summary>
        /// Frame number.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sessionId")]
        public int SessionId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when the page with currently enabled screencast was shown or hidden `.
    /// </summary>
    public class ScreencastVisibilityChangedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// True if the page is visible.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("visible")]
        public bool Visible
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a new window is going to be opened, via window.open(), link click, form submission,
    /// etc.
    /// </summary>
    public class WindowOpenEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// The URL for the new window.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Window name.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("windowName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string WindowName
        {
            get;
            private set;
        }

        /// <summary>
        /// An array of enabled window features.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("windowFeatures")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] WindowFeatures
        {
            get;
            private set;
        }

        /// <summary>
        /// Whether or not it was triggered by user gesture.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("userGesture")]
        public bool UserGesture
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued for every compilation cache generated. Is only available
    /// if Page.setGenerateCompilationCache is enabled.
    /// </summary>
    public class CompilationCacheProducedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Url
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Base64-encoded data
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] Data
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Performance
{
    /// <summary>
    /// Run-time execution metric.
    /// </summary>
    public partial class Metric : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Metric name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Metric value.
        /// </summary>
        [JsonPropertyName("value")]
        public double Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Current values of the metrics.
    /// </summary>
    public class MetricsEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Current values of the metrics.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("metrics")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Performance.Metric> Metrics
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp title.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.PerformanceTimeline
{
    /// <summary>
    /// See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl
    /// </summary>
    public partial class LargestContentfulPaint : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// RenderTime
        /// </summary>
        [JsonPropertyName("renderTime")]
        public double RenderTime
        {
            get;
            set;
        }

        /// <summary>
        /// LoadTime
        /// </summary>
        [JsonPropertyName("loadTime")]
        public double LoadTime
        {
            get;
            set;
        }

        /// <summary>
        /// The number of pixels being painted.
        /// </summary>
        [JsonPropertyName("size")]
        public double Size
        {
            get;
            set;
        }

        /// <summary>
        /// The id attribute of the element, if available.
        /// </summary>
        [JsonPropertyName("elementId")]
        public string ElementId
        {
            get;
            set;
        }

        /// <summary>
        /// The URL of the image (may be trimmed).
        /// </summary>
        [JsonPropertyName("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// NodeId
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int? NodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// LayoutShiftAttribution
    /// </summary>
    public partial class LayoutShiftAttribution : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// PreviousRect
        /// </summary>
        [JsonPropertyName("previousRect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect PreviousRect
        {
            get;
            set;
        }

        /// <summary>
        /// CurrentRect
        /// </summary>
        [JsonPropertyName("currentRect")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.DOM.Rect CurrentRect
        {
            get;
            set;
        }

        /// <summary>
        /// NodeId
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int? NodeId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl
    /// </summary>
    public partial class LayoutShift : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Score increment produced by this event.
        /// </summary>
        [JsonPropertyName("value")]
        public double Value
        {
            get;
            set;
        }

        /// <summary>
        /// HadRecentInput
        /// </summary>
        [JsonPropertyName("hadRecentInput")]
        public bool HadRecentInput
        {
            get;
            set;
        }

        /// <summary>
        /// LastInputTime
        /// </summary>
        [JsonPropertyName("lastInputTime")]
        public double LastInputTime
        {
            get;
            set;
        }

        /// <summary>
        /// Sources
        /// </summary>
        [JsonPropertyName("sources")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.PerformanceTimeline.LayoutShiftAttribution> Sources
        {
            get;
            set;
        }
    }

    /// <summary>
    /// TimelineEvent
    /// </summary>
    public partial class TimelineEvent : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Identifies the frame that this event is related to. Empty for non-frame targets.
        /// </summary>
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            set;
        }

        /// <summary>
        /// The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
        /// This determines which of the optional &quot;details&quot; fiedls is present.
        /// </summary>
        [JsonPropertyName("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Name may be empty depending on the type.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Time in seconds since Epoch, monotonically increasing within document lifetime.
        /// </summary>
        [JsonPropertyName("time")]
        public double Time
        {
            get;
            set;
        }

        /// <summary>
        /// Event duration, if applicable.
        /// </summary>
        [JsonPropertyName("duration")]
        public double? Duration
        {
            get;
            set;
        }

        /// <summary>
        /// LcpDetails
        /// </summary>
        [JsonPropertyName("lcpDetails")]
        public CefSharp.DevTools.PerformanceTimeline.LargestContentfulPaint LcpDetails
        {
            get;
            set;
        }

        /// <summary>
        /// LayoutShiftDetails
        /// </summary>
        [JsonPropertyName("layoutShiftDetails")]
        public CefSharp.DevTools.PerformanceTimeline.LayoutShift LayoutShiftDetails
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Sent when a performance timeline event is added. See reportPerformanceTimeline method.
    /// </summary>
    public class TimelineEventAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Event
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("event")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.PerformanceTimeline.TimelineEvent Event
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Security
{
    /// <summary>
    /// A description of mixed content (HTTP resources on HTTPS pages), as defined by
    /// https://www.w3.org/TR/mixed-content/#categories
    /// </summary>
    public enum MixedContentType
    {
        /// <summary>
        /// blockable
        /// </summary>
        [JsonPropertyName("blockable")]
        Blockable,
        /// <summary>
        /// optionally-blockable
        /// </summary>
        [JsonPropertyName("optionally-blockable")]
        OptionallyBlockable,
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None
    }

    /// <summary>
    /// The security level of a page or resource.
    /// </summary>
    public enum SecurityState
    {
        /// <summary>
        /// unknown
        /// </summary>
        [JsonPropertyName("unknown")]
        Unknown,
        /// <summary>
        /// neutral
        /// </summary>
        [JsonPropertyName("neutral")]
        Neutral,
        /// <summary>
        /// insecure
        /// </summary>
        [JsonPropertyName("insecure")]
        Insecure,
        /// <summary>
        /// secure
        /// </summary>
        [JsonPropertyName("secure")]
        Secure,
        /// <summary>
        /// info
        /// </summary>
        [JsonPropertyName("info")]
        Info,
        /// <summary>
        /// insecure-broken
        /// </summary>
        [JsonPropertyName("insecure-broken")]
        InsecureBroken
    }

    /// <summary>
    /// Details about the security state of the page certificate.
    /// </summary>
    public partial class CertificateSecurityState : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Protocol name (e.g. &quot;TLS 1.2&quot; or &quot;QUIC&quot;).
        /// </summary>
        [JsonPropertyName("protocol")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Protocol
        {
            get;
            set;
        }

        /// <summary>
        /// Key Exchange used by the connection, or the empty string if not applicable.
        /// </summary>
        [JsonPropertyName("keyExchange")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string KeyExchange
        {
            get;
            set;
        }

        /// <summary>
        /// (EC)DH group used by the connection, if applicable.
        /// </summary>
        [JsonPropertyName("keyExchangeGroup")]
        public string KeyExchangeGroup
        {
            get;
            set;
        }

        /// <summary>
        /// Cipher name.
        /// </summary>
        [JsonPropertyName("cipher")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Cipher
        {
            get;
            set;
        }

        /// <summary>
        /// TLS MAC. Note that AEAD ciphers do not have separate MACs.
        /// </summary>
        [JsonPropertyName("mac")]
        public string Mac
        {
            get;
            set;
        }

        /// <summary>
        /// Page certificate.
        /// </summary>
        [JsonPropertyName("certificate")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Certificate
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate subject name.
        /// </summary>
        [JsonPropertyName("subjectName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SubjectName
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the issuing CA.
        /// </summary>
        [JsonPropertyName("issuer")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Issuer
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate valid from date.
        /// </summary>
        [JsonPropertyName("validFrom")]
        public double ValidFrom
        {
            get;
            set;
        }

        /// <summary>
        /// Certificate valid to (expiration) date
        /// </summary>
        [JsonPropertyName("validTo")]
        public double ValidTo
        {
            get;
            set;
        }

        /// <summary>
        /// The highest priority network error code, if the certificate has an error.
        /// </summary>
        [JsonPropertyName("certificateNetworkError")]
        public string CertificateNetworkError
        {
            get;
            set;
        }

        /// <summary>
        /// True if the certificate uses a weak signature aglorithm.
        /// </summary>
        [JsonPropertyName("certificateHasWeakSignature")]
        public bool CertificateHasWeakSignature
        {
            get;
            set;
        }

        /// <summary>
        /// True if the certificate has a SHA1 signature in the chain.
        /// </summary>
        [JsonPropertyName("certificateHasSha1Signature")]
        public bool CertificateHasSha1Signature
        {
            get;
            set;
        }

        /// <summary>
        /// True if modern SSL
        /// </summary>
        [JsonPropertyName("modernSSL")]
        public bool ModernSSL
        {
            get;
            set;
        }

        /// <summary>
        /// True if the connection is using an obsolete SSL protocol.
        /// </summary>
        [JsonPropertyName("obsoleteSslProtocol")]
        public bool ObsoleteSslProtocol
        {
            get;
            set;
        }

        /// <summary>
        /// True if the connection is using an obsolete SSL key exchange.
        /// </summary>
        [JsonPropertyName("obsoleteSslKeyExchange")]
        public bool ObsoleteSslKeyExchange
        {
            get;
            set;
        }

        /// <summary>
        /// True if the connection is using an obsolete SSL cipher.
        /// </summary>
        [JsonPropertyName("obsoleteSslCipher")]
        public bool ObsoleteSslCipher
        {
            get;
            set;
        }

        /// <summary>
        /// True if the connection is using an obsolete SSL signature.
        /// </summary>
        [JsonPropertyName("obsoleteSslSignature")]
        public bool ObsoleteSslSignature
        {
            get;
            set;
        }
    }

    /// <summary>
    /// SafetyTipStatus
    /// </summary>
    public enum SafetyTipStatus
    {
        /// <summary>
        /// badReputation
        /// </summary>
        [JsonPropertyName("badReputation")]
        BadReputation,
        /// <summary>
        /// lookalike
        /// </summary>
        [JsonPropertyName("lookalike")]
        Lookalike
    }

    /// <summary>
    /// SafetyTipInfo
    /// </summary>
    public partial class SafetyTipInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
        /// </summary>
        [JsonPropertyName("safetyTipStatus")]
        public CefSharp.DevTools.Security.SafetyTipStatus SafetyTipStatus
        {
            get;
            set;
        }

        /// <summary>
        /// The URL the safety tip suggested (&quot;Did you mean?&quot;). Only filled in for lookalike matches.
        /// </summary>
        [JsonPropertyName("safeUrl")]
        public string SafeUrl
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Security state information about the page.
    /// </summary>
    public partial class VisibleSecurityState : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The security level of the page.
        /// </summary>
        [JsonPropertyName("securityState")]
        public CefSharp.DevTools.Security.SecurityState SecurityState
        {
            get;
            set;
        }

        /// <summary>
        /// Security state details about the page certificate.
        /// </summary>
        [JsonPropertyName("certificateSecurityState")]
        public CefSharp.DevTools.Security.CertificateSecurityState CertificateSecurityState
        {
            get;
            set;
        }

        /// <summary>
        /// The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
        /// </summary>
        [JsonPropertyName("safetyTipInfo")]
        public CefSharp.DevTools.Security.SafetyTipInfo SafetyTipInfo
        {
            get;
            set;
        }

        /// <summary>
        /// Array of security state issues ids.
        /// </summary>
        [JsonPropertyName("securityStateIssueIds")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] SecurityStateIssueIds
        {
            get;
            set;
        }
    }

    /// <summary>
    /// An explanation of an factor contributing to the security state.
    /// </summary>
    public partial class SecurityStateExplanation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Security state representing the severity of the factor being explained.
        /// </summary>
        [JsonPropertyName("securityState")]
        public CefSharp.DevTools.Security.SecurityState SecurityState
        {
            get;
            set;
        }

        /// <summary>
        /// Title describing the type of factor.
        /// </summary>
        [JsonPropertyName("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// Short phrase describing the type of factor.
        /// </summary>
        [JsonPropertyName("summary")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Summary
        {
            get;
            set;
        }

        /// <summary>
        /// Full text explanation of the factor.
        /// </summary>
        [JsonPropertyName("description")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// The type of mixed content described by the explanation.
        /// </summary>
        [JsonPropertyName("mixedContentType")]
        public CefSharp.DevTools.Security.MixedContentType MixedContentType
        {
            get;
            set;
        }

        /// <summary>
        /// Page certificate.
        /// </summary>
        [JsonPropertyName("certificate")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Certificate
        {
            get;
            set;
        }

        /// <summary>
        /// Recommendations to fix any issues.
        /// </summary>
        [JsonPropertyName("recommendations")]
        public string[] Recommendations
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Information about insecure content on the page.
    /// </summary>
    public partial class InsecureContentStatus : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Always false.
        /// </summary>
        [JsonPropertyName("ranMixedContent")]
        public bool RanMixedContent
        {
            get;
            set;
        }

        /// <summary>
        /// Always false.
        /// </summary>
        [JsonPropertyName("displayedMixedContent")]
        public bool DisplayedMixedContent
        {
            get;
            set;
        }

        /// <summary>
        /// Always false.
        /// </summary>
        [JsonPropertyName("containedMixedForm")]
        public bool ContainedMixedForm
        {
            get;
            set;
        }

        /// <summary>
        /// Always false.
        /// </summary>
        [JsonPropertyName("ranContentWithCertErrors")]
        public bool RanContentWithCertErrors
        {
            get;
            set;
        }

        /// <summary>
        /// Always false.
        /// </summary>
        [JsonPropertyName("displayedContentWithCertErrors")]
        public bool DisplayedContentWithCertErrors
        {
            get;
            set;
        }

        /// <summary>
        /// Always set to unknown.
        /// </summary>
        [JsonPropertyName("ranInsecureContentStyle")]
        public CefSharp.DevTools.Security.SecurityState RanInsecureContentStyle
        {
            get;
            set;
        }

        /// <summary>
        /// Always set to unknown.
        /// </summary>
        [JsonPropertyName("displayedInsecureContentStyle")]
        public CefSharp.DevTools.Security.SecurityState DisplayedInsecureContentStyle
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The action to take when a certificate error occurs. continue will continue processing the
    /// request and cancel will cancel the request.
    /// </summary>
    public enum CertificateErrorAction
    {
        /// <summary>
        /// continue
        /// </summary>
        [JsonPropertyName("continue")]
        Continue,
        /// <summary>
        /// cancel
        /// </summary>
        [JsonPropertyName("cancel")]
        Cancel
    }

    /// <summary>
    /// There is a certificate error. If overriding certificate errors is enabled, then it should be
    /// handled with the `handleCertificateError` command. Note: this event does not fire if the
    /// certificate error has been allowed internally. Only one client per target should override
    /// certificate errors at the same time.
    /// </summary>
    public class CertificateErrorEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// The ID of the event.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("eventId")]
        public int EventId
        {
            get;
            private set;
        }

        /// <summary>
        /// The type of the error.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errorType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorType
        {
            get;
            private set;
        }

        /// <summary>
        /// The url that was requested.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestURL
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// The security state of the page changed.
    /// </summary>
    public class VisibleSecurityStateChangedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Security state information about the page.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("visibleSecurityState")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Security.VisibleSecurityState VisibleSecurityState
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// The security state of the page changed. No longer being sent.
    /// </summary>
    public class SecurityStateChangedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Security state.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("securityState")]
        public CefSharp.DevTools.Security.SecurityState SecurityState
        {
            get;
            private set;
        }

        /// <summary>
        /// True if the page was loaded over cryptographic transport such as HTTPS.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("schemeIsCryptographic")]
        public bool SchemeIsCryptographic
        {
            get;
            private set;
        }

        /// <summary>
        /// Previously a list of explanations for the security state. Now always
        /// empty.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("explanations")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Security.SecurityStateExplanation> Explanations
        {
            get;
            private set;
        }

        /// <summary>
        /// Information about insecure content on the page.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("insecureContentStatus")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Security.InsecureContentStatus InsecureContentStatus
        {
            get;
            private set;
        }

        /// <summary>
        /// Overrides user-visible description of the state. Always omitted.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("summary")]
        public string Summary
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.ServiceWorker
{
    /// <summary>
    /// ServiceWorker registration.
    /// </summary>
    public partial class ServiceWorkerRegistration : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// RegistrationId
        /// </summary>
        [JsonPropertyName("registrationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RegistrationId
        {
            get;
            set;
        }

        /// <summary>
        /// ScopeURL
        /// </summary>
        [JsonPropertyName("scopeURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScopeURL
        {
            get;
            set;
        }

        /// <summary>
        /// IsDeleted
        /// </summary>
        [JsonPropertyName("isDeleted")]
        public bool IsDeleted
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ServiceWorkerVersionRunningStatus
    /// </summary>
    public enum ServiceWorkerVersionRunningStatus
    {
        /// <summary>
        /// stopped
        /// </summary>
        [JsonPropertyName("stopped")]
        Stopped,
        /// <summary>
        /// starting
        /// </summary>
        [JsonPropertyName("starting")]
        Starting,
        /// <summary>
        /// running
        /// </summary>
        [JsonPropertyName("running")]
        Running,
        /// <summary>
        /// stopping
        /// </summary>
        [JsonPropertyName("stopping")]
        Stopping
    }

    /// <summary>
    /// ServiceWorkerVersionStatus
    /// </summary>
    public enum ServiceWorkerVersionStatus
    {
        /// <summary>
        /// new
        /// </summary>
        [JsonPropertyName("new")]
        New,
        /// <summary>
        /// installing
        /// </summary>
        [JsonPropertyName("installing")]
        Installing,
        /// <summary>
        /// installed
        /// </summary>
        [JsonPropertyName("installed")]
        Installed,
        /// <summary>
        /// activating
        /// </summary>
        [JsonPropertyName("activating")]
        Activating,
        /// <summary>
        /// activated
        /// </summary>
        [JsonPropertyName("activated")]
        Activated,
        /// <summary>
        /// redundant
        /// </summary>
        [JsonPropertyName("redundant")]
        Redundant
    }

    /// <summary>
    /// ServiceWorker version.
    /// </summary>
    public partial class ServiceWorkerVersion : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// VersionId
        /// </summary>
        [JsonPropertyName("versionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string VersionId
        {
            get;
            set;
        }

        /// <summary>
        /// RegistrationId
        /// </summary>
        [JsonPropertyName("registrationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RegistrationId
        {
            get;
            set;
        }

        /// <summary>
        /// ScriptURL
        /// </summary>
        [JsonPropertyName("scriptURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptURL
        {
            get;
            set;
        }

        /// <summary>
        /// RunningStatus
        /// </summary>
        [JsonPropertyName("runningStatus")]
        public CefSharp.DevTools.ServiceWorker.ServiceWorkerVersionRunningStatus RunningStatus
        {
            get;
            set;
        }

        /// <summary>
        /// Status
        /// </summary>
        [JsonPropertyName("status")]
        public CefSharp.DevTools.ServiceWorker.ServiceWorkerVersionStatus Status
        {
            get;
            set;
        }

        /// <summary>
        /// The Last-Modified header value of the main script.
        /// </summary>
        [JsonPropertyName("scriptLastModified")]
        public double? ScriptLastModified
        {
            get;
            set;
        }

        /// <summary>
        /// The time at which the response headers of the main script were received from the server.
        /// For cached script it is the last time the cache entry was validated.
        /// </summary>
        [JsonPropertyName("scriptResponseTime")]
        public double? ScriptResponseTime
        {
            get;
            set;
        }

        /// <summary>
        /// ControlledClients
        /// </summary>
        [JsonPropertyName("controlledClients")]
        public string[] ControlledClients
        {
            get;
            set;
        }

        /// <summary>
        /// TargetId
        /// </summary>
        [JsonPropertyName("targetId")]
        public string TargetId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// ServiceWorker error message.
    /// </summary>
    public partial class ServiceWorkerErrorMessage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ErrorMessage
        /// </summary>
        [JsonPropertyName("errorMessage")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorMessage
        {
            get;
            set;
        }

        /// <summary>
        /// RegistrationId
        /// </summary>
        [JsonPropertyName("registrationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RegistrationId
        {
            get;
            set;
        }

        /// <summary>
        /// VersionId
        /// </summary>
        [JsonPropertyName("versionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string VersionId
        {
            get;
            set;
        }

        /// <summary>
        /// SourceURL
        /// </summary>
        [JsonPropertyName("sourceURL")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceURL
        {
            get;
            set;
        }

        /// <summary>
        /// LineNumber
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// ColumnNumber
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }
    }

    /// <summary>
    /// workerErrorReported
    /// </summary>
    public class WorkerErrorReportedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ErrorMessage
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errorMessage")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.ServiceWorker.ServiceWorkerErrorMessage ErrorMessage
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// workerRegistrationUpdated
    /// </summary>
    public class WorkerRegistrationUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Registrations
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("registrations")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.ServiceWorker.ServiceWorkerRegistration> Registrations
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// workerVersionUpdated
    /// </summary>
    public class WorkerVersionUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Versions
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("versions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.ServiceWorker.ServiceWorkerVersion> Versions
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// Enum of possible storage types.
    /// </summary>
    public enum StorageType
    {
        /// <summary>
        /// appcache
        /// </summary>
        [JsonPropertyName("appcache")]
        Appcache,
        /// <summary>
        /// cookies
        /// </summary>
        [JsonPropertyName("cookies")]
        Cookies,
        /// <summary>
        /// file_systems
        /// </summary>
        [JsonPropertyName("file_systems")]
        FileSystems,
        /// <summary>
        /// indexeddb
        /// </summary>
        [JsonPropertyName("indexeddb")]
        Indexeddb,
        /// <summary>
        /// local_storage
        /// </summary>
        [JsonPropertyName("local_storage")]
        LocalStorage,
        /// <summary>
        /// shader_cache
        /// </summary>
        [JsonPropertyName("shader_cache")]
        ShaderCache,
        /// <summary>
        /// websql
        /// </summary>
        [JsonPropertyName("websql")]
        Websql,
        /// <summary>
        /// service_workers
        /// </summary>
        [JsonPropertyName("service_workers")]
        ServiceWorkers,
        /// <summary>
        /// cache_storage
        /// </summary>
        [JsonPropertyName("cache_storage")]
        CacheStorage,
        /// <summary>
        /// interest_groups
        /// </summary>
        [JsonPropertyName("interest_groups")]
        InterestGroups,
        /// <summary>
        /// shared_storage
        /// </summary>
        [JsonPropertyName("shared_storage")]
        SharedStorage,
        /// <summary>
        /// storage_buckets
        /// </summary>
        [JsonPropertyName("storage_buckets")]
        StorageBuckets,
        /// <summary>
        /// all
        /// </summary>
        [JsonPropertyName("all")]
        All,
        /// <summary>
        /// other
        /// </summary>
        [JsonPropertyName("other")]
        Other
    }

    /// <summary>
    /// Usage for a storage type.
    /// </summary>
    public partial class UsageForType : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name of storage type.
        /// </summary>
        [JsonPropertyName("storageType")]
        public CefSharp.DevTools.Storage.StorageType StorageType
        {
            get;
            set;
        }

        /// <summary>
        /// Storage usage (bytes).
        /// </summary>
        [JsonPropertyName("usage")]
        public double Usage
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Pair of issuer origin and number of available (signed, but not used) Trust
    /// Tokens from that issuer.
    /// </summary>
    public partial class TrustTokens : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// IssuerOrigin
        /// </summary>
        [JsonPropertyName("issuerOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string IssuerOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// Count
        /// </summary>
        [JsonPropertyName("count")]
        public double Count
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Enum of interest group access types.
    /// </summary>
    public enum InterestGroupAccessType
    {
        /// <summary>
        /// join
        /// </summary>
        [JsonPropertyName("join")]
        Join,
        /// <summary>
        /// leave
        /// </summary>
        [JsonPropertyName("leave")]
        Leave,
        /// <summary>
        /// update
        /// </summary>
        [JsonPropertyName("update")]
        Update,
        /// <summary>
        /// loaded
        /// </summary>
        [JsonPropertyName("loaded")]
        Loaded,
        /// <summary>
        /// bid
        /// </summary>
        [JsonPropertyName("bid")]
        Bid,
        /// <summary>
        /// win
        /// </summary>
        [JsonPropertyName("win")]
        Win
    }

    /// <summary>
    /// Ad advertising element inside an interest group.
    /// </summary>
    public partial class InterestGroupAd : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// RenderUrl
        /// </summary>
        [JsonPropertyName("renderUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RenderUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Metadata
        /// </summary>
        [JsonPropertyName("metadata")]
        public string Metadata
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The full details of an interest group.
    /// </summary>
    public partial class InterestGroupDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// OwnerOrigin
        /// </summary>
        [JsonPropertyName("ownerOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string OwnerOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// ExpirationTime
        /// </summary>
        [JsonPropertyName("expirationTime")]
        public double ExpirationTime
        {
            get;
            set;
        }

        /// <summary>
        /// JoiningOrigin
        /// </summary>
        [JsonPropertyName("joiningOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string JoiningOrigin
        {
            get;
            set;
        }

        /// <summary>
        /// BiddingUrl
        /// </summary>
        [JsonPropertyName("biddingUrl")]
        public string BiddingUrl
        {
            get;
            set;
        }

        /// <summary>
        /// BiddingWasmHelperUrl
        /// </summary>
        [JsonPropertyName("biddingWasmHelperUrl")]
        public string BiddingWasmHelperUrl
        {
            get;
            set;
        }

        /// <summary>
        /// UpdateUrl
        /// </summary>
        [JsonPropertyName("updateUrl")]
        public string UpdateUrl
        {
            get;
            set;
        }

        /// <summary>
        /// TrustedBiddingSignalsUrl
        /// </summary>
        [JsonPropertyName("trustedBiddingSignalsUrl")]
        public string TrustedBiddingSignalsUrl
        {
            get;
            set;
        }

        /// <summary>
        /// TrustedBiddingSignalsKeys
        /// </summary>
        [JsonPropertyName("trustedBiddingSignalsKeys")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] TrustedBiddingSignalsKeys
        {
            get;
            set;
        }

        /// <summary>
        /// UserBiddingSignals
        /// </summary>
        [JsonPropertyName("userBiddingSignals")]
        public string UserBiddingSignals
        {
            get;
            set;
        }

        /// <summary>
        /// Ads
        /// </summary>
        [JsonPropertyName("ads")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Storage.InterestGroupAd> Ads
        {
            get;
            set;
        }

        /// <summary>
        /// AdComponents
        /// </summary>
        [JsonPropertyName("adComponents")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Storage.InterestGroupAd> AdComponents
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Enum of shared storage access types.
    /// </summary>
    public enum SharedStorageAccessType
    {
        /// <summary>
        /// documentAddModule
        /// </summary>
        [JsonPropertyName("documentAddModule")]
        DocumentAddModule,
        /// <summary>
        /// documentSelectURL
        /// </summary>
        [JsonPropertyName("documentSelectURL")]
        DocumentSelectURL,
        /// <summary>
        /// documentRun
        /// </summary>
        [JsonPropertyName("documentRun")]
        DocumentRun,
        /// <summary>
        /// documentSet
        /// </summary>
        [JsonPropertyName("documentSet")]
        DocumentSet,
        /// <summary>
        /// documentAppend
        /// </summary>
        [JsonPropertyName("documentAppend")]
        DocumentAppend,
        /// <summary>
        /// documentDelete
        /// </summary>
        [JsonPropertyName("documentDelete")]
        DocumentDelete,
        /// <summary>
        /// documentClear
        /// </summary>
        [JsonPropertyName("documentClear")]
        DocumentClear,
        /// <summary>
        /// workletSet
        /// </summary>
        [JsonPropertyName("workletSet")]
        WorkletSet,
        /// <summary>
        /// workletAppend
        /// </summary>
        [JsonPropertyName("workletAppend")]
        WorkletAppend,
        /// <summary>
        /// workletDelete
        /// </summary>
        [JsonPropertyName("workletDelete")]
        WorkletDelete,
        /// <summary>
        /// workletClear
        /// </summary>
        [JsonPropertyName("workletClear")]
        WorkletClear,
        /// <summary>
        /// workletGet
        /// </summary>
        [JsonPropertyName("workletGet")]
        WorkletGet,
        /// <summary>
        /// workletKeys
        /// </summary>
        [JsonPropertyName("workletKeys")]
        WorkletKeys,
        /// <summary>
        /// workletEntries
        /// </summary>
        [JsonPropertyName("workletEntries")]
        WorkletEntries,
        /// <summary>
        /// workletLength
        /// </summary>
        [JsonPropertyName("workletLength")]
        WorkletLength,
        /// <summary>
        /// workletRemainingBudget
        /// </summary>
        [JsonPropertyName("workletRemainingBudget")]
        WorkletRemainingBudget
    }

    /// <summary>
    /// Struct for a single key-value pair in an origin&apos;s shared storage.
    /// </summary>
    public partial class SharedStorageEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key
        /// </summary>
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Key
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Details for an origin&apos;s shared storage.
    /// </summary>
    public partial class SharedStorageMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CreationTime
        /// </summary>
        [JsonPropertyName("creationTime")]
        public double CreationTime
        {
            get;
            set;
        }

        /// <summary>
        /// Length
        /// </summary>
        [JsonPropertyName("length")]
        public int Length
        {
            get;
            set;
        }

        /// <summary>
        /// RemainingBudget
        /// </summary>
        [JsonPropertyName("remainingBudget")]
        public double RemainingBudget
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Pair of reporting metadata details for a candidate URL for `selectURL()`.
    /// </summary>
    public partial class SharedStorageReportingMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// EventType
        /// </summary>
        [JsonPropertyName("eventType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string EventType
        {
            get;
            set;
        }

        /// <summary>
        /// ReportingUrl
        /// </summary>
        [JsonPropertyName("reportingUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ReportingUrl
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Bundles a candidate URL with its reporting metadata.
    /// </summary>
    public partial class SharedStorageUrlWithMetadata : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Spec of candidate URL.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Any associated reporting metadata.
        /// </summary>
        [JsonPropertyName("reportingMetadata")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Storage.SharedStorageReportingMetadata> ReportingMetadata
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Bundles the parameters for shared storage access events whose
    /// presence/absence can vary according to SharedStorageAccessType.
    /// </summary>
    public partial class SharedStorageAccessParams : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Spec of the module script URL.
        /// Present only for SharedStorageAccessType.documentAddModule.
        /// </summary>
        [JsonPropertyName("scriptSourceUrl")]
        public string ScriptSourceUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the registered operation to be run.
        /// Present only for SharedStorageAccessType.documentRun and
        /// SharedStorageAccessType.documentSelectURL.
        /// </summary>
        [JsonPropertyName("operationName")]
        public string OperationName
        {
            get;
            set;
        }

        /// <summary>
        /// The operation&apos;s serialized data in bytes (converted to a string).
        /// Present only for SharedStorageAccessType.documentRun and
        /// SharedStorageAccessType.documentSelectURL.
        /// </summary>
        [JsonPropertyName("serializedData")]
        public string SerializedData
        {
            get;
            set;
        }

        /// <summary>
        /// Array of candidate URLs&apos; specs, along with any associated metadata.
        /// Present only for SharedStorageAccessType.documentSelectURL.
        /// </summary>
        [JsonPropertyName("urlsWithMetadata")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Storage.SharedStorageUrlWithMetadata> UrlsWithMetadata
        {
            get;
            set;
        }

        /// <summary>
        /// Key for a specific entry in an origin&apos;s shared storage.
        /// Present only for SharedStorageAccessType.documentSet,
        /// SharedStorageAccessType.documentAppend,
        /// SharedStorageAccessType.documentDelete,
        /// SharedStorageAccessType.workletSet,
        /// SharedStorageAccessType.workletAppend,
        /// SharedStorageAccessType.workletDelete, and
        /// SharedStorageAccessType.workletGet.
        /// </summary>
        [JsonPropertyName("key")]
        public string Key
        {
            get;
            set;
        }

        /// <summary>
        /// Value for a specific entry in an origin&apos;s shared storage.
        /// Present only for SharedStorageAccessType.documentSet,
        /// SharedStorageAccessType.documentAppend,
        /// SharedStorageAccessType.workletSet, and
        /// SharedStorageAccessType.workletAppend.
        /// </summary>
        [JsonPropertyName("value")]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Whether or not to set an entry for a key if that key is already present.
        /// Present only for SharedStorageAccessType.documentSet and
        /// SharedStorageAccessType.workletSet.
        /// </summary>
        [JsonPropertyName("ignoreIfPresent")]
        public bool? IgnoreIfPresent
        {
            get;
            set;
        }
    }

    /// <summary>
    /// StorageBucketsDurability
    /// </summary>
    public enum StorageBucketsDurability
    {
        /// <summary>
        /// relaxed
        /// </summary>
        [JsonPropertyName("relaxed")]
        Relaxed,
        /// <summary>
        /// strict
        /// </summary>
        [JsonPropertyName("strict")]
        Strict
    }

    /// <summary>
    /// StorageBucketInfo
    /// </summary>
    public partial class StorageBucketInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// StorageKey
        /// </summary>
        [JsonPropertyName("storageKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StorageKey
        {
            get;
            set;
        }

        /// <summary>
        /// Id
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// IsDefault
        /// </summary>
        [JsonPropertyName("isDefault")]
        public bool IsDefault
        {
            get;
            set;
        }

        /// <summary>
        /// Expiration
        /// </summary>
        [JsonPropertyName("expiration")]
        public double Expiration
        {
            get;
            set;
        }

        /// <summary>
        /// Storage quota (bytes).
        /// </summary>
        [JsonPropertyName("quota")]
        public double Quota
        {
            get;
            set;
        }

        /// <summary>
        /// Persistent
        /// </summary>
        [JsonPropertyName("persistent")]
        public bool Persistent
        {
            get;
            set;
        }

        /// <summary>
        /// Durability
        /// </summary>
        [JsonPropertyName("durability")]
        public CefSharp.DevTools.Storage.StorageBucketsDurability Durability
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A cache&apos;s contents have been modified.
    /// </summary>
    public class CacheStorageContentUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Origin to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            private set;
        }

        /// <summary>
        /// Storage key to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StorageKey
        {
            get;
            private set;
        }

        /// <summary>
        /// Name of cache in origin.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cacheName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CacheName
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// A cache has been added/deleted.
    /// </summary>
    public class CacheStorageListUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Origin to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            private set;
        }

        /// <summary>
        /// Storage key to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StorageKey
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// The origin&apos;s IndexedDB object store has been modified.
    /// </summary>
    public class IndexedDBContentUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Origin to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            private set;
        }

        /// <summary>
        /// Storage key to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StorageKey
        {
            get;
            private set;
        }

        /// <summary>
        /// Database to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("databaseName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DatabaseName
        {
            get;
            private set;
        }

        /// <summary>
        /// ObjectStore to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("objectStoreName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ObjectStoreName
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// The origin&apos;s IndexedDB database list has been modified.
    /// </summary>
    public class IndexedDBListUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Origin to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            private set;
        }

        /// <summary>
        /// Storage key to update.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string StorageKey
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// One of the interest groups was accessed by the associated page.
    /// </summary>
    public class InterestGroupAccessedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// AccessTime
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("accessTime")]
        public double AccessTime
        {
            get;
            private set;
        }

        /// <summary>
        /// Type
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Storage.InterestGroupAccessType Type
        {
            get;
            private set;
        }

        /// <summary>
        /// OwnerOrigin
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("ownerOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string OwnerOrigin
        {
            get;
            private set;
        }

        /// <summary>
        /// Name
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Shared storage was accessed by the associated page.
    /// The following parameters are included in all events.
    /// </summary>
    public class SharedStorageAccessedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Time of the access.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("accessTime")]
        public double AccessTime
        {
            get;
            private set;
        }

        /// <summary>
        /// Enum value indicating the Shared Storage API method invoked.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Storage.SharedStorageAccessType Type
        {
            get;
            private set;
        }

        /// <summary>
        /// DevTools Frame Token for the primary frame tree&apos;s root.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("mainFrameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string MainFrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// Serialized origin for the context that invoked the Shared Storage API.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("ownerOrigin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string OwnerOrigin
        {
            get;
            private set;
        }

        /// <summary>
        /// The sub-parameters warapped by `params` are all optional and their
        /// presence/absence depends on `type`.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("params")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Storage.SharedStorageAccessParams Params
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// storageBucketCreatedOrUpdated
    /// </summary>
    public class StorageBucketCreatedOrUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Bucket
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("bucket")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Storage.StorageBucketInfo Bucket
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// storageBucketDeleted
    /// </summary>
    public class StorageBucketDeletedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// BucketId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("bucketId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string BucketId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// Describes a single graphics processor (GPU).
    /// </summary>
    public partial class GPUDevice : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// PCI ID of the GPU vendor, if available; 0 otherwise.
        /// </summary>
        [JsonPropertyName("vendorId")]
        public double VendorId
        {
            get;
            set;
        }

        /// <summary>
        /// PCI ID of the GPU device, if available; 0 otherwise.
        /// </summary>
        [JsonPropertyName("deviceId")]
        public double DeviceId
        {
            get;
            set;
        }

        /// <summary>
        /// Sub sys ID of the GPU, only available on Windows.
        /// </summary>
        [JsonPropertyName("subSysId")]
        public double? SubSysId
        {
            get;
            set;
        }

        /// <summary>
        /// Revision of the GPU, only available on Windows.
        /// </summary>
        [JsonPropertyName("revision")]
        public double? Revision
        {
            get;
            set;
        }

        /// <summary>
        /// String description of the GPU vendor, if the PCI ID is not available.
        /// </summary>
        [JsonPropertyName("vendorString")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string VendorString
        {
            get;
            set;
        }

        /// <summary>
        /// String description of the GPU device, if the PCI ID is not available.
        /// </summary>
        [JsonPropertyName("deviceString")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DeviceString
        {
            get;
            set;
        }

        /// <summary>
        /// String description of the GPU driver vendor.
        /// </summary>
        [JsonPropertyName("driverVendor")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DriverVendor
        {
            get;
            set;
        }

        /// <summary>
        /// String description of the GPU driver version.
        /// </summary>
        [JsonPropertyName("driverVersion")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DriverVersion
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Describes the width and height dimensions of an entity.
    /// </summary>
    public partial class Size : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Width in pixels.
        /// </summary>
        [JsonPropertyName("width")]
        public int Width
        {
            get;
            set;
        }

        /// <summary>
        /// Height in pixels.
        /// </summary>
        [JsonPropertyName("height")]
        public int Height
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Describes a supported video decoding profile with its associated minimum and
    /// maximum resolutions.
    /// </summary>
    public partial class VideoDecodeAcceleratorCapability : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Video codec profile that is supported, e.g. VP9 Profile 2.
        /// </summary>
        [JsonPropertyName("profile")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Profile
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum video dimensions in pixels supported for this |profile|.
        /// </summary>
        [JsonPropertyName("maxResolution")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MaxResolution
        {
            get;
            set;
        }

        /// <summary>
        /// Minimum video dimensions in pixels supported for this |profile|.
        /// </summary>
        [JsonPropertyName("minResolution")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MinResolution
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Describes a supported video encoding profile with its associated maximum
    /// resolution and maximum framerate.
    /// </summary>
    public partial class VideoEncodeAcceleratorCapability : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Video codec profile that is supported, e.g H264 Main.
        /// </summary>
        [JsonPropertyName("profile")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Profile
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum video dimensions in pixels supported for this |profile|.
        /// </summary>
        [JsonPropertyName("maxResolution")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MaxResolution
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum encoding framerate in frames per second supported for this
        /// |profile|, as fraction&apos;s numerator and denominator, e.g. 24/1 fps,
        /// 24000/1001 fps, etc.
        /// </summary>
        [JsonPropertyName("maxFramerateNumerator")]
        public int MaxFramerateNumerator
        {
            get;
            set;
        }

        /// <summary>
        /// MaxFramerateDenominator
        /// </summary>
        [JsonPropertyName("maxFramerateDenominator")]
        public int MaxFramerateDenominator
        {
            get;
            set;
        }
    }

    /// <summary>
    /// YUV subsampling type of the pixels of a given image.
    /// </summary>
    public enum SubsamplingFormat
    {
        /// <summary>
        /// yuv420
        /// </summary>
        [JsonPropertyName("yuv420")]
        Yuv420,
        /// <summary>
        /// yuv422
        /// </summary>
        [JsonPropertyName("yuv422")]
        Yuv422,
        /// <summary>
        /// yuv444
        /// </summary>
        [JsonPropertyName("yuv444")]
        Yuv444
    }

    /// <summary>
    /// Image format of a given image.
    /// </summary>
    public enum ImageType
    {
        /// <summary>
        /// jpeg
        /// </summary>
        [JsonPropertyName("jpeg")]
        Jpeg,
        /// <summary>
        /// webp
        /// </summary>
        [JsonPropertyName("webp")]
        Webp,
        /// <summary>
        /// unknown
        /// </summary>
        [JsonPropertyName("unknown")]
        Unknown
    }

    /// <summary>
    /// Describes a supported image decoding profile with its associated minimum and
    /// maximum resolutions and subsampling.
    /// </summary>
    public partial class ImageDecodeAcceleratorCapability : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Image coded, e.g. Jpeg.
        /// </summary>
        [JsonPropertyName("imageType")]
        public CefSharp.DevTools.SystemInfo.ImageType ImageType
        {
            get;
            set;
        }

        /// <summary>
        /// Maximum supported dimensions of the image in pixels.
        /// </summary>
        [JsonPropertyName("maxDimensions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MaxDimensions
        {
            get;
            set;
        }

        /// <summary>
        /// Minimum supported dimensions of the image in pixels.
        /// </summary>
        [JsonPropertyName("minDimensions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.SystemInfo.Size MinDimensions
        {
            get;
            set;
        }

        /// <summary>
        /// Optional array of supported subsampling formats, e.g. 4:2:0, if known.
        /// </summary>
        [JsonPropertyName("subsamplings")]
        public CefSharp.DevTools.SystemInfo.SubsamplingFormat[] Subsamplings
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Provides information about the GPU(s) on the system.
    /// </summary>
    public partial class GPUInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The graphics devices on the system. Element 0 is the primary GPU.
        /// </summary>
        [JsonPropertyName("devices")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.GPUDevice> Devices
        {
            get;
            set;
        }

        /// <summary>
        /// An optional dictionary of additional GPU related attributes.
        /// </summary>
        [JsonPropertyName("auxAttributes")]
        public object AuxAttributes
        {
            get;
            set;
        }

        /// <summary>
        /// An optional dictionary of graphics features and their status.
        /// </summary>
        [JsonPropertyName("featureStatus")]
        public object FeatureStatus
        {
            get;
            set;
        }

        /// <summary>
        /// An optional array of GPU driver bug workarounds.
        /// </summary>
        [JsonPropertyName("driverBugWorkarounds")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] DriverBugWorkarounds
        {
            get;
            set;
        }

        /// <summary>
        /// Supported accelerated video decoding capabilities.
        /// </summary>
        [JsonPropertyName("videoDecoding")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.VideoDecodeAcceleratorCapability> VideoDecoding
        {
            get;
            set;
        }

        /// <summary>
        /// Supported accelerated video encoding capabilities.
        /// </summary>
        [JsonPropertyName("videoEncoding")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.VideoEncodeAcceleratorCapability> VideoEncoding
        {
            get;
            set;
        }

        /// <summary>
        /// Supported accelerated image decoding capabilities.
        /// </summary>
        [JsonPropertyName("imageDecoding")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.ImageDecodeAcceleratorCapability> ImageDecoding
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Represents process info.
    /// </summary>
    public partial class ProcessInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Specifies process type.
        /// </summary>
        [JsonPropertyName("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies process id.
        /// </summary>
        [JsonPropertyName("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// Specifies cumulative CPU usage in seconds across all threads of the
        /// process since the process start.
        /// </summary>
        [JsonPropertyName("cpuTime")]
        public double CpuTime
        {
            get;
            set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// TargetInfo
    /// </summary>
    public partial class TargetInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// TargetId
        /// </summary>
        [JsonPropertyName("targetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TargetId
        {
            get;
            set;
        }

        /// <summary>
        /// Type
        /// </summary>
        [JsonPropertyName("type")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Type
        {
            get;
            set;
        }

        /// <summary>
        /// Title
        /// </summary>
        [JsonPropertyName("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// Url
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the target has an attached client.
        /// </summary>
        [JsonPropertyName("attached")]
        public bool Attached
        {
            get;
            set;
        }

        /// <summary>
        /// Opener target Id
        /// </summary>
        [JsonPropertyName("openerId")]
        public string OpenerId
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the target has access to the originating window.
        /// </summary>
        [JsonPropertyName("canAccessOpener")]
        public bool CanAccessOpener
        {
            get;
            set;
        }

        /// <summary>
        /// Frame id of originating window (is only set if target has an opener).
        /// </summary>
        [JsonPropertyName("openerFrameId")]
        public string OpenerFrameId
        {
            get;
            set;
        }

        /// <summary>
        /// BrowserContextId
        /// </summary>
        [JsonPropertyName("browserContextId")]
        public string BrowserContextId
        {
            get;
            set;
        }

        /// <summary>
        /// Provides additional details for specific target types. For example, for
        /// the type of &quot;page&quot;, this may be set to &quot;portal&quot; or &quot;prerender&quot;.
        /// </summary>
        [JsonPropertyName("subtype")]
        public string Subtype
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A filter used by target query/discovery/auto-attach operations.
    /// </summary>
    public partial class FilterEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// If set, causes exclusion of mathcing targets from the list.
        /// </summary>
        [JsonPropertyName("exclude")]
        public bool? Exclude
        {
            get;
            set;
        }

        /// <summary>
        /// If not present, matches any type.
        /// </summary>
        [JsonPropertyName("type")]
        public string Type
        {
            get;
            set;
        }
    }

    /// <summary>
    /// RemoteLocation
    /// </summary>
    public partial class RemoteLocation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Host
        /// </summary>
        [JsonPropertyName("host")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Host
        {
            get;
            set;
        }

        /// <summary>
        /// Port
        /// </summary>
        [JsonPropertyName("port")]
        public int Port
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Issued when attached to target because of auto-attach or `attachToTarget` command.
    /// </summary>
    public class AttachedToTargetEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Identifier assigned to the session used to send/receive messages.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sessionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SessionId
        {
            get;
            private set;
        }

        /// <summary>
        /// TargetInfo
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetInfo")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Target.TargetInfo TargetInfo
        {
            get;
            private set;
        }

        /// <summary>
        /// WaitingForDebugger
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("waitingForDebugger")]
        public bool WaitingForDebugger
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when detached from target for any reason (including `detachFromTarget` command). Can be
    /// issued multiple times per target if multiple sessions have been attached to it.
    /// </summary>
    public class DetachedFromTargetEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Detached session identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sessionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SessionId
        {
            get;
            private set;
        }

        /// <summary>
        /// Deprecated.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetId")]
        public string TargetId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies about a new protocol message received from the session (as reported in
    /// `attachedToTarget` event).
    /// </summary>
    public class ReceivedMessageFromTargetEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Identifier of a session which sends a message.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sessionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SessionId
        {
            get;
            private set;
        }

        /// <summary>
        /// Message
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            private set;
        }

        /// <summary>
        /// Deprecated.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetId")]
        public string TargetId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when a possible inspection target is created.
    /// </summary>
    public class TargetCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// TargetInfo
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetInfo")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Target.TargetInfo TargetInfo
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when a target is destroyed.
    /// </summary>
    public class TargetDestroyedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// TargetId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TargetId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when a target has crashed.
    /// </summary>
    public class TargetCrashedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// TargetId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string TargetId
        {
            get;
            private set;
        }

        /// <summary>
        /// Termination status type.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("status")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Status
        {
            get;
            private set;
        }

        /// <summary>
        /// Termination error code.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errorCode")]
        public int ErrorCode
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when some information about a target has changed. This only happens between
    /// `targetCreated` and `targetDestroyed`.
    /// </summary>
    public class TargetInfoChangedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// TargetInfo
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetInfo")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Target.TargetInfo TargetInfo
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Tethering
{
    /// <summary>
    /// Informs that port was successfully bound and got a specified connection id.
    /// </summary>
    public class AcceptedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Port number that was successfully bound.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("port")]
        public int Port
        {
            get;
            private set;
        }

        /// <summary>
        /// Connection id to be used.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("connectionId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ConnectionId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    /// <summary>
    /// Controls how the trace buffer stores data.
    /// </summary>
    public enum TraceConfigRecordMode
    {
        /// <summary>
        /// recordUntilFull
        /// </summary>
        [JsonPropertyName("recordUntilFull")]
        RecordUntilFull,
        /// <summary>
        /// recordContinuously
        /// </summary>
        [JsonPropertyName("recordContinuously")]
        RecordContinuously,
        /// <summary>
        /// recordAsMuchAsPossible
        /// </summary>
        [JsonPropertyName("recordAsMuchAsPossible")]
        RecordAsMuchAsPossible,
        /// <summary>
        /// echoToConsole
        /// </summary>
        [JsonPropertyName("echoToConsole")]
        EchoToConsole
    }

    /// <summary>
    /// TraceConfig
    /// </summary>
    public partial class TraceConfig : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Controls how the trace buffer stores data.
        /// </summary>
        [JsonPropertyName("recordMode")]
        public CefSharp.DevTools.Tracing.TraceConfigRecordMode? RecordMode
        {
            get;
            set;
        }

        /// <summary>
        /// Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value
        /// of 200 MB would be used.
        /// </summary>
        [JsonPropertyName("traceBufferSizeInKb")]
        public double? TraceBufferSizeInKb
        {
            get;
            set;
        }

        /// <summary>
        /// Turns on JavaScript stack sampling.
        /// </summary>
        [JsonPropertyName("enableSampling")]
        public bool? EnableSampling
        {
            get;
            set;
        }

        /// <summary>
        /// Turns on system tracing.
        /// </summary>
        [JsonPropertyName("enableSystrace")]
        public bool? EnableSystrace
        {
            get;
            set;
        }

        /// <summary>
        /// Turns on argument filter.
        /// </summary>
        [JsonPropertyName("enableArgumentFilter")]
        public bool? EnableArgumentFilter
        {
            get;
            set;
        }

        /// <summary>
        /// Included category filters.
        /// </summary>
        [JsonPropertyName("includedCategories")]
        public string[] IncludedCategories
        {
            get;
            set;
        }

        /// <summary>
        /// Excluded category filters.
        /// </summary>
        [JsonPropertyName("excludedCategories")]
        public string[] ExcludedCategories
        {
            get;
            set;
        }

        /// <summary>
        /// Configuration to synthesize the delays in tracing.
        /// </summary>
        [JsonPropertyName("syntheticDelays")]
        public string[] SyntheticDelays
        {
            get;
            set;
        }

        /// <summary>
        /// Configuration for memory dump triggers. Used only when &quot;memory-infra&quot; category is enabled.
        /// </summary>
        [JsonPropertyName("memoryDumpConfig")]
        public CefSharp.DevTools.Tracing.MemoryDumpConfig MemoryDumpConfig
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Data format of a trace. Can be either the legacy JSON format or the
    /// protocol buffer format. Note that the JSON format will be deprecated soon.
    /// </summary>
    public enum StreamFormat
    {
        /// <summary>
        /// json
        /// </summary>
        [JsonPropertyName("json")]
        Json,
        /// <summary>
        /// proto
        /// </summary>
        [JsonPropertyName("proto")]
        Proto
    }

    /// <summary>
    /// Compression type to use for traces returned via streams.
    /// </summary>
    public enum StreamCompression
    {
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None,
        /// <summary>
        /// gzip
        /// </summary>
        [JsonPropertyName("gzip")]
        Gzip
    }

    /// <summary>
    /// Details exposed when memory request explicitly declared.
    /// Keep consistent with memory_dump_request_args.h and
    /// memory_instrumentation.mojom
    /// </summary>
    public enum MemoryDumpLevelOfDetail
    {
        /// <summary>
        /// background
        /// </summary>
        [JsonPropertyName("background")]
        Background,
        /// <summary>
        /// light
        /// </summary>
        [JsonPropertyName("light")]
        Light,
        /// <summary>
        /// detailed
        /// </summary>
        [JsonPropertyName("detailed")]
        Detailed
    }

    /// <summary>
    /// Backend type to use for tracing. `chrome` uses the Chrome-integrated
    /// tracing service and is supported on all platforms. `system` is only
    /// supported on Chrome OS and uses the Perfetto system tracing service.
    /// `auto` chooses `system` when the perfettoConfig provided to Tracing.start
    /// specifies at least one non-Chrome data source; otherwise uses `chrome`.
    /// </summary>
    public enum TracingBackend
    {
        /// <summary>
        /// auto
        /// </summary>
        [JsonPropertyName("auto")]
        Auto,
        /// <summary>
        /// chrome
        /// </summary>
        [JsonPropertyName("chrome")]
        Chrome,
        /// <summary>
        /// system
        /// </summary>
        [JsonPropertyName("system")]
        System
    }

    /// <summary>
    /// bufferUsage
    /// </summary>
    public class BufferUsageEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// A number in range [0..1] that indicates the used size of event buffer as a fraction of its
        /// total size.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("percentFull")]
        public double? PercentFull
        {
            get;
            private set;
        }

        /// <summary>
        /// An approximate number of events in the trace log.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("eventCount")]
        public double? EventCount
        {
            get;
            private set;
        }

        /// <summary>
        /// A number in range [0..1] that indicates the used size of event buffer as a fraction of its
        /// total size.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("value")]
        public double? Value
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Contains a bucket of collected trace events. When tracing is stopped collected events will be
    /// sent as a sequence of dataCollected events followed by tracingComplete event.
    /// </summary>
    public class DataCollectedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Value
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<object> Value
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Signals that tracing is stopped and there is no trace buffers pending flush, all data were
    /// delivered via dataCollected events.
    /// </summary>
    public class TracingCompleteEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Indicates whether some trace data is known to have been lost, e.g. because the trace ring
        /// buffer wrapped around.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("dataLossOccurred")]
        public bool DataLossOccurred
        {
            get;
            private set;
        }

        /// <summary>
        /// A handle of the stream that holds resulting trace data.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stream")]
        public string Stream
        {
            get;
            private set;
        }

        /// <summary>
        /// Trace data format of returned stream.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("traceFormat")]
        public CefSharp.DevTools.Tracing.StreamFormat? TraceFormat
        {
            get;
            private set;
        }

        /// <summary>
        /// Compression format of returned stream.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("streamCompression")]
        public CefSharp.DevTools.Tracing.StreamCompression? StreamCompression
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// Stages of the request to handle. Request will intercept before the request is
    /// sent. Response will intercept after the response is received (but before response
    /// body is received).
    /// </summary>
    public enum RequestStage
    {
        /// <summary>
        /// Request
        /// </summary>
        [JsonPropertyName("Request")]
        Request,
        /// <summary>
        /// Response
        /// </summary>
        [JsonPropertyName("Response")]
        Response
    }

    /// <summary>
    /// RequestPattern
    /// </summary>
    public partial class RequestPattern : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Wildcards (`&apos;*&apos;` -&gt; zero or more, `&apos;?&apos;` -&gt; exactly one) are allowed. Escape character is
        /// backslash. Omitting is equivalent to `&quot;*&quot;`.
        /// </summary>
        [JsonPropertyName("urlPattern")]
        public string UrlPattern
        {
            get;
            set;
        }

        /// <summary>
        /// If set, only requests for matching resource types will be intercepted.
        /// </summary>
        [JsonPropertyName("resourceType")]
        public CefSharp.DevTools.Network.ResourceType? ResourceType
        {
            get;
            set;
        }

        /// <summary>
        /// Stage at which to begin intercepting requests. Default is Request.
        /// </summary>
        [JsonPropertyName("requestStage")]
        public CefSharp.DevTools.Fetch.RequestStage? RequestStage
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Response HTTP header entry
    /// </summary>
    public partial class HeaderEntry : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Source of the authentication challenge.
    /// </summary>
    public enum AuthChallengeSource
    {
        /// <summary>
        /// Server
        /// </summary>
        [JsonPropertyName("Server")]
        Server,
        /// <summary>
        /// Proxy
        /// </summary>
        [JsonPropertyName("Proxy")]
        Proxy
    }

    /// <summary>
    /// Authorization challenge for HTTP status code 401 or 407.
    /// </summary>
    public partial class AuthChallenge : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Source of the authentication challenge.
        /// </summary>
        [JsonPropertyName("source")]
        public CefSharp.DevTools.Fetch.AuthChallengeSource? Source
        {
            get;
            set;
        }

        /// <summary>
        /// Origin of the challenger.
        /// </summary>
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// The authentication scheme used, such as basic or digest
        /// </summary>
        [JsonPropertyName("scheme")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Scheme
        {
            get;
            set;
        }

        /// <summary>
        /// The realm of the challenge. May be empty.
        /// </summary>
        [JsonPropertyName("realm")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Realm
        {
            get;
            set;
        }
    }

    /// <summary>
    /// The decision on what to do in response to the authorization challenge.  Default means
    /// deferring to the default behavior of the net stack, which will likely either the Cancel
    /// authentication or display a popup dialog box.
    /// </summary>
    public enum AuthChallengeResponseResponse
    {
        /// <summary>
        /// Default
        /// </summary>
        [JsonPropertyName("Default")]
        Default,
        /// <summary>
        /// CancelAuth
        /// </summary>
        [JsonPropertyName("CancelAuth")]
        CancelAuth,
        /// <summary>
        /// ProvideCredentials
        /// </summary>
        [JsonPropertyName("ProvideCredentials")]
        ProvideCredentials
    }

    /// <summary>
    /// Response to an AuthChallenge.
    /// </summary>
    public partial class AuthChallengeResponse : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The decision on what to do in response to the authorization challenge.  Default means
        /// deferring to the default behavior of the net stack, which will likely either the Cancel
        /// authentication or display a popup dialog box.
        /// </summary>
        [JsonPropertyName("response")]
        public CefSharp.DevTools.Fetch.AuthChallengeResponseResponse Response
        {
            get;
            set;
        }

        /// <summary>
        /// The username to provide, possibly empty. Should only be set if response is
        /// ProvideCredentials.
        /// </summary>
        [JsonPropertyName("username")]
        public string Username
        {
            get;
            set;
        }

        /// <summary>
        /// The password to provide, possibly empty. Should only be set if response is
        /// ProvideCredentials.
        /// </summary>
        [JsonPropertyName("password")]
        public string Password
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Issued when the domain is enabled and the request URL matches the
    /// specified filter. The request is paused until the client responds
    /// with one of continueRequest, failRequest or fulfillRequest.
    /// The stage of the request can be determined by presence of responseErrorReason
    /// and responseStatusCode -- the request is at the response stage if either
    /// of these fields is present and in the request stage otherwise.
    /// </summary>
    public class RequestPausedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Each request the page makes will have a unique id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// The details of the request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("request")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Request Request
        {
            get;
            private set;
        }

        /// <summary>
        /// The id of the frame that initiated the request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// How the requested resource will be used.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("resourceType")]
        public CefSharp.DevTools.Network.ResourceType ResourceType
        {
            get;
            private set;
        }

        /// <summary>
        /// Response error if intercepted at response stage.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("responseErrorReason")]
        public CefSharp.DevTools.Network.ErrorReason? ResponseErrorReason
        {
            get;
            private set;
        }

        /// <summary>
        /// Response code if intercepted at response stage.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("responseStatusCode")]
        public int? ResponseStatusCode
        {
            get;
            private set;
        }

        /// <summary>
        /// Response status text if intercepted at response stage.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("responseStatusText")]
        public string ResponseStatusText
        {
            get;
            private set;
        }

        /// <summary>
        /// Response headers if intercepted at the response stage.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("responseHeaders")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> ResponseHeaders
        {
            get;
            private set;
        }

        /// <summary>
        /// If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
        /// then this networkId will be the same as the requestId present in the requestWillBeSent event.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("networkId")]
        public string NetworkId
        {
            get;
            private set;
        }

        /// <summary>
        /// If the request is due to a redirect response from the server, the id of the request that
        /// has caused the redirect.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("redirectedRequestId")]
        public string RedirectedRequestId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when the domain is enabled with handleAuthRequests set to true.
    /// The request is paused until client responds with continueWithAuth.
    /// </summary>
    public class AuthRequiredEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Each request the page makes will have a unique id.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("requestId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string RequestId
        {
            get;
            private set;
        }

        /// <summary>
        /// The details of the request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("request")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Network.Request Request
        {
            get;
            private set;
        }

        /// <summary>
        /// The id of the frame that initiated the request.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// How the requested resource will be used.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("resourceType")]
        public CefSharp.DevTools.Network.ResourceType ResourceType
        {
            get;
            private set;
        }

        /// <summary>
        /// Details of the Authorization Challenge encountered.
        /// If this is set, client should respond with continueRequest that
        /// contains AuthChallengeResponse.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("authChallenge")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Fetch.AuthChallenge AuthChallenge
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// Enum of BaseAudioContext types
    /// </summary>
    public enum ContextType
    {
        /// <summary>
        /// realtime
        /// </summary>
        [JsonPropertyName("realtime")]
        Realtime,
        /// <summary>
        /// offline
        /// </summary>
        [JsonPropertyName("offline")]
        Offline
    }

    /// <summary>
    /// Enum of AudioContextState from the spec
    /// </summary>
    public enum ContextState
    {
        /// <summary>
        /// suspended
        /// </summary>
        [JsonPropertyName("suspended")]
        Suspended,
        /// <summary>
        /// running
        /// </summary>
        [JsonPropertyName("running")]
        Running,
        /// <summary>
        /// closed
        /// </summary>
        [JsonPropertyName("closed")]
        Closed
    }

    /// <summary>
    /// Enum of AudioNode::ChannelCountMode from the spec
    /// </summary>
    public enum ChannelCountMode
    {
        /// <summary>
        /// clamped-max
        /// </summary>
        [JsonPropertyName("clamped-max")]
        ClampedMax,
        /// <summary>
        /// explicit
        /// </summary>
        [JsonPropertyName("explicit")]
        Explicit,
        /// <summary>
        /// max
        /// </summary>
        [JsonPropertyName("max")]
        Max
    }

    /// <summary>
    /// Enum of AudioNode::ChannelInterpretation from the spec
    /// </summary>
    public enum ChannelInterpretation
    {
        /// <summary>
        /// discrete
        /// </summary>
        [JsonPropertyName("discrete")]
        Discrete,
        /// <summary>
        /// speakers
        /// </summary>
        [JsonPropertyName("speakers")]
        Speakers
    }

    /// <summary>
    /// Enum of AudioParam::AutomationRate from the spec
    /// </summary>
    public enum AutomationRate
    {
        /// <summary>
        /// a-rate
        /// </summary>
        [JsonPropertyName("a-rate")]
        ARate,
        /// <summary>
        /// k-rate
        /// </summary>
        [JsonPropertyName("k-rate")]
        KRate
    }

    /// <summary>
    /// Fields in AudioContext that change in real-time.
    /// </summary>
    public partial class ContextRealtimeData : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The current context time in second in BaseAudioContext.
        /// </summary>
        [JsonPropertyName("currentTime")]
        public double CurrentTime
        {
            get;
            set;
        }

        /// <summary>
        /// The time spent on rendering graph divided by render quantum duration,
        /// and multiplied by 100. 100 means the audio renderer reached the full
        /// capacity and glitch may occur.
        /// </summary>
        [JsonPropertyName("renderCapacity")]
        public double RenderCapacity
        {
            get;
            set;
        }

        /// <summary>
        /// A running mean of callback interval.
        /// </summary>
        [JsonPropertyName("callbackIntervalMean")]
        public double CallbackIntervalMean
        {
            get;
            set;
        }

        /// <summary>
        /// A running variance of callback interval.
        /// </summary>
        [JsonPropertyName("callbackIntervalVariance")]
        public double CallbackIntervalVariance
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Protocol object for BaseAudioContext
    /// </summary>
    public partial class BaseAudioContext : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            set;
        }

        /// <summary>
        /// ContextType
        /// </summary>
        [JsonPropertyName("contextType")]
        public CefSharp.DevTools.WebAudio.ContextType ContextType
        {
            get;
            set;
        }

        /// <summary>
        /// ContextState
        /// </summary>
        [JsonPropertyName("contextState")]
        public CefSharp.DevTools.WebAudio.ContextState ContextState
        {
            get;
            set;
        }

        /// <summary>
        /// RealtimeData
        /// </summary>
        [JsonPropertyName("realtimeData")]
        public CefSharp.DevTools.WebAudio.ContextRealtimeData RealtimeData
        {
            get;
            set;
        }

        /// <summary>
        /// Platform-dependent callback buffer size.
        /// </summary>
        [JsonPropertyName("callbackBufferSize")]
        public double CallbackBufferSize
        {
            get;
            set;
        }

        /// <summary>
        /// Number of output channels supported by audio hardware in use.
        /// </summary>
        [JsonPropertyName("maxOutputChannelCount")]
        public double MaxOutputChannelCount
        {
            get;
            set;
        }

        /// <summary>
        /// Context sample rate.
        /// </summary>
        [JsonPropertyName("sampleRate")]
        public double SampleRate
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Protocol object for AudioListener
    /// </summary>
    public partial class AudioListener : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ListenerId
        /// </summary>
        [JsonPropertyName("listenerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ListenerId
        {
            get;
            set;
        }

        /// <summary>
        /// ContextId
        /// </summary>
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Protocol object for AudioNode
    /// </summary>
    public partial class AudioNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// NodeId
        /// </summary>
        [JsonPropertyName("nodeId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// ContextId
        /// </summary>
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            set;
        }

        /// <summary>
        /// NodeType
        /// </summary>
        [JsonPropertyName("nodeType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeType
        {
            get;
            set;
        }

        /// <summary>
        /// NumberOfInputs
        /// </summary>
        [JsonPropertyName("numberOfInputs")]
        public double NumberOfInputs
        {
            get;
            set;
        }

        /// <summary>
        /// NumberOfOutputs
        /// </summary>
        [JsonPropertyName("numberOfOutputs")]
        public double NumberOfOutputs
        {
            get;
            set;
        }

        /// <summary>
        /// ChannelCount
        /// </summary>
        [JsonPropertyName("channelCount")]
        public double ChannelCount
        {
            get;
            set;
        }

        /// <summary>
        /// ChannelCountMode
        /// </summary>
        [JsonPropertyName("channelCountMode")]
        public CefSharp.DevTools.WebAudio.ChannelCountMode ChannelCountMode
        {
            get;
            set;
        }

        /// <summary>
        /// ChannelInterpretation
        /// </summary>
        [JsonPropertyName("channelInterpretation")]
        public CefSharp.DevTools.WebAudio.ChannelInterpretation ChannelInterpretation
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Protocol object for AudioParam
    /// </summary>
    public partial class AudioParam : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ParamId
        /// </summary>
        [JsonPropertyName("paramId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ParamId
        {
            get;
            set;
        }

        /// <summary>
        /// NodeId
        /// </summary>
        [JsonPropertyName("nodeId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// ContextId
        /// </summary>
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            set;
        }

        /// <summary>
        /// ParamType
        /// </summary>
        [JsonPropertyName("paramType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ParamType
        {
            get;
            set;
        }

        /// <summary>
        /// Rate
        /// </summary>
        [JsonPropertyName("rate")]
        public CefSharp.DevTools.WebAudio.AutomationRate Rate
        {
            get;
            set;
        }

        /// <summary>
        /// DefaultValue
        /// </summary>
        [JsonPropertyName("defaultValue")]
        public double DefaultValue
        {
            get;
            set;
        }

        /// <summary>
        /// MinValue
        /// </summary>
        [JsonPropertyName("minValue")]
        public double MinValue
        {
            get;
            set;
        }

        /// <summary>
        /// MaxValue
        /// </summary>
        [JsonPropertyName("maxValue")]
        public double MaxValue
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Notifies that a new BaseAudioContext has been created.
    /// </summary>
    public class ContextCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Context
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("context")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.WebAudio.BaseAudioContext Context
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that an existing BaseAudioContext will be destroyed.
    /// </summary>
    public class ContextWillBeDestroyedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
    /// </summary>
    public class ContextChangedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Context
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("context")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.WebAudio.BaseAudioContext Context
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that the construction of an AudioListener has finished.
    /// </summary>
    public class AudioListenerCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Listener
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("listener")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.WebAudio.AudioListener Listener
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that a new AudioListener has been created.
    /// </summary>
    public class AudioListenerWillBeDestroyedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// ListenerId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("listenerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ListenerId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that a new AudioNode has been created.
    /// </summary>
    public class AudioNodeCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Node
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("node")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.WebAudio.AudioNode Node
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that an existing AudioNode has been destroyed.
    /// </summary>
    public class AudioNodeWillBeDestroyedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// NodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that a new AudioParam has been created.
    /// </summary>
    public class AudioParamCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Param
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("param")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.WebAudio.AudioParam Param
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that an existing AudioParam has been destroyed.
    /// </summary>
    public class AudioParamWillBeDestroyedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// NodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string NodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// ParamId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("paramId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ParamId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that two AudioNodes are connected.
    /// </summary>
    public class NodesConnectedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// SourceId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceId
        {
            get;
            private set;
        }

        /// <summary>
        /// DestinationId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("destinationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DestinationId
        {
            get;
            private set;
        }

        /// <summary>
        /// SourceOutputIndex
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceOutputIndex")]
        public double? SourceOutputIndex
        {
            get;
            private set;
        }

        /// <summary>
        /// DestinationInputIndex
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("destinationInputIndex")]
        public double? DestinationInputIndex
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
    /// </summary>
    public class NodesDisconnectedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// SourceId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceId
        {
            get;
            private set;
        }

        /// <summary>
        /// DestinationId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("destinationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DestinationId
        {
            get;
            private set;
        }

        /// <summary>
        /// SourceOutputIndex
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceOutputIndex")]
        public double? SourceOutputIndex
        {
            get;
            private set;
        }

        /// <summary>
        /// DestinationInputIndex
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("destinationInputIndex")]
        public double? DestinationInputIndex
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that an AudioNode is connected to an AudioParam.
    /// </summary>
    public class NodeParamConnectedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// SourceId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceId
        {
            get;
            private set;
        }

        /// <summary>
        /// DestinationId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("destinationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DestinationId
        {
            get;
            private set;
        }

        /// <summary>
        /// SourceOutputIndex
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceOutputIndex")]
        public double? SourceOutputIndex
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Notifies that an AudioNode is disconnected to an AudioParam.
    /// </summary>
    public class NodeParamDisconnectedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// ContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contextId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// SourceId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceId
        {
            get;
            private set;
        }

        /// <summary>
        /// DestinationId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("destinationId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DestinationId
        {
            get;
            private set;
        }

        /// <summary>
        /// SourceOutputIndex
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceOutputIndex")]
        public double? SourceOutputIndex
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// AuthenticatorProtocol
    /// </summary>
    public enum AuthenticatorProtocol
    {
        /// <summary>
        /// u2f
        /// </summary>
        [JsonPropertyName("u2f")]
        U2f,
        /// <summary>
        /// ctap2
        /// </summary>
        [JsonPropertyName("ctap2")]
        Ctap2
    }

    /// <summary>
    /// Ctap2Version
    /// </summary>
    public enum Ctap2Version
    {
        /// <summary>
        /// ctap2_0
        /// </summary>
        [JsonPropertyName("ctap2_0")]
        Ctap20,
        /// <summary>
        /// ctap2_1
        /// </summary>
        [JsonPropertyName("ctap2_1")]
        Ctap21
    }

    /// <summary>
    /// AuthenticatorTransport
    /// </summary>
    public enum AuthenticatorTransport
    {
        /// <summary>
        /// usb
        /// </summary>
        [JsonPropertyName("usb")]
        Usb,
        /// <summary>
        /// nfc
        /// </summary>
        [JsonPropertyName("nfc")]
        Nfc,
        /// <summary>
        /// ble
        /// </summary>
        [JsonPropertyName("ble")]
        Ble,
        /// <summary>
        /// cable
        /// </summary>
        [JsonPropertyName("cable")]
        Cable,
        /// <summary>
        /// internal
        /// </summary>
        [JsonPropertyName("internal")]
        Internal
    }

    /// <summary>
    /// VirtualAuthenticatorOptions
    /// </summary>
    public partial class VirtualAuthenticatorOptions : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Protocol
        /// </summary>
        [JsonPropertyName("protocol")]
        public CefSharp.DevTools.WebAuthn.AuthenticatorProtocol Protocol
        {
            get;
            set;
        }

        /// <summary>
        /// Defaults to ctap2_0. Ignored if |protocol| == u2f.
        /// </summary>
        [JsonPropertyName("ctap2Version")]
        public CefSharp.DevTools.WebAuthn.Ctap2Version? Ctap2Version
        {
            get;
            set;
        }

        /// <summary>
        /// Transport
        /// </summary>
        [JsonPropertyName("transport")]
        public CefSharp.DevTools.WebAuthn.AuthenticatorTransport Transport
        {
            get;
            set;
        }

        /// <summary>
        /// Defaults to false.
        /// </summary>
        [JsonPropertyName("hasResidentKey")]
        public bool? HasResidentKey
        {
            get;
            set;
        }

        /// <summary>
        /// Defaults to false.
        /// </summary>
        [JsonPropertyName("hasUserVerification")]
        public bool? HasUserVerification
        {
            get;
            set;
        }

        /// <summary>
        /// If set to true, the authenticator will support the largeBlob extension.
        /// https://w3c.github.io/webauthn#largeBlob
        /// Defaults to false.
        /// </summary>
        [JsonPropertyName("hasLargeBlob")]
        public bool? HasLargeBlob
        {
            get;
            set;
        }

        /// <summary>
        /// If set to true, the authenticator will support the credBlob extension.
        /// https://fidoalliance.org/specs/fido-v2.1-rd-20201208/fido-client-to-authenticator-protocol-v2.1-rd-20201208.html#sctn-credBlob-extension
        /// Defaults to false.
        /// </summary>
        [JsonPropertyName("hasCredBlob")]
        public bool? HasCredBlob
        {
            get;
            set;
        }

        /// <summary>
        /// If set to true, the authenticator will support the minPinLength extension.
        /// https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension
        /// Defaults to false.
        /// </summary>
        [JsonPropertyName("hasMinPinLength")]
        public bool? HasMinPinLength
        {
            get;
            set;
        }

        /// <summary>
        /// If set to true, the authenticator will support the prf extension.
        /// https://w3c.github.io/webauthn/#prf-extension
        /// Defaults to false.
        /// </summary>
        [JsonPropertyName("hasPrf")]
        public bool? HasPrf
        {
            get;
            set;
        }

        /// <summary>
        /// If set to true, tests of user presence will succeed immediately.
        /// Otherwise, they will not be resolved. Defaults to true.
        /// </summary>
        [JsonPropertyName("automaticPresenceSimulation")]
        public bool? AutomaticPresenceSimulation
        {
            get;
            set;
        }

        /// <summary>
        /// Sets whether User Verification succeeds or fails for an authenticator.
        /// Defaults to false.
        /// </summary>
        [JsonPropertyName("isUserVerified")]
        public bool? IsUserVerified
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Credential
    /// </summary>
    public partial class Credential : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// CredentialId
        /// </summary>
        [JsonPropertyName("credentialId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] CredentialId
        {
            get;
            set;
        }

        /// <summary>
        /// IsResidentCredential
        /// </summary>
        [JsonPropertyName("isResidentCredential")]
        public bool IsResidentCredential
        {
            get;
            set;
        }

        /// <summary>
        /// Relying Party ID the credential is scoped to. Must be set when adding a
        /// credential.
        /// </summary>
        [JsonPropertyName("rpId")]
        public string RpId
        {
            get;
            set;
        }

        /// <summary>
        /// The ECDSA P-256 private key in PKCS#8 format.
        /// </summary>
        [JsonPropertyName("privateKey")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public byte[] PrivateKey
        {
            get;
            set;
        }

        /// <summary>
        /// An opaque byte sequence with a maximum size of 64 bytes mapping the
        /// credential to a specific user.
        /// </summary>
        [JsonPropertyName("userHandle")]
        public byte[] UserHandle
        {
            get;
            set;
        }

        /// <summary>
        /// Signature counter. This is incremented by one for each successful
        /// assertion.
        /// See https://w3c.github.io/webauthn/#signature-counter
        /// </summary>
        [JsonPropertyName("signCount")]
        public int SignCount
        {
            get;
            set;
        }

        /// <summary>
        /// The large blob associated with the credential.
        /// See https://w3c.github.io/webauthn/#sctn-large-blob-extension
        /// </summary>
        [JsonPropertyName("largeBlob")]
        public byte[] LargeBlob
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Triggered when a credential is added to an authenticator.
    /// </summary>
    public class CredentialAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// AuthenticatorId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("authenticatorId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string AuthenticatorId
        {
            get;
            private set;
        }

        /// <summary>
        /// Credential
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("credential")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.WebAuthn.Credential Credential
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Triggered when a credential is used in a webauthn assertion.
    /// </summary>
    public class CredentialAssertedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// AuthenticatorId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("authenticatorId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string AuthenticatorId
        {
            get;
            private set;
        }

        /// <summary>
        /// Credential
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("credential")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.WebAuthn.Credential Credential
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Media
{
    /// <summary>
    /// Keep in sync with MediaLogMessageLevel
    /// We are currently keeping the message level &apos;error&apos; separate from the
    /// PlayerError type because right now they represent different things,
    /// this one being a DVLOG(ERROR) style log message that gets printed
    /// based on what log level is selected in the UI, and the other is a
    /// representation of a media::PipelineStatus object. Soon however we&apos;re
    /// going to be moving away from using PipelineStatus for errors and
    /// introducing a new error type which should hopefully let us integrate
    /// the error log level into the PlayerError type.
    /// </summary>
    public enum PlayerMessageLevel
    {
        /// <summary>
        /// error
        /// </summary>
        [JsonPropertyName("error")]
        Error,
        /// <summary>
        /// warning
        /// </summary>
        [JsonPropertyName("warning")]
        Warning,
        /// <summary>
        /// info
        /// </summary>
        [JsonPropertyName("info")]
        Info,
        /// <summary>
        /// debug
        /// </summary>
        [JsonPropertyName("debug")]
        Debug
    }

    /// <summary>
    /// Have one type per entry in MediaLogRecord::Type
    /// Corresponds to kMessage
    /// </summary>
    public partial class PlayerMessage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Keep in sync with MediaLogMessageLevel
        /// We are currently keeping the message level &apos;error&apos; separate from the
        /// PlayerError type because right now they represent different things,
        /// this one being a DVLOG(ERROR) style log message that gets printed
        /// based on what log level is selected in the UI, and the other is a
        /// representation of a media::PipelineStatus object. Soon however we&apos;re
        /// going to be moving away from using PipelineStatus for errors and
        /// introducing a new error type which should hopefully let us integrate
        /// the error log level into the PlayerError type.
        /// </summary>
        [JsonPropertyName("level")]
        public CefSharp.DevTools.Media.PlayerMessageLevel Level
        {
            get;
            set;
        }

        /// <summary>
        /// Message
        /// </summary>
        [JsonPropertyName("message")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Message
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Corresponds to kMediaPropertyChange
    /// </summary>
    public partial class PlayerProperty : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Corresponds to kMediaEventTriggered
    /// </summary>
    public partial class PlayerEvent : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Timestamp
        /// </summary>
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Represents logged source line numbers reported in an error.
    /// NOTE: file and line are from chromium c++ implementation code, not js.
    /// </summary>
    public partial class PlayerErrorSourceLocation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// File
        /// </summary>
        [JsonPropertyName("file")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string File
        {
            get;
            set;
        }

        /// <summary>
        /// Line
        /// </summary>
        [JsonPropertyName("line")]
        public int Line
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Corresponds to kMediaError
    /// </summary>
    public partial class PlayerError : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ErrorType
        /// </summary>
        [JsonPropertyName("errorType")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ErrorType
        {
            get;
            set;
        }

        /// <summary>
        /// Code is the numeric enum entry for a specific set of error codes, such
        /// as PipelineStatusCodes in media/base/pipeline_status.h
        /// </summary>
        [JsonPropertyName("code")]
        public int Code
        {
            get;
            set;
        }

        /// <summary>
        /// A trace of where this error was caused / where it passed through.
        /// </summary>
        [JsonPropertyName("stack")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Media.PlayerErrorSourceLocation> Stack
        {
            get;
            set;
        }

        /// <summary>
        /// Errors potentially have a root cause error, ie, a DecoderError might be
        /// caused by an WindowsError
        /// </summary>
        [JsonPropertyName("cause")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Media.PlayerError> Cause
        {
            get;
            set;
        }

        /// <summary>
        /// Extra data attached to an error, such as an HRESULT, Video Codec, etc.
        /// </summary>
        [JsonPropertyName("data")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public object Data
        {
            get;
            set;
        }
    }

    /// <summary>
    /// This can be called multiple times, and can be used to set / override /
    /// remove player properties. A null propValue indicates removal.
    /// </summary>
    public class PlayerPropertiesChangedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// PlayerId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("playerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlayerId
        {
            get;
            private set;
        }

        /// <summary>
        /// Properties
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("properties")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Media.PlayerProperty> Properties
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Send events as a list, allowing them to be batched on the browser for less
    /// congestion. If batched, events must ALWAYS be in chronological order.
    /// </summary>
    public class PlayerEventsAddedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// PlayerId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("playerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlayerId
        {
            get;
            private set;
        }

        /// <summary>
        /// Events
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("events")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Media.PlayerEvent> Events
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Send a list of any messages that need to be delivered.
    /// </summary>
    public class PlayerMessagesLoggedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// PlayerId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("playerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlayerId
        {
            get;
            private set;
        }

        /// <summary>
        /// Messages
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("messages")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Media.PlayerMessage> Messages
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Send a list of any errors that need to be delivered.
    /// </summary>
    public class PlayerErrorsRaisedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// PlayerId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("playerId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PlayerId
        {
            get;
            private set;
        }

        /// <summary>
        /// Errors
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errors")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Media.PlayerError> Errors
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Called whenever a player is created, or when a new agent joins and receives
    /// a list of active players. If an agent is restored, it will receive the full
    /// list of player ids and all events again.
    /// </summary>
    public class PlayersCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Players
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("players")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Players
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DeviceAccess
{
    /// <summary>
    /// Device information displayed in a user prompt to select a device.
    /// </summary>
    public partial class PromptDevice : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Display name as it appears in a device request user prompt.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A device request opened a user prompt to select a device. Respond with the
    /// selectPrompt or cancelPrompt command.
    /// </summary>
    public class DeviceRequestPromptedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            private set;
        }

        /// <summary>
        /// Devices
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("devices")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.DeviceAccess.PromptDevice> Devices
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Preload
{
    /// <summary>
    /// Corresponds to SpeculationRuleSet
    /// </summary>
    public partial class RuleSet : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// Identifies a document which the rule set is associated with.
        /// </summary>
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            set;
        }

        /// <summary>
        /// Source text of JSON representing the rule set. If it comes from
        /// &lt;script&gt; tag, it is the textContent of the node. Note that it is
        /// a JSON for valid case.
        /// 
        /// See also:
        /// - https://wicg.github.io/nav-speculation/speculation-rules.html
        /// - https://github.com/WICG/nav-speculation/blob/main/triggers.md
        /// </summary>
        [JsonPropertyName("sourceText")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string SourceText
        {
            get;
            set;
        }

        /// <summary>
        /// Error information
        /// `errorMessage` is null iff `errorType` is null.
        /// </summary>
        [JsonPropertyName("errorType")]
        public CefSharp.DevTools.Preload.RuleSetErrorType? ErrorType
        {
            get;
            set;
        }

        /// <summary>
        /// TODO(https://crbug.com/1425354): Replace this property with structured error.
        /// </summary>
        [JsonPropertyName("errorMessage")]
        public string ErrorMessage
        {
            get;
            set;
        }
    }

    /// <summary>
    /// RuleSetErrorType
    /// </summary>
    public enum RuleSetErrorType
    {
        /// <summary>
        /// SourceIsNotJsonObject
        /// </summary>
        [JsonPropertyName("SourceIsNotJsonObject")]
        SourceIsNotJsonObject,
        /// <summary>
        /// InvalidRulesSkipped
        /// </summary>
        [JsonPropertyName("InvalidRulesSkipped")]
        InvalidRulesSkipped
    }

    /// <summary>
    /// The type of preloading attempted. It corresponds to
    /// mojom::SpeculationAction (although PrefetchWithSubresources is omitted as it
    /// isn&apos;t being used by clients).
    /// </summary>
    public enum SpeculationAction
    {
        /// <summary>
        /// Prefetch
        /// </summary>
        [JsonPropertyName("Prefetch")]
        Prefetch,
        /// <summary>
        /// Prerender
        /// </summary>
        [JsonPropertyName("Prerender")]
        Prerender
    }

    /// <summary>
    /// Corresponds to mojom::SpeculationTargetHint.
    /// See https://github.com/WICG/nav-speculation/blob/main/triggers.md#window-name-targeting-hints
    /// </summary>
    public enum SpeculationTargetHint
    {
        /// <summary>
        /// Blank
        /// </summary>
        [JsonPropertyName("Blank")]
        Blank,
        /// <summary>
        /// Self
        /// </summary>
        [JsonPropertyName("Self")]
        Self
    }

    /// <summary>
    /// A key that identifies a preloading attempt.
    /// 
    /// The url used is the url specified by the trigger (i.e. the initial URL), and
    /// not the final url that is navigated to. For example, prerendering allows
    /// same-origin main frame navigations during the attempt, but the attempt is
    /// still keyed with the initial URL.
    /// </summary>
    public partial class PreloadingAttemptKey : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// LoaderId
        /// </summary>
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            set;
        }

        /// <summary>
        /// Action
        /// </summary>
        [JsonPropertyName("action")]
        public CefSharp.DevTools.Preload.SpeculationAction Action
        {
            get;
            set;
        }

        /// <summary>
        /// Url
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// TargetHint
        /// </summary>
        [JsonPropertyName("targetHint")]
        public CefSharp.DevTools.Preload.SpeculationTargetHint? TargetHint
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Lists sources for a preloading attempt, specifically the ids of rule sets
    /// that had a speculation rule that triggered the attempt, and the
    /// BackendNodeIds of &lt;a href&gt; or &lt;area href&gt; elements that triggered the
    /// attempt (in the case of attempts triggered by a document rule). It is
    /// possible for mulitple rule sets and links to trigger a single attempt.
    /// </summary>
    public partial class PreloadingAttemptSource : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Key
        /// </summary>
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Preload.PreloadingAttemptKey Key
        {
            get;
            set;
        }

        /// <summary>
        /// RuleSetIds
        /// </summary>
        [JsonPropertyName("ruleSetIds")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] RuleSetIds
        {
            get;
            set;
        }

        /// <summary>
        /// NodeIds
        /// </summary>
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            set;
        }
    }

    /// <summary>
    /// List of FinalStatus reasons for Prerender2.
    /// </summary>
    public enum PrerenderFinalStatus
    {
        /// <summary>
        /// Activated
        /// </summary>
        [JsonPropertyName("Activated")]
        Activated,
        /// <summary>
        /// Destroyed
        /// </summary>
        [JsonPropertyName("Destroyed")]
        Destroyed,
        /// <summary>
        /// LowEndDevice
        /// </summary>
        [JsonPropertyName("LowEndDevice")]
        LowEndDevice,
        /// <summary>
        /// InvalidSchemeRedirect
        /// </summary>
        [JsonPropertyName("InvalidSchemeRedirect")]
        InvalidSchemeRedirect,
        /// <summary>
        /// InvalidSchemeNavigation
        /// </summary>
        [JsonPropertyName("InvalidSchemeNavigation")]
        InvalidSchemeNavigation,
        /// <summary>
        /// InProgressNavigation
        /// </summary>
        [JsonPropertyName("InProgressNavigation")]
        InProgressNavigation,
        /// <summary>
        /// NavigationRequestBlockedByCsp
        /// </summary>
        [JsonPropertyName("NavigationRequestBlockedByCsp")]
        NavigationRequestBlockedByCsp,
        /// <summary>
        /// MainFrameNavigation
        /// </summary>
        [JsonPropertyName("MainFrameNavigation")]
        MainFrameNavigation,
        /// <summary>
        /// MojoBinderPolicy
        /// </summary>
        [JsonPropertyName("MojoBinderPolicy")]
        MojoBinderPolicy,
        /// <summary>
        /// RendererProcessCrashed
        /// </summary>
        [JsonPropertyName("RendererProcessCrashed")]
        RendererProcessCrashed,
        /// <summary>
        /// RendererProcessKilled
        /// </summary>
        [JsonPropertyName("RendererProcessKilled")]
        RendererProcessKilled,
        /// <summary>
        /// Download
        /// </summary>
        [JsonPropertyName("Download")]
        Download,
        /// <summary>
        /// TriggerDestroyed
        /// </summary>
        [JsonPropertyName("TriggerDestroyed")]
        TriggerDestroyed,
        /// <summary>
        /// NavigationNotCommitted
        /// </summary>
        [JsonPropertyName("NavigationNotCommitted")]
        NavigationNotCommitted,
        /// <summary>
        /// NavigationBadHttpStatus
        /// </summary>
        [JsonPropertyName("NavigationBadHttpStatus")]
        NavigationBadHttpStatus,
        /// <summary>
        /// ClientCertRequested
        /// </summary>
        [JsonPropertyName("ClientCertRequested")]
        ClientCertRequested,
        /// <summary>
        /// NavigationRequestNetworkError
        /// </summary>
        [JsonPropertyName("NavigationRequestNetworkError")]
        NavigationRequestNetworkError,
        /// <summary>
        /// MaxNumOfRunningPrerendersExceeded
        /// </summary>
        [JsonPropertyName("MaxNumOfRunningPrerendersExceeded")]
        MaxNumOfRunningPrerendersExceeded,
        /// <summary>
        /// CancelAllHostsForTesting
        /// </summary>
        [JsonPropertyName("CancelAllHostsForTesting")]
        CancelAllHostsForTesting,
        /// <summary>
        /// DidFailLoad
        /// </summary>
        [JsonPropertyName("DidFailLoad")]
        DidFailLoad,
        /// <summary>
        /// Stop
        /// </summary>
        [JsonPropertyName("Stop")]
        Stop,
        /// <summary>
        /// SslCertificateError
        /// </summary>
        [JsonPropertyName("SslCertificateError")]
        SslCertificateError,
        /// <summary>
        /// LoginAuthRequested
        /// </summary>
        [JsonPropertyName("LoginAuthRequested")]
        LoginAuthRequested,
        /// <summary>
        /// UaChangeRequiresReload
        /// </summary>
        [JsonPropertyName("UaChangeRequiresReload")]
        UaChangeRequiresReload,
        /// <summary>
        /// BlockedByClient
        /// </summary>
        [JsonPropertyName("BlockedByClient")]
        BlockedByClient,
        /// <summary>
        /// AudioOutputDeviceRequested
        /// </summary>
        [JsonPropertyName("AudioOutputDeviceRequested")]
        AudioOutputDeviceRequested,
        /// <summary>
        /// MixedContent
        /// </summary>
        [JsonPropertyName("MixedContent")]
        MixedContent,
        /// <summary>
        /// TriggerBackgrounded
        /// </summary>
        [JsonPropertyName("TriggerBackgrounded")]
        TriggerBackgrounded,
        /// <summary>
        /// EmbedderTriggeredAndCrossOriginRedirected
        /// </summary>
        [JsonPropertyName("EmbedderTriggeredAndCrossOriginRedirected")]
        EmbedderTriggeredAndCrossOriginRedirected,
        /// <summary>
        /// MemoryLimitExceeded
        /// </summary>
        [JsonPropertyName("MemoryLimitExceeded")]
        MemoryLimitExceeded,
        /// <summary>
        /// FailToGetMemoryUsage
        /// </summary>
        [JsonPropertyName("FailToGetMemoryUsage")]
        FailToGetMemoryUsage,
        /// <summary>
        /// DataSaverEnabled
        /// </summary>
        [JsonPropertyName("DataSaverEnabled")]
        DataSaverEnabled,
        /// <summary>
        /// HasEffectiveUrl
        /// </summary>
        [JsonPropertyName("HasEffectiveUrl")]
        HasEffectiveUrl,
        /// <summary>
        /// ActivatedBeforeStarted
        /// </summary>
        [JsonPropertyName("ActivatedBeforeStarted")]
        ActivatedBeforeStarted,
        /// <summary>
        /// InactivePageRestriction
        /// </summary>
        [JsonPropertyName("InactivePageRestriction")]
        InactivePageRestriction,
        /// <summary>
        /// StartFailed
        /// </summary>
        [JsonPropertyName("StartFailed")]
        StartFailed,
        /// <summary>
        /// TimeoutBackgrounded
        /// </summary>
        [JsonPropertyName("TimeoutBackgrounded")]
        TimeoutBackgrounded,
        /// <summary>
        /// CrossSiteRedirectInInitialNavigation
        /// </summary>
        [JsonPropertyName("CrossSiteRedirectInInitialNavigation")]
        CrossSiteRedirectInInitialNavigation,
        /// <summary>
        /// CrossSiteNavigationInInitialNavigation
        /// </summary>
        [JsonPropertyName("CrossSiteNavigationInInitialNavigation")]
        CrossSiteNavigationInInitialNavigation,
        /// <summary>
        /// SameSiteCrossOriginRedirectNotOptInInInitialNavigation
        /// </summary>
        [JsonPropertyName("SameSiteCrossOriginRedirectNotOptInInInitialNavigation")]
        SameSiteCrossOriginRedirectNotOptInInInitialNavigation,
        /// <summary>
        /// SameSiteCrossOriginNavigationNotOptInInInitialNavigation
        /// </summary>
        [JsonPropertyName("SameSiteCrossOriginNavigationNotOptInInInitialNavigation")]
        SameSiteCrossOriginNavigationNotOptInInInitialNavigation,
        /// <summary>
        /// ActivationNavigationParameterMismatch
        /// </summary>
        [JsonPropertyName("ActivationNavigationParameterMismatch")]
        ActivationNavigationParameterMismatch,
        /// <summary>
        /// ActivatedInBackground
        /// </summary>
        [JsonPropertyName("ActivatedInBackground")]
        ActivatedInBackground,
        /// <summary>
        /// EmbedderHostDisallowed
        /// </summary>
        [JsonPropertyName("EmbedderHostDisallowed")]
        EmbedderHostDisallowed,
        /// <summary>
        /// ActivationNavigationDestroyedBeforeSuccess
        /// </summary>
        [JsonPropertyName("ActivationNavigationDestroyedBeforeSuccess")]
        ActivationNavigationDestroyedBeforeSuccess,
        /// <summary>
        /// TabClosedByUserGesture
        /// </summary>
        [JsonPropertyName("TabClosedByUserGesture")]
        TabClosedByUserGesture,
        /// <summary>
        /// TabClosedWithoutUserGesture
        /// </summary>
        [JsonPropertyName("TabClosedWithoutUserGesture")]
        TabClosedWithoutUserGesture,
        /// <summary>
        /// PrimaryMainFrameRendererProcessCrashed
        /// </summary>
        [JsonPropertyName("PrimaryMainFrameRendererProcessCrashed")]
        PrimaryMainFrameRendererProcessCrashed,
        /// <summary>
        /// PrimaryMainFrameRendererProcessKilled
        /// </summary>
        [JsonPropertyName("PrimaryMainFrameRendererProcessKilled")]
        PrimaryMainFrameRendererProcessKilled,
        /// <summary>
        /// ActivationFramePolicyNotCompatible
        /// </summary>
        [JsonPropertyName("ActivationFramePolicyNotCompatible")]
        ActivationFramePolicyNotCompatible,
        /// <summary>
        /// PreloadingDisabled
        /// </summary>
        [JsonPropertyName("PreloadingDisabled")]
        PreloadingDisabled,
        /// <summary>
        /// BatterySaverEnabled
        /// </summary>
        [JsonPropertyName("BatterySaverEnabled")]
        BatterySaverEnabled,
        /// <summary>
        /// ActivatedDuringMainFrameNavigation
        /// </summary>
        [JsonPropertyName("ActivatedDuringMainFrameNavigation")]
        ActivatedDuringMainFrameNavigation,
        /// <summary>
        /// PreloadingUnsupportedByWebContents
        /// </summary>
        [JsonPropertyName("PreloadingUnsupportedByWebContents")]
        PreloadingUnsupportedByWebContents,
        /// <summary>
        /// CrossSiteRedirectInMainFrameNavigation
        /// </summary>
        [JsonPropertyName("CrossSiteRedirectInMainFrameNavigation")]
        CrossSiteRedirectInMainFrameNavigation,
        /// <summary>
        /// CrossSiteNavigationInMainFrameNavigation
        /// </summary>
        [JsonPropertyName("CrossSiteNavigationInMainFrameNavigation")]
        CrossSiteNavigationInMainFrameNavigation,
        /// <summary>
        /// SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation
        /// </summary>
        [JsonPropertyName("SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation")]
        SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation,
        /// <summary>
        /// SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation
        /// </summary>
        [JsonPropertyName("SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation")]
        SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation,
        /// <summary>
        /// MemoryPressureOnTrigger
        /// </summary>
        [JsonPropertyName("MemoryPressureOnTrigger")]
        MemoryPressureOnTrigger,
        /// <summary>
        /// MemoryPressureAfterTriggered
        /// </summary>
        [JsonPropertyName("MemoryPressureAfterTriggered")]
        MemoryPressureAfterTriggered
    }

    /// <summary>
    /// PreloadEnabledState
    /// </summary>
    public enum PreloadEnabledState
    {
        /// <summary>
        /// Enabled
        /// </summary>
        [JsonPropertyName("Enabled")]
        Enabled,
        /// <summary>
        /// DisabledByDataSaver
        /// </summary>
        [JsonPropertyName("DisabledByDataSaver")]
        DisabledByDataSaver,
        /// <summary>
        /// DisabledByBatterySaver
        /// </summary>
        [JsonPropertyName("DisabledByBatterySaver")]
        DisabledByBatterySaver,
        /// <summary>
        /// DisabledByPreference
        /// </summary>
        [JsonPropertyName("DisabledByPreference")]
        DisabledByPreference,
        /// <summary>
        /// NotSupported
        /// </summary>
        [JsonPropertyName("NotSupported")]
        NotSupported
    }

    /// <summary>
    /// Preloading status values, see also PreloadingTriggeringOutcome. This
    /// status is shared by prefetchStatusUpdated and prerenderStatusUpdated.
    /// </summary>
    public enum PreloadingStatus
    {
        /// <summary>
        /// Pending
        /// </summary>
        [JsonPropertyName("Pending")]
        Pending,
        /// <summary>
        /// Running
        /// </summary>
        [JsonPropertyName("Running")]
        Running,
        /// <summary>
        /// Ready
        /// </summary>
        [JsonPropertyName("Ready")]
        Ready,
        /// <summary>
        /// Success
        /// </summary>
        [JsonPropertyName("Success")]
        Success,
        /// <summary>
        /// Failure
        /// </summary>
        [JsonPropertyName("Failure")]
        Failure,
        /// <summary>
        /// NotSupported
        /// </summary>
        [JsonPropertyName("NotSupported")]
        NotSupported
    }

    /// <summary>
    /// Upsert. Currently, it is only emitted when a rule set added.
    /// </summary>
    public class RuleSetUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// RuleSet
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("ruleSet")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Preload.RuleSet RuleSet
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// ruleSetRemoved
    /// </summary>
    public class RuleSetRemovedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a prerender attempt is completed.
    /// </summary>
    public class PrerenderAttemptCompletedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Key
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Preload.PreloadingAttemptKey Key
        {
            get;
            private set;
        }

        /// <summary>
        /// The frame id of the frame initiating prerendering.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("initiatingFrameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InitiatingFrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// PrerenderingUrl
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("prerenderingUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PrerenderingUrl
        {
            get;
            private set;
        }

        /// <summary>
        /// FinalStatus
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("finalStatus")]
        public CefSharp.DevTools.Preload.PrerenderFinalStatus FinalStatus
        {
            get;
            private set;
        }

        /// <summary>
        /// This is used to give users more information about the name of the API call
        /// that is incompatible with prerender and has caused the cancellation of the attempt
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("disallowedApiMethod")]
        public string DisallowedApiMethod
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a preload enabled state is updated.
    /// </summary>
    public class PreloadEnabledStateUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// State
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("state")]
        public CefSharp.DevTools.Preload.PreloadEnabledState State
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a prefetch attempt is updated.
    /// </summary>
    public class PrefetchStatusUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Key
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Preload.PreloadingAttemptKey Key
        {
            get;
            private set;
        }

        /// <summary>
        /// The frame id of the frame initiating prefetch.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("initiatingFrameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InitiatingFrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// PrefetchUrl
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("prefetchUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PrefetchUrl
        {
            get;
            private set;
        }

        /// <summary>
        /// Status
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("status")]
        public CefSharp.DevTools.Preload.PreloadingStatus Status
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when a prerender attempt is updated.
    /// </summary>
    public class PrerenderStatusUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Key
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("key")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Preload.PreloadingAttemptKey Key
        {
            get;
            private set;
        }

        /// <summary>
        /// The frame id of the frame initiating prerender.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("initiatingFrameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string InitiatingFrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// PrerenderingUrl
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("prerenderingUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PrerenderingUrl
        {
            get;
            private set;
        }

        /// <summary>
        /// Status
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("status")]
        public CefSharp.DevTools.Preload.PreloadingStatus Status
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Send a list of sources for all preloading attempts in a document.
    /// </summary>
    public class PreloadingAttemptSourcesUpdatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// LoaderId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("loaderId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LoaderId
        {
            get;
            private set;
        }

        /// <summary>
        /// PreloadingAttemptSources
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("preloadingAttemptSources")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Preload.PreloadingAttemptSource> PreloadingAttemptSources
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.FedCm
{
    /// <summary>
    /// Whether this is a sign-up or sign-in action for this account, i.e.
    /// whether this account has ever been used to sign in to this RP before.
    /// </summary>
    public enum LoginState
    {
        /// <summary>
        /// SignIn
        /// </summary>
        [JsonPropertyName("SignIn")]
        SignIn,
        /// <summary>
        /// SignUp
        /// </summary>
        [JsonPropertyName("SignUp")]
        SignUp
    }

    /// <summary>
    /// Corresponds to IdentityRequestAccount
    /// </summary>
    public partial class Account : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// AccountId
        /// </summary>
        [JsonPropertyName("accountId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string AccountId
        {
            get;
            set;
        }

        /// <summary>
        /// Email
        /// </summary>
        [JsonPropertyName("email")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Email
        {
            get;
            set;
        }

        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// GivenName
        /// </summary>
        [JsonPropertyName("givenName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string GivenName
        {
            get;
            set;
        }

        /// <summary>
        /// PictureUrl
        /// </summary>
        [JsonPropertyName("pictureUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string PictureUrl
        {
            get;
            set;
        }

        /// <summary>
        /// IdpConfigUrl
        /// </summary>
        [JsonPropertyName("idpConfigUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string IdpConfigUrl
        {
            get;
            set;
        }

        /// <summary>
        /// IdpSigninUrl
        /// </summary>
        [JsonPropertyName("idpSigninUrl")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string IdpSigninUrl
        {
            get;
            set;
        }

        /// <summary>
        /// LoginState
        /// </summary>
        [JsonPropertyName("loginState")]
        public CefSharp.DevTools.FedCm.LoginState LoginState
        {
            get;
            set;
        }

        /// <summary>
        /// These two are only set if the loginState is signUp
        /// </summary>
        [JsonPropertyName("termsOfServiceUrl")]
        public string TermsOfServiceUrl
        {
            get;
            set;
        }

        /// <summary>
        /// PrivacyPolicyUrl
        /// </summary>
        [JsonPropertyName("privacyPolicyUrl")]
        public string PrivacyPolicyUrl
        {
            get;
            set;
        }
    }

    /// <summary>
    /// dialogShown
    /// </summary>
    public class DialogShownEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// DialogId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("dialogId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string DialogId
        {
            get;
            private set;
        }

        /// <summary>
        /// Accounts
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("accounts")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.FedCm.Account> Accounts
        {
            get;
            private set;
        }

        /// <summary>
        /// These exist primarily so that the caller can verify the
        /// RP context was used appropriately.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("title")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Title
        {
            get;
            private set;
        }

        /// <summary>
        /// Subtitle
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("subtitle")]
        public string Subtitle
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// Location in the source code.
    /// </summary>
    public partial class Location : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Script identifier as reported in the `Debugger.scriptParsed`.
        /// </summary>
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Line number in the script (0-based).
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Column number in the script (0-based).
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public int? ColumnNumber
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Location in the source code.
    /// </summary>
    public partial class ScriptPosition : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// LineNumber
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// ColumnNumber
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Location range within one script.
    /// </summary>
    public partial class LocationRange : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// ScriptId
        /// </summary>
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Start
        /// </summary>
        [JsonPropertyName("start")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.ScriptPosition Start
        {
            get;
            set;
        }

        /// <summary>
        /// End
        /// </summary>
        [JsonPropertyName("end")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.ScriptPosition End
        {
            get;
            set;
        }
    }

    /// <summary>
    /// JavaScript call frame. Array of call frames form the call stack.
    /// </summary>
    public partial class CallFrame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Call frame identifier. This identifier is only valid while the virtual machine is paused.
        /// </summary>
        [JsonPropertyName("callFrameId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string CallFrameId
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the JavaScript function called on this call frame.
        /// </summary>
        [JsonPropertyName("functionName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FunctionName
        {
            get;
            set;
        }

        /// <summary>
        /// Location in the source code.
        /// </summary>
        [JsonPropertyName("functionLocation")]
        public CefSharp.DevTools.Debugger.Location FunctionLocation
        {
            get;
            set;
        }

        /// <summary>
        /// Location in the source code.
        /// </summary>
        [JsonPropertyName("location")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.Location Location
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script name or url.
        /// Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
        /// sent `Debugger.scriptParsed` event.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Scope chain for this call frame.
        /// </summary>
        [JsonPropertyName("scopeChain")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.Scope> ScopeChain
        {
            get;
            set;
        }

        /// <summary>
        /// `this` object for this call frame.
        /// </summary>
        [JsonPropertyName("this")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject This
        {
            get;
            set;
        }

        /// <summary>
        /// The value being returned, if the function is at return point.
        /// </summary>
        [JsonPropertyName("returnValue")]
        public CefSharp.DevTools.Runtime.RemoteObject ReturnValue
        {
            get;
            set;
        }

        /// <summary>
        /// Valid only while the VM is paused and indicates whether this frame
        /// can be restarted or not. Note that a `true` value here does not
        /// guarantee that Debugger#restartFrame with this CallFrameId will be
        /// successful, but it is very likely.
        /// </summary>
        [JsonPropertyName("canBeRestarted")]
        public bool? CanBeRestarted
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Scope type.
    /// </summary>
    public enum ScopeType
    {
        /// <summary>
        /// global
        /// </summary>
        [JsonPropertyName("global")]
        Global,
        /// <summary>
        /// local
        /// </summary>
        [JsonPropertyName("local")]
        Local,
        /// <summary>
        /// with
        /// </summary>
        [JsonPropertyName("with")]
        With,
        /// <summary>
        /// closure
        /// </summary>
        [JsonPropertyName("closure")]
        Closure,
        /// <summary>
        /// catch
        /// </summary>
        [JsonPropertyName("catch")]
        Catch,
        /// <summary>
        /// block
        /// </summary>
        [JsonPropertyName("block")]
        Block,
        /// <summary>
        /// script
        /// </summary>
        [JsonPropertyName("script")]
        Script,
        /// <summary>
        /// eval
        /// </summary>
        [JsonPropertyName("eval")]
        Eval,
        /// <summary>
        /// module
        /// </summary>
        [JsonPropertyName("module")]
        Module,
        /// <summary>
        /// wasm-expression-stack
        /// </summary>
        [JsonPropertyName("wasm-expression-stack")]
        WasmExpressionStack
    }

    /// <summary>
    /// Scope description.
    /// </summary>
    public partial class Scope : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Scope type.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Debugger.ScopeType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Object representing the scope. For `global` and `with` scopes it represents the actual
        /// object; for the rest of the scopes, it is artificial transient object enumerating scope
        /// variables as its properties.
        /// </summary>
        [JsonPropertyName("object")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject Object
        {
            get;
            set;
        }

        /// <summary>
        /// Name
        /// </summary>
        [JsonPropertyName("name")]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Location in the source code where scope starts
        /// </summary>
        [JsonPropertyName("startLocation")]
        public CefSharp.DevTools.Debugger.Location StartLocation
        {
            get;
            set;
        }

        /// <summary>
        /// Location in the source code where scope ends
        /// </summary>
        [JsonPropertyName("endLocation")]
        public CefSharp.DevTools.Debugger.Location EndLocation
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Search match for resource.
    /// </summary>
    public partial class SearchMatch : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Line number in resource content.
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public double LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Line with match content.
        /// </summary>
        [JsonPropertyName("lineContent")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string LineContent
        {
            get;
            set;
        }
    }

    /// <summary>
    /// BreakLocationType
    /// </summary>
    public enum BreakLocationType
    {
        /// <summary>
        /// debuggerStatement
        /// </summary>
        [JsonPropertyName("debuggerStatement")]
        DebuggerStatement,
        /// <summary>
        /// call
        /// </summary>
        [JsonPropertyName("call")]
        Call,
        /// <summary>
        /// return
        /// </summary>
        [JsonPropertyName("return")]
        Return
    }

    /// <summary>
    /// BreakLocation
    /// </summary>
    public partial class BreakLocation : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Script identifier as reported in the `Debugger.scriptParsed`.
        /// </summary>
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// Line number in the script (0-based).
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Column number in the script (0-based).
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public int? ColumnNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Type
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Debugger.BreakLocationType? Type
        {
            get;
            set;
        }
    }

    /// <summary>
    /// WasmDisassemblyChunk
    /// </summary>
    public partial class WasmDisassemblyChunk : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The next chunk of disassembled lines.
        /// </summary>
        [JsonPropertyName("lines")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string[] Lines
        {
            get;
            set;
        }

        /// <summary>
        /// The bytecode offsets describing the start of each line.
        /// </summary>
        [JsonPropertyName("bytecodeOffsets")]
        public int[] BytecodeOffsets
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Enum of possible script languages.
    /// </summary>
    public enum ScriptLanguage
    {
        /// <summary>
        /// JavaScript
        /// </summary>
        [JsonPropertyName("JavaScript")]
        JavaScript,
        /// <summary>
        /// WebAssembly
        /// </summary>
        [JsonPropertyName("WebAssembly")]
        WebAssembly
    }

    /// <summary>
    /// Type of the debug symbols.
    /// </summary>
    public enum DebugSymbolsType
    {
        /// <summary>
        /// None
        /// </summary>
        [JsonPropertyName("None")]
        None,
        /// <summary>
        /// SourceMap
        /// </summary>
        [JsonPropertyName("SourceMap")]
        SourceMap,
        /// <summary>
        /// EmbeddedDWARF
        /// </summary>
        [JsonPropertyName("EmbeddedDWARF")]
        EmbeddedDWARF,
        /// <summary>
        /// ExternalDWARF
        /// </summary>
        [JsonPropertyName("ExternalDWARF")]
        ExternalDWARF
    }

    /// <summary>
    /// Debug symbols available for a wasm script.
    /// </summary>
    public partial class DebugSymbols : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Type of the debug symbols.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Debugger.DebugSymbolsType Type
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the external symbol source.
        /// </summary>
        [JsonPropertyName("externalURL")]
        public string ExternalURL
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Fired when breakpoint is resolved to an actual script and location.
    /// </summary>
    public class BreakpointResolvedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Breakpoint unique identifier.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("breakpointId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string BreakpointId
        {
            get;
            private set;
        }

        /// <summary>
        /// Actual breakpoint location.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("location")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.Location Location
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Pause reason.
    /// </summary>
    public enum PausedReason
    {
        /// <summary>
        /// ambiguous
        /// </summary>
        [JsonPropertyName("ambiguous")]
        Ambiguous,
        /// <summary>
        /// assert
        /// </summary>
        [JsonPropertyName("assert")]
        Assert,
        /// <summary>
        /// CSPViolation
        /// </summary>
        [JsonPropertyName("CSPViolation")]
        CSPViolation,
        /// <summary>
        /// debugCommand
        /// </summary>
        [JsonPropertyName("debugCommand")]
        DebugCommand,
        /// <summary>
        /// DOM
        /// </summary>
        [JsonPropertyName("DOM")]
        DOM,
        /// <summary>
        /// EventListener
        /// </summary>
        [JsonPropertyName("EventListener")]
        EventListener,
        /// <summary>
        /// exception
        /// </summary>
        [JsonPropertyName("exception")]
        Exception,
        /// <summary>
        /// instrumentation
        /// </summary>
        [JsonPropertyName("instrumentation")]
        Instrumentation,
        /// <summary>
        /// OOM
        /// </summary>
        [JsonPropertyName("OOM")]
        OOM,
        /// <summary>
        /// other
        /// </summary>
        [JsonPropertyName("other")]
        Other,
        /// <summary>
        /// promiseRejection
        /// </summary>
        [JsonPropertyName("promiseRejection")]
        PromiseRejection,
        /// <summary>
        /// XHR
        /// </summary>
        [JsonPropertyName("XHR")]
        XHR,
        /// <summary>
        /// step
        /// </summary>
        [JsonPropertyName("step")]
        Step
    }

    /// <summary>
    /// Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    /// </summary>
    public class PausedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Call stack the virtual machine stopped on.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("callFrames")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.CallFrame> CallFrames
        {
            get;
            private set;
        }

        /// <summary>
        /// Pause reason.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("reason")]
        public CefSharp.DevTools.Debugger.PausedReason Reason
        {
            get;
            private set;
        }

        /// <summary>
        /// Object containing break-specific auxiliary properties.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        public object Data
        {
            get;
            private set;
        }

        /// <summary>
        /// Hit breakpoints IDs
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hitBreakpoints")]
        public string[] HitBreakpoints
        {
            get;
            private set;
        }

        /// <summary>
        /// Async stack trace, if any.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("asyncStackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace AsyncStackTrace
        {
            get;
            private set;
        }

        /// <summary>
        /// Async stack trace, if any.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("asyncStackTraceId")]
        public CefSharp.DevTools.Runtime.StackTraceId AsyncStackTraceId
        {
            get;
            private set;
        }

        /// <summary>
        /// Never present, will be removed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("asyncCallStackTraceId")]
        public CefSharp.DevTools.Runtime.StackTraceId AsyncCallStackTraceId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when virtual machine fails to parse the script.
    /// </summary>
    public class ScriptFailedToParseEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Identifier of the script parsed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            private set;
        }

        /// <summary>
        /// URL or name of the script parsed (if any).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Line offset of the script within the resource with given URL (for script tags).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("startLine")]
        public int StartLine
        {
            get;
            private set;
        }

        /// <summary>
        /// Column offset of the script within the resource with given URL.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("startColumn")]
        public int StartColumn
        {
            get;
            private set;
        }

        /// <summary>
        /// Last line of the script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("endLine")]
        public int EndLine
        {
            get;
            private set;
        }

        /// <summary>
        /// Length of the last line of the script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("endColumn")]
        public int EndColumn
        {
            get;
            private set;
        }

        /// <summary>
        /// Specifies script creation context.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextId")]
        public int ExecutionContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// Content hash of the script, SHA-256.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hash")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Hash
        {
            get;
            private set;
        }

        /// <summary>
        /// Embedder-specific auxiliary data likely matching {isDefault: boolean, type: &apos;default&apos;|&apos;isolated&apos;|&apos;worker&apos;, frameId: string}
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextAuxData")]
        public object ExecutionContextAuxData
        {
            get;
            private set;
        }

        /// <summary>
        /// URL of source map associated with script (if any).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceMapURL")]
        public string SourceMapURL
        {
            get;
            private set;
        }

        /// <summary>
        /// True, if this script has sourceURL.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hasSourceURL")]
        public bool? HasSourceURL
        {
            get;
            private set;
        }

        /// <summary>
        /// True, if this script is ES6 module.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("isModule")]
        public bool? IsModule
        {
            get;
            private set;
        }

        /// <summary>
        /// This script length.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("length")]
        public int? Length
        {
            get;
            private set;
        }

        /// <summary>
        /// JavaScript top stack frame of where the script parsed event was triggered if available.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            private set;
        }

        /// <summary>
        /// If the scriptLanguage is WebAssembly, the code section offset in the module.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("codeOffset")]
        public int? CodeOffset
        {
            get;
            private set;
        }

        /// <summary>
        /// The language of the script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("scriptLanguage")]
        public CefSharp.DevTools.Debugger.ScriptLanguage? ScriptLanguage
        {
            get;
            private set;
        }

        /// <summary>
        /// The name the embedder supplied for this script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("embedderName")]
        public string EmbedderName
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Fired when virtual machine parses script. This event is also fired for all known and uncollected
    /// scripts upon enabling debugger.
    /// </summary>
    public class ScriptParsedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Identifier of the script parsed.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            private set;
        }

        /// <summary>
        /// URL or name of the script parsed (if any).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// Line offset of the script within the resource with given URL (for script tags).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("startLine")]
        public int StartLine
        {
            get;
            private set;
        }

        /// <summary>
        /// Column offset of the script within the resource with given URL.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("startColumn")]
        public int StartColumn
        {
            get;
            private set;
        }

        /// <summary>
        /// Last line of the script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("endLine")]
        public int EndLine
        {
            get;
            private set;
        }

        /// <summary>
        /// Length of the last line of the script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("endColumn")]
        public int EndColumn
        {
            get;
            private set;
        }

        /// <summary>
        /// Specifies script creation context.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextId")]
        public int ExecutionContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// Content hash of the script, SHA-256.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hash")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Hash
        {
            get;
            private set;
        }

        /// <summary>
        /// Embedder-specific auxiliary data likely matching {isDefault: boolean, type: &apos;default&apos;|&apos;isolated&apos;|&apos;worker&apos;, frameId: string}
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextAuxData")]
        public object ExecutionContextAuxData
        {
            get;
            private set;
        }

        /// <summary>
        /// True, if this script is generated as a result of the live edit operation.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("isLiveEdit")]
        public bool? IsLiveEdit
        {
            get;
            private set;
        }

        /// <summary>
        /// URL of source map associated with script (if any).
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceMapURL")]
        public string SourceMapURL
        {
            get;
            private set;
        }

        /// <summary>
        /// True, if this script has sourceURL.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hasSourceURL")]
        public bool? HasSourceURL
        {
            get;
            private set;
        }

        /// <summary>
        /// True, if this script is ES6 module.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("isModule")]
        public bool? IsModule
        {
            get;
            private set;
        }

        /// <summary>
        /// This script length.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("length")]
        public int? Length
        {
            get;
            private set;
        }

        /// <summary>
        /// JavaScript top stack frame of where the script parsed event was triggered if available.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            private set;
        }

        /// <summary>
        /// If the scriptLanguage is WebAssembly, the code section offset in the module.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("codeOffset")]
        public int? CodeOffset
        {
            get;
            private set;
        }

        /// <summary>
        /// The language of the script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("scriptLanguage")]
        public CefSharp.DevTools.Debugger.ScriptLanguage? ScriptLanguage
        {
            get;
            private set;
        }

        /// <summary>
        /// If the scriptLanguage is WebASsembly, the source of debug symbols for the module.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("debugSymbols")]
        public CefSharp.DevTools.Debugger.DebugSymbols DebugSymbols
        {
            get;
            private set;
        }

        /// <summary>
        /// The name the embedder supplied for this script.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("embedderName")]
        public string EmbedderName
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
    /// </summary>
    public partial class SamplingHeapProfileNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Function location.
        /// </summary>
        [JsonPropertyName("callFrame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.CallFrame CallFrame
        {
            get;
            set;
        }

        /// <summary>
        /// Allocations size in bytes for the node excluding children.
        /// </summary>
        [JsonPropertyName("selfSize")]
        public double SelfSize
        {
            get;
            set;
        }

        /// <summary>
        /// Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
        /// </summary>
        [JsonPropertyName("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// Child nodes.
        /// </summary>
        [JsonPropertyName("children")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.HeapProfiler.SamplingHeapProfileNode> Children
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A single sample from a sampling profile.
    /// </summary>
    public partial class SamplingHeapProfileSample : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Allocation size in bytes attributed to the sample.
        /// </summary>
        [JsonPropertyName("size")]
        public double Size
        {
            get;
            set;
        }

        /// <summary>
        /// Id of the corresponding profile tree node.
        /// </summary>
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            set;
        }

        /// <summary>
        /// Time-ordered sample ordinal number. It is unique across all profiles retrieved
        /// between startSampling and stopSampling.
        /// </summary>
        [JsonPropertyName("ordinal")]
        public double Ordinal
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Sampling profile.
    /// </summary>
    public partial class SamplingHeapProfile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Head
        /// </summary>
        [JsonPropertyName("head")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.HeapProfiler.SamplingHeapProfileNode Head
        {
            get;
            set;
        }

        /// <summary>
        /// Samples
        /// </summary>
        [JsonPropertyName("samples")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.HeapProfiler.SamplingHeapProfileSample> Samples
        {
            get;
            set;
        }
    }

    /// <summary>
    /// addHeapSnapshotChunk
    /// </summary>
    public class AddHeapSnapshotChunkEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Chunk
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("chunk")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Chunk
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// If heap objects tracking has been started then backend may send update for one or more fragments
    /// </summary>
    public class HeapStatsUpdateEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// An array of triplets. Each triplet describes a fragment. The first integer is the fragment
        /// index, the second integer is a total count of objects for the fragment, the third integer is
        /// a total size of the objects for the fragment.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("statsUpdate")]
        public int[] StatsUpdate
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// If heap objects tracking has been started then backend regularly sends a current value for last
    /// seen object id and corresponding timestamp. If the were changes in the heap since last event
    /// then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
    /// </summary>
    public class LastSeenObjectIdEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// LastSeenObjectId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("lastSeenObjectId")]
        public int LastSeenObjectId
        {
            get;
            private set;
        }

        /// <summary>
        /// Timestamp
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// reportHeapSnapshotProgress
    /// </summary>
    public class ReportHeapSnapshotProgressEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Done
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("done")]
        public int Done
        {
            get;
            private set;
        }

        /// <summary>
        /// Total
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("total")]
        public int Total
        {
            get;
            private set;
        }

        /// <summary>
        /// Finished
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("finished")]
        public bool? Finished
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// Profile node. Holds callsite information, execution statistics and child nodes.
    /// </summary>
    public partial class ProfileNode : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Unique id of the node.
        /// </summary>
        [JsonPropertyName("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// Function location.
        /// </summary>
        [JsonPropertyName("callFrame")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.CallFrame CallFrame
        {
            get;
            set;
        }

        /// <summary>
        /// Number of samples where this node was on top of the call stack.
        /// </summary>
        [JsonPropertyName("hitCount")]
        public int? HitCount
        {
            get;
            set;
        }

        /// <summary>
        /// Child node ids.
        /// </summary>
        [JsonPropertyName("children")]
        public int[] Children
        {
            get;
            set;
        }

        /// <summary>
        /// The reason of being not optimized. The function may be deoptimized or marked as don&apos;t
        /// optimize.
        /// </summary>
        [JsonPropertyName("deoptReason")]
        public string DeoptReason
        {
            get;
            set;
        }

        /// <summary>
        /// An array of source position ticks.
        /// </summary>
        [JsonPropertyName("positionTicks")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.PositionTickInfo> PositionTicks
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Profile.
    /// </summary>
    public partial class Profile : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The list of profile nodes. First item is the root node.
        /// </summary>
        [JsonPropertyName("nodes")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.ProfileNode> Nodes
        {
            get;
            set;
        }

        /// <summary>
        /// Profiling start timestamp in microseconds.
        /// </summary>
        [JsonPropertyName("startTime")]
        public double StartTime
        {
            get;
            set;
        }

        /// <summary>
        /// Profiling end timestamp in microseconds.
        /// </summary>
        [JsonPropertyName("endTime")]
        public double EndTime
        {
            get;
            set;
        }

        /// <summary>
        /// Ids of samples top nodes.
        /// </summary>
        [JsonPropertyName("samples")]
        public int[] Samples
        {
            get;
            set;
        }

        /// <summary>
        /// Time intervals between adjacent samples in microseconds. The first delta is relative to the
        /// profile startTime.
        /// </summary>
        [JsonPropertyName("timeDeltas")]
        public int[] TimeDeltas
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Specifies a number of samples attributed to a certain source position.
    /// </summary>
    public partial class PositionTickInfo : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Source line number (1-based).
        /// </summary>
        [JsonPropertyName("line")]
        public int Line
        {
            get;
            set;
        }

        /// <summary>
        /// Number of samples attributed to the source line.
        /// </summary>
        [JsonPropertyName("ticks")]
        public int Ticks
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Coverage data for a source range.
    /// </summary>
    public partial class CoverageRange : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript script source offset for the range start.
        /// </summary>
        [JsonPropertyName("startOffset")]
        public int StartOffset
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script source offset for the range end.
        /// </summary>
        [JsonPropertyName("endOffset")]
        public int EndOffset
        {
            get;
            set;
        }

        /// <summary>
        /// Collected execution count of the source range.
        /// </summary>
        [JsonPropertyName("count")]
        public int Count
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Coverage data for a JavaScript function.
    /// </summary>
    public partial class FunctionCoverage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript function name.
        /// </summary>
        [JsonPropertyName("functionName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FunctionName
        {
            get;
            set;
        }

        /// <summary>
        /// Source ranges inside the function with coverage data.
        /// </summary>
        [JsonPropertyName("ranges")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.CoverageRange> Ranges
        {
            get;
            set;
        }

        /// <summary>
        /// Whether coverage data for this function has block granularity.
        /// </summary>
        [JsonPropertyName("isBlockCoverage")]
        public bool IsBlockCoverage
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Coverage data for a JavaScript script.
    /// </summary>
    public partial class ScriptCoverage : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript script id.
        /// </summary>
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script name or url.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// Functions contained in the script that has coverage data.
        /// </summary>
        [JsonPropertyName("functions")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.FunctionCoverage> Functions
        {
            get;
            set;
        }
    }

    /// <summary>
    /// consoleProfileFinished
    /// </summary>
    public class ConsoleProfileFinishedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            private set;
        }

        /// <summary>
        /// Location of console.profileEnd().
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("location")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.Location Location
        {
            get;
            private set;
        }

        /// <summary>
        /// Profile
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("profile")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Profiler.Profile Profile
        {
            get;
            private set;
        }

        /// <summary>
        /// Profile title passed as an argument to console.profile().
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("title")]
        public string Title
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Sent when new profile recording is started using console.profile() call.
    /// </summary>
    public class ConsoleProfileStartedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            private set;
        }

        /// <summary>
        /// Location of console.profile().
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("location")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Debugger.Location Location
        {
            get;
            private set;
        }

        /// <summary>
        /// Profile title passed as an argument to console.profile().
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("title")]
        public string Title
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Reports coverage delta since the last poll (either from an event like this, or from
    /// `takePreciseCoverage` for the current isolate. May only be sent if precise code
    /// coverage has been started. This event can be trigged by the embedder to, for example,
    /// trigger collection of coverage data immediately at a certain point in time.
    /// </summary>
    public class PreciseCoverageDeltaUpdateEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Identifier for distinguishing coverage events.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("occasion")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Occasion
        {
            get;
            private set;
        }

        /// <summary>
        /// Coverage data for the current isolate.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.ScriptCoverage> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// WebDriverValueType
    /// </summary>
    public enum WebDriverValueType
    {
        /// <summary>
        /// undefined
        /// </summary>
        [JsonPropertyName("undefined")]
        Undefined,
        /// <summary>
        /// null
        /// </summary>
        [JsonPropertyName("null")]
        Null,
        /// <summary>
        /// string
        /// </summary>
        [JsonPropertyName("string")]
        String,
        /// <summary>
        /// number
        /// </summary>
        [JsonPropertyName("number")]
        Number,
        /// <summary>
        /// boolean
        /// </summary>
        [JsonPropertyName("boolean")]
        Boolean,
        /// <summary>
        /// bigint
        /// </summary>
        [JsonPropertyName("bigint")]
        Bigint,
        /// <summary>
        /// regexp
        /// </summary>
        [JsonPropertyName("regexp")]
        Regexp,
        /// <summary>
        /// date
        /// </summary>
        [JsonPropertyName("date")]
        Date,
        /// <summary>
        /// symbol
        /// </summary>
        [JsonPropertyName("symbol")]
        Symbol,
        /// <summary>
        /// array
        /// </summary>
        [JsonPropertyName("array")]
        Array,
        /// <summary>
        /// object
        /// </summary>
        [JsonPropertyName("object")]
        Object,
        /// <summary>
        /// function
        /// </summary>
        [JsonPropertyName("function")]
        Function,
        /// <summary>
        /// map
        /// </summary>
        [JsonPropertyName("map")]
        Map,
        /// <summary>
        /// set
        /// </summary>
        [JsonPropertyName("set")]
        Set,
        /// <summary>
        /// weakmap
        /// </summary>
        [JsonPropertyName("weakmap")]
        Weakmap,
        /// <summary>
        /// weakset
        /// </summary>
        [JsonPropertyName("weakset")]
        Weakset,
        /// <summary>
        /// error
        /// </summary>
        [JsonPropertyName("error")]
        Error,
        /// <summary>
        /// proxy
        /// </summary>
        [JsonPropertyName("proxy")]
        Proxy,
        /// <summary>
        /// promise
        /// </summary>
        [JsonPropertyName("promise")]
        Promise,
        /// <summary>
        /// typedarray
        /// </summary>
        [JsonPropertyName("typedarray")]
        Typedarray,
        /// <summary>
        /// arraybuffer
        /// </summary>
        [JsonPropertyName("arraybuffer")]
        Arraybuffer,
        /// <summary>
        /// node
        /// </summary>
        [JsonPropertyName("node")]
        Node,
        /// <summary>
        /// window
        /// </summary>
        [JsonPropertyName("window")]
        Window
    }

    /// <summary>
    /// Represents the value serialiazed by the WebDriver BiDi specification
    /// https://w3c.github.io/webdriver-bidi.
    /// </summary>
    public partial class WebDriverValue : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Type
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Runtime.WebDriverValueType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Value
        /// </summary>
        [JsonPropertyName("value")]
        public object Value
        {
            get;
            set;
        }

        /// <summary>
        /// ObjectId
        /// </summary>
        [JsonPropertyName("objectId")]
        public string ObjectId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Object type.
    /// </summary>
    public enum RemoteObjectType
    {
        /// <summary>
        /// object
        /// </summary>
        [JsonPropertyName("object")]
        Object,
        /// <summary>
        /// function
        /// </summary>
        [JsonPropertyName("function")]
        Function,
        /// <summary>
        /// undefined
        /// </summary>
        [JsonPropertyName("undefined")]
        Undefined,
        /// <summary>
        /// string
        /// </summary>
        [JsonPropertyName("string")]
        String,
        /// <summary>
        /// number
        /// </summary>
        [JsonPropertyName("number")]
        Number,
        /// <summary>
        /// boolean
        /// </summary>
        [JsonPropertyName("boolean")]
        Boolean,
        /// <summary>
        /// symbol
        /// </summary>
        [JsonPropertyName("symbol")]
        Symbol,
        /// <summary>
        /// bigint
        /// </summary>
        [JsonPropertyName("bigint")]
        Bigint
    }

    /// <summary>
    /// Object subtype hint. Specified for `object` type values only.
    /// NOTE: If you change anything here, make sure to also update
    /// `subtype` in `ObjectPreview` and `PropertyPreview` below.
    /// </summary>
    public enum RemoteObjectSubtype
    {
        /// <summary>
        /// array
        /// </summary>
        [JsonPropertyName("array")]
        Array,
        /// <summary>
        /// null
        /// </summary>
        [JsonPropertyName("null")]
        Null,
        /// <summary>
        /// node
        /// </summary>
        [JsonPropertyName("node")]
        Node,
        /// <summary>
        /// regexp
        /// </summary>
        [JsonPropertyName("regexp")]
        Regexp,
        /// <summary>
        /// date
        /// </summary>
        [JsonPropertyName("date")]
        Date,
        /// <summary>
        /// map
        /// </summary>
        [JsonPropertyName("map")]
        Map,
        /// <summary>
        /// set
        /// </summary>
        [JsonPropertyName("set")]
        Set,
        /// <summary>
        /// weakmap
        /// </summary>
        [JsonPropertyName("weakmap")]
        Weakmap,
        /// <summary>
        /// weakset
        /// </summary>
        [JsonPropertyName("weakset")]
        Weakset,
        /// <summary>
        /// iterator
        /// </summary>
        [JsonPropertyName("iterator")]
        Iterator,
        /// <summary>
        /// generator
        /// </summary>
        [JsonPropertyName("generator")]
        Generator,
        /// <summary>
        /// error
        /// </summary>
        [JsonPropertyName("error")]
        Error,
        /// <summary>
        /// proxy
        /// </summary>
        [JsonPropertyName("proxy")]
        Proxy,
        /// <summary>
        /// promise
        /// </summary>
        [JsonPropertyName("promise")]
        Promise,
        /// <summary>
        /// typedarray
        /// </summary>
        [JsonPropertyName("typedarray")]
        Typedarray,
        /// <summary>
        /// arraybuffer
        /// </summary>
        [JsonPropertyName("arraybuffer")]
        Arraybuffer,
        /// <summary>
        /// dataview
        /// </summary>
        [JsonPropertyName("dataview")]
        Dataview,
        /// <summary>
        /// webassemblymemory
        /// </summary>
        [JsonPropertyName("webassemblymemory")]
        Webassemblymemory,
        /// <summary>
        /// wasmvalue
        /// </summary>
        [JsonPropertyName("wasmvalue")]
        Wasmvalue
    }

    /// <summary>
    /// Mirror object referencing original JavaScript object.
    /// </summary>
    public partial class RemoteObject : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Object type.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Runtime.RemoteObjectType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Object subtype hint. Specified for `object` type values only.
        /// NOTE: If you change anything here, make sure to also update
        /// `subtype` in `ObjectPreview` and `PropertyPreview` below.
        /// </summary>
        [JsonPropertyName("subtype")]
        public CefSharp.DevTools.Runtime.RemoteObjectSubtype? Subtype
        {
            get;
            set;
        }

        /// <summary>
        /// Object class (constructor) name. Specified for `object` type values only.
        /// </summary>
        [JsonPropertyName("className")]
        public string ClassName
        {
            get;
            set;
        }

        /// <summary>
        /// Remote object value in case of primitive values or JSON values (if it was requested).
        /// </summary>
        [JsonPropertyName("value")]
        public object Value
        {
            get;
            set;
        }

        /// <summary>
        /// Primitive value which can not be JSON-stringified does not have `value`, but gets this
        /// property.
        /// </summary>
        [JsonPropertyName("unserializableValue")]
        public string UnserializableValue
        {
            get;
            set;
        }

        /// <summary>
        /// String representation of the object.
        /// </summary>
        [JsonPropertyName("description")]
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// WebDriver BiDi representation of the value.
        /// </summary>
        [JsonPropertyName("webDriverValue")]
        public CefSharp.DevTools.Runtime.WebDriverValue WebDriverValue
        {
            get;
            set;
        }

        /// <summary>
        /// Unique object identifier (for non-primitive values).
        /// </summary>
        [JsonPropertyName("objectId")]
        public string ObjectId
        {
            get;
            set;
        }

        /// <summary>
        /// Preview containing abbreviated property values. Specified for `object` type values only.
        /// </summary>
        [JsonPropertyName("preview")]
        public CefSharp.DevTools.Runtime.ObjectPreview Preview
        {
            get;
            set;
        }

        /// <summary>
        /// CustomPreview
        /// </summary>
        [JsonPropertyName("customPreview")]
        public CefSharp.DevTools.Runtime.CustomPreview CustomPreview
        {
            get;
            set;
        }
    }

    /// <summary>
    /// CustomPreview
    /// </summary>
    public partial class CustomPreview : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// The JSON-stringified result of formatter.header(object, config) call.
        /// It contains json ML array that represents RemoteObject.
        /// </summary>
        [JsonPropertyName("header")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Header
        {
            get;
            set;
        }

        /// <summary>
        /// If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
        /// contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
        /// The result value is json ML array.
        /// </summary>
        [JsonPropertyName("bodyGetterId")]
        public string BodyGetterId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Object type.
    /// </summary>
    public enum ObjectPreviewType
    {
        /// <summary>
        /// object
        /// </summary>
        [JsonPropertyName("object")]
        Object,
        /// <summary>
        /// function
        /// </summary>
        [JsonPropertyName("function")]
        Function,
        /// <summary>
        /// undefined
        /// </summary>
        [JsonPropertyName("undefined")]
        Undefined,
        /// <summary>
        /// string
        /// </summary>
        [JsonPropertyName("string")]
        String,
        /// <summary>
        /// number
        /// </summary>
        [JsonPropertyName("number")]
        Number,
        /// <summary>
        /// boolean
        /// </summary>
        [JsonPropertyName("boolean")]
        Boolean,
        /// <summary>
        /// symbol
        /// </summary>
        [JsonPropertyName("symbol")]
        Symbol,
        /// <summary>
        /// bigint
        /// </summary>
        [JsonPropertyName("bigint")]
        Bigint
    }

    /// <summary>
    /// Object subtype hint. Specified for `object` type values only.
    /// </summary>
    public enum ObjectPreviewSubtype
    {
        /// <summary>
        /// array
        /// </summary>
        [JsonPropertyName("array")]
        Array,
        /// <summary>
        /// null
        /// </summary>
        [JsonPropertyName("null")]
        Null,
        /// <summary>
        /// node
        /// </summary>
        [JsonPropertyName("node")]
        Node,
        /// <summary>
        /// regexp
        /// </summary>
        [JsonPropertyName("regexp")]
        Regexp,
        /// <summary>
        /// date
        /// </summary>
        [JsonPropertyName("date")]
        Date,
        /// <summary>
        /// map
        /// </summary>
        [JsonPropertyName("map")]
        Map,
        /// <summary>
        /// set
        /// </summary>
        [JsonPropertyName("set")]
        Set,
        /// <summary>
        /// weakmap
        /// </summary>
        [JsonPropertyName("weakmap")]
        Weakmap,
        /// <summary>
        /// weakset
        /// </summary>
        [JsonPropertyName("weakset")]
        Weakset,
        /// <summary>
        /// iterator
        /// </summary>
        [JsonPropertyName("iterator")]
        Iterator,
        /// <summary>
        /// generator
        /// </summary>
        [JsonPropertyName("generator")]
        Generator,
        /// <summary>
        /// error
        /// </summary>
        [JsonPropertyName("error")]
        Error,
        /// <summary>
        /// proxy
        /// </summary>
        [JsonPropertyName("proxy")]
        Proxy,
        /// <summary>
        /// promise
        /// </summary>
        [JsonPropertyName("promise")]
        Promise,
        /// <summary>
        /// typedarray
        /// </summary>
        [JsonPropertyName("typedarray")]
        Typedarray,
        /// <summary>
        /// arraybuffer
        /// </summary>
        [JsonPropertyName("arraybuffer")]
        Arraybuffer,
        /// <summary>
        /// dataview
        /// </summary>
        [JsonPropertyName("dataview")]
        Dataview,
        /// <summary>
        /// webassemblymemory
        /// </summary>
        [JsonPropertyName("webassemblymemory")]
        Webassemblymemory,
        /// <summary>
        /// wasmvalue
        /// </summary>
        [JsonPropertyName("wasmvalue")]
        Wasmvalue
    }

    /// <summary>
    /// Object containing abbreviated remote object value.
    /// </summary>
    public partial class ObjectPreview : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Object type.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Runtime.ObjectPreviewType Type
        {
            get;
            set;
        }

        /// <summary>
        /// Object subtype hint. Specified for `object` type values only.
        /// </summary>
        [JsonPropertyName("subtype")]
        public CefSharp.DevTools.Runtime.ObjectPreviewSubtype? Subtype
        {
            get;
            set;
        }

        /// <summary>
        /// String representation of the object.
        /// </summary>
        [JsonPropertyName("description")]
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// True iff some of the properties or entries of the original object did not fit.
        /// </summary>
        [JsonPropertyName("overflow")]
        public bool Overflow
        {
            get;
            set;
        }

        /// <summary>
        /// List of the properties.
        /// </summary>
        [JsonPropertyName("properties")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.PropertyPreview> Properties
        {
            get;
            set;
        }

        /// <summary>
        /// List of the entries. Specified for `map` and `set` subtype values only.
        /// </summary>
        [JsonPropertyName("entries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.EntryPreview> Entries
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Object type. Accessor means that the property itself is an accessor property.
    /// </summary>
    public enum PropertyPreviewType
    {
        /// <summary>
        /// object
        /// </summary>
        [JsonPropertyName("object")]
        Object,
        /// <summary>
        /// function
        /// </summary>
        [JsonPropertyName("function")]
        Function,
        /// <summary>
        /// undefined
        /// </summary>
        [JsonPropertyName("undefined")]
        Undefined,
        /// <summary>
        /// string
        /// </summary>
        [JsonPropertyName("string")]
        String,
        /// <summary>
        /// number
        /// </summary>
        [JsonPropertyName("number")]
        Number,
        /// <summary>
        /// boolean
        /// </summary>
        [JsonPropertyName("boolean")]
        Boolean,
        /// <summary>
        /// symbol
        /// </summary>
        [JsonPropertyName("symbol")]
        Symbol,
        /// <summary>
        /// accessor
        /// </summary>
        [JsonPropertyName("accessor")]
        Accessor,
        /// <summary>
        /// bigint
        /// </summary>
        [JsonPropertyName("bigint")]
        Bigint
    }

    /// <summary>
    /// Object subtype hint. Specified for `object` type values only.
    /// </summary>
    public enum PropertyPreviewSubtype
    {
        /// <summary>
        /// array
        /// </summary>
        [JsonPropertyName("array")]
        Array,
        /// <summary>
        /// null
        /// </summary>
        [JsonPropertyName("null")]
        Null,
        /// <summary>
        /// node
        /// </summary>
        [JsonPropertyName("node")]
        Node,
        /// <summary>
        /// regexp
        /// </summary>
        [JsonPropertyName("regexp")]
        Regexp,
        /// <summary>
        /// date
        /// </summary>
        [JsonPropertyName("date")]
        Date,
        /// <summary>
        /// map
        /// </summary>
        [JsonPropertyName("map")]
        Map,
        /// <summary>
        /// set
        /// </summary>
        [JsonPropertyName("set")]
        Set,
        /// <summary>
        /// weakmap
        /// </summary>
        [JsonPropertyName("weakmap")]
        Weakmap,
        /// <summary>
        /// weakset
        /// </summary>
        [JsonPropertyName("weakset")]
        Weakset,
        /// <summary>
        /// iterator
        /// </summary>
        [JsonPropertyName("iterator")]
        Iterator,
        /// <summary>
        /// generator
        /// </summary>
        [JsonPropertyName("generator")]
        Generator,
        /// <summary>
        /// error
        /// </summary>
        [JsonPropertyName("error")]
        Error,
        /// <summary>
        /// proxy
        /// </summary>
        [JsonPropertyName("proxy")]
        Proxy,
        /// <summary>
        /// promise
        /// </summary>
        [JsonPropertyName("promise")]
        Promise,
        /// <summary>
        /// typedarray
        /// </summary>
        [JsonPropertyName("typedarray")]
        Typedarray,
        /// <summary>
        /// arraybuffer
        /// </summary>
        [JsonPropertyName("arraybuffer")]
        Arraybuffer,
        /// <summary>
        /// dataview
        /// </summary>
        [JsonPropertyName("dataview")]
        Dataview,
        /// <summary>
        /// webassemblymemory
        /// </summary>
        [JsonPropertyName("webassemblymemory")]
        Webassemblymemory,
        /// <summary>
        /// wasmvalue
        /// </summary>
        [JsonPropertyName("wasmvalue")]
        Wasmvalue
    }

    /// <summary>
    /// PropertyPreview
    /// </summary>
    public partial class PropertyPreview : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Property name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Object type. Accessor means that the property itself is an accessor property.
        /// </summary>
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Runtime.PropertyPreviewType Type
        {
            get;
            set;
        }

        /// <summary>
        /// User-friendly property value string.
        /// </summary>
        [JsonPropertyName("value")]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// Nested value preview.
        /// </summary>
        [JsonPropertyName("valuePreview")]
        public CefSharp.DevTools.Runtime.ObjectPreview ValuePreview
        {
            get;
            set;
        }

        /// <summary>
        /// Object subtype hint. Specified for `object` type values only.
        /// </summary>
        [JsonPropertyName("subtype")]
        public CefSharp.DevTools.Runtime.PropertyPreviewSubtype? Subtype
        {
            get;
            set;
        }
    }

    /// <summary>
    /// EntryPreview
    /// </summary>
    public partial class EntryPreview : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Preview of the key. Specified for map-like collection entries.
        /// </summary>
        [JsonPropertyName("key")]
        public CefSharp.DevTools.Runtime.ObjectPreview Key
        {
            get;
            set;
        }

        /// <summary>
        /// Preview of the value.
        /// </summary>
        [JsonPropertyName("value")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.ObjectPreview Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Object property descriptor.
    /// </summary>
    public partial class PropertyDescriptor : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Property name or symbol description.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The value associated with the property.
        /// </summary>
        [JsonPropertyName("value")]
        public CefSharp.DevTools.Runtime.RemoteObject Value
        {
            get;
            set;
        }

        /// <summary>
        /// True if the value associated with the property may be changed (data descriptors only).
        /// </summary>
        [JsonPropertyName("writable")]
        public bool? Writable
        {
            get;
            set;
        }

        /// <summary>
        /// A function which serves as a getter for the property, or `undefined` if there is no getter
        /// (accessor descriptors only).
        /// </summary>
        [JsonPropertyName("get")]
        public CefSharp.DevTools.Runtime.RemoteObject Get
        {
            get;
            set;
        }

        /// <summary>
        /// A function which serves as a setter for the property, or `undefined` if there is no setter
        /// (accessor descriptors only).
        /// </summary>
        [JsonPropertyName("set")]
        public CefSharp.DevTools.Runtime.RemoteObject Set
        {
            get;
            set;
        }

        /// <summary>
        /// True if the type of this property descriptor may be changed and if the property may be
        /// deleted from the corresponding object.
        /// </summary>
        [JsonPropertyName("configurable")]
        public bool Configurable
        {
            get;
            set;
        }

        /// <summary>
        /// True if this property shows up during enumeration of the properties on the corresponding
        /// object.
        /// </summary>
        [JsonPropertyName("enumerable")]
        public bool Enumerable
        {
            get;
            set;
        }

        /// <summary>
        /// True if the result was thrown during the evaluation.
        /// </summary>
        [JsonPropertyName("wasThrown")]
        public bool? WasThrown
        {
            get;
            set;
        }

        /// <summary>
        /// True if the property is owned for the object.
        /// </summary>
        [JsonPropertyName("isOwn")]
        public bool? IsOwn
        {
            get;
            set;
        }

        /// <summary>
        /// Property symbol object, if the property is of the `symbol` type.
        /// </summary>
        [JsonPropertyName("symbol")]
        public CefSharp.DevTools.Runtime.RemoteObject Symbol
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Object internal property descriptor. This property isn&apos;t normally visible in JavaScript code.
    /// </summary>
    public partial class InternalPropertyDescriptor : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Conventional property name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The value associated with the property.
        /// </summary>
        [JsonPropertyName("value")]
        public CefSharp.DevTools.Runtime.RemoteObject Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Object private field descriptor.
    /// </summary>
    public partial class PrivatePropertyDescriptor : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Private property name.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// The value associated with the private property.
        /// </summary>
        [JsonPropertyName("value")]
        public CefSharp.DevTools.Runtime.RemoteObject Value
        {
            get;
            set;
        }

        /// <summary>
        /// A function which serves as a getter for the private property,
        /// or `undefined` if there is no getter (accessor descriptors only).
        /// </summary>
        [JsonPropertyName("get")]
        public CefSharp.DevTools.Runtime.RemoteObject Get
        {
            get;
            set;
        }

        /// <summary>
        /// A function which serves as a setter for the private property,
        /// or `undefined` if there is no setter (accessor descriptors only).
        /// </summary>
        [JsonPropertyName("set")]
        public CefSharp.DevTools.Runtime.RemoteObject Set
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Represents function call argument. Either remote object id `objectId`, primitive `value`,
    /// unserializable primitive value or neither of (for undefined) them should be specified.
    /// </summary>
    public partial class CallArgument : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Primitive value or serializable javascript object.
        /// </summary>
        [JsonPropertyName("value")]
        public object Value
        {
            get;
            set;
        }

        /// <summary>
        /// Primitive value which can not be JSON-stringified.
        /// </summary>
        [JsonPropertyName("unserializableValue")]
        public string UnserializableValue
        {
            get;
            set;
        }

        /// <summary>
        /// Remote object handle.
        /// </summary>
        [JsonPropertyName("objectId")]
        public string ObjectId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Description of an isolated world.
    /// </summary>
    public partial class ExecutionContextDescription : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Unique id of the execution context. It can be used to specify in which execution context
        /// script evaluation should be performed.
        /// </summary>
        [JsonPropertyName("id")]
        public int Id
        {
            get;
            set;
        }

        /// <summary>
        /// Execution context origin.
        /// </summary>
        [JsonPropertyName("origin")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Origin
        {
            get;
            set;
        }

        /// <summary>
        /// Human readable name describing given context.
        /// </summary>
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// A system-unique execution context identifier. Unlike the id, this is unique across
        /// multiple processes, so can be reliably used to identify specific context while backend
        /// performs a cross-process navigation.
        /// </summary>
        [JsonPropertyName("uniqueId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string UniqueId
        {
            get;
            set;
        }

        /// <summary>
        /// Embedder-specific auxiliary data likely matching {isDefault: boolean, type: &apos;default&apos;|&apos;isolated&apos;|&apos;worker&apos;, frameId: string}
        /// </summary>
        [JsonPropertyName("auxData")]
        public object AuxData
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Detailed information about exception (or error) that was thrown during script compilation or
    /// execution.
    /// </summary>
    public partial class ExceptionDetails : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Exception id.
        /// </summary>
        [JsonPropertyName("exceptionId")]
        public int ExceptionId
        {
            get;
            set;
        }

        /// <summary>
        /// Exception text, which should be used together with exception object when available.
        /// </summary>
        [JsonPropertyName("text")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Text
        {
            get;
            set;
        }

        /// <summary>
        /// Line number of the exception location (0-based).
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Column number of the exception location (0-based).
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Script ID of the exception location.
        /// </summary>
        [JsonPropertyName("scriptId")]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// URL of the exception location, to be used when the script was not reported.
        /// </summary>
        [JsonPropertyName("url")]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript stack trace if available.
        /// </summary>
        [JsonPropertyName("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            set;
        }

        /// <summary>
        /// Exception object if available.
        /// </summary>
        [JsonPropertyName("exception")]
        public CefSharp.DevTools.Runtime.RemoteObject Exception
        {
            get;
            set;
        }

        /// <summary>
        /// Identifier of the context where exception happened.
        /// </summary>
        [JsonPropertyName("executionContextId")]
        public int? ExecutionContextId
        {
            get;
            set;
        }

        /// <summary>
        /// Dictionary with entries of meta data that the client associated
        /// with this exception, such as information about associated network
        /// requests, etc.
        /// </summary>
        [JsonPropertyName("exceptionMetaData")]
        public object ExceptionMetaData
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Stack entry for runtime errors and assertions.
    /// </summary>
    public partial class CallFrame : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// JavaScript function name.
        /// </summary>
        [JsonPropertyName("functionName")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string FunctionName
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script id.
        /// </summary>
        [JsonPropertyName("scriptId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ScriptId
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script name or url.
        /// </summary>
        [JsonPropertyName("url")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Url
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script line number (0-based).
        /// </summary>
        [JsonPropertyName("lineNumber")]
        public int LineNumber
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript script column number (0-based).
        /// </summary>
        [JsonPropertyName("columnNumber")]
        public int ColumnNumber
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Call frames for assertions or error messages.
    /// </summary>
    public partial class StackTrace : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// String label of this stack trace. For async traces this may be a name of the function that
        /// initiated the async call.
        /// </summary>
        [JsonPropertyName("description")]
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// JavaScript function name.
        /// </summary>
        [JsonPropertyName("callFrames")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.CallFrame> CallFrames
        {
            get;
            set;
        }

        /// <summary>
        /// Asynchronous JavaScript stack trace that preceded this stack, if available.
        /// </summary>
        [JsonPropertyName("parent")]
        public CefSharp.DevTools.Runtime.StackTrace Parent
        {
            get;
            set;
        }

        /// <summary>
        /// Asynchronous JavaScript stack trace that preceded this stack, if available.
        /// </summary>
        [JsonPropertyName("parentId")]
        public CefSharp.DevTools.Runtime.StackTraceId ParentId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
    /// allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
    /// </summary>
    public partial class StackTraceId : CefSharp.DevTools.DevToolsDomainEntityBase
    {
        /// <summary>
        /// Id
        /// </summary>
        [JsonPropertyName("id")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Id
        {
            get;
            set;
        }

        /// <summary>
        /// DebuggerId
        /// </summary>
        [JsonPropertyName("debuggerId")]
        public string DebuggerId
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Notification is issued every time when binding is called.
    /// </summary>
    public class BindingCalledEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Name
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("name")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Name
        {
            get;
            private set;
        }

        /// <summary>
        /// Payload
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("payload")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Payload
        {
            get;
            private set;
        }

        /// <summary>
        /// Identifier of the context where the call was made.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextId")]
        public int ExecutionContextId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Type of the call.
    /// </summary>
    public enum ConsoleAPICalledType
    {
        /// <summary>
        /// log
        /// </summary>
        [JsonPropertyName("log")]
        Log,
        /// <summary>
        /// debug
        /// </summary>
        [JsonPropertyName("debug")]
        Debug,
        /// <summary>
        /// info
        /// </summary>
        [JsonPropertyName("info")]
        Info,
        /// <summary>
        /// error
        /// </summary>
        [JsonPropertyName("error")]
        Error,
        /// <summary>
        /// warning
        /// </summary>
        [JsonPropertyName("warning")]
        Warning,
        /// <summary>
        /// dir
        /// </summary>
        [JsonPropertyName("dir")]
        Dir,
        /// <summary>
        /// dirxml
        /// </summary>
        [JsonPropertyName("dirxml")]
        Dirxml,
        /// <summary>
        /// table
        /// </summary>
        [JsonPropertyName("table")]
        Table,
        /// <summary>
        /// trace
        /// </summary>
        [JsonPropertyName("trace")]
        Trace,
        /// <summary>
        /// clear
        /// </summary>
        [JsonPropertyName("clear")]
        Clear,
        /// <summary>
        /// startGroup
        /// </summary>
        [JsonPropertyName("startGroup")]
        StartGroup,
        /// <summary>
        /// startGroupCollapsed
        /// </summary>
        [JsonPropertyName("startGroupCollapsed")]
        StartGroupCollapsed,
        /// <summary>
        /// endGroup
        /// </summary>
        [JsonPropertyName("endGroup")]
        EndGroup,
        /// <summary>
        /// assert
        /// </summary>
        [JsonPropertyName("assert")]
        Assert,
        /// <summary>
        /// profile
        /// </summary>
        [JsonPropertyName("profile")]
        Profile,
        /// <summary>
        /// profileEnd
        /// </summary>
        [JsonPropertyName("profileEnd")]
        ProfileEnd,
        /// <summary>
        /// count
        /// </summary>
        [JsonPropertyName("count")]
        Count,
        /// <summary>
        /// timeEnd
        /// </summary>
        [JsonPropertyName("timeEnd")]
        TimeEnd
    }

    /// <summary>
    /// Issued when console API was called.
    /// </summary>
    public class ConsoleAPICalledEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Type of the call.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("type")]
        public CefSharp.DevTools.Runtime.ConsoleAPICalledType Type
        {
            get;
            private set;
        }

        /// <summary>
        /// Call arguments.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("args")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.RemoteObject> Args
        {
            get;
            private set;
        }

        /// <summary>
        /// Identifier of the context where the call was made.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextId")]
        public int ExecutionContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// Call timestamp.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// Stack trace captured when the call was made. The async stack chain is automatically reported for
        /// the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
        /// chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            private set;
        }

        /// <summary>
        /// Console context descriptor for calls on non-default console context (not console.*):
        /// &apos;anonymous#unique-logger-id&apos; for call on unnamed context, &apos;name#unique-logger-id&apos; for call
        /// on named context.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("context")]
        public string Context
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when unhandled exception was revoked.
    /// </summary>
    public class ExceptionRevokedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Reason describing why exception was revoked.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("reason")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string Reason
        {
            get;
            private set;
        }

        /// <summary>
        /// The id of revoked exception, as reported in `exceptionThrown`.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionId")]
        public int ExceptionId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when exception was thrown and unhandled.
    /// </summary>
    public class ExceptionThrownEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Timestamp of the exception.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }

        /// <summary>
        /// ExceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when new execution context is created.
    /// </summary>
    public class ExecutionContextCreatedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// A newly created execution context.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("context")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.ExecutionContextDescription Context
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when execution context is destroyed.
    /// </summary>
    public class ExecutionContextDestroyedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Id of the destroyed context
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextId")]
        public int ExecutionContextId
        {
            get;
            private set;
        }

        /// <summary>
        /// Unique Id of the destroyed context
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextUniqueId")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public string ExecutionContextUniqueId
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Issued when object should be inspected (for example, as a result of inspect() command line API
    /// call).
    /// </summary>
    public class InspectRequestedEventArgs : CefSharp.DevTools.DevToolsDomainEventArgsBase
    {
        /// <summary>
        /// Object
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("object")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public CefSharp.DevTools.Runtime.RemoteObject Object
        {
            get;
            private set;
        }

        /// <summary>
        /// Hints
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hints")]
        [System.Diagnostics.CodeAnalysis.DisallowNull]
        public object Hints
        {
            get;
            private set;
        }

        /// <summary>
        /// Identifier of the context where the call was made.
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextId")]
        public int? ExecutionContextId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// GetPartialAXTreeResponse
    /// </summary>
    public class GetPartialAXTreeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodes
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// GetFullAXTreeResponse
    /// </summary>
    public class GetFullAXTreeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodes
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// GetRootAXNodeResponse
    /// </summary>
    public class GetRootAXNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// node
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("node")]
        public CefSharp.DevTools.Accessibility.AXNode Node
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// GetAXNodeAndAncestorsResponse
    /// </summary>
    public class GetAXNodeAndAncestorsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodes
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// GetChildAXNodesResponse
    /// </summary>
    public class GetChildAXNodesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodes
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    /// <summary>
    /// QueryAXTreeResponse
    /// </summary>
    public class QueryAXTreeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodes
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodes")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Accessibility.AXNode> Nodes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Accessibility
{
    using System.Linq;

    /// <summary>
    /// Accessibility
    /// </summary>
    public partial class AccessibilityClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Accessibility
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public AccessibilityClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// The loadComplete event mirrors the load complete event sent by the browser to assistive
        /// technology when the web page has finished loading.
        /// </summary>
        public event System.EventHandler<LoadCompleteEventArgs> LoadComplete
        {
            add
            {
                _client.AddEventHandler<LoadCompleteEventArgs>("Accessibility.loadComplete", value);
            }

            remove
            {
                _client.RemoveEventHandler<LoadCompleteEventArgs>("Accessibility.loadComplete", value);
            }
        }

        /// <summary>
        /// The nodesUpdated event is sent every time a previously requested node has changed the in tree.
        /// </summary>
        public event System.EventHandler<NodesUpdatedEventArgs> NodesUpdated
        {
            add
            {
                _client.AddEventHandler<NodesUpdatedEventArgs>("Accessibility.nodesUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<NodesUpdatedEventArgs>("Accessibility.nodesUpdated", value);
            }
        }

        /// <summary>
        /// Disables the accessibility domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Accessibility.disable", dict);
        }

        /// <summary>
        /// Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
        /// This turns on accessibility for the page, which can impact performance until accessibility is disabled.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Accessibility.enable", dict);
        }

        partial void ValidateGetPartialAXTree(int? nodeId = null, int? backendNodeId = null, string objectId = null, bool? fetchRelatives = null);
        /// <summary>
        /// Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node to get the partial accessibility tree for.</param>
        /// <param name = "backendNodeId">Identifier of the backend node to get the partial accessibility tree for.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper to get the partial accessibility tree for.</param>
        /// <param name = "fetchRelatives">Whether to fetch this node's ancestors, siblings and children. Defaults to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPartialAXTreeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetPartialAXTreeResponse> GetPartialAXTreeAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null, bool? fetchRelatives = null)
        {
            ValidateGetPartialAXTree(nodeId, backendNodeId, objectId, fetchRelatives);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if (fetchRelatives.HasValue)
            {
                dict.Add("fetchRelatives", fetchRelatives.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetPartialAXTreeResponse>("Accessibility.getPartialAXTree", dict);
        }

        partial void ValidateGetFullAXTree(int? depth = null, string frameId = null);
        /// <summary>
        /// Fetches the entire accessibility tree for the root Document
        /// </summary>
        /// <param name = "depth">The maximum depth at which descendants of the root node should be retrieved.If omitted, the full tree is returned.</param>
        /// <param name = "frameId">The frame for whose document the AX tree should be retrieved.If omited, the root frame is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFullAXTreeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetFullAXTreeResponse> GetFullAXTreeAsync(int? depth = null, string frameId = null)
        {
            ValidateGetFullAXTree(depth, frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (!(string.IsNullOrEmpty(frameId)))
            {
                dict.Add("frameId", frameId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetFullAXTreeResponse>("Accessibility.getFullAXTree", dict);
        }

        partial void ValidateGetRootAXNode(string frameId = null);
        /// <summary>
        /// Fetches the root node.
        /// Requires `enable()` to have been called previously.
        /// </summary>
        /// <param name = "frameId">The frame in whose document the node resides.If omitted, the root frame is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetRootAXNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetRootAXNodeResponse> GetRootAXNodeAsync(string frameId = null)
        {
            ValidateGetRootAXNode(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(frameId)))
            {
                dict.Add("frameId", frameId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetRootAXNodeResponse>("Accessibility.getRootAXNode", dict);
        }

        partial void ValidateGetAXNodeAndAncestors(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Fetches a node and all ancestors up to and including the root.
        /// Requires `enable()` to have been called previously.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node to get.</param>
        /// <param name = "backendNodeId">Identifier of the backend node to get.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper to get.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAXNodeAndAncestorsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetAXNodeAndAncestorsResponse> GetAXNodeAndAncestorsAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateGetAXNodeAndAncestors(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetAXNodeAndAncestorsResponse>("Accessibility.getAXNodeAndAncestors", dict);
        }

        partial void ValidateGetChildAXNodes(string id, string frameId = null);
        /// <summary>
        /// Fetches a particular accessibility node by AXNodeId.
        /// Requires `enable()` to have been called previously.
        /// </summary>
        /// <param name = "id">id</param>
        /// <param name = "frameId">The frame in whose document the node resides.If omitted, the root frame is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetChildAXNodesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetChildAXNodesResponse> GetChildAXNodesAsync(string id, string frameId = null)
        {
            ValidateGetChildAXNodes(id, frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("id", id);
            if (!(string.IsNullOrEmpty(frameId)))
            {
                dict.Add("frameId", frameId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetChildAXNodesResponse>("Accessibility.getChildAXNodes", dict);
        }

        partial void ValidateQueryAXTree(int? nodeId = null, int? backendNodeId = null, string objectId = null, string accessibleName = null, string role = null);
        /// <summary>
        /// Query a DOM node&apos;s accessibility subtree for accessible name and role.
        /// This command computes the name and role for all nodes in the subtree, including those that are
        /// ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
        /// node is specified, or the DOM node does not exist, the command returns an error. If neither
        /// `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node for the root to query.</param>
        /// <param name = "backendNodeId">Identifier of the backend node for the root to query.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper for the root to query.</param>
        /// <param name = "accessibleName">Find nodes with this computed name.</param>
        /// <param name = "role">Find nodes with this computed role.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;QueryAXTreeResponse&gt;</returns>
        public System.Threading.Tasks.Task<QueryAXTreeResponse> QueryAXTreeAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null, string accessibleName = null, string role = null)
        {
            ValidateQueryAXTree(nodeId, backendNodeId, objectId, accessibleName, role);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if (!(string.IsNullOrEmpty(accessibleName)))
            {
                dict.Add("accessibleName", accessibleName);
            }

            if (!(string.IsNullOrEmpty(role)))
            {
                dict.Add("role", role);
            }

            return _client.ExecuteDevToolsMethodAsync<QueryAXTreeResponse>("Accessibility.queryAXTree", dict);
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// GetCurrentTimeResponse
    /// </summary>
    public class GetCurrentTimeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// currentTime
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("currentTime")]
        public double CurrentTime
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// GetPlaybackRateResponse
    /// </summary>
    public class GetPlaybackRateResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// playbackRate
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("playbackRate")]
        public double PlaybackRate
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    /// <summary>
    /// ResolveAnimationResponse
    /// </summary>
    public class ResolveAnimationResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// remoteObject
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("remoteObject")]
        public CefSharp.DevTools.Runtime.RemoteObject RemoteObject
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Animation
{
    using System.Linq;

    /// <summary>
    /// Animation
    /// </summary>
    public partial class AnimationClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Animation
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public AnimationClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Event for when an animation has been cancelled.
        /// </summary>
        public event System.EventHandler<AnimationCanceledEventArgs> AnimationCanceled
        {
            add
            {
                _client.AddEventHandler<AnimationCanceledEventArgs>("Animation.animationCanceled", value);
            }

            remove
            {
                _client.RemoveEventHandler<AnimationCanceledEventArgs>("Animation.animationCanceled", value);
            }
        }

        /// <summary>
        /// Event for each animation that has been created.
        /// </summary>
        public event System.EventHandler<AnimationCreatedEventArgs> AnimationCreated
        {
            add
            {
                _client.AddEventHandler<AnimationCreatedEventArgs>("Animation.animationCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<AnimationCreatedEventArgs>("Animation.animationCreated", value);
            }
        }

        /// <summary>
        /// Event for animation that has been started.
        /// </summary>
        public event System.EventHandler<AnimationStartedEventArgs> AnimationStarted
        {
            add
            {
                _client.AddEventHandler<AnimationStartedEventArgs>("Animation.animationStarted", value);
            }

            remove
            {
                _client.RemoveEventHandler<AnimationStartedEventArgs>("Animation.animationStarted", value);
            }
        }

        /// <summary>
        /// Disables animation domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Animation.disable", dict);
        }

        /// <summary>
        /// Enables animation domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Animation.enable", dict);
        }

        partial void ValidateGetCurrentTime(string id);
        /// <summary>
        /// Returns the current time of the an animation.
        /// </summary>
        /// <param name = "id">Id of animation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCurrentTimeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetCurrentTimeResponse> GetCurrentTimeAsync(string id)
        {
            ValidateGetCurrentTime(id);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("id", id);
            return _client.ExecuteDevToolsMethodAsync<GetCurrentTimeResponse>("Animation.getCurrentTime", dict);
        }

        /// <summary>
        /// Gets the playback rate of the document timeline.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPlaybackRateResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetPlaybackRateResponse> GetPlaybackRateAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetPlaybackRateResponse>("Animation.getPlaybackRate", dict);
        }

        partial void ValidateReleaseAnimations(string[] animations);
        /// <summary>
        /// Releases a set of animations to no longer be manipulated.
        /// </summary>
        /// <param name = "animations">List of animation ids to seek.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ReleaseAnimationsAsync(string[] animations)
        {
            ValidateReleaseAnimations(animations);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animations", animations);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Animation.releaseAnimations", dict);
        }

        partial void ValidateResolveAnimation(string animationId);
        /// <summary>
        /// Gets the remote object of the Animation.
        /// </summary>
        /// <param name = "animationId">Animation id.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ResolveAnimationResponse&gt;</returns>
        public System.Threading.Tasks.Task<ResolveAnimationResponse> ResolveAnimationAsync(string animationId)
        {
            ValidateResolveAnimation(animationId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animationId", animationId);
            return _client.ExecuteDevToolsMethodAsync<ResolveAnimationResponse>("Animation.resolveAnimation", dict);
        }

        partial void ValidateSeekAnimations(string[] animations, double currentTime);
        /// <summary>
        /// Seek a set of animations to a particular time within each animation.
        /// </summary>
        /// <param name = "animations">List of animation ids to seek.</param>
        /// <param name = "currentTime">Set the current time of each animation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SeekAnimationsAsync(string[] animations, double currentTime)
        {
            ValidateSeekAnimations(animations, currentTime);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animations", animations);
            dict.Add("currentTime", currentTime);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Animation.seekAnimations", dict);
        }

        partial void ValidateSetPaused(string[] animations, bool paused);
        /// <summary>
        /// Sets the paused state of a set of animations.
        /// </summary>
        /// <param name = "animations">Animations to set the pause state of.</param>
        /// <param name = "paused">Paused state to set to.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetPausedAsync(string[] animations, bool paused)
        {
            ValidateSetPaused(animations, paused);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animations", animations);
            dict.Add("paused", paused);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Animation.setPaused", dict);
        }

        partial void ValidateSetPlaybackRate(double playbackRate);
        /// <summary>
        /// Sets the playback rate of the document timeline.
        /// </summary>
        /// <param name = "playbackRate">Playback rate for animations on page</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetPlaybackRateAsync(double playbackRate)
        {
            ValidateSetPlaybackRate(playbackRate);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("playbackRate", playbackRate);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Animation.setPlaybackRate", dict);
        }

        partial void ValidateSetTiming(string animationId, double duration, double delay);
        /// <summary>
        /// Sets the timing of an animation node.
        /// </summary>
        /// <param name = "animationId">Animation id.</param>
        /// <param name = "duration">Duration of the animation.</param>
        /// <param name = "delay">Delay of the animation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetTimingAsync(string animationId, double duration, double delay)
        {
            ValidateSetTiming(animationId, duration, delay);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("animationId", animationId);
            dict.Add("duration", duration);
            dict.Add("delay", delay);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Animation.setTiming", dict);
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    /// <summary>
    /// GetEncodedResponseResponse
    /// </summary>
    public class GetEncodedResponseResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// body
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("body")]
        public byte[] Body
        {
            get;
            private set;
        }

        /// <summary>
        /// originalSize
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("originalSize")]
        public int OriginalSize
        {
            get;
            private set;
        }

        /// <summary>
        /// encodedSize
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("encodedSize")]
        public int EncodedSize
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Audits
{
    using System.Linq;

    /// <summary>
    /// The encoding to use.
    /// </summary>
    public enum GetEncodedResponseEncoding
    {
        /// <summary>
        /// webp
        /// </summary>
        [JsonPropertyName("webp")]
        Webp,
        /// <summary>
        /// jpeg
        /// </summary>
        [JsonPropertyName("jpeg")]
        Jpeg,
        /// <summary>
        /// png
        /// </summary>
        [JsonPropertyName("png")]
        Png
    }

    /// <summary>
    /// Audits domain allows investigation of page violations and possible improvements.
    /// </summary>
    public partial class AuditsClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Audits
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public AuditsClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// IssueAdded
        /// </summary>
        public event System.EventHandler<IssueAddedEventArgs> IssueAdded
        {
            add
            {
                _client.AddEventHandler<IssueAddedEventArgs>("Audits.issueAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<IssueAddedEventArgs>("Audits.issueAdded", value);
            }
        }

        partial void ValidateGetEncodedResponse(string requestId, CefSharp.DevTools.Audits.GetEncodedResponseEncoding encoding, double? quality = null, bool? sizeOnly = null);
        /// <summary>
        /// Returns the response body and size if it were re-encoded with the specified settings. Only
        /// applies to images.
        /// </summary>
        /// <param name = "requestId">Identifier of the network request to get content for.</param>
        /// <param name = "encoding">The encoding to use.</param>
        /// <param name = "quality">The quality of the encoding (0-1). (defaults to 1)</param>
        /// <param name = "sizeOnly">Whether to only return the size information (defaults to false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetEncodedResponseResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetEncodedResponseResponse> GetEncodedResponseAsync(string requestId, CefSharp.DevTools.Audits.GetEncodedResponseEncoding encoding, double? quality = null, bool? sizeOnly = null)
        {
            ValidateGetEncodedResponse(requestId, encoding, quality, sizeOnly);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("encoding", EnumToString(encoding));
            if (quality.HasValue)
            {
                dict.Add("quality", quality.Value);
            }

            if (sizeOnly.HasValue)
            {
                dict.Add("sizeOnly", sizeOnly.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetEncodedResponseResponse>("Audits.getEncodedResponse", dict);
        }

        /// <summary>
        /// Disables issues domain, prevents further issues from being reported to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Audits.disable", dict);
        }

        /// <summary>
        /// Enables issues domain, sends the issues collected so far to the client by means of the
        /// `issueAdded` event.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Audits.enable", dict);
        }

        partial void ValidateCheckContrast(bool? reportAAA = null);
        /// <summary>
        /// Runs the contrast check for the target page. Found issues are reported
        /// using Audits.issueAdded event.
        /// </summary>
        /// <param name = "reportAAA">Whether to report WCAG AAA level issues. Default is false.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CheckContrastAsync(bool? reportAAA = null)
        {
            ValidateCheckContrast(reportAAA);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (reportAAA.HasValue)
            {
                dict.Add("reportAAA", reportAAA.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Audits.checkContrast", dict);
        }
    }
}

namespace CefSharp.DevTools.BackgroundService
{
    using System.Linq;

    /// <summary>
    /// Defines events for background web platform features.
    /// </summary>
    public partial class BackgroundServiceClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// BackgroundService
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public BackgroundServiceClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Called when the recording state for the service has been updated.
        /// </summary>
        public event System.EventHandler<RecordingStateChangedEventArgs> RecordingStateChanged
        {
            add
            {
                _client.AddEventHandler<RecordingStateChangedEventArgs>("BackgroundService.recordingStateChanged", value);
            }

            remove
            {
                _client.RemoveEventHandler<RecordingStateChangedEventArgs>("BackgroundService.recordingStateChanged", value);
            }
        }

        /// <summary>
        /// Called with all existing backgroundServiceEvents when enabled, and all new
        /// events afterwards if enabled and recording.
        /// </summary>
        public event System.EventHandler<BackgroundServiceEventReceivedEventArgs> BackgroundServiceEventReceived
        {
            add
            {
                _client.AddEventHandler<BackgroundServiceEventReceivedEventArgs>("BackgroundService.backgroundServiceEventReceived", value);
            }

            remove
            {
                _client.RemoveEventHandler<BackgroundServiceEventReceivedEventArgs>("BackgroundService.backgroundServiceEventReceived", value);
            }
        }

        partial void ValidateStartObserving(CefSharp.DevTools.BackgroundService.ServiceName service);
        /// <summary>
        /// Enables event updates for the service.
        /// </summary>
        /// <param name = "service">service</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartObservingAsync(CefSharp.DevTools.BackgroundService.ServiceName service)
        {
            ValidateStartObserving(service);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("service", EnumToString(service));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("BackgroundService.startObserving", dict);
        }

        partial void ValidateStopObserving(CefSharp.DevTools.BackgroundService.ServiceName service);
        /// <summary>
        /// Disables event updates for the service.
        /// </summary>
        /// <param name = "service">service</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopObservingAsync(CefSharp.DevTools.BackgroundService.ServiceName service)
        {
            ValidateStopObserving(service);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("service", EnumToString(service));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("BackgroundService.stopObserving", dict);
        }

        partial void ValidateSetRecording(bool shouldRecord, CefSharp.DevTools.BackgroundService.ServiceName service);
        /// <summary>
        /// Set the recording state for the service.
        /// </summary>
        /// <param name = "shouldRecord">shouldRecord</param>
        /// <param name = "service">service</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetRecordingAsync(bool shouldRecord, CefSharp.DevTools.BackgroundService.ServiceName service)
        {
            ValidateSetRecording(shouldRecord, service);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("shouldRecord", shouldRecord);
            dict.Add("service", EnumToString(service));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("BackgroundService.setRecording", dict);
        }

        partial void ValidateClearEvents(CefSharp.DevTools.BackgroundService.ServiceName service);
        /// <summary>
        /// Clears all stored data for the service.
        /// </summary>
        /// <param name = "service">service</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearEventsAsync(CefSharp.DevTools.BackgroundService.ServiceName service)
        {
            ValidateClearEvents(service);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("service", EnumToString(service));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("BackgroundService.clearEvents", dict);
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetVersionResponse
    /// </summary>
    public class GetVersionResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// protocolVersion
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("protocolVersion")]
        public string ProtocolVersion
        {
            get;
            private set;
        }

        /// <summary>
        /// product
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("product")]
        public string Product
        {
            get;
            private set;
        }

        /// <summary>
        /// revision
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("revision")]
        public string Revision
        {
            get;
            private set;
        }

        /// <summary>
        /// userAgent
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("userAgent")]
        public string UserAgent
        {
            get;
            private set;
        }

        /// <summary>
        /// jsVersion
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("jsVersion")]
        public string JsVersion
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetBrowserCommandLineResponse
    /// </summary>
    public class GetBrowserCommandLineResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// arguments
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("arguments")]
        public string[] Arguments
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetHistogramsResponse
    /// </summary>
    public class GetHistogramsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// histograms
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("histograms")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Browser.Histogram> Histograms
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetHistogramResponse
    /// </summary>
    public class GetHistogramResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// histogram
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("histogram")]
        public CefSharp.DevTools.Browser.Histogram Histogram
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetWindowBoundsResponse
    /// </summary>
    public class GetWindowBoundsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// bounds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("bounds")]
        public CefSharp.DevTools.Browser.Bounds Bounds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    /// <summary>
    /// GetWindowForTargetResponse
    /// </summary>
    public class GetWindowForTargetResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// windowId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("windowId")]
        public int WindowId
        {
            get;
            private set;
        }

        /// <summary>
        /// bounds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("bounds")]
        public CefSharp.DevTools.Browser.Bounds Bounds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Browser
{
    using System.Linq;

    /// <summary>
    /// Whether to allow all or deny all download requests, or use default Chrome behavior if
    /// available (otherwise deny). |allowAndName| allows download and names files according to
    /// their dowmload guids.
    /// </summary>
    public enum SetDownloadBehaviorBehavior
    {
        /// <summary>
        /// deny
        /// </summary>
        [JsonPropertyName("deny")]
        Deny,
        /// <summary>
        /// allow
        /// </summary>
        [JsonPropertyName("allow")]
        Allow,
        /// <summary>
        /// allowAndName
        /// </summary>
        [JsonPropertyName("allowAndName")]
        AllowAndName,
        /// <summary>
        /// default
        /// </summary>
        [JsonPropertyName("default")]
        Default
    }

    /// <summary>
    /// The Browser domain defines methods and events for browser managing.
    /// </summary>
    public partial class BrowserClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Browser
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public BrowserClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Fired when page is about to start a download.
        /// </summary>
        public event System.EventHandler<DownloadWillBeginEventArgs> DownloadWillBegin
        {
            add
            {
                _client.AddEventHandler<DownloadWillBeginEventArgs>("Browser.downloadWillBegin", value);
            }

            remove
            {
                _client.RemoveEventHandler<DownloadWillBeginEventArgs>("Browser.downloadWillBegin", value);
            }
        }

        /// <summary>
        /// Fired when download makes progress. Last call has |done| == true.
        /// </summary>
        public event System.EventHandler<DownloadProgressEventArgs> DownloadProgress
        {
            add
            {
                _client.AddEventHandler<DownloadProgressEventArgs>("Browser.downloadProgress", value);
            }

            remove
            {
                _client.RemoveEventHandler<DownloadProgressEventArgs>("Browser.downloadProgress", value);
            }
        }

        partial void ValidateSetPermission(CefSharp.DevTools.Browser.PermissionDescriptor permission, CefSharp.DevTools.Browser.PermissionSetting setting, string origin = null, string browserContextId = null);
        /// <summary>
        /// Set permission settings for given origin.
        /// </summary>
        /// <param name = "permission">Descriptor of permission to override.</param>
        /// <param name = "setting">Setting of the permission.</param>
        /// <param name = "origin">Origin the permission applies to, all origins if not specified.</param>
        /// <param name = "browserContextId">Context to override. When omitted, default browser context is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetPermissionAsync(CefSharp.DevTools.Browser.PermissionDescriptor permission, CefSharp.DevTools.Browser.PermissionSetting setting, string origin = null, string browserContextId = null)
        {
            ValidateSetPermission(permission, setting, origin, browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("permission", permission.ToDictionary());
            dict.Add("setting", EnumToString(setting));
            if (!(string.IsNullOrEmpty(origin)))
            {
                dict.Add("origin", origin);
            }

            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.setPermission", dict);
        }

        partial void ValidateGrantPermissions(CefSharp.DevTools.Browser.PermissionType[] permissions, string origin = null, string browserContextId = null);
        /// <summary>
        /// Grant specific permissions to the given origin and reject all others.
        /// </summary>
        /// <param name = "permissions">permissions</param>
        /// <param name = "origin">Origin the permission applies to, all origins if not specified.</param>
        /// <param name = "browserContextId">BrowserContext to override permissions. When omitted, default browser context is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> GrantPermissionsAsync(CefSharp.DevTools.Browser.PermissionType[] permissions, string origin = null, string browserContextId = null)
        {
            ValidateGrantPermissions(permissions, origin, browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("permissions", EnumToString(permissions));
            if (!(string.IsNullOrEmpty(origin)))
            {
                dict.Add("origin", origin);
            }

            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.grantPermissions", dict);
        }

        partial void ValidateResetPermissions(string browserContextId = null);
        /// <summary>
        /// Reset all permission management for all origins.
        /// </summary>
        /// <param name = "browserContextId">BrowserContext to reset permissions. When omitted, default browser context is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ResetPermissionsAsync(string browserContextId = null)
        {
            ValidateResetPermissions(browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.resetPermissions", dict);
        }

        partial void ValidateSetDownloadBehavior(CefSharp.DevTools.Browser.SetDownloadBehaviorBehavior behavior, string browserContextId = null, string downloadPath = null, bool? eventsEnabled = null);
        /// <summary>
        /// Set the behavior when downloading a file.
        /// </summary>
        /// <param name = "behavior">Whether to allow all or deny all download requests, or use default Chrome behavior ifavailable (otherwise deny). |allowAndName| allows download and names files according totheir dowmload guids.</param>
        /// <param name = "browserContextId">BrowserContext to set download behavior. When omitted, default browser context is used.</param>
        /// <param name = "downloadPath">The default path to save downloaded files to. This is required if behavior is set to 'allow'or 'allowAndName'.</param>
        /// <param name = "eventsEnabled">Whether to emit download events (defaults to false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDownloadBehaviorAsync(CefSharp.DevTools.Browser.SetDownloadBehaviorBehavior behavior, string browserContextId = null, string downloadPath = null, bool? eventsEnabled = null)
        {
            ValidateSetDownloadBehavior(behavior, browserContextId, downloadPath, eventsEnabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("behavior", EnumToString(behavior));
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            if (!(string.IsNullOrEmpty(downloadPath)))
            {
                dict.Add("downloadPath", downloadPath);
            }

            if (eventsEnabled.HasValue)
            {
                dict.Add("eventsEnabled", eventsEnabled.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.setDownloadBehavior", dict);
        }

        partial void ValidateCancelDownload(string guid, string browserContextId = null);
        /// <summary>
        /// Cancel a download if in progress
        /// </summary>
        /// <param name = "guid">Global unique identifier of the download.</param>
        /// <param name = "browserContextId">BrowserContext to perform the action in. When omitted, default browser context is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CancelDownloadAsync(string guid, string browserContextId = null)
        {
            ValidateCancelDownload(guid, browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("guid", guid);
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.cancelDownload", dict);
        }

        /// <summary>
        /// Close browser gracefully.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CloseAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.close", dict);
        }

        /// <summary>
        /// Crashes browser on the main thread.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CrashAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.crash", dict);
        }

        /// <summary>
        /// Crashes GPU process.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CrashGpuProcessAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.crashGpuProcess", dict);
        }

        /// <summary>
        /// Returns version information.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetVersionResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetVersionResponse> GetVersionAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetVersionResponse>("Browser.getVersion", dict);
        }

        /// <summary>
        /// Returns the command line switches for the browser process if, and only if
        /// --enable-automation is on the commandline.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBrowserCommandLineResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetBrowserCommandLineResponse> GetBrowserCommandLineAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetBrowserCommandLineResponse>("Browser.getBrowserCommandLine", dict);
        }

        partial void ValidateGetHistograms(string query = null, bool? delta = null);
        /// <summary>
        /// Get Chrome histograms.
        /// </summary>
        /// <param name = "query">Requested substring in name. Only histograms which have query as asubstring in their name are extracted. An empty or absent query returnsall histograms.</param>
        /// <param name = "delta">If true, retrieve delta since last delta call.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHistogramsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetHistogramsResponse> GetHistogramsAsync(string query = null, bool? delta = null)
        {
            ValidateGetHistograms(query, delta);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(query)))
            {
                dict.Add("query", query);
            }

            if (delta.HasValue)
            {
                dict.Add("delta", delta.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetHistogramsResponse>("Browser.getHistograms", dict);
        }

        partial void ValidateGetHistogram(string name, bool? delta = null);
        /// <summary>
        /// Get a Chrome histogram by name.
        /// </summary>
        /// <param name = "name">Requested histogram name.</param>
        /// <param name = "delta">If true, retrieve delta since last delta call.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHistogramResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetHistogramResponse> GetHistogramAsync(string name, bool? delta = null)
        {
            ValidateGetHistogram(name, delta);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            if (delta.HasValue)
            {
                dict.Add("delta", delta.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetHistogramResponse>("Browser.getHistogram", dict);
        }

        partial void ValidateGetWindowBounds(int windowId);
        /// <summary>
        /// Get position and size of the browser window.
        /// </summary>
        /// <param name = "windowId">Browser window id.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetWindowBoundsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetWindowBoundsResponse> GetWindowBoundsAsync(int windowId)
        {
            ValidateGetWindowBounds(windowId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("windowId", windowId);
            return _client.ExecuteDevToolsMethodAsync<GetWindowBoundsResponse>("Browser.getWindowBounds", dict);
        }

        partial void ValidateGetWindowForTarget(string targetId = null);
        /// <summary>
        /// Get the browser window that contains the devtools target.
        /// </summary>
        /// <param name = "targetId">Devtools agent host id. If called as a part of the session, associated targetId is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetWindowForTargetResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetWindowForTargetResponse> GetWindowForTargetAsync(string targetId = null)
        {
            ValidateGetWindowForTarget(targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(targetId)))
            {
                dict.Add("targetId", targetId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetWindowForTargetResponse>("Browser.getWindowForTarget", dict);
        }

        partial void ValidateSetWindowBounds(int windowId, CefSharp.DevTools.Browser.Bounds bounds);
        /// <summary>
        /// Set position and/or size of the browser window.
        /// </summary>
        /// <param name = "windowId">Browser window id.</param>
        /// <param name = "bounds">New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combinedwith 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetWindowBoundsAsync(int windowId, CefSharp.DevTools.Browser.Bounds bounds)
        {
            ValidateSetWindowBounds(windowId, bounds);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("windowId", windowId);
            dict.Add("bounds", bounds.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.setWindowBounds", dict);
        }

        partial void ValidateSetDockTile(string badgeLabel = null, byte[] image = null);
        /// <summary>
        /// Set dock tile details, platform-specific.
        /// </summary>
        /// <param name = "badgeLabel">badgeLabel</param>
        /// <param name = "image">Png encoded image.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDockTileAsync(string badgeLabel = null, byte[] image = null)
        {
            ValidateSetDockTile(badgeLabel, image);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(badgeLabel)))
            {
                dict.Add("badgeLabel", badgeLabel);
            }

            if ((image) != (null))
            {
                dict.Add("image", ToBase64String(image));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.setDockTile", dict);
        }

        partial void ValidateExecuteBrowserCommand(CefSharp.DevTools.Browser.BrowserCommandId commandId);
        /// <summary>
        /// Invoke custom browser commands used by telemetry.
        /// </summary>
        /// <param name = "commandId">commandId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ExecuteBrowserCommandAsync(CefSharp.DevTools.Browser.BrowserCommandId commandId)
        {
            ValidateExecuteBrowserCommand(commandId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("commandId", EnumToString(commandId));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Browser.executeBrowserCommand", dict);
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// AddRuleResponse
    /// </summary>
    public class AddRuleResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// rule
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("rule")]
        public CefSharp.DevTools.CSS.CSSRule Rule
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CollectClassNamesResponse
    /// </summary>
    public class CollectClassNamesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// classNames
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("classNames")]
        public string[] ClassNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// CreateStyleSheetResponse
    /// </summary>
    public class CreateStyleSheetResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// styleSheetId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("styleSheetId")]
        public string StyleSheetId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetBackgroundColorsResponse
    /// </summary>
    public class GetBackgroundColorsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// backgroundColors
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("backgroundColors")]
        public string[] BackgroundColors
        {
            get;
            private set;
        }

        /// <summary>
        /// computedFontSize
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("computedFontSize")]
        public string ComputedFontSize
        {
            get;
            private set;
        }

        /// <summary>
        /// computedFontWeight
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("computedFontWeight")]
        public string ComputedFontWeight
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetComputedStyleForNodeResponse
    /// </summary>
    public class GetComputedStyleForNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// computedStyle
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("computedStyle")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSComputedStyleProperty> ComputedStyle
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetInlineStylesForNodeResponse
    /// </summary>
    public class GetInlineStylesForNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// inlineStyle
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("inlineStyle")]
        public CefSharp.DevTools.CSS.CSSStyle InlineStyle
        {
            get;
            private set;
        }

        /// <summary>
        /// attributesStyle
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("attributesStyle")]
        public CefSharp.DevTools.CSS.CSSStyle AttributesStyle
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetMatchedStylesForNodeResponse
    /// </summary>
    public class GetMatchedStylesForNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// inlineStyle
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("inlineStyle")]
        public CefSharp.DevTools.CSS.CSSStyle InlineStyle
        {
            get;
            private set;
        }

        /// <summary>
        /// attributesStyle
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("attributesStyle")]
        public CefSharp.DevTools.CSS.CSSStyle AttributesStyle
        {
            get;
            private set;
        }

        /// <summary>
        /// matchedCSSRules
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("matchedCSSRules")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleMatch> MatchedCSSRules
        {
            get;
            private set;
        }

        /// <summary>
        /// pseudoElements
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("pseudoElements")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.PseudoElementMatches> PseudoElements
        {
            get;
            private set;
        }

        /// <summary>
        /// inherited
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("inherited")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.InheritedStyleEntry> Inherited
        {
            get;
            private set;
        }

        /// <summary>
        /// inheritedPseudoElements
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("inheritedPseudoElements")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.InheritedPseudoElementMatches> InheritedPseudoElements
        {
            get;
            private set;
        }

        /// <summary>
        /// cssKeyframesRules
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cssKeyframesRules")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSKeyframesRule> CssKeyframesRules
        {
            get;
            private set;
        }

        /// <summary>
        /// cssPositionFallbackRules
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cssPositionFallbackRules")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSPositionFallbackRule> CssPositionFallbackRules
        {
            get;
            private set;
        }

        /// <summary>
        /// parentLayoutNodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("parentLayoutNodeId")]
        public int? ParentLayoutNodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetMediaQueriesResponse
    /// </summary>
    public class GetMediaQueriesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// medias
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("medias")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSMedia> Medias
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetPlatformFontsForNodeResponse
    /// </summary>
    public class GetPlatformFontsForNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// fonts
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("fonts")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.PlatformFontUsage> Fonts
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetStyleSheetTextResponse
    /// </summary>
    public class GetStyleSheetTextResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// text
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("text")]
        public string Text
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// GetLayersForNodeResponse
    /// </summary>
    public class GetLayersForNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// rootLayer
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("rootLayer")]
        public CefSharp.DevTools.CSS.CSSLayerData RootLayer
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// TakeComputedStyleUpdatesResponse
    /// </summary>
    public class TakeComputedStyleUpdatesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetKeyframeKeyResponse
    /// </summary>
    public class SetKeyframeKeyResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// keyText
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("keyText")]
        public CefSharp.DevTools.CSS.Value KeyText
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetMediaTextResponse
    /// </summary>
    public class SetMediaTextResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// media
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("media")]
        public CefSharp.DevTools.CSS.CSSMedia Media
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetContainerQueryTextResponse
    /// </summary>
    public class SetContainerQueryTextResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// containerQuery
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("containerQuery")]
        public CefSharp.DevTools.CSS.CSSContainerQuery ContainerQuery
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetSupportsTextResponse
    /// </summary>
    public class SetSupportsTextResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// supports
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("supports")]
        public CefSharp.DevTools.CSS.CSSSupports Supports
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetScopeTextResponse
    /// </summary>
    public class SetScopeTextResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// scope
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("scope")]
        public CefSharp.DevTools.CSS.CSSScope Scope
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetRuleSelectorResponse
    /// </summary>
    public class SetRuleSelectorResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// selectorList
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("selectorList")]
        public CefSharp.DevTools.CSS.SelectorList SelectorList
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetStyleSheetTextResponse
    /// </summary>
    public class SetStyleSheetTextResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// sourceMapURL
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sourceMapURL")]
        public string SourceMapURL
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// SetStyleTextsResponse
    /// </summary>
    public class SetStyleTextsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// styles
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("styles")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSStyle> Styles
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// StopRuleUsageTrackingResponse
    /// </summary>
    public class StopRuleUsageTrackingResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// ruleUsage
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("ruleUsage")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleUsage> RuleUsage
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    /// <summary>
    /// TakeCoverageDeltaResponse
    /// </summary>
    public class TakeCoverageDeltaResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// coverage
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("coverage")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CSS.RuleUsage> Coverage
        {
            get;
            private set;
        }

        /// <summary>
        /// timestamp
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CSS
{
    using System.Linq;

    /// <summary>
    /// This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
    /// have an associated `id` used in subsequent operations on the related object. Each object type has
    /// a specific `id` structure, and those are not interchangeable between objects of different kinds.
    /// CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
    /// can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
    /// subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods.
    /// </summary>
    public partial class CSSClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// CSS
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public CSSClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
        /// web font.
        /// </summary>
        public event System.EventHandler<FontsUpdatedEventArgs> FontsUpdated
        {
            add
            {
                _client.AddEventHandler<FontsUpdatedEventArgs>("CSS.fontsUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<FontsUpdatedEventArgs>("CSS.fontsUpdated", value);
            }
        }

        /// <summary>
        /// Fires whenever a MediaQuery result changes (for example, after a browser window has been
        /// resized.) The current implementation considers only viewport-dependent media features.
        /// </summary>
        public event System.EventHandler<System.EventArgs> MediaQueryResultChanged
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("CSS.mediaQueryResultChanged", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("CSS.mediaQueryResultChanged", value);
            }
        }

        /// <summary>
        /// Fired whenever an active document stylesheet is added.
        /// </summary>
        public event System.EventHandler<StyleSheetAddedEventArgs> StyleSheetAdded
        {
            add
            {
                _client.AddEventHandler<StyleSheetAddedEventArgs>("CSS.styleSheetAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<StyleSheetAddedEventArgs>("CSS.styleSheetAdded", value);
            }
        }

        /// <summary>
        /// Fired whenever a stylesheet is changed as a result of the client operation.
        /// </summary>
        public event System.EventHandler<StyleSheetChangedEventArgs> StyleSheetChanged
        {
            add
            {
                _client.AddEventHandler<StyleSheetChangedEventArgs>("CSS.styleSheetChanged", value);
            }

            remove
            {
                _client.RemoveEventHandler<StyleSheetChangedEventArgs>("CSS.styleSheetChanged", value);
            }
        }

        /// <summary>
        /// Fired whenever an active document stylesheet is removed.
        /// </summary>
        public event System.EventHandler<StyleSheetRemovedEventArgs> StyleSheetRemoved
        {
            add
            {
                _client.AddEventHandler<StyleSheetRemovedEventArgs>("CSS.styleSheetRemoved", value);
            }

            remove
            {
                _client.RemoveEventHandler<StyleSheetRemovedEventArgs>("CSS.styleSheetRemoved", value);
            }
        }

        partial void ValidateAddRule(string styleSheetId, string ruleText, CefSharp.DevTools.CSS.SourceRange location);
        /// <summary>
        /// Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
        /// position specified by `location`.
        /// </summary>
        /// <param name = "styleSheetId">The css style sheet identifier where a new rule should be inserted.</param>
        /// <param name = "ruleText">The text of a new rule.</param>
        /// <param name = "location">Text position of a new rule in the target style sheet.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AddRuleResponse&gt;</returns>
        public System.Threading.Tasks.Task<AddRuleResponse> AddRuleAsync(string styleSheetId, string ruleText, CefSharp.DevTools.CSS.SourceRange location)
        {
            ValidateAddRule(styleSheetId, ruleText, location);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("ruleText", ruleText);
            dict.Add("location", location.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<AddRuleResponse>("CSS.addRule", dict);
        }

        partial void ValidateCollectClassNames(string styleSheetId);
        /// <summary>
        /// Returns all class names from specified stylesheet.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CollectClassNamesResponse&gt;</returns>
        public System.Threading.Tasks.Task<CollectClassNamesResponse> CollectClassNamesAsync(string styleSheetId)
        {
            ValidateCollectClassNames(styleSheetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            return _client.ExecuteDevToolsMethodAsync<CollectClassNamesResponse>("CSS.collectClassNames", dict);
        }

        partial void ValidateCreateStyleSheet(string frameId);
        /// <summary>
        /// Creates a new special &quot;via-inspector&quot; stylesheet in the frame with given `frameId`.
        /// </summary>
        /// <param name = "frameId">Identifier of the frame where "via-inspector" stylesheet should be created.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CreateStyleSheetResponse&gt;</returns>
        public System.Threading.Tasks.Task<CreateStyleSheetResponse> CreateStyleSheetAsync(string frameId)
        {
            ValidateCreateStyleSheet(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            return _client.ExecuteDevToolsMethodAsync<CreateStyleSheetResponse>("CSS.createStyleSheet", dict);
        }

        /// <summary>
        /// Disables the CSS agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CSS.disable", dict);
        }

        /// <summary>
        /// Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
        /// enabled until the result of this command is received.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CSS.enable", dict);
        }

        partial void ValidateForcePseudoState(int nodeId, string[] forcedPseudoClasses);
        /// <summary>
        /// Ensures that the given node will have specified pseudo-classes whenever its style is computed by
        /// the browser.
        /// </summary>
        /// <param name = "nodeId">The element id for which to force the pseudo state.</param>
        /// <param name = "forcedPseudoClasses">Element pseudo classes to force when computing the element's style.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ForcePseudoStateAsync(int nodeId, string[] forcedPseudoClasses)
        {
            ValidateForcePseudoState(nodeId, forcedPseudoClasses);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("forcedPseudoClasses", forcedPseudoClasses);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CSS.forcePseudoState", dict);
        }

        partial void ValidateGetBackgroundColors(int nodeId);
        /// <summary>
        /// GetBackgroundColors
        /// </summary>
        /// <param name = "nodeId">Id of the node to get background colors for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBackgroundColorsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetBackgroundColorsResponse> GetBackgroundColorsAsync(int nodeId)
        {
            ValidateGetBackgroundColors(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetBackgroundColorsResponse>("CSS.getBackgroundColors", dict);
        }

        partial void ValidateGetComputedStyleForNode(int nodeId);
        /// <summary>
        /// Returns the computed style for a DOM node identified by `nodeId`.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetComputedStyleForNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetComputedStyleForNodeResponse> GetComputedStyleForNodeAsync(int nodeId)
        {
            ValidateGetComputedStyleForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetComputedStyleForNodeResponse>("CSS.getComputedStyleForNode", dict);
        }

        partial void ValidateGetInlineStylesForNode(int nodeId);
        /// <summary>
        /// Returns the styles defined inline (explicitly in the &quot;style&quot; attribute and implicitly, using DOM
        /// attributes) for a DOM node identified by `nodeId`.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetInlineStylesForNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetInlineStylesForNodeResponse> GetInlineStylesForNodeAsync(int nodeId)
        {
            ValidateGetInlineStylesForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetInlineStylesForNodeResponse>("CSS.getInlineStylesForNode", dict);
        }

        partial void ValidateGetMatchedStylesForNode(int nodeId);
        /// <summary>
        /// Returns requested styles for a DOM node identified by `nodeId`.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetMatchedStylesForNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetMatchedStylesForNodeResponse> GetMatchedStylesForNodeAsync(int nodeId)
        {
            ValidateGetMatchedStylesForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetMatchedStylesForNodeResponse>("CSS.getMatchedStylesForNode", dict);
        }

        /// <summary>
        /// Returns all media queries parsed by the rendering engine.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetMediaQueriesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetMediaQueriesResponse> GetMediaQueriesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetMediaQueriesResponse>("CSS.getMediaQueries", dict);
        }

        partial void ValidateGetPlatformFontsForNode(int nodeId);
        /// <summary>
        /// Requests information about platform fonts which we used to render child TextNodes in the given
        /// node.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPlatformFontsForNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetPlatformFontsForNodeResponse> GetPlatformFontsForNodeAsync(int nodeId)
        {
            ValidateGetPlatformFontsForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetPlatformFontsForNodeResponse>("CSS.getPlatformFontsForNode", dict);
        }

        partial void ValidateGetStyleSheetText(string styleSheetId);
        /// <summary>
        /// Returns the current textual content for a stylesheet.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetStyleSheetTextResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetStyleSheetTextResponse> GetStyleSheetTextAsync(string styleSheetId)
        {
            ValidateGetStyleSheetText(styleSheetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            return _client.ExecuteDevToolsMethodAsync<GetStyleSheetTextResponse>("CSS.getStyleSheetText", dict);
        }

        partial void ValidateGetLayersForNode(int nodeId);
        /// <summary>
        /// Returns all layers parsed by the rendering engine for the tree scope of a node.
        /// Given a DOM element identified by nodeId, getLayersForNode returns the root
        /// layer for the nearest ancestor document or shadow root. The layer root contains
        /// the full layer tree for the tree scope and their ordering.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetLayersForNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetLayersForNodeResponse> GetLayersForNodeAsync(int nodeId)
        {
            ValidateGetLayersForNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetLayersForNodeResponse>("CSS.getLayersForNode", dict);
        }

        partial void ValidateTrackComputedStyleUpdates(System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSComputedStyleProperty> propertiesToTrack);
        /// <summary>
        /// Starts tracking the given computed styles for updates. The specified array of properties
        /// replaces the one previously specified. Pass empty array to disable tracking.
        /// Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
        /// The changes to computed style properties are only tracked for nodes pushed to the front-end
        /// by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
        /// to the front-end, no updates will be issued for the node.
        /// </summary>
        /// <param name = "propertiesToTrack">propertiesToTrack</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> TrackComputedStyleUpdatesAsync(System.Collections.Generic.IList<CefSharp.DevTools.CSS.CSSComputedStyleProperty> propertiesToTrack)
        {
            ValidateTrackComputedStyleUpdates(propertiesToTrack);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("propertiesToTrack", propertiesToTrack.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CSS.trackComputedStyleUpdates", dict);
        }

        /// <summary>
        /// Polls the next batch of computed style updates.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeComputedStyleUpdatesResponse&gt;</returns>
        public System.Threading.Tasks.Task<TakeComputedStyleUpdatesResponse> TakeComputedStyleUpdatesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<TakeComputedStyleUpdatesResponse>("CSS.takeComputedStyleUpdates", dict);
        }

        partial void ValidateSetEffectivePropertyValueForNode(int nodeId, string propertyName, string value);
        /// <summary>
        /// Find a rule with the given active property for the given node and set the new value for this
        /// property
        /// </summary>
        /// <param name = "nodeId">The element id for which to set property.</param>
        /// <param name = "propertyName">propertyName</param>
        /// <param name = "value">value</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetEffectivePropertyValueForNodeAsync(int nodeId, string propertyName, string value)
        {
            ValidateSetEffectivePropertyValueForNode(nodeId, propertyName, value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("propertyName", propertyName);
            dict.Add("value", value);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CSS.setEffectivePropertyValueForNode", dict);
        }

        partial void ValidateSetKeyframeKey(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string keyText);
        /// <summary>
        /// Modifies the keyframe rule key text.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "keyText">keyText</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetKeyframeKeyResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetKeyframeKeyResponse> SetKeyframeKeyAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string keyText)
        {
            ValidateSetKeyframeKey(styleSheetId, range, keyText);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("keyText", keyText);
            return _client.ExecuteDevToolsMethodAsync<SetKeyframeKeyResponse>("CSS.setKeyframeKey", dict);
        }

        partial void ValidateSetMediaText(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text);
        /// <summary>
        /// Modifies the rule selector.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "text">text</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetMediaTextResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetMediaTextResponse> SetMediaTextAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text)
        {
            ValidateSetMediaText(styleSheetId, range, text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("text", text);
            return _client.ExecuteDevToolsMethodAsync<SetMediaTextResponse>("CSS.setMediaText", dict);
        }

        partial void ValidateSetContainerQueryText(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text);
        /// <summary>
        /// Modifies the expression of a container query.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "text">text</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetContainerQueryTextResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetContainerQueryTextResponse> SetContainerQueryTextAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text)
        {
            ValidateSetContainerQueryText(styleSheetId, range, text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("text", text);
            return _client.ExecuteDevToolsMethodAsync<SetContainerQueryTextResponse>("CSS.setContainerQueryText", dict);
        }

        partial void ValidateSetSupportsText(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text);
        /// <summary>
        /// Modifies the expression of a supports at-rule.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "text">text</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetSupportsTextResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetSupportsTextResponse> SetSupportsTextAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text)
        {
            ValidateSetSupportsText(styleSheetId, range, text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("text", text);
            return _client.ExecuteDevToolsMethodAsync<SetSupportsTextResponse>("CSS.setSupportsText", dict);
        }

        partial void ValidateSetScopeText(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text);
        /// <summary>
        /// Modifies the expression of a scope at-rule.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "text">text</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetScopeTextResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetScopeTextResponse> SetScopeTextAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string text)
        {
            ValidateSetScopeText(styleSheetId, range, text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("text", text);
            return _client.ExecuteDevToolsMethodAsync<SetScopeTextResponse>("CSS.setScopeText", dict);
        }

        partial void ValidateSetRuleSelector(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string selector);
        /// <summary>
        /// Modifies the rule selector.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "range">range</param>
        /// <param name = "selector">selector</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetRuleSelectorResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetRuleSelectorResponse> SetRuleSelectorAsync(string styleSheetId, CefSharp.DevTools.CSS.SourceRange range, string selector)
        {
            ValidateSetRuleSelector(styleSheetId, range, selector);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("range", range.ToDictionary());
            dict.Add("selector", selector);
            return _client.ExecuteDevToolsMethodAsync<SetRuleSelectorResponse>("CSS.setRuleSelector", dict);
        }

        partial void ValidateSetStyleSheetText(string styleSheetId, string text);
        /// <summary>
        /// Sets the new stylesheet text.
        /// </summary>
        /// <param name = "styleSheetId">styleSheetId</param>
        /// <param name = "text">text</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetStyleSheetTextResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetStyleSheetTextResponse> SetStyleSheetTextAsync(string styleSheetId, string text)
        {
            ValidateSetStyleSheetText(styleSheetId, text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("styleSheetId", styleSheetId);
            dict.Add("text", text);
            return _client.ExecuteDevToolsMethodAsync<SetStyleSheetTextResponse>("CSS.setStyleSheetText", dict);
        }

        partial void ValidateSetStyleTexts(System.Collections.Generic.IList<CefSharp.DevTools.CSS.StyleDeclarationEdit> edits);
        /// <summary>
        /// Applies specified style edits one after another in the given order.
        /// </summary>
        /// <param name = "edits">edits</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetStyleTextsResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetStyleTextsResponse> SetStyleTextsAsync(System.Collections.Generic.IList<CefSharp.DevTools.CSS.StyleDeclarationEdit> edits)
        {
            ValidateSetStyleTexts(edits);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("edits", edits.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<SetStyleTextsResponse>("CSS.setStyleTexts", dict);
        }

        /// <summary>
        /// Enables the selector recording.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartRuleUsageTrackingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CSS.startRuleUsageTracking", dict);
        }

        /// <summary>
        /// Stop tracking rule usage and return the list of rules that were used since last call to
        /// `takeCoverageDelta` (or since start of coverage instrumentation).
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;StopRuleUsageTrackingResponse&gt;</returns>
        public System.Threading.Tasks.Task<StopRuleUsageTrackingResponse> StopRuleUsageTrackingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<StopRuleUsageTrackingResponse>("CSS.stopRuleUsageTracking", dict);
        }

        /// <summary>
        /// Obtain list of rules that became used since last call to this method (or since start of coverage
        /// instrumentation).
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeCoverageDeltaResponse&gt;</returns>
        public System.Threading.Tasks.Task<TakeCoverageDeltaResponse> TakeCoverageDeltaAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<TakeCoverageDeltaResponse>("CSS.takeCoverageDelta", dict);
        }

        partial void ValidateSetLocalFontsEnabled(bool enabled);
        /// <summary>
        /// Enables/disables rendering of local CSS fonts (enabled by default).
        /// </summary>
        /// <param name = "enabled">Whether rendering of local fonts is enabled.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetLocalFontsEnabledAsync(bool enabled)
        {
            ValidateSetLocalFontsEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CSS.setLocalFontsEnabled", dict);
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// RequestCacheNamesResponse
    /// </summary>
    public class RequestCacheNamesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// caches
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("caches")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Cache> Caches
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// RequestCachedResponseResponse
    /// </summary>
    public class RequestCachedResponseResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// response
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("response")]
        public CefSharp.DevTools.CacheStorage.CachedResponse Response
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    /// <summary>
    /// RequestEntriesResponse
    /// </summary>
    public class RequestEntriesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// cacheDataEntries
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cacheDataEntries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.DataEntry> CacheDataEntries
        {
            get;
            private set;
        }

        /// <summary>
        /// returnCount
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("returnCount")]
        public double ReturnCount
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.CacheStorage
{
    using System.Linq;

    /// <summary>
    /// CacheStorage
    /// </summary>
    public partial class CacheStorageClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// CacheStorage
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public CacheStorageClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateDeleteCache(string cacheId);
        /// <summary>
        /// Deletes a cache.
        /// </summary>
        /// <param name = "cacheId">Id of cache for deletion.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteCacheAsync(string cacheId)
        {
            ValidateDeleteCache(cacheId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheId", cacheId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CacheStorage.deleteCache", dict);
        }

        partial void ValidateDeleteEntry(string cacheId, string request);
        /// <summary>
        /// Deletes a cache entry.
        /// </summary>
        /// <param name = "cacheId">Id of cache where the entry will be deleted.</param>
        /// <param name = "request">URL spec of the request.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteEntryAsync(string cacheId, string request)
        {
            ValidateDeleteEntry(cacheId, request);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheId", cacheId);
            dict.Add("request", request);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("CacheStorage.deleteEntry", dict);
        }

        partial void ValidateRequestCacheNames(string securityOrigin = null, string storageKey = null);
        /// <summary>
        /// Requests cache names.
        /// </summary>
        /// <param name = "securityOrigin">At least and at most one of securityOrigin, storageKey must be specified.Security origin.</param>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestCacheNamesResponse&gt;</returns>
        public System.Threading.Tasks.Task<RequestCacheNamesResponse> RequestCacheNamesAsync(string securityOrigin = null, string storageKey = null)
        {
            ValidateRequestCacheNames(securityOrigin, storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(securityOrigin)))
            {
                dict.Add("securityOrigin", securityOrigin);
            }

            if (!(string.IsNullOrEmpty(storageKey)))
            {
                dict.Add("storageKey", storageKey);
            }

            return _client.ExecuteDevToolsMethodAsync<RequestCacheNamesResponse>("CacheStorage.requestCacheNames", dict);
        }

        partial void ValidateRequestCachedResponse(string cacheId, string requestURL, System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Header> requestHeaders);
        /// <summary>
        /// Fetches cache entry.
        /// </summary>
        /// <param name = "cacheId">Id of cache that contains the entry.</param>
        /// <param name = "requestURL">URL spec of the request.</param>
        /// <param name = "requestHeaders">headers of the request.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestCachedResponseResponse&gt;</returns>
        public System.Threading.Tasks.Task<RequestCachedResponseResponse> RequestCachedResponseAsync(string cacheId, string requestURL, System.Collections.Generic.IList<CefSharp.DevTools.CacheStorage.Header> requestHeaders)
        {
            ValidateRequestCachedResponse(cacheId, requestURL, requestHeaders);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheId", cacheId);
            dict.Add("requestURL", requestURL);
            dict.Add("requestHeaders", requestHeaders.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<RequestCachedResponseResponse>("CacheStorage.requestCachedResponse", dict);
        }

        partial void ValidateRequestEntries(string cacheId, int? skipCount = null, int? pageSize = null, string pathFilter = null);
        /// <summary>
        /// Requests data from cache.
        /// </summary>
        /// <param name = "cacheId">ID of cache to get entries from.</param>
        /// <param name = "skipCount">Number of records to skip.</param>
        /// <param name = "pageSize">Number of records to fetch.</param>
        /// <param name = "pathFilter">If present, only return the entries containing this substring in the path</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestEntriesResponse&gt;</returns>
        public System.Threading.Tasks.Task<RequestEntriesResponse> RequestEntriesAsync(string cacheId, int? skipCount = null, int? pageSize = null, string pathFilter = null)
        {
            ValidateRequestEntries(cacheId, skipCount, pageSize, pathFilter);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheId", cacheId);
            if (skipCount.HasValue)
            {
                dict.Add("skipCount", skipCount.Value);
            }

            if (pageSize.HasValue)
            {
                dict.Add("pageSize", pageSize.Value);
            }

            if (!(string.IsNullOrEmpty(pathFilter)))
            {
                dict.Add("pathFilter", pathFilter);
            }

            return _client.ExecuteDevToolsMethodAsync<RequestEntriesResponse>("CacheStorage.requestEntries", dict);
        }
    }
}

namespace CefSharp.DevTools.Cast
{
    using System.Linq;

    /// <summary>
    /// A domain for interacting with Cast, Presentation API, and Remote Playback API
    /// functionalities.
    /// </summary>
    public partial class CastClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Cast
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public CastClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// This is fired whenever the list of available sinks changes. A sink is a
        /// device or a software surface that you can cast to.
        /// </summary>
        public event System.EventHandler<SinksUpdatedEventArgs> SinksUpdated
        {
            add
            {
                _client.AddEventHandler<SinksUpdatedEventArgs>("Cast.sinksUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<SinksUpdatedEventArgs>("Cast.sinksUpdated", value);
            }
        }

        /// <summary>
        /// This is fired whenever the outstanding issue/error message changes.
        /// |issueMessage| is empty if there is no issue.
        /// </summary>
        public event System.EventHandler<IssueUpdatedEventArgs> IssueUpdated
        {
            add
            {
                _client.AddEventHandler<IssueUpdatedEventArgs>("Cast.issueUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<IssueUpdatedEventArgs>("Cast.issueUpdated", value);
            }
        }

        partial void ValidateEnable(string presentationUrl = null);
        /// <summary>
        /// Starts observing for sinks that can be used for tab mirroring, and if set,
        /// sinks compatible with |presentationUrl| as well. When sinks are found, a
        /// |sinksUpdated| event is fired.
        /// Also starts observing for issue messages. When an issue is added or removed,
        /// an |issueUpdated| event is fired.
        /// </summary>
        /// <param name = "presentationUrl">presentationUrl</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(string presentationUrl = null)
        {
            ValidateEnable(presentationUrl);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(presentationUrl)))
            {
                dict.Add("presentationUrl", presentationUrl);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Cast.enable", dict);
        }

        /// <summary>
        /// Stops observing for sinks and issues.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Cast.disable", dict);
        }

        partial void ValidateSetSinkToUse(string sinkName);
        /// <summary>
        /// Sets a sink to be used when the web page requests the browser to choose a
        /// sink via Presentation API, Remote Playback API, or Cast SDK.
        /// </summary>
        /// <param name = "sinkName">sinkName</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetSinkToUseAsync(string sinkName)
        {
            ValidateSetSinkToUse(sinkName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sinkName", sinkName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Cast.setSinkToUse", dict);
        }

        partial void ValidateStartDesktopMirroring(string sinkName);
        /// <summary>
        /// Starts mirroring the desktop to the sink.
        /// </summary>
        /// <param name = "sinkName">sinkName</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartDesktopMirroringAsync(string sinkName)
        {
            ValidateStartDesktopMirroring(sinkName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sinkName", sinkName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Cast.startDesktopMirroring", dict);
        }

        partial void ValidateStartTabMirroring(string sinkName);
        /// <summary>
        /// Starts mirroring the tab to the sink.
        /// </summary>
        /// <param name = "sinkName">sinkName</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartTabMirroringAsync(string sinkName)
        {
            ValidateStartTabMirroring(sinkName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sinkName", sinkName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Cast.startTabMirroring", dict);
        }

        partial void ValidateStopCasting(string sinkName);
        /// <summary>
        /// Stops the active Cast session on the sink.
        /// </summary>
        /// <param name = "sinkName">sinkName</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopCastingAsync(string sinkName)
        {
            ValidateStopCasting(sinkName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sinkName", sinkName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Cast.stopCasting", dict);
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// CollectClassNamesFromSubtreeResponse
    /// </summary>
    public class CollectClassNamesFromSubtreeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// classNames
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("classNames")]
        public string[] ClassNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// CopyToResponse
    /// </summary>
    public class CopyToResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// DescribeNodeResponse
    /// </summary>
    public class DescribeNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// node
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("node")]
        public CefSharp.DevTools.DOM.Node Node
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetAttributesResponse
    /// </summary>
    public class GetAttributesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// attributes
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("attributes")]
        public string[] Attributes
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetBoxModelResponse
    /// </summary>
    public class GetBoxModelResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// model
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("model")]
        public CefSharp.DevTools.DOM.BoxModel Model
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetContentQuadsResponse
    /// </summary>
    public class GetContentQuadsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// quads
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("quads")]
        public double[] Quads
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetDocumentResponse
    /// </summary>
    public class GetDocumentResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// root
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("root")]
        public CefSharp.DevTools.DOM.Node Root
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetNodesForSubtreeByStyleResponse
    /// </summary>
    public class GetNodesForSubtreeByStyleResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetNodeForLocationResponse
    /// </summary>
    public class GetNodeForLocationResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// backendNodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("backendNodeId")]
        public int BackendNodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// frameId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int? NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetOuterHTMLResponse
    /// </summary>
    public class GetOuterHTMLResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// outerHTML
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("outerHTML")]
        public string OuterHTML
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetRelayoutBoundaryResponse
    /// </summary>
    public class GetRelayoutBoundaryResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetSearchResultsResponse
    /// </summary>
    public class GetSearchResultsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// MoveToResponse
    /// </summary>
    public class MoveToResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// PerformSearchResponse
    /// </summary>
    public class PerformSearchResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// searchId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("searchId")]
        public string SearchId
        {
            get;
            private set;
        }

        /// <summary>
        /// resultCount
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("resultCount")]
        public int ResultCount
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// PushNodeByPathToFrontendResponse
    /// </summary>
    public class PushNodeByPathToFrontendResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// PushNodesByBackendIdsToFrontendResponse
    /// </summary>
    public class PushNodesByBackendIdsToFrontendResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// QuerySelectorResponse
    /// </summary>
    public class QuerySelectorResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// QuerySelectorAllResponse
    /// </summary>
    public class QuerySelectorAllResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetTopLayerElementsResponse
    /// </summary>
    public class GetTopLayerElementsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// RequestNodeResponse
    /// </summary>
    public class RequestNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// ResolveNodeResponse
    /// </summary>
    public class ResolveNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// object
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("object")]
        public CefSharp.DevTools.Runtime.RemoteObject Object
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetNodeStackTracesResponse
    /// </summary>
    public class GetNodeStackTracesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// creation
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("creation")]
        public CefSharp.DevTools.Runtime.StackTrace Creation
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetFileInfoResponse
    /// </summary>
    public class GetFileInfoResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// path
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("path")]
        public string Path
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// SetNodeNameResponse
    /// </summary>
    public class SetNodeNameResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetFrameOwnerResponse
    /// </summary>
    public class GetFrameOwnerResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// backendNodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("backendNodeId")]
        public int BackendNodeId
        {
            get;
            private set;
        }

        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int? NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetContainerForNodeResponse
    /// </summary>
    public class GetContainerForNodeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeId")]
        public int? NodeId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    /// <summary>
    /// GetQueryingDescendantsForContainerResponse
    /// </summary>
    public class GetQueryingDescendantsForContainerResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// nodeIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodeIds")]
        public int[] NodeIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOM
{
    using System.Linq;

    /// <summary>
    /// Whether to include whitespaces in the children array of returned Nodes.
    /// </summary>
    public enum EnableIncludeWhitespace
    {
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None,
        /// <summary>
        /// all
        /// </summary>
        [JsonPropertyName("all")]
        All
    }

    /// <summary>
    /// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
    /// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
    /// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
    /// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
    /// and never sends the same node twice. It is client&apos;s responsibility to collect information about
    /// the nodes that were sent to the client.&lt;p&gt;Note that `iframe` owner elements will return
    /// corresponding document elements as their child nodes.&lt;/p&gt;
    /// </summary>
    public partial class DOMClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// DOM
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public DOMClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Fired when `Element`&apos;s attribute is modified.
        /// </summary>
        public event System.EventHandler<AttributeModifiedEventArgs> AttributeModified
        {
            add
            {
                _client.AddEventHandler<AttributeModifiedEventArgs>("DOM.attributeModified", value);
            }

            remove
            {
                _client.RemoveEventHandler<AttributeModifiedEventArgs>("DOM.attributeModified", value);
            }
        }

        /// <summary>
        /// Fired when `Element`&apos;s attribute is removed.
        /// </summary>
        public event System.EventHandler<AttributeRemovedEventArgs> AttributeRemoved
        {
            add
            {
                _client.AddEventHandler<AttributeRemovedEventArgs>("DOM.attributeRemoved", value);
            }

            remove
            {
                _client.RemoveEventHandler<AttributeRemovedEventArgs>("DOM.attributeRemoved", value);
            }
        }

        /// <summary>
        /// Mirrors `DOMCharacterDataModified` event.
        /// </summary>
        public event System.EventHandler<CharacterDataModifiedEventArgs> CharacterDataModified
        {
            add
            {
                _client.AddEventHandler<CharacterDataModifiedEventArgs>("DOM.characterDataModified", value);
            }

            remove
            {
                _client.RemoveEventHandler<CharacterDataModifiedEventArgs>("DOM.characterDataModified", value);
            }
        }

        /// <summary>
        /// Fired when `Container`&apos;s child node count has changed.
        /// </summary>
        public event System.EventHandler<ChildNodeCountUpdatedEventArgs> ChildNodeCountUpdated
        {
            add
            {
                _client.AddEventHandler<ChildNodeCountUpdatedEventArgs>("DOM.childNodeCountUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<ChildNodeCountUpdatedEventArgs>("DOM.childNodeCountUpdated", value);
            }
        }

        /// <summary>
        /// Mirrors `DOMNodeInserted` event.
        /// </summary>
        public event System.EventHandler<ChildNodeInsertedEventArgs> ChildNodeInserted
        {
            add
            {
                _client.AddEventHandler<ChildNodeInsertedEventArgs>("DOM.childNodeInserted", value);
            }

            remove
            {
                _client.RemoveEventHandler<ChildNodeInsertedEventArgs>("DOM.childNodeInserted", value);
            }
        }

        /// <summary>
        /// Mirrors `DOMNodeRemoved` event.
        /// </summary>
        public event System.EventHandler<ChildNodeRemovedEventArgs> ChildNodeRemoved
        {
            add
            {
                _client.AddEventHandler<ChildNodeRemovedEventArgs>("DOM.childNodeRemoved", value);
            }

            remove
            {
                _client.RemoveEventHandler<ChildNodeRemovedEventArgs>("DOM.childNodeRemoved", value);
            }
        }

        /// <summary>
        /// Called when distribution is changed.
        /// </summary>
        public event System.EventHandler<DistributedNodesUpdatedEventArgs> DistributedNodesUpdated
        {
            add
            {
                _client.AddEventHandler<DistributedNodesUpdatedEventArgs>("DOM.distributedNodesUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<DistributedNodesUpdatedEventArgs>("DOM.distributedNodesUpdated", value);
            }
        }

        /// <summary>
        /// Fired when `Document` has been totally updated. Node ids are no longer valid.
        /// </summary>
        public event System.EventHandler<System.EventArgs> DocumentUpdated
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("DOM.documentUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("DOM.documentUpdated", value);
            }
        }

        /// <summary>
        /// Fired when `Element`&apos;s inline style is modified via a CSS property modification.
        /// </summary>
        public event System.EventHandler<InlineStyleInvalidatedEventArgs> InlineStyleInvalidated
        {
            add
            {
                _client.AddEventHandler<InlineStyleInvalidatedEventArgs>("DOM.inlineStyleInvalidated", value);
            }

            remove
            {
                _client.RemoveEventHandler<InlineStyleInvalidatedEventArgs>("DOM.inlineStyleInvalidated", value);
            }
        }

        /// <summary>
        /// Called when a pseudo element is added to an element.
        /// </summary>
        public event System.EventHandler<PseudoElementAddedEventArgs> PseudoElementAdded
        {
            add
            {
                _client.AddEventHandler<PseudoElementAddedEventArgs>("DOM.pseudoElementAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<PseudoElementAddedEventArgs>("DOM.pseudoElementAdded", value);
            }
        }

        /// <summary>
        /// Called when top layer elements are changed.
        /// </summary>
        public event System.EventHandler<System.EventArgs> TopLayerElementsUpdated
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("DOM.topLayerElementsUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("DOM.topLayerElementsUpdated", value);
            }
        }

        /// <summary>
        /// Called when a pseudo element is removed from an element.
        /// </summary>
        public event System.EventHandler<PseudoElementRemovedEventArgs> PseudoElementRemoved
        {
            add
            {
                _client.AddEventHandler<PseudoElementRemovedEventArgs>("DOM.pseudoElementRemoved", value);
            }

            remove
            {
                _client.RemoveEventHandler<PseudoElementRemovedEventArgs>("DOM.pseudoElementRemoved", value);
            }
        }

        /// <summary>
        /// Fired when backend wants to provide client with the missing DOM structure. This happens upon
        /// most of the calls requesting node ids.
        /// </summary>
        public event System.EventHandler<SetChildNodesEventArgs> SetChildNodes
        {
            add
            {
                _client.AddEventHandler<SetChildNodesEventArgs>("DOM.setChildNodes", value);
            }

            remove
            {
                _client.RemoveEventHandler<SetChildNodesEventArgs>("DOM.setChildNodes", value);
            }
        }

        /// <summary>
        /// Called when shadow root is popped from the element.
        /// </summary>
        public event System.EventHandler<ShadowRootPoppedEventArgs> ShadowRootPopped
        {
            add
            {
                _client.AddEventHandler<ShadowRootPoppedEventArgs>("DOM.shadowRootPopped", value);
            }

            remove
            {
                _client.RemoveEventHandler<ShadowRootPoppedEventArgs>("DOM.shadowRootPopped", value);
            }
        }

        /// <summary>
        /// Called when shadow root is pushed into the element.
        /// </summary>
        public event System.EventHandler<ShadowRootPushedEventArgs> ShadowRootPushed
        {
            add
            {
                _client.AddEventHandler<ShadowRootPushedEventArgs>("DOM.shadowRootPushed", value);
            }

            remove
            {
                _client.RemoveEventHandler<ShadowRootPushedEventArgs>("DOM.shadowRootPushed", value);
            }
        }

        partial void ValidateCollectClassNamesFromSubtree(int nodeId);
        /// <summary>
        /// Collects class names for the node with given id and all of it&apos;s child nodes.
        /// </summary>
        /// <param name = "nodeId">Id of the node to collect class names.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CollectClassNamesFromSubtreeResponse&gt;</returns>
        public System.Threading.Tasks.Task<CollectClassNamesFromSubtreeResponse> CollectClassNamesFromSubtreeAsync(int nodeId)
        {
            ValidateCollectClassNamesFromSubtree(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<CollectClassNamesFromSubtreeResponse>("DOM.collectClassNamesFromSubtree", dict);
        }

        partial void ValidateCopyTo(int nodeId, int targetNodeId, int? insertBeforeNodeId = null);
        /// <summary>
        /// Creates a deep copy of the specified node and places it into the target container before the
        /// given anchor.
        /// </summary>
        /// <param name = "nodeId">Id of the node to copy.</param>
        /// <param name = "targetNodeId">Id of the element to drop the copy into.</param>
        /// <param name = "insertBeforeNodeId">Drop the copy before this node (if absent, the copy becomes the last child of`targetNodeId`).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CopyToResponse&gt;</returns>
        public System.Threading.Tasks.Task<CopyToResponse> CopyToAsync(int nodeId, int targetNodeId, int? insertBeforeNodeId = null)
        {
            ValidateCopyTo(nodeId, targetNodeId, insertBeforeNodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("targetNodeId", targetNodeId);
            if (insertBeforeNodeId.HasValue)
            {
                dict.Add("insertBeforeNodeId", insertBeforeNodeId.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<CopyToResponse>("DOM.copyTo", dict);
        }

        partial void ValidateDescribeNode(int? nodeId = null, int? backendNodeId = null, string objectId = null, int? depth = null, bool? pierce = null);
        /// <summary>
        /// Describes node given its id, does not require domain to be enabled. Does not start tracking any
        /// objects, can be used for automation.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <param name = "depth">The maximum depth at which children should be retrieved, defaults to 1. Use -1 for theentire subtree or provide an integer larger than 0.</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots should be traversed when returning the subtree(default is false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DescribeNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<DescribeNodeResponse> DescribeNodeAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null, int? depth = null, bool? pierce = null)
        {
            ValidateDescribeNode(nodeId, backendNodeId, objectId, depth, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DescribeNodeResponse>("DOM.describeNode", dict);
        }

        partial void ValidateScrollIntoViewIfNeeded(int? nodeId = null, int? backendNodeId = null, string objectId = null, CefSharp.DevTools.DOM.Rect rect = null);
        /// <summary>
        /// Scrolls the specified rect of the given node into view if not already visible.
        /// Note: exactly one between nodeId, backendNodeId and objectId should be passed
        /// to identify the node.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <param name = "rect">The rect to be scrolled into view, relative to the node's border box, in CSS pixels.When omitted, center of the node will be used, similar to Element.scrollIntoView.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ScrollIntoViewIfNeededAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null, CefSharp.DevTools.DOM.Rect rect = null)
        {
            ValidateScrollIntoViewIfNeeded(nodeId, backendNodeId, objectId, rect);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if ((rect) != (null))
            {
                dict.Add("rect", rect.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.scrollIntoViewIfNeeded", dict);
        }

        /// <summary>
        /// Disables DOM agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.disable", dict);
        }

        partial void ValidateDiscardSearchResults(string searchId);
        /// <summary>
        /// Discards search results from the session with the given id. `getSearchResults` should no longer
        /// be called for that search.
        /// </summary>
        /// <param name = "searchId">Unique search session identifier.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DiscardSearchResultsAsync(string searchId)
        {
            ValidateDiscardSearchResults(searchId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("searchId", searchId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.discardSearchResults", dict);
        }

        partial void ValidateEnable(CefSharp.DevTools.DOM.EnableIncludeWhitespace? includeWhitespace = null);
        /// <summary>
        /// Enables DOM agent for the given page.
        /// </summary>
        /// <param name = "includeWhitespace">Whether to include whitespaces in the children array of returned Nodes.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(CefSharp.DevTools.DOM.EnableIncludeWhitespace? includeWhitespace = null)
        {
            ValidateEnable(includeWhitespace);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (includeWhitespace.HasValue)
            {
                dict.Add("includeWhitespace", EnumToString(includeWhitespace));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.enable", dict);
        }

        partial void ValidateFocus(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Focuses the given element.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> FocusAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateFocus(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.focus", dict);
        }

        partial void ValidateGetAttributes(int nodeId);
        /// <summary>
        /// Returns attributes for the specified node.
        /// </summary>
        /// <param name = "nodeId">Id of the node to retrieve attibutes for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAttributesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetAttributesResponse> GetAttributesAsync(int nodeId)
        {
            ValidateGetAttributes(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetAttributesResponse>("DOM.getAttributes", dict);
        }

        partial void ValidateGetBoxModel(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Returns boxes for the given node.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBoxModelResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetBoxModelResponse> GetBoxModelAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateGetBoxModel(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetBoxModelResponse>("DOM.getBoxModel", dict);
        }

        partial void ValidateGetContentQuads(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Returns quads that describe node position on the page. This method
        /// might return multiple quads for inline nodes.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetContentQuadsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetContentQuadsResponse> GetContentQuadsAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateGetContentQuads(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetContentQuadsResponse>("DOM.getContentQuads", dict);
        }

        partial void ValidateGetDocument(int? depth = null, bool? pierce = null);
        /// <summary>
        /// Returns the root DOM node (and optionally the subtree) to the caller.
        /// Implicitly enables the DOM domain events for the current target.
        /// </summary>
        /// <param name = "depth">The maximum depth at which children should be retrieved, defaults to 1. Use -1 for theentire subtree or provide an integer larger than 0.</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots should be traversed when returning the subtree(default is false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetDocumentResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetDocumentResponse> GetDocumentAsync(int? depth = null, bool? pierce = null)
        {
            ValidateGetDocument(depth, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetDocumentResponse>("DOM.getDocument", dict);
        }

        partial void ValidateGetNodesForSubtreeByStyle(int nodeId, System.Collections.Generic.IList<CefSharp.DevTools.DOM.CSSComputedStyleProperty> computedStyles, bool? pierce = null);
        /// <summary>
        /// Finds nodes with a given computed style in a subtree.
        /// </summary>
        /// <param name = "nodeId">Node ID pointing to the root of a subtree.</param>
        /// <param name = "computedStyles">The style to filter nodes by (includes nodes if any of properties matches).</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots in the same target should be traversed when returning theresults (default is false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetNodesForSubtreeByStyleResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetNodesForSubtreeByStyleResponse> GetNodesForSubtreeByStyleAsync(int nodeId, System.Collections.Generic.IList<CefSharp.DevTools.DOM.CSSComputedStyleProperty> computedStyles, bool? pierce = null)
        {
            ValidateGetNodesForSubtreeByStyle(nodeId, computedStyles, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("computedStyles", computedStyles.Select(x => x.ToDictionary()));
            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetNodesForSubtreeByStyleResponse>("DOM.getNodesForSubtreeByStyle", dict);
        }

        partial void ValidateGetNodeForLocation(int x, int y, bool? includeUserAgentShadowDOM = null, bool? ignorePointerEventsNone = null);
        /// <summary>
        /// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
        /// either returned or not.
        /// </summary>
        /// <param name = "x">X coordinate.</param>
        /// <param name = "y">Y coordinate.</param>
        /// <param name = "includeUserAgentShadowDOM">False to skip to the nearest non-UA shadow root ancestor (default: false).</param>
        /// <param name = "ignorePointerEventsNone">Whether to ignore pointer-events: none on elements and hit test them.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetNodeForLocationResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetNodeForLocationResponse> GetNodeForLocationAsync(int x, int y, bool? includeUserAgentShadowDOM = null, bool? ignorePointerEventsNone = null)
        {
            ValidateGetNodeForLocation(x, y, includeUserAgentShadowDOM, ignorePointerEventsNone);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            if (includeUserAgentShadowDOM.HasValue)
            {
                dict.Add("includeUserAgentShadowDOM", includeUserAgentShadowDOM.Value);
            }

            if (ignorePointerEventsNone.HasValue)
            {
                dict.Add("ignorePointerEventsNone", ignorePointerEventsNone.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetNodeForLocationResponse>("DOM.getNodeForLocation", dict);
        }

        partial void ValidateGetOuterHTML(int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Returns node&apos;s HTML markup.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetOuterHTMLResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetOuterHTMLResponse> GetOuterHTMLAsync(int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateGetOuterHTML(nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetOuterHTMLResponse>("DOM.getOuterHTML", dict);
        }

        partial void ValidateGetRelayoutBoundary(int nodeId);
        /// <summary>
        /// Returns the id of the nearest ancestor that is a relayout boundary.
        /// </summary>
        /// <param name = "nodeId">Id of the node.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetRelayoutBoundaryResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetRelayoutBoundaryResponse> GetRelayoutBoundaryAsync(int nodeId)
        {
            ValidateGetRelayoutBoundary(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetRelayoutBoundaryResponse>("DOM.getRelayoutBoundary", dict);
        }

        partial void ValidateGetSearchResults(string searchId, int fromIndex, int toIndex);
        /// <summary>
        /// Returns search results from given `fromIndex` to given `toIndex` from the search with the given
        /// identifier.
        /// </summary>
        /// <param name = "searchId">Unique search session identifier.</param>
        /// <param name = "fromIndex">Start index of the search result to be returned.</param>
        /// <param name = "toIndex">End index of the search result to be returned.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSearchResultsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetSearchResultsResponse> GetSearchResultsAsync(string searchId, int fromIndex, int toIndex)
        {
            ValidateGetSearchResults(searchId, fromIndex, toIndex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("searchId", searchId);
            dict.Add("fromIndex", fromIndex);
            dict.Add("toIndex", toIndex);
            return _client.ExecuteDevToolsMethodAsync<GetSearchResultsResponse>("DOM.getSearchResults", dict);
        }

        /// <summary>
        /// Hides any highlight.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HideHighlightAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.hideHighlight", dict);
        }

        /// <summary>
        /// Highlights DOM node.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightNodeAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.highlightNode", dict);
        }

        /// <summary>
        /// Highlights given rectangle.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightRectAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.highlightRect", dict);
        }

        /// <summary>
        /// Marks last undoable state.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> MarkUndoableStateAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.markUndoableState", dict);
        }

        partial void ValidateMoveTo(int nodeId, int targetNodeId, int? insertBeforeNodeId = null);
        /// <summary>
        /// Moves node into the new container, places it before the given anchor.
        /// </summary>
        /// <param name = "nodeId">Id of the node to move.</param>
        /// <param name = "targetNodeId">Id of the element to drop the moved node into.</param>
        /// <param name = "insertBeforeNodeId">Drop node before this one (if absent, the moved node becomes the last child of`targetNodeId`).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;MoveToResponse&gt;</returns>
        public System.Threading.Tasks.Task<MoveToResponse> MoveToAsync(int nodeId, int targetNodeId, int? insertBeforeNodeId = null)
        {
            ValidateMoveTo(nodeId, targetNodeId, insertBeforeNodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("targetNodeId", targetNodeId);
            if (insertBeforeNodeId.HasValue)
            {
                dict.Add("insertBeforeNodeId", insertBeforeNodeId.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<MoveToResponse>("DOM.moveTo", dict);
        }

        partial void ValidatePerformSearch(string query, bool? includeUserAgentShadowDOM = null);
        /// <summary>
        /// Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
        /// `cancelSearch` to end this search session.
        /// </summary>
        /// <param name = "query">Plain text or query selector or XPath search query.</param>
        /// <param name = "includeUserAgentShadowDOM">True to search in user agent shadow DOM.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;PerformSearchResponse&gt;</returns>
        public System.Threading.Tasks.Task<PerformSearchResponse> PerformSearchAsync(string query, bool? includeUserAgentShadowDOM = null)
        {
            ValidatePerformSearch(query, includeUserAgentShadowDOM);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("query", query);
            if (includeUserAgentShadowDOM.HasValue)
            {
                dict.Add("includeUserAgentShadowDOM", includeUserAgentShadowDOM.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<PerformSearchResponse>("DOM.performSearch", dict);
        }

        partial void ValidatePushNodeByPathToFrontend(string path);
        /// <summary>
        /// Requests that the node is sent to the caller given its path. // FIXME, use XPath
        /// </summary>
        /// <param name = "path">Path to node in the proprietary format.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;PushNodeByPathToFrontendResponse&gt;</returns>
        public System.Threading.Tasks.Task<PushNodeByPathToFrontendResponse> PushNodeByPathToFrontendAsync(string path)
        {
            ValidatePushNodeByPathToFrontend(path);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("path", path);
            return _client.ExecuteDevToolsMethodAsync<PushNodeByPathToFrontendResponse>("DOM.pushNodeByPathToFrontend", dict);
        }

        partial void ValidatePushNodesByBackendIdsToFrontend(int[] backendNodeIds);
        /// <summary>
        /// Requests that a batch of nodes is sent to the caller given their backend node ids.
        /// </summary>
        /// <param name = "backendNodeIds">The array of backend node ids.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;PushNodesByBackendIdsToFrontendResponse&gt;</returns>
        public System.Threading.Tasks.Task<PushNodesByBackendIdsToFrontendResponse> PushNodesByBackendIdsToFrontendAsync(int[] backendNodeIds)
        {
            ValidatePushNodesByBackendIdsToFrontend(backendNodeIds);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("backendNodeIds", backendNodeIds);
            return _client.ExecuteDevToolsMethodAsync<PushNodesByBackendIdsToFrontendResponse>("DOM.pushNodesByBackendIdsToFrontend", dict);
        }

        partial void ValidateQuerySelector(int nodeId, string selector);
        /// <summary>
        /// Executes `querySelector` on a given node.
        /// </summary>
        /// <param name = "nodeId">Id of the node to query upon.</param>
        /// <param name = "selector">Selector string.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;QuerySelectorResponse&gt;</returns>
        public System.Threading.Tasks.Task<QuerySelectorResponse> QuerySelectorAsync(int nodeId, string selector)
        {
            ValidateQuerySelector(nodeId, selector);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("selector", selector);
            return _client.ExecuteDevToolsMethodAsync<QuerySelectorResponse>("DOM.querySelector", dict);
        }

        partial void ValidateQuerySelectorAll(int nodeId, string selector);
        /// <summary>
        /// Executes `querySelectorAll` on a given node.
        /// </summary>
        /// <param name = "nodeId">Id of the node to query upon.</param>
        /// <param name = "selector">Selector string.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;QuerySelectorAllResponse&gt;</returns>
        public System.Threading.Tasks.Task<QuerySelectorAllResponse> QuerySelectorAllAsync(int nodeId, string selector)
        {
            ValidateQuerySelectorAll(nodeId, selector);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("selector", selector);
            return _client.ExecuteDevToolsMethodAsync<QuerySelectorAllResponse>("DOM.querySelectorAll", dict);
        }

        /// <summary>
        /// Returns NodeIds of current top layer elements.
        /// Top layer is rendered closest to the user within a viewport, therefore its elements always
        /// appear on top of all other content.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetTopLayerElementsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetTopLayerElementsResponse> GetTopLayerElementsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetTopLayerElementsResponse>("DOM.getTopLayerElements", dict);
        }

        /// <summary>
        /// Re-does the last undone action.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RedoAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.redo", dict);
        }

        partial void ValidateRemoveAttribute(int nodeId, string name);
        /// <summary>
        /// Removes attribute with given name from an element with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the element to remove attribute from.</param>
        /// <param name = "name">Name of the attribute to remove.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveAttributeAsync(int nodeId, string name)
        {
            ValidateRemoveAttribute(nodeId, name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("name", name);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.removeAttribute", dict);
        }

        partial void ValidateRemoveNode(int nodeId);
        /// <summary>
        /// Removes node with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the node to remove.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveNodeAsync(int nodeId)
        {
            ValidateRemoveNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.removeNode", dict);
        }

        partial void ValidateRequestChildNodes(int nodeId, int? depth = null, bool? pierce = null);
        /// <summary>
        /// Requests that children of the node with given id are returned to the caller in form of
        /// `setChildNodes` events where not only immediate children are retrieved, but all children down to
        /// the specified depth.
        /// </summary>
        /// <param name = "nodeId">Id of the node to get children for.</param>
        /// <param name = "depth">The maximum depth at which children should be retrieved, defaults to 1. Use -1 for theentire subtree or provide an integer larger than 0.</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots should be traversed when returning the sub-tree(default is false).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RequestChildNodesAsync(int nodeId, int? depth = null, bool? pierce = null)
        {
            ValidateRequestChildNodes(nodeId, depth, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.requestChildNodes", dict);
        }

        partial void ValidateRequestNode(string objectId);
        /// <summary>
        /// Requests that the node is sent to the caller given the JavaScript node object reference. All
        /// nodes that form the path from the node to the root are also sent to the client as a series of
        /// `setChildNodes` notifications.
        /// </summary>
        /// <param name = "objectId">JavaScript object id to convert into node.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<RequestNodeResponse> RequestNodeAsync(string objectId)
        {
            ValidateRequestNode(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            return _client.ExecuteDevToolsMethodAsync<RequestNodeResponse>("DOM.requestNode", dict);
        }

        partial void ValidateResolveNode(int? nodeId = null, int? backendNodeId = null, string objectGroup = null, int? executionContextId = null);
        /// <summary>
        /// Resolves the JavaScript node object for a given NodeId or BackendNodeId.
        /// </summary>
        /// <param name = "nodeId">Id of the node to resolve.</param>
        /// <param name = "backendNodeId">Backend identifier of the node to resolve.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects.</param>
        /// <param name = "executionContextId">Execution context in which to resolve the node.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ResolveNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<ResolveNodeResponse> ResolveNodeAsync(int? nodeId = null, int? backendNodeId = null, string objectGroup = null, int? executionContextId = null)
        {
            ValidateResolveNode(nodeId, backendNodeId, objectGroup, executionContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<ResolveNodeResponse>("DOM.resolveNode", dict);
        }

        partial void ValidateSetAttributeValue(int nodeId, string name, string value);
        /// <summary>
        /// Sets attribute for an element with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the element to set attribute for.</param>
        /// <param name = "name">Attribute name.</param>
        /// <param name = "value">Attribute value.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAttributeValueAsync(int nodeId, string name, string value)
        {
            ValidateSetAttributeValue(nodeId, name, value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("name", name);
            dict.Add("value", value);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.setAttributeValue", dict);
        }

        partial void ValidateSetAttributesAsText(int nodeId, string text, string name = null);
        /// <summary>
        /// Sets attributes on element with given id. This method is useful when user edits some existing
        /// attribute value and types in several attribute name/value pairs.
        /// </summary>
        /// <param name = "nodeId">Id of the element to set attributes for.</param>
        /// <param name = "text">Text with a number of attributes. Will parse this text using HTML parser.</param>
        /// <param name = "name">Attribute name to replace with new attributes derived from text in case text parsedsuccessfully.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAttributesAsTextAsync(int nodeId, string text, string name = null)
        {
            ValidateSetAttributesAsText(nodeId, text, name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("text", text);
            if (!(string.IsNullOrEmpty(name)))
            {
                dict.Add("name", name);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.setAttributesAsText", dict);
        }

        partial void ValidateSetFileInputFiles(string[] files, int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Sets files for the given file input element.
        /// </summary>
        /// <param name = "files">Array of file paths to set.</param>
        /// <param name = "nodeId">Identifier of the node.</param>
        /// <param name = "backendNodeId">Identifier of the backend node.</param>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetFileInputFilesAsync(string[] files, int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateSetFileInputFiles(files, nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("files", files);
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.setFileInputFiles", dict);
        }

        partial void ValidateSetNodeStackTracesEnabled(bool enable);
        /// <summary>
        /// Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
        /// </summary>
        /// <param name = "enable">Enable or disable.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetNodeStackTracesEnabledAsync(bool enable)
        {
            ValidateSetNodeStackTracesEnabled(enable);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enable", enable);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.setNodeStackTracesEnabled", dict);
        }

        partial void ValidateGetNodeStackTraces(int nodeId);
        /// <summary>
        /// Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
        /// </summary>
        /// <param name = "nodeId">Id of the node to get stack traces for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetNodeStackTracesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetNodeStackTracesResponse> GetNodeStackTracesAsync(int nodeId)
        {
            ValidateGetNodeStackTraces(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetNodeStackTracesResponse>("DOM.getNodeStackTraces", dict);
        }

        partial void ValidateGetFileInfo(string objectId);
        /// <summary>
        /// Returns file information for the given
        /// File wrapper.
        /// </summary>
        /// <param name = "objectId">JavaScript object id of the node wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFileInfoResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetFileInfoResponse> GetFileInfoAsync(string objectId)
        {
            ValidateGetFileInfo(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            return _client.ExecuteDevToolsMethodAsync<GetFileInfoResponse>("DOM.getFileInfo", dict);
        }

        partial void ValidateSetInspectedNode(int nodeId);
        /// <summary>
        /// Enables console to refer to the node with given id via $x (see Command Line API for more details
        /// $x functions).
        /// </summary>
        /// <param name = "nodeId">DOM node id to be accessible by means of $x command line API.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetInspectedNodeAsync(int nodeId)
        {
            ValidateSetInspectedNode(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.setInspectedNode", dict);
        }

        partial void ValidateSetNodeName(int nodeId, string name);
        /// <summary>
        /// Sets node name for a node with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the node to set name for.</param>
        /// <param name = "name">New node's name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetNodeNameResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetNodeNameResponse> SetNodeNameAsync(int nodeId, string name)
        {
            ValidateSetNodeName(nodeId, name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("name", name);
            return _client.ExecuteDevToolsMethodAsync<SetNodeNameResponse>("DOM.setNodeName", dict);
        }

        partial void ValidateSetNodeValue(int nodeId, string value);
        /// <summary>
        /// Sets node value for a node with given id.
        /// </summary>
        /// <param name = "nodeId">Id of the node to set value for.</param>
        /// <param name = "value">New node's value.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetNodeValueAsync(int nodeId, string value)
        {
            ValidateSetNodeValue(nodeId, value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("value", value);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.setNodeValue", dict);
        }

        partial void ValidateSetOuterHTML(int nodeId, string outerHTML);
        /// <summary>
        /// Sets node HTML markup, returns new node id.
        /// </summary>
        /// <param name = "nodeId">Id of the node to set markup for.</param>
        /// <param name = "outerHTML">Outer HTML markup to set.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetOuterHTMLAsync(int nodeId, string outerHTML)
        {
            ValidateSetOuterHTML(nodeId, outerHTML);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("outerHTML", outerHTML);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.setOuterHTML", dict);
        }

        /// <summary>
        /// Undoes the last performed action.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> UndoAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOM.undo", dict);
        }

        partial void ValidateGetFrameOwner(string frameId);
        /// <summary>
        /// Returns iframe node that owns iframe with the given domain.
        /// </summary>
        /// <param name = "frameId">frameId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFrameOwnerResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetFrameOwnerResponse> GetFrameOwnerAsync(string frameId)
        {
            ValidateGetFrameOwner(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            return _client.ExecuteDevToolsMethodAsync<GetFrameOwnerResponse>("DOM.getFrameOwner", dict);
        }

        partial void ValidateGetContainerForNode(int nodeId, string containerName = null, CefSharp.DevTools.DOM.PhysicalAxes? physicalAxes = null, CefSharp.DevTools.DOM.LogicalAxes? logicalAxes = null);
        /// <summary>
        /// Returns the query container of the given node based on container query
        /// conditions: containerName, physical, and logical axes. If no axes are
        /// provided, the style container is returned, which is the direct parent or the
        /// closest element with a matching container-name.
        /// </summary>
        /// <param name = "nodeId">nodeId</param>
        /// <param name = "containerName">containerName</param>
        /// <param name = "physicalAxes">physicalAxes</param>
        /// <param name = "logicalAxes">logicalAxes</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetContainerForNodeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetContainerForNodeResponse> GetContainerForNodeAsync(int nodeId, string containerName = null, CefSharp.DevTools.DOM.PhysicalAxes? physicalAxes = null, CefSharp.DevTools.DOM.LogicalAxes? logicalAxes = null)
        {
            ValidateGetContainerForNode(nodeId, containerName, physicalAxes, logicalAxes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            if (!(string.IsNullOrEmpty(containerName)))
            {
                dict.Add("containerName", containerName);
            }

            if (physicalAxes.HasValue)
            {
                dict.Add("physicalAxes", EnumToString(physicalAxes));
            }

            if (logicalAxes.HasValue)
            {
                dict.Add("logicalAxes", EnumToString(logicalAxes));
            }

            return _client.ExecuteDevToolsMethodAsync<GetContainerForNodeResponse>("DOM.getContainerForNode", dict);
        }

        partial void ValidateGetQueryingDescendantsForContainer(int nodeId);
        /// <summary>
        /// Returns the descendants of a container query container that have
        /// container queries against this container.
        /// </summary>
        /// <param name = "nodeId">Id of the container node to find querying descendants from.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetQueryingDescendantsForContainerResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetQueryingDescendantsForContainerResponse> GetQueryingDescendantsForContainerAsync(int nodeId)
        {
            ValidateGetQueryingDescendantsForContainer(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetQueryingDescendantsForContainerResponse>("DOM.getQueryingDescendantsForContainer", dict);
        }
    }
}

namespace CefSharp.DevTools.DOMDebugger
{
    /// <summary>
    /// GetEventListenersResponse
    /// </summary>
    public class GetEventListenersResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// listeners
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("listeners")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMDebugger.EventListener> Listeners
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOMDebugger
{
    using System.Linq;

    /// <summary>
    /// DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
    /// execution will stop on these operations as if there was a regular breakpoint set.
    /// </summary>
    public partial class DOMDebuggerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// DOMDebugger
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public DOMDebuggerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateGetEventListeners(string objectId, int? depth = null, bool? pierce = null);
        /// <summary>
        /// Returns event listeners of the given object.
        /// </summary>
        /// <param name = "objectId">Identifier of the object to return listeners for.</param>
        /// <param name = "depth">The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for theentire subtree or provide an integer larger than 0.</param>
        /// <param name = "pierce">Whether or not iframes and shadow roots should be traversed when returning the subtree(default is false). Reports listeners for all contexts if pierce is enabled.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetEventListenersResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetEventListenersResponse> GetEventListenersAsync(string objectId, int? depth = null, bool? pierce = null)
        {
            ValidateGetEventListeners(objectId, depth, pierce);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            if (depth.HasValue)
            {
                dict.Add("depth", depth.Value);
            }

            if (pierce.HasValue)
            {
                dict.Add("pierce", pierce.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetEventListenersResponse>("DOMDebugger.getEventListeners", dict);
        }

        partial void ValidateRemoveDOMBreakpoint(int nodeId, CefSharp.DevTools.DOMDebugger.DOMBreakpointType type);
        /// <summary>
        /// Removes DOM breakpoint that was set using `setDOMBreakpoint`.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node to remove breakpoint from.</param>
        /// <param name = "type">Type of the breakpoint to remove.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveDOMBreakpointAsync(int nodeId, CefSharp.DevTools.DOMDebugger.DOMBreakpointType type)
        {
            ValidateRemoveDOMBreakpoint(nodeId, type);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("type", EnumToString(type));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.removeDOMBreakpoint", dict);
        }

        partial void ValidateRemoveEventListenerBreakpoint(string eventName, string targetName = null);
        /// <summary>
        /// Removes breakpoint on particular DOM event.
        /// </summary>
        /// <param name = "eventName">Event name.</param>
        /// <param name = "targetName">EventTarget interface name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveEventListenerBreakpointAsync(string eventName, string targetName = null)
        {
            ValidateRemoveEventListenerBreakpoint(eventName, targetName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            if (!(string.IsNullOrEmpty(targetName)))
            {
                dict.Add("targetName", targetName);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.removeEventListenerBreakpoint", dict);
        }

        partial void ValidateRemoveInstrumentationBreakpoint(string eventName);
        /// <summary>
        /// Removes breakpoint on particular native event.
        /// </summary>
        /// <param name = "eventName">Instrumentation name to stop on.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveInstrumentationBreakpointAsync(string eventName)
        {
            ValidateRemoveInstrumentationBreakpoint(eventName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.removeInstrumentationBreakpoint", dict);
        }

        partial void ValidateRemoveXHRBreakpoint(string url);
        /// <summary>
        /// Removes breakpoint from XMLHttpRequest.
        /// </summary>
        /// <param name = "url">Resource URL substring.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveXHRBreakpointAsync(string url)
        {
            ValidateRemoveXHRBreakpoint(url);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.removeXHRBreakpoint", dict);
        }

        partial void ValidateSetBreakOnCSPViolation(CefSharp.DevTools.DOMDebugger.CSPViolationType[] violationTypes);
        /// <summary>
        /// Sets breakpoint on particular CSP violations.
        /// </summary>
        /// <param name = "violationTypes">CSP Violations to stop upon.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetBreakOnCSPViolationAsync(CefSharp.DevTools.DOMDebugger.CSPViolationType[] violationTypes)
        {
            ValidateSetBreakOnCSPViolation(violationTypes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("violationTypes", EnumToString(violationTypes));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.setBreakOnCSPViolation", dict);
        }

        partial void ValidateSetDOMBreakpoint(int nodeId, CefSharp.DevTools.DOMDebugger.DOMBreakpointType type);
        /// <summary>
        /// Sets breakpoint on particular operation with DOM.
        /// </summary>
        /// <param name = "nodeId">Identifier of the node to set breakpoint on.</param>
        /// <param name = "type">Type of the operation to stop upon.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDOMBreakpointAsync(int nodeId, CefSharp.DevTools.DOMDebugger.DOMBreakpointType type)
        {
            ValidateSetDOMBreakpoint(nodeId, type);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            dict.Add("type", EnumToString(type));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.setDOMBreakpoint", dict);
        }

        partial void ValidateSetEventListenerBreakpoint(string eventName, string targetName = null);
        /// <summary>
        /// Sets breakpoint on particular DOM event.
        /// </summary>
        /// <param name = "eventName">DOM Event name to stop on (any DOM event will do).</param>
        /// <param name = "targetName">EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on anyEventTarget.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetEventListenerBreakpointAsync(string eventName, string targetName = null)
        {
            ValidateSetEventListenerBreakpoint(eventName, targetName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            if (!(string.IsNullOrEmpty(targetName)))
            {
                dict.Add("targetName", targetName);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.setEventListenerBreakpoint", dict);
        }

        partial void ValidateSetInstrumentationBreakpoint(string eventName);
        /// <summary>
        /// Sets breakpoint on particular native event.
        /// </summary>
        /// <param name = "eventName">Instrumentation name to stop on.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetInstrumentationBreakpointAsync(string eventName)
        {
            ValidateSetInstrumentationBreakpoint(eventName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.setInstrumentationBreakpoint", dict);
        }

        partial void ValidateSetXHRBreakpoint(string url);
        /// <summary>
        /// Sets breakpoint on XMLHttpRequest.
        /// </summary>
        /// <param name = "url">Resource URL substring. All XHRs having this substring in the URL will get stopped upon.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetXHRBreakpointAsync(string url)
        {
            ValidateSetXHRBreakpoint(url);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMDebugger.setXHRBreakpoint", dict);
        }
    }
}

namespace CefSharp.DevTools.EventBreakpoints
{
    using System.Linq;

    /// <summary>
    /// EventBreakpoints permits setting breakpoints on particular operations and
    /// events in targets that run JavaScript but do not have a DOM.
    /// JavaScript execution will stop on these operations as if there was a regular
    /// breakpoint set.
    /// </summary>
    public partial class EventBreakpointsClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// EventBreakpoints
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public EventBreakpointsClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateSetInstrumentationBreakpoint(string eventName);
        /// <summary>
        /// Sets breakpoint on particular native event.
        /// </summary>
        /// <param name = "eventName">Instrumentation name to stop on.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetInstrumentationBreakpointAsync(string eventName)
        {
            ValidateSetInstrumentationBreakpoint(eventName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("EventBreakpoints.setInstrumentationBreakpoint", dict);
        }

        partial void ValidateRemoveInstrumentationBreakpoint(string eventName);
        /// <summary>
        /// Removes breakpoint on particular native event.
        /// </summary>
        /// <param name = "eventName">Instrumentation name to stop on.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveInstrumentationBreakpointAsync(string eventName)
        {
            ValidateRemoveInstrumentationBreakpoint(eventName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventName", eventName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("EventBreakpoints.removeInstrumentationBreakpoint", dict);
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    /// <summary>
    /// CaptureSnapshotResponse
    /// </summary>
    public class CaptureSnapshotResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// documents
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("documents")]
        public System.Collections.Generic.IList<CefSharp.DevTools.DOMSnapshot.DocumentSnapshot> Documents
        {
            get;
            private set;
        }

        /// <summary>
        /// strings
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("strings")]
        public string[] Strings
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOMSnapshot
{
    using System.Linq;

    /// <summary>
    /// This domain facilitates obtaining document snapshots with DOM, layout, and style information.
    /// </summary>
    public partial class DOMSnapshotClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// DOMSnapshot
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public DOMSnapshotClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Disables DOM snapshot agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMSnapshot.disable", dict);
        }

        /// <summary>
        /// Enables DOM snapshot agent for the given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMSnapshot.enable", dict);
        }

        partial void ValidateCaptureSnapshot(string[] computedStyles, bool? includePaintOrder = null, bool? includeDOMRects = null, bool? includeBlendedBackgroundColors = null, bool? includeTextColorOpacities = null);
        /// <summary>
        /// Returns a document snapshot, including the full DOM tree of the root node (including iframes,
        /// template contents, and imported documents) in a flattened array, as well as layout and
        /// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
        /// flattened.
        /// </summary>
        /// <param name = "computedStyles">Whitelist of computed styles to return.</param>
        /// <param name = "includePaintOrder">Whether to include layout object paint orders into the snapshot.</param>
        /// <param name = "includeDOMRects">Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot</param>
        /// <param name = "includeBlendedBackgroundColors">Whether to include blended background colors in the snapshot (default: false).Blended background color is achieved by blending background colors of all elementsthat overlap with the current element.</param>
        /// <param name = "includeTextColorOpacities">Whether to include text color opacity in the snapshot (default: false).An element might have the opacity property set that affects the text color of the element.The final text color opacity is computed based on the opacity of all overlapping elements.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CaptureSnapshotResponse&gt;</returns>
        public System.Threading.Tasks.Task<CaptureSnapshotResponse> CaptureSnapshotAsync(string[] computedStyles, bool? includePaintOrder = null, bool? includeDOMRects = null, bool? includeBlendedBackgroundColors = null, bool? includeTextColorOpacities = null)
        {
            ValidateCaptureSnapshot(computedStyles, includePaintOrder, includeDOMRects, includeBlendedBackgroundColors, includeTextColorOpacities);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("computedStyles", computedStyles);
            if (includePaintOrder.HasValue)
            {
                dict.Add("includePaintOrder", includePaintOrder.Value);
            }

            if (includeDOMRects.HasValue)
            {
                dict.Add("includeDOMRects", includeDOMRects.Value);
            }

            if (includeBlendedBackgroundColors.HasValue)
            {
                dict.Add("includeBlendedBackgroundColors", includeBlendedBackgroundColors.Value);
            }

            if (includeTextColorOpacities.HasValue)
            {
                dict.Add("includeTextColorOpacities", includeTextColorOpacities.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<CaptureSnapshotResponse>("DOMSnapshot.captureSnapshot", dict);
        }
    }
}

namespace CefSharp.DevTools.DOMStorage
{
    /// <summary>
    /// GetDOMStorageItemsResponse
    /// </summary>
    public class GetDOMStorageItemsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// entries
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("entries")]
        public string[] Entries
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.DOMStorage
{
    using System.Linq;

    /// <summary>
    /// Query and modify DOM storage.
    /// </summary>
    public partial class DOMStorageClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// DOMStorage
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public DOMStorageClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// DomStorageItemAdded
        /// </summary>
        public event System.EventHandler<DomStorageItemAddedEventArgs> DomStorageItemAdded
        {
            add
            {
                _client.AddEventHandler<DomStorageItemAddedEventArgs>("DOMStorage.domStorageItemAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<DomStorageItemAddedEventArgs>("DOMStorage.domStorageItemAdded", value);
            }
        }

        /// <summary>
        /// DomStorageItemRemoved
        /// </summary>
        public event System.EventHandler<DomStorageItemRemovedEventArgs> DomStorageItemRemoved
        {
            add
            {
                _client.AddEventHandler<DomStorageItemRemovedEventArgs>("DOMStorage.domStorageItemRemoved", value);
            }

            remove
            {
                _client.RemoveEventHandler<DomStorageItemRemovedEventArgs>("DOMStorage.domStorageItemRemoved", value);
            }
        }

        /// <summary>
        /// DomStorageItemUpdated
        /// </summary>
        public event System.EventHandler<DomStorageItemUpdatedEventArgs> DomStorageItemUpdated
        {
            add
            {
                _client.AddEventHandler<DomStorageItemUpdatedEventArgs>("DOMStorage.domStorageItemUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<DomStorageItemUpdatedEventArgs>("DOMStorage.domStorageItemUpdated", value);
            }
        }

        /// <summary>
        /// DomStorageItemsCleared
        /// </summary>
        public event System.EventHandler<DomStorageItemsClearedEventArgs> DomStorageItemsCleared
        {
            add
            {
                _client.AddEventHandler<DomStorageItemsClearedEventArgs>("DOMStorage.domStorageItemsCleared", value);
            }

            remove
            {
                _client.RemoveEventHandler<DomStorageItemsClearedEventArgs>("DOMStorage.domStorageItemsCleared", value);
            }
        }

        partial void ValidateClear(CefSharp.DevTools.DOMStorage.StorageId storageId);
        /// <summary>
        /// Clear
        /// </summary>
        /// <param name = "storageId">storageId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearAsync(CefSharp.DevTools.DOMStorage.StorageId storageId)
        {
            ValidateClear(storageId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageId", storageId.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMStorage.clear", dict);
        }

        /// <summary>
        /// Disables storage tracking, prevents storage events from being sent to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMStorage.disable", dict);
        }

        /// <summary>
        /// Enables storage tracking, storage events will now be delivered to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMStorage.enable", dict);
        }

        partial void ValidateGetDOMStorageItems(CefSharp.DevTools.DOMStorage.StorageId storageId);
        /// <summary>
        /// GetDOMStorageItems
        /// </summary>
        /// <param name = "storageId">storageId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetDOMStorageItemsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetDOMStorageItemsResponse> GetDOMStorageItemsAsync(CefSharp.DevTools.DOMStorage.StorageId storageId)
        {
            ValidateGetDOMStorageItems(storageId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageId", storageId.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<GetDOMStorageItemsResponse>("DOMStorage.getDOMStorageItems", dict);
        }

        partial void ValidateRemoveDOMStorageItem(CefSharp.DevTools.DOMStorage.StorageId storageId, string key);
        /// <summary>
        /// RemoveDOMStorageItem
        /// </summary>
        /// <param name = "storageId">storageId</param>
        /// <param name = "key">key</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveDOMStorageItemAsync(CefSharp.DevTools.DOMStorage.StorageId storageId, string key)
        {
            ValidateRemoveDOMStorageItem(storageId, key);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageId", storageId.ToDictionary());
            dict.Add("key", key);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMStorage.removeDOMStorageItem", dict);
        }

        partial void ValidateSetDOMStorageItem(CefSharp.DevTools.DOMStorage.StorageId storageId, string key, string value);
        /// <summary>
        /// SetDOMStorageItem
        /// </summary>
        /// <param name = "storageId">storageId</param>
        /// <param name = "key">key</param>
        /// <param name = "value">value</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDOMStorageItemAsync(CefSharp.DevTools.DOMStorage.StorageId storageId, string key, string value)
        {
            ValidateSetDOMStorageItem(storageId, key, value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageId", storageId.ToDictionary());
            dict.Add("key", key);
            dict.Add("value", value);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DOMStorage.setDOMStorageItem", dict);
        }
    }
}

namespace CefSharp.DevTools.Database
{
    /// <summary>
    /// ExecuteSQLResponse
    /// </summary>
    public class ExecuteSQLResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// columnNames
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("columnNames")]
        public string[] ColumnNames
        {
            get;
            private set;
        }

        /// <summary>
        /// values
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("values")]
        public object[] Values
        {
            get;
            private set;
        }

        /// <summary>
        /// sqlError
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sqlError")]
        public CefSharp.DevTools.Database.Error SqlError
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Database
{
    /// <summary>
    /// GetDatabaseTableNamesResponse
    /// </summary>
    public class GetDatabaseTableNamesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// tableNames
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("tableNames")]
        public string[] TableNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Database
{
    using System.Linq;

    /// <summary>
    /// Database
    /// </summary>
    public partial class DatabaseClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Database
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public DatabaseClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// AddDatabase
        /// </summary>
        public event System.EventHandler<AddDatabaseEventArgs> AddDatabase
        {
            add
            {
                _client.AddEventHandler<AddDatabaseEventArgs>("Database.addDatabase", value);
            }

            remove
            {
                _client.RemoveEventHandler<AddDatabaseEventArgs>("Database.addDatabase", value);
            }
        }

        /// <summary>
        /// Disables database tracking, prevents database events from being sent to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Database.disable", dict);
        }

        /// <summary>
        /// Enables database tracking, database events will now be delivered to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Database.enable", dict);
        }

        partial void ValidateExecuteSQL(string databaseId, string query);
        /// <summary>
        /// ExecuteSQL
        /// </summary>
        /// <param name = "databaseId">databaseId</param>
        /// <param name = "query">query</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ExecuteSQLResponse&gt;</returns>
        public System.Threading.Tasks.Task<ExecuteSQLResponse> ExecuteSQLAsync(string databaseId, string query)
        {
            ValidateExecuteSQL(databaseId, query);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseId", databaseId);
            dict.Add("query", query);
            return _client.ExecuteDevToolsMethodAsync<ExecuteSQLResponse>("Database.executeSQL", dict);
        }

        partial void ValidateGetDatabaseTableNames(string databaseId);
        /// <summary>
        /// GetDatabaseTableNames
        /// </summary>
        /// <param name = "databaseId">databaseId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetDatabaseTableNamesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetDatabaseTableNamesResponse> GetDatabaseTableNamesAsync(string databaseId)
        {
            ValidateGetDatabaseTableNames(databaseId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseId", databaseId);
            return _client.ExecuteDevToolsMethodAsync<GetDatabaseTableNamesResponse>("Database.getDatabaseTableNames", dict);
        }
    }
}

namespace CefSharp.DevTools.DeviceOrientation
{
    using System.Linq;

    /// <summary>
    /// DeviceOrientation
    /// </summary>
    public partial class DeviceOrientationClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// DeviceOrientation
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public DeviceOrientationClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Clears the overridden Device Orientation.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearDeviceOrientationOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DeviceOrientation.clearDeviceOrientationOverride", dict);
        }

        partial void ValidateSetDeviceOrientationOverride(double alpha, double beta, double gamma);
        /// <summary>
        /// Overrides the Device Orientation.
        /// </summary>
        /// <param name = "alpha">Mock alpha</param>
        /// <param name = "beta">Mock beta</param>
        /// <param name = "gamma">Mock gamma</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDeviceOrientationOverrideAsync(double alpha, double beta, double gamma)
        {
            ValidateSetDeviceOrientationOverride(alpha, beta, gamma);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("alpha", alpha);
            dict.Add("beta", beta);
            dict.Add("gamma", gamma);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DeviceOrientation.setDeviceOrientationOverride", dict);
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// CanEmulateResponse
    /// </summary>
    public class CanEmulateResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public bool Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    /// <summary>
    /// SetVirtualTimePolicyResponse
    /// </summary>
    public class SetVirtualTimePolicyResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// virtualTimeTicksBase
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("virtualTimeTicksBase")]
        public double VirtualTimeTicksBase
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Emulation
{
    using System.Linq;

    /// <summary>
    /// Touch/gesture events configuration. Default: current platform.
    /// </summary>
    public enum SetEmitTouchEventsForMouseConfiguration
    {
        /// <summary>
        /// mobile
        /// </summary>
        [JsonPropertyName("mobile")]
        Mobile,
        /// <summary>
        /// desktop
        /// </summary>
        [JsonPropertyName("desktop")]
        Desktop
    }

    /// <summary>
    /// Vision deficiency to emulate. Order: best-effort emulations come first, followed by any
    /// physiologically accurate emulations for medically recognized color vision deficiencies.
    /// </summary>
    public enum SetEmulatedVisionDeficiencyType
    {
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None,
        /// <summary>
        /// blurredVision
        /// </summary>
        [JsonPropertyName("blurredVision")]
        BlurredVision,
        /// <summary>
        /// reducedContrast
        /// </summary>
        [JsonPropertyName("reducedContrast")]
        ReducedContrast,
        /// <summary>
        /// achromatopsia
        /// </summary>
        [JsonPropertyName("achromatopsia")]
        Achromatopsia,
        /// <summary>
        /// deuteranopia
        /// </summary>
        [JsonPropertyName("deuteranopia")]
        Deuteranopia,
        /// <summary>
        /// protanopia
        /// </summary>
        [JsonPropertyName("protanopia")]
        Protanopia,
        /// <summary>
        /// tritanopia
        /// </summary>
        [JsonPropertyName("tritanopia")]
        Tritanopia
    }

    /// <summary>
    /// This domain emulates different environments for the page.
    /// </summary>
    public partial class EmulationClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Emulation
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public EmulationClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
        /// </summary>
        public event System.EventHandler<System.EventArgs> VirtualTimeBudgetExpired
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Emulation.virtualTimeBudgetExpired", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Emulation.virtualTimeBudgetExpired", value);
            }
        }

        /// <summary>
        /// Tells whether emulation is supported.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;CanEmulateResponse&gt;</returns>
        public System.Threading.Tasks.Task<CanEmulateResponse> CanEmulateAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<CanEmulateResponse>("Emulation.canEmulate", dict);
        }

        /// <summary>
        /// Clears the overridden device metrics.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearDeviceMetricsOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.clearDeviceMetricsOverride", dict);
        }

        /// <summary>
        /// Clears the overridden Geolocation Position and Error.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearGeolocationOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.clearGeolocationOverride", dict);
        }

        /// <summary>
        /// Requests that page scale factor is reset to initial values.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ResetPageScaleFactorAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.resetPageScaleFactor", dict);
        }

        partial void ValidateSetFocusEmulationEnabled(bool enabled);
        /// <summary>
        /// Enables or disables simulating a focused and active page.
        /// </summary>
        /// <param name = "enabled">Whether to enable to disable focus emulation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetFocusEmulationEnabledAsync(bool enabled)
        {
            ValidateSetFocusEmulationEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setFocusEmulationEnabled", dict);
        }

        partial void ValidateSetAutoDarkModeOverride(bool? enabled = null);
        /// <summary>
        /// Automatically render all web contents using a dark theme.
        /// </summary>
        /// <param name = "enabled">Whether to enable or disable automatic dark mode.If not specified, any existing override will be cleared.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAutoDarkModeOverrideAsync(bool? enabled = null)
        {
            ValidateSetAutoDarkModeOverride(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (enabled.HasValue)
            {
                dict.Add("enabled", enabled.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setAutoDarkModeOverride", dict);
        }

        partial void ValidateSetCPUThrottlingRate(double rate);
        /// <summary>
        /// Enables CPU throttling to emulate slow CPUs.
        /// </summary>
        /// <param name = "rate">Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetCPUThrottlingRateAsync(double rate)
        {
            ValidateSetCPUThrottlingRate(rate);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("rate", rate);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setCPUThrottlingRate", dict);
        }

        partial void ValidateSetDefaultBackgroundColorOverride(CefSharp.DevTools.DOM.RGBA color = null);
        /// <summary>
        /// Sets or clears an override of the default background color of the frame. This override is used
        /// if the content does not specify one.
        /// </summary>
        /// <param name = "color">RGBA of the default background color. If not specified, any existing override will becleared.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDefaultBackgroundColorOverrideAsync(CefSharp.DevTools.DOM.RGBA color = null)
        {
            ValidateSetDefaultBackgroundColorOverride(color);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((color) != (null))
            {
                dict.Add("color", color.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setDefaultBackgroundColorOverride", dict);
        }

        partial void ValidateSetDeviceMetricsOverride(int width, int height, double deviceScaleFactor, bool mobile, double? scale = null, int? screenWidth = null, int? screenHeight = null, int? positionX = null, int? positionY = null, bool? dontSetVisibleSize = null, CefSharp.DevTools.Emulation.ScreenOrientation screenOrientation = null, CefSharp.DevTools.Page.Viewport viewport = null, CefSharp.DevTools.Emulation.DisplayFeature displayFeature = null);
        /// <summary>
        /// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
        /// window.innerWidth, window.innerHeight, and &quot;device-width&quot;/&quot;device-height&quot;-related CSS media
        /// query results).
        /// </summary>
        /// <param name = "width">Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.</param>
        /// <param name = "height">Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.</param>
        /// <param name = "deviceScaleFactor">Overriding device scale factor value. 0 disables the override.</param>
        /// <param name = "mobile">Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, textautosizing and more.</param>
        /// <param name = "scale">Scale to apply to resulting view image.</param>
        /// <param name = "screenWidth">Overriding screen width value in pixels (minimum 0, maximum 10000000).</param>
        /// <param name = "screenHeight">Overriding screen height value in pixels (minimum 0, maximum 10000000).</param>
        /// <param name = "positionX">Overriding view X position on screen in pixels (minimum 0, maximum 10000000).</param>
        /// <param name = "positionY">Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).</param>
        /// <param name = "dontSetVisibleSize">Do not set visible view size, rely upon explicit setVisibleSize call.</param>
        /// <param name = "screenOrientation">Screen orientation override.</param>
        /// <param name = "viewport">If set, the visible area of the page will be overridden to this viewport. This viewportchange is not observed by the page, e.g. viewport-relative elements do not change positions.</param>
        /// <param name = "displayFeature">If set, the display feature of a multi-segment screen. If not set, multi-segment supportis turned-off.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDeviceMetricsOverrideAsync(int width, int height, double deviceScaleFactor, bool mobile, double? scale = null, int? screenWidth = null, int? screenHeight = null, int? positionX = null, int? positionY = null, bool? dontSetVisibleSize = null, CefSharp.DevTools.Emulation.ScreenOrientation screenOrientation = null, CefSharp.DevTools.Page.Viewport viewport = null, CefSharp.DevTools.Emulation.DisplayFeature displayFeature = null)
        {
            ValidateSetDeviceMetricsOverride(width, height, deviceScaleFactor, mobile, scale, screenWidth, screenHeight, positionX, positionY, dontSetVisibleSize, screenOrientation, viewport, displayFeature);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("width", width);
            dict.Add("height", height);
            dict.Add("deviceScaleFactor", deviceScaleFactor);
            dict.Add("mobile", mobile);
            if (scale.HasValue)
            {
                dict.Add("scale", scale.Value);
            }

            if (screenWidth.HasValue)
            {
                dict.Add("screenWidth", screenWidth.Value);
            }

            if (screenHeight.HasValue)
            {
                dict.Add("screenHeight", screenHeight.Value);
            }

            if (positionX.HasValue)
            {
                dict.Add("positionX", positionX.Value);
            }

            if (positionY.HasValue)
            {
                dict.Add("positionY", positionY.Value);
            }

            if (dontSetVisibleSize.HasValue)
            {
                dict.Add("dontSetVisibleSize", dontSetVisibleSize.Value);
            }

            if ((screenOrientation) != (null))
            {
                dict.Add("screenOrientation", screenOrientation.ToDictionary());
            }

            if ((viewport) != (null))
            {
                dict.Add("viewport", viewport.ToDictionary());
            }

            if ((displayFeature) != (null))
            {
                dict.Add("displayFeature", displayFeature.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setDeviceMetricsOverride", dict);
        }

        partial void ValidateSetScrollbarsHidden(bool hidden);
        /// <summary>
        /// SetScrollbarsHidden
        /// </summary>
        /// <param name = "hidden">Whether scrollbars should be always hidden.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetScrollbarsHiddenAsync(bool hidden)
        {
            ValidateSetScrollbarsHidden(hidden);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("hidden", hidden);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setScrollbarsHidden", dict);
        }

        partial void ValidateSetDocumentCookieDisabled(bool disabled);
        /// <summary>
        /// SetDocumentCookieDisabled
        /// </summary>
        /// <param name = "disabled">Whether document.coookie API should be disabled.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDocumentCookieDisabledAsync(bool disabled)
        {
            ValidateSetDocumentCookieDisabled(disabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("disabled", disabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setDocumentCookieDisabled", dict);
        }

        partial void ValidateSetEmitTouchEventsForMouse(bool enabled, CefSharp.DevTools.Emulation.SetEmitTouchEventsForMouseConfiguration? configuration = null);
        /// <summary>
        /// SetEmitTouchEventsForMouse
        /// </summary>
        /// <param name = "enabled">Whether touch emulation based on mouse input should be enabled.</param>
        /// <param name = "configuration">Touch/gesture events configuration. Default: current platform.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetEmitTouchEventsForMouseAsync(bool enabled, CefSharp.DevTools.Emulation.SetEmitTouchEventsForMouseConfiguration? configuration = null)
        {
            ValidateSetEmitTouchEventsForMouse(enabled, configuration);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            if (configuration.HasValue)
            {
                dict.Add("configuration", EnumToString(configuration));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setEmitTouchEventsForMouse", dict);
        }

        partial void ValidateSetEmulatedMedia(string media = null, System.Collections.Generic.IList<CefSharp.DevTools.Emulation.MediaFeature> features = null);
        /// <summary>
        /// Emulates the given media type or media feature for CSS media queries.
        /// </summary>
        /// <param name = "media">Media type to emulate. Empty string disables the override.</param>
        /// <param name = "features">Media features to emulate.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetEmulatedMediaAsync(string media = null, System.Collections.Generic.IList<CefSharp.DevTools.Emulation.MediaFeature> features = null)
        {
            ValidateSetEmulatedMedia(media, features);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(media)))
            {
                dict.Add("media", media);
            }

            if ((features) != (null))
            {
                dict.Add("features", features.Select(x => x.ToDictionary()));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setEmulatedMedia", dict);
        }

        partial void ValidateSetEmulatedVisionDeficiency(CefSharp.DevTools.Emulation.SetEmulatedVisionDeficiencyType type);
        /// <summary>
        /// Emulates the given vision deficiency.
        /// </summary>
        /// <param name = "type">Vision deficiency to emulate. Order: best-effort emulations come first, followed by anyphysiologically accurate emulations for medically recognized color vision deficiencies.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetEmulatedVisionDeficiencyAsync(CefSharp.DevTools.Emulation.SetEmulatedVisionDeficiencyType type)
        {
            ValidateSetEmulatedVisionDeficiency(type);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", EnumToString(type));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setEmulatedVisionDeficiency", dict);
        }

        partial void ValidateSetGeolocationOverride(double? latitude = null, double? longitude = null, double? accuracy = null);
        /// <summary>
        /// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
        /// unavailable.
        /// </summary>
        /// <param name = "latitude">Mock latitude</param>
        /// <param name = "longitude">Mock longitude</param>
        /// <param name = "accuracy">Mock accuracy</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetGeolocationOverrideAsync(double? latitude = null, double? longitude = null, double? accuracy = null)
        {
            ValidateSetGeolocationOverride(latitude, longitude, accuracy);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (latitude.HasValue)
            {
                dict.Add("latitude", latitude.Value);
            }

            if (longitude.HasValue)
            {
                dict.Add("longitude", longitude.Value);
            }

            if (accuracy.HasValue)
            {
                dict.Add("accuracy", accuracy.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setGeolocationOverride", dict);
        }

        partial void ValidateSetIdleOverride(bool isUserActive, bool isScreenUnlocked);
        /// <summary>
        /// Overrides the Idle state.
        /// </summary>
        /// <param name = "isUserActive">Mock isUserActive</param>
        /// <param name = "isScreenUnlocked">Mock isScreenUnlocked</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetIdleOverrideAsync(bool isUserActive, bool isScreenUnlocked)
        {
            ValidateSetIdleOverride(isUserActive, isScreenUnlocked);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("isUserActive", isUserActive);
            dict.Add("isScreenUnlocked", isScreenUnlocked);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setIdleOverride", dict);
        }

        /// <summary>
        /// Clears Idle state overrides.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearIdleOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.clearIdleOverride", dict);
        }

        partial void ValidateSetPageScaleFactor(double pageScaleFactor);
        /// <summary>
        /// Sets a specified page scale factor.
        /// </summary>
        /// <param name = "pageScaleFactor">Page scale factor.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetPageScaleFactorAsync(double pageScaleFactor)
        {
            ValidateSetPageScaleFactor(pageScaleFactor);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("pageScaleFactor", pageScaleFactor);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setPageScaleFactor", dict);
        }

        partial void ValidateSetScriptExecutionDisabled(bool value);
        /// <summary>
        /// Switches script execution in the page.
        /// </summary>
        /// <param name = "value">Whether script execution should be disabled in the page.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetScriptExecutionDisabledAsync(bool value)
        {
            ValidateSetScriptExecutionDisabled(value);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("value", value);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setScriptExecutionDisabled", dict);
        }

        partial void ValidateSetTouchEmulationEnabled(bool enabled, int? maxTouchPoints = null);
        /// <summary>
        /// Enables touch on platforms which do not support them.
        /// </summary>
        /// <param name = "enabled">Whether the touch event emulation should be enabled.</param>
        /// <param name = "maxTouchPoints">Maximum touch points supported. Defaults to one.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetTouchEmulationEnabledAsync(bool enabled, int? maxTouchPoints = null)
        {
            ValidateSetTouchEmulationEnabled(enabled, maxTouchPoints);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            if (maxTouchPoints.HasValue)
            {
                dict.Add("maxTouchPoints", maxTouchPoints.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setTouchEmulationEnabled", dict);
        }

        partial void ValidateSetVirtualTimePolicy(CefSharp.DevTools.Emulation.VirtualTimePolicy policy, double? budget = null, int? maxVirtualTimeTaskStarvationCount = null, double? initialVirtualTime = null);
        /// <summary>
        /// Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
        /// the current virtual time policy.  Note this supersedes any previous time budget.
        /// </summary>
        /// <param name = "policy">policy</param>
        /// <param name = "budget">If set, after this many virtual milliseconds have elapsed virtual time will be paused and avirtualTimeBudgetExpired event is sent.</param>
        /// <param name = "maxVirtualTimeTaskStarvationCount">If set this specifies the maximum number of tasks that can be run before virtual is forcedforwards to prevent deadlock.</param>
        /// <param name = "initialVirtualTime">If set, base::Time::Now will be overridden to initially return this value.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetVirtualTimePolicyResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetVirtualTimePolicyResponse> SetVirtualTimePolicyAsync(CefSharp.DevTools.Emulation.VirtualTimePolicy policy, double? budget = null, int? maxVirtualTimeTaskStarvationCount = null, double? initialVirtualTime = null)
        {
            ValidateSetVirtualTimePolicy(policy, budget, maxVirtualTimeTaskStarvationCount, initialVirtualTime);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("policy", EnumToString(policy));
            if (budget.HasValue)
            {
                dict.Add("budget", budget.Value);
            }

            if (maxVirtualTimeTaskStarvationCount.HasValue)
            {
                dict.Add("maxVirtualTimeTaskStarvationCount", maxVirtualTimeTaskStarvationCount.Value);
            }

            if (initialVirtualTime.HasValue)
            {
                dict.Add("initialVirtualTime", initialVirtualTime.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<SetVirtualTimePolicyResponse>("Emulation.setVirtualTimePolicy", dict);
        }

        partial void ValidateSetLocaleOverride(string locale = null);
        /// <summary>
        /// Overrides default host system locale with the specified one.
        /// </summary>
        /// <param name = "locale">ICU style C locale (e.g. "en_US"). If not specified or empty, disables the override andrestores default host system locale.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetLocaleOverrideAsync(string locale = null)
        {
            ValidateSetLocaleOverride(locale);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(locale)))
            {
                dict.Add("locale", locale);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setLocaleOverride", dict);
        }

        partial void ValidateSetTimezoneOverride(string timezoneId);
        /// <summary>
        /// Overrides default host system timezone with the specified one.
        /// </summary>
        /// <param name = "timezoneId">The timezone identifier. If empty, disables the override andrestores default host system timezone.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetTimezoneOverrideAsync(string timezoneId)
        {
            ValidateSetTimezoneOverride(timezoneId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("timezoneId", timezoneId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setTimezoneOverride", dict);
        }

        partial void ValidateSetDisabledImageTypes(CefSharp.DevTools.Emulation.DisabledImageType[] imageTypes);
        /// <summary>
        /// SetDisabledImageTypes
        /// </summary>
        /// <param name = "imageTypes">Image types to disable.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDisabledImageTypesAsync(CefSharp.DevTools.Emulation.DisabledImageType[] imageTypes)
        {
            ValidateSetDisabledImageTypes(imageTypes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("imageTypes", EnumToString(imageTypes));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setDisabledImageTypes", dict);
        }

        partial void ValidateSetHardwareConcurrencyOverride(int hardwareConcurrency);
        /// <summary>
        /// SetHardwareConcurrencyOverride
        /// </summary>
        /// <param name = "hardwareConcurrency">Hardware concurrency to report</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetHardwareConcurrencyOverrideAsync(int hardwareConcurrency)
        {
            ValidateSetHardwareConcurrencyOverride(hardwareConcurrency);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("hardwareConcurrency", hardwareConcurrency);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setHardwareConcurrencyOverride", dict);
        }

        partial void ValidateSetUserAgentOverride(string userAgent, string acceptLanguage = null, string platform = null, CefSharp.DevTools.Emulation.UserAgentMetadata userAgentMetadata = null);
        /// <summary>
        /// Allows overriding user agent with the given string.
        /// </summary>
        /// <param name = "userAgent">User agent to use.</param>
        /// <param name = "acceptLanguage">Browser langugage to emulate.</param>
        /// <param name = "platform">The platform navigator.platform should return.</param>
        /// <param name = "userAgentMetadata">To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetUserAgentOverrideAsync(string userAgent, string acceptLanguage = null, string platform = null, CefSharp.DevTools.Emulation.UserAgentMetadata userAgentMetadata = null)
        {
            ValidateSetUserAgentOverride(userAgent, acceptLanguage, platform, userAgentMetadata);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("userAgent", userAgent);
            if (!(string.IsNullOrEmpty(acceptLanguage)))
            {
                dict.Add("acceptLanguage", acceptLanguage);
            }

            if (!(string.IsNullOrEmpty(platform)))
            {
                dict.Add("platform", platform);
            }

            if ((userAgentMetadata) != (null))
            {
                dict.Add("userAgentMetadata", userAgentMetadata.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setUserAgentOverride", dict);
        }

        partial void ValidateSetAutomationOverride(bool enabled);
        /// <summary>
        /// Allows overriding the automation flag.
        /// </summary>
        /// <param name = "enabled">Whether the override should be enabled.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAutomationOverrideAsync(bool enabled)
        {
            ValidateSetAutomationOverride(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Emulation.setAutomationOverride", dict);
        }
    }
}

namespace CefSharp.DevTools.HeadlessExperimental
{
    /// <summary>
    /// BeginFrameResponse
    /// </summary>
    public class BeginFrameResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// hasDamage
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hasDamage")]
        public bool HasDamage
        {
            get;
            private set;
        }

        /// <summary>
        /// screenshotData
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("screenshotData")]
        public byte[] ScreenshotData
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeadlessExperimental
{
    using System.Linq;

    /// <summary>
    /// This domain provides experimental commands only supported in headless mode.
    /// </summary>
    public partial class HeadlessExperimentalClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// HeadlessExperimental
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public HeadlessExperimentalClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateBeginFrame(double? frameTimeTicks = null, double? interval = null, bool? noDisplayUpdates = null, CefSharp.DevTools.HeadlessExperimental.ScreenshotParams screenshot = null);
        /// <summary>
        /// Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
        /// screenshot from the resulting frame. Requires that the target was created with enabled
        /// BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
        /// https://goo.gle/chrome-headless-rendering for more background.
        /// </summary>
        /// <param name = "frameTimeTicks">Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,the current time will be used.</param>
        /// <param name = "interval">The interval between BeginFrames that is reported to the compositor, in milliseconds.Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.</param>
        /// <param name = "noDisplayUpdates">Whether updates should not be committed and drawn onto the display. False by default. Iftrue, only side effects of the BeginFrame will be run, such as layout and animations, butany visual updates may not be visible on the display or in screenshots.</param>
        /// <param name = "screenshot">If set, a screenshot of the frame will be captured and returned in the response. Otherwise,no screenshot will be captured. Note that capturing a screenshot can fail, for example,during renderer initialization. In such a case, no screenshot data will be returned.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;BeginFrameResponse&gt;</returns>
        public System.Threading.Tasks.Task<BeginFrameResponse> BeginFrameAsync(double? frameTimeTicks = null, double? interval = null, bool? noDisplayUpdates = null, CefSharp.DevTools.HeadlessExperimental.ScreenshotParams screenshot = null)
        {
            ValidateBeginFrame(frameTimeTicks, interval, noDisplayUpdates, screenshot);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (frameTimeTicks.HasValue)
            {
                dict.Add("frameTimeTicks", frameTimeTicks.Value);
            }

            if (interval.HasValue)
            {
                dict.Add("interval", interval.Value);
            }

            if (noDisplayUpdates.HasValue)
            {
                dict.Add("noDisplayUpdates", noDisplayUpdates.Value);
            }

            if ((screenshot) != (null))
            {
                dict.Add("screenshot", screenshot.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<BeginFrameResponse>("HeadlessExperimental.beginFrame", dict);
        }
    }
}

namespace CefSharp.DevTools.IO
{
    /// <summary>
    /// ReadResponse
    /// </summary>
    public class ReadResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// base64Encoded
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("base64Encoded")]
        public bool? Base64Encoded
        {
            get;
            private set;
        }

        /// <summary>
        /// data
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        public string Data
        {
            get;
            private set;
        }

        /// <summary>
        /// eof
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("eof")]
        public bool Eof
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IO
{
    /// <summary>
    /// ResolveBlobResponse
    /// </summary>
    public class ResolveBlobResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// uuid
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("uuid")]
        public string Uuid
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IO
{
    using System.Linq;

    /// <summary>
    /// Input/Output operations for streams produced by DevTools.
    /// </summary>
    public partial class IOClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// IO
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public IOClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateClose(string handle);
        /// <summary>
        /// Close the stream, discard any temporary backing storage.
        /// </summary>
        /// <param name = "handle">Handle of the stream to close.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CloseAsync(string handle)
        {
            ValidateClose(handle);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("handle", handle);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("IO.close", dict);
        }

        partial void ValidateRead(string handle, int? offset = null, int? size = null);
        /// <summary>
        /// Read a chunk of the stream
        /// </summary>
        /// <param name = "handle">Handle of the stream to read.</param>
        /// <param name = "offset">Seek to the specified offset before reading (if not specificed, proceed with offsetfollowing the last read). Some types of streams may only support sequential reads.</param>
        /// <param name = "size">Maximum number of bytes to read (left upon the agent discretion if not specified).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ReadResponse&gt;</returns>
        public System.Threading.Tasks.Task<ReadResponse> ReadAsync(string handle, int? offset = null, int? size = null)
        {
            ValidateRead(handle, offset, size);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("handle", handle);
            if (offset.HasValue)
            {
                dict.Add("offset", offset.Value);
            }

            if (size.HasValue)
            {
                dict.Add("size", size.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<ReadResponse>("IO.read", dict);
        }

        partial void ValidateResolveBlob(string objectId);
        /// <summary>
        /// Return UUID of Blob object specified by a remote object id.
        /// </summary>
        /// <param name = "objectId">Object id of a Blob object wrapper.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ResolveBlobResponse&gt;</returns>
        public System.Threading.Tasks.Task<ResolveBlobResponse> ResolveBlobAsync(string objectId)
        {
            ValidateResolveBlob(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            return _client.ExecuteDevToolsMethodAsync<ResolveBlobResponse>("IO.resolveBlob", dict);
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// RequestDataResponse
    /// </summary>
    public class RequestDataResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// objectStoreDataEntries
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("objectStoreDataEntries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.IndexedDB.DataEntry> ObjectStoreDataEntries
        {
            get;
            private set;
        }

        /// <summary>
        /// hasMore
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("hasMore")]
        public bool HasMore
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// GetMetadataResponse
    /// </summary>
    public class GetMetadataResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// entriesCount
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("entriesCount")]
        public double EntriesCount
        {
            get;
            private set;
        }

        /// <summary>
        /// keyGeneratorValue
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("keyGeneratorValue")]
        public double KeyGeneratorValue
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// RequestDatabaseResponse
    /// </summary>
    public class RequestDatabaseResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// databaseWithObjectStores
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("databaseWithObjectStores")]
        public CefSharp.DevTools.IndexedDB.DatabaseWithObjectStores DatabaseWithObjectStores
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    /// <summary>
    /// RequestDatabaseNamesResponse
    /// </summary>
    public class RequestDatabaseNamesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// databaseNames
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("databaseNames")]
        public string[] DatabaseNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.IndexedDB
{
    using System.Linq;

    /// <summary>
    /// IndexedDB
    /// </summary>
    public partial class IndexedDBClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// IndexedDB
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public IndexedDBClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        partial void ValidateClearObjectStore(string databaseName, string objectStoreName, string securityOrigin = null, string storageKey = null);
        /// <summary>
        /// Clears all entries from an object store.
        /// </summary>
        /// <param name = "databaseName">Database name.</param>
        /// <param name = "objectStoreName">Object store name.</param>
        /// <param name = "securityOrigin">At least and at most one of securityOrigin, storageKey must be specified.Security origin.</param>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearObjectStoreAsync(string databaseName, string objectStoreName, string securityOrigin = null, string storageKey = null)
        {
            ValidateClearObjectStore(databaseName, objectStoreName, securityOrigin, storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseName", databaseName);
            dict.Add("objectStoreName", objectStoreName);
            if (!(string.IsNullOrEmpty(securityOrigin)))
            {
                dict.Add("securityOrigin", securityOrigin);
            }

            if (!(string.IsNullOrEmpty(storageKey)))
            {
                dict.Add("storageKey", storageKey);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("IndexedDB.clearObjectStore", dict);
        }

        partial void ValidateDeleteDatabase(string databaseName, string securityOrigin = null, string storageKey = null);
        /// <summary>
        /// Deletes a database.
        /// </summary>
        /// <param name = "databaseName">Database name.</param>
        /// <param name = "securityOrigin">At least and at most one of securityOrigin, storageKey must be specified.Security origin.</param>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteDatabaseAsync(string databaseName, string securityOrigin = null, string storageKey = null)
        {
            ValidateDeleteDatabase(databaseName, securityOrigin, storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseName", databaseName);
            if (!(string.IsNullOrEmpty(securityOrigin)))
            {
                dict.Add("securityOrigin", securityOrigin);
            }

            if (!(string.IsNullOrEmpty(storageKey)))
            {
                dict.Add("storageKey", storageKey);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("IndexedDB.deleteDatabase", dict);
        }

        partial void ValidateDeleteObjectStoreEntries(string databaseName, string objectStoreName, CefSharp.DevTools.IndexedDB.KeyRange keyRange, string securityOrigin = null, string storageKey = null);
        /// <summary>
        /// Delete a range of entries from an object store
        /// </summary>
        /// <param name = "databaseName">databaseName</param>
        /// <param name = "objectStoreName">objectStoreName</param>
        /// <param name = "keyRange">Range of entry keys to delete</param>
        /// <param name = "securityOrigin">At least and at most one of securityOrigin, storageKey must be specified.Security origin.</param>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteObjectStoreEntriesAsync(string databaseName, string objectStoreName, CefSharp.DevTools.IndexedDB.KeyRange keyRange, string securityOrigin = null, string storageKey = null)
        {
            ValidateDeleteObjectStoreEntries(databaseName, objectStoreName, keyRange, securityOrigin, storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseName", databaseName);
            dict.Add("objectStoreName", objectStoreName);
            dict.Add("keyRange", keyRange.ToDictionary());
            if (!(string.IsNullOrEmpty(securityOrigin)))
            {
                dict.Add("securityOrigin", securityOrigin);
            }

            if (!(string.IsNullOrEmpty(storageKey)))
            {
                dict.Add("storageKey", storageKey);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("IndexedDB.deleteObjectStoreEntries", dict);
        }

        /// <summary>
        /// Disables events from backend.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("IndexedDB.disable", dict);
        }

        /// <summary>
        /// Enables events from backend.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("IndexedDB.enable", dict);
        }

        partial void ValidateRequestData(string databaseName, string objectStoreName, string indexName, int skipCount, int pageSize, string securityOrigin = null, string storageKey = null, CefSharp.DevTools.IndexedDB.KeyRange keyRange = null);
        /// <summary>
        /// Requests data from object store or index.
        /// </summary>
        /// <param name = "databaseName">Database name.</param>
        /// <param name = "objectStoreName">Object store name.</param>
        /// <param name = "indexName">Index name, empty string for object store data requests.</param>
        /// <param name = "skipCount">Number of records to skip.</param>
        /// <param name = "pageSize">Number of records to fetch.</param>
        /// <param name = "securityOrigin">At least and at most one of securityOrigin, storageKey must be specified.Security origin.</param>
        /// <param name = "storageKey">Storage key.</param>
        /// <param name = "keyRange">Key range.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestDataResponse&gt;</returns>
        public System.Threading.Tasks.Task<RequestDataResponse> RequestDataAsync(string databaseName, string objectStoreName, string indexName, int skipCount, int pageSize, string securityOrigin = null, string storageKey = null, CefSharp.DevTools.IndexedDB.KeyRange keyRange = null)
        {
            ValidateRequestData(databaseName, objectStoreName, indexName, skipCount, pageSize, securityOrigin, storageKey, keyRange);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseName", databaseName);
            dict.Add("objectStoreName", objectStoreName);
            dict.Add("indexName", indexName);
            dict.Add("skipCount", skipCount);
            dict.Add("pageSize", pageSize);
            if (!(string.IsNullOrEmpty(securityOrigin)))
            {
                dict.Add("securityOrigin", securityOrigin);
            }

            if (!(string.IsNullOrEmpty(storageKey)))
            {
                dict.Add("storageKey", storageKey);
            }

            if ((keyRange) != (null))
            {
                dict.Add("keyRange", keyRange.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<RequestDataResponse>("IndexedDB.requestData", dict);
        }

        partial void ValidateGetMetadata(string databaseName, string objectStoreName, string securityOrigin = null, string storageKey = null);
        /// <summary>
        /// Gets metadata of an object store.
        /// </summary>
        /// <param name = "databaseName">Database name.</param>
        /// <param name = "objectStoreName">Object store name.</param>
        /// <param name = "securityOrigin">At least and at most one of securityOrigin, storageKey must be specified.Security origin.</param>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetMetadataResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetMetadataResponse> GetMetadataAsync(string databaseName, string objectStoreName, string securityOrigin = null, string storageKey = null)
        {
            ValidateGetMetadata(databaseName, objectStoreName, securityOrigin, storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseName", databaseName);
            dict.Add("objectStoreName", objectStoreName);
            if (!(string.IsNullOrEmpty(securityOrigin)))
            {
                dict.Add("securityOrigin", securityOrigin);
            }

            if (!(string.IsNullOrEmpty(storageKey)))
            {
                dict.Add("storageKey", storageKey);
            }

            return _client.ExecuteDevToolsMethodAsync<GetMetadataResponse>("IndexedDB.getMetadata", dict);
        }

        partial void ValidateRequestDatabase(string databaseName, string securityOrigin = null, string storageKey = null);
        /// <summary>
        /// Requests database with given name in given frame.
        /// </summary>
        /// <param name = "databaseName">Database name.</param>
        /// <param name = "securityOrigin">At least and at most one of securityOrigin, storageKey must be specified.Security origin.</param>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestDatabaseResponse&gt;</returns>
        public System.Threading.Tasks.Task<RequestDatabaseResponse> RequestDatabaseAsync(string databaseName, string securityOrigin = null, string storageKey = null)
        {
            ValidateRequestDatabase(databaseName, securityOrigin, storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("databaseName", databaseName);
            if (!(string.IsNullOrEmpty(securityOrigin)))
            {
                dict.Add("securityOrigin", securityOrigin);
            }

            if (!(string.IsNullOrEmpty(storageKey)))
            {
                dict.Add("storageKey", storageKey);
            }

            return _client.ExecuteDevToolsMethodAsync<RequestDatabaseResponse>("IndexedDB.requestDatabase", dict);
        }

        partial void ValidateRequestDatabaseNames(string securityOrigin = null, string storageKey = null);
        /// <summary>
        /// Requests database names for given security origin.
        /// </summary>
        /// <param name = "securityOrigin">At least and at most one of securityOrigin, storageKey must be specified.Security origin.</param>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestDatabaseNamesResponse&gt;</returns>
        public System.Threading.Tasks.Task<RequestDatabaseNamesResponse> RequestDatabaseNamesAsync(string securityOrigin = null, string storageKey = null)
        {
            ValidateRequestDatabaseNames(securityOrigin, storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(securityOrigin)))
            {
                dict.Add("securityOrigin", securityOrigin);
            }

            if (!(string.IsNullOrEmpty(storageKey)))
            {
                dict.Add("storageKey", storageKey);
            }

            return _client.ExecuteDevToolsMethodAsync<RequestDatabaseNamesResponse>("IndexedDB.requestDatabaseNames", dict);
        }
    }
}

namespace CefSharp.DevTools.Input
{
    using System.Linq;

    /// <summary>
    /// Type of the drag event.
    /// </summary>
    public enum DispatchDragEventType
    {
        /// <summary>
        /// dragEnter
        /// </summary>
        [JsonPropertyName("dragEnter")]
        DragEnter,
        /// <summary>
        /// dragOver
        /// </summary>
        [JsonPropertyName("dragOver")]
        DragOver,
        /// <summary>
        /// drop
        /// </summary>
        [JsonPropertyName("drop")]
        Drop,
        /// <summary>
        /// dragCancel
        /// </summary>
        [JsonPropertyName("dragCancel")]
        DragCancel
    }

    /// <summary>
    /// Type of the key event.
    /// </summary>
    public enum DispatchKeyEventType
    {
        /// <summary>
        /// keyDown
        /// </summary>
        [JsonPropertyName("keyDown")]
        KeyDown,
        /// <summary>
        /// keyUp
        /// </summary>
        [JsonPropertyName("keyUp")]
        KeyUp,
        /// <summary>
        /// rawKeyDown
        /// </summary>
        [JsonPropertyName("rawKeyDown")]
        RawKeyDown,
        /// <summary>
        /// char
        /// </summary>
        [JsonPropertyName("char")]
        Char
    }

    /// <summary>
    /// Type of the mouse event.
    /// </summary>
    public enum DispatchMouseEventType
    {
        /// <summary>
        /// mousePressed
        /// </summary>
        [JsonPropertyName("mousePressed")]
        MousePressed,
        /// <summary>
        /// mouseReleased
        /// </summary>
        [JsonPropertyName("mouseReleased")]
        MouseReleased,
        /// <summary>
        /// mouseMoved
        /// </summary>
        [JsonPropertyName("mouseMoved")]
        MouseMoved,
        /// <summary>
        /// mouseWheel
        /// </summary>
        [JsonPropertyName("mouseWheel")]
        MouseWheel
    }

    /// <summary>
    /// Pointer type (default: &quot;mouse&quot;).
    /// </summary>
    public enum DispatchMouseEventPointerType
    {
        /// <summary>
        /// mouse
        /// </summary>
        [JsonPropertyName("mouse")]
        Mouse,
        /// <summary>
        /// pen
        /// </summary>
        [JsonPropertyName("pen")]
        Pen
    }

    /// <summary>
    /// Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
    /// TouchStart and TouchMove must contains at least one.
    /// </summary>
    public enum DispatchTouchEventType
    {
        /// <summary>
        /// touchStart
        /// </summary>
        [JsonPropertyName("touchStart")]
        TouchStart,
        /// <summary>
        /// touchEnd
        /// </summary>
        [JsonPropertyName("touchEnd")]
        TouchEnd,
        /// <summary>
        /// touchMove
        /// </summary>
        [JsonPropertyName("touchMove")]
        TouchMove,
        /// <summary>
        /// touchCancel
        /// </summary>
        [JsonPropertyName("touchCancel")]
        TouchCancel
    }

    /// <summary>
    /// Type of the mouse event.
    /// </summary>
    public enum EmulateTouchFromMouseEventType
    {
        /// <summary>
        /// mousePressed
        /// </summary>
        [JsonPropertyName("mousePressed")]
        MousePressed,
        /// <summary>
        /// mouseReleased
        /// </summary>
        [JsonPropertyName("mouseReleased")]
        MouseReleased,
        /// <summary>
        /// mouseMoved
        /// </summary>
        [JsonPropertyName("mouseMoved")]
        MouseMoved,
        /// <summary>
        /// mouseWheel
        /// </summary>
        [JsonPropertyName("mouseWheel")]
        MouseWheel
    }

    /// <summary>
    /// Input
    /// </summary>
    public partial class InputClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Input
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public InputClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
        /// restore normal drag and drop behavior.
        /// </summary>
        public event System.EventHandler<DragInterceptedEventArgs> DragIntercepted
        {
            add
            {
                _client.AddEventHandler<DragInterceptedEventArgs>("Input.dragIntercepted", value);
            }

            remove
            {
                _client.RemoveEventHandler<DragInterceptedEventArgs>("Input.dragIntercepted", value);
            }
        }

        partial void ValidateDispatchDragEvent(CefSharp.DevTools.Input.DispatchDragEventType type, double x, double y, CefSharp.DevTools.Input.DragData data, int? modifiers = null);
        /// <summary>
        /// Dispatches a drag event into the page.
        /// </summary>
        /// <param name = "type">Type of the drag event.</param>
        /// <param name = "x">X coordinate of the event relative to the main frame's viewport in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers tothe top of the viewport and Y increases as it proceeds towards the bottom of the viewport.</param>
        /// <param name = "data">data</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchDragEventAsync(CefSharp.DevTools.Input.DispatchDragEventType type, double x, double y, CefSharp.DevTools.Input.DragData data, int? modifiers = null)
        {
            ValidateDispatchDragEvent(type, x, y, data, modifiers);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", EnumToString(type));
            dict.Add("x", x);
            dict.Add("y", y);
            dict.Add("data", data.ToDictionary());
            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.dispatchDragEvent", dict);
        }

        partial void ValidateDispatchKeyEvent(CefSharp.DevTools.Input.DispatchKeyEventType type, int? modifiers = null, double? timestamp = null, string text = null, string unmodifiedText = null, string keyIdentifier = null, string code = null, string key = null, int? windowsVirtualKeyCode = null, int? nativeVirtualKeyCode = null, bool? autoRepeat = null, bool? isKeypad = null, bool? isSystemKey = null, int? location = null, string[] commands = null);
        /// <summary>
        /// Dispatches a key event to the page.
        /// </summary>
        /// <param name = "type">Type of the key event.</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <param name = "timestamp">Time at which the event occurred.</param>
        /// <param name = "text">Text as generated by processing a virtual key code with a keyboard layout. Not needed forfor `keyUp` and `rawKeyDown` events (default: "")</param>
        /// <param name = "unmodifiedText">Text that would have been generated by the keyboard if no modifiers were pressed (except forshift). Useful for shortcut (accelerator) key handling (default: "").</param>
        /// <param name = "keyIdentifier">Unique key identifier (e.g., 'U+0041') (default: "").</param>
        /// <param name = "code">Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").</param>
        /// <param name = "key">Unique DOM defined string value describing the meaning of the key in the context of activemodifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").</param>
        /// <param name = "windowsVirtualKeyCode">Windows virtual key code (default: 0).</param>
        /// <param name = "nativeVirtualKeyCode">Native virtual key code (default: 0).</param>
        /// <param name = "autoRepeat">Whether the event was generated from auto repeat (default: false).</param>
        /// <param name = "isKeypad">Whether the event was generated from the keypad (default: false).</param>
        /// <param name = "isSystemKey">Whether the event was a system key event (default: false).</param>
        /// <param name = "location">Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:0).</param>
        /// <param name = "commands">Editing commands to send with the key event (e.g., 'selectAll') (default: []).These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchKeyEventAsync(CefSharp.DevTools.Input.DispatchKeyEventType type, int? modifiers = null, double? timestamp = null, string text = null, string unmodifiedText = null, string keyIdentifier = null, string code = null, string key = null, int? windowsVirtualKeyCode = null, int? nativeVirtualKeyCode = null, bool? autoRepeat = null, bool? isKeypad = null, bool? isSystemKey = null, int? location = null, string[] commands = null)
        {
            ValidateDispatchKeyEvent(type, modifiers, timestamp, text, unmodifiedText, keyIdentifier, code, key, windowsVirtualKeyCode, nativeVirtualKeyCode, autoRepeat, isKeypad, isSystemKey, location, commands);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", EnumToString(type));
            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            if (timestamp.HasValue)
            {
                dict.Add("timestamp", timestamp.Value);
            }

            if (!(string.IsNullOrEmpty(text)))
            {
                dict.Add("text", text);
            }

            if (!(string.IsNullOrEmpty(unmodifiedText)))
            {
                dict.Add("unmodifiedText", unmodifiedText);
            }

            if (!(string.IsNullOrEmpty(keyIdentifier)))
            {
                dict.Add("keyIdentifier", keyIdentifier);
            }

            if (!(string.IsNullOrEmpty(code)))
            {
                dict.Add("code", code);
            }

            if (!(string.IsNullOrEmpty(key)))
            {
                dict.Add("key", key);
            }

            if (windowsVirtualKeyCode.HasValue)
            {
                dict.Add("windowsVirtualKeyCode", windowsVirtualKeyCode.Value);
            }

            if (nativeVirtualKeyCode.HasValue)
            {
                dict.Add("nativeVirtualKeyCode", nativeVirtualKeyCode.Value);
            }

            if (autoRepeat.HasValue)
            {
                dict.Add("autoRepeat", autoRepeat.Value);
            }

            if (isKeypad.HasValue)
            {
                dict.Add("isKeypad", isKeypad.Value);
            }

            if (isSystemKey.HasValue)
            {
                dict.Add("isSystemKey", isSystemKey.Value);
            }

            if (location.HasValue)
            {
                dict.Add("location", location.Value);
            }

            if ((commands) != (null))
            {
                dict.Add("commands", commands);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.dispatchKeyEvent", dict);
        }

        partial void ValidateInsertText(string text);
        /// <summary>
        /// This method emulates inserting text that doesn&apos;t come from a key press,
        /// for example an emoji keyboard or an IME.
        /// </summary>
        /// <param name = "text">The text to insert.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> InsertTextAsync(string text)
        {
            ValidateInsertText(text);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("text", text);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.insertText", dict);
        }

        partial void ValidateImeSetComposition(string text, int selectionStart, int selectionEnd, int? replacementStart = null, int? replacementEnd = null);
        /// <summary>
        /// This method sets the current candidate text for ime.
        /// Use imeCommitComposition to commit the final text.
        /// Use imeSetComposition with empty string as text to cancel composition.
        /// </summary>
        /// <param name = "text">The text to insert</param>
        /// <param name = "selectionStart">selection start</param>
        /// <param name = "selectionEnd">selection end</param>
        /// <param name = "replacementStart">replacement start</param>
        /// <param name = "replacementEnd">replacement end</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ImeSetCompositionAsync(string text, int selectionStart, int selectionEnd, int? replacementStart = null, int? replacementEnd = null)
        {
            ValidateImeSetComposition(text, selectionStart, selectionEnd, replacementStart, replacementEnd);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("text", text);
            dict.Add("selectionStart", selectionStart);
            dict.Add("selectionEnd", selectionEnd);
            if (replacementStart.HasValue)
            {
                dict.Add("replacementStart", replacementStart.Value);
            }

            if (replacementEnd.HasValue)
            {
                dict.Add("replacementEnd", replacementEnd.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.imeSetComposition", dict);
        }

        partial void ValidateDispatchMouseEvent(CefSharp.DevTools.Input.DispatchMouseEventType type, double x, double y, int? modifiers = null, double? timestamp = null, CefSharp.DevTools.Input.MouseButton? button = null, int? buttons = null, int? clickCount = null, double? force = null, double? tangentialPressure = null, int? tiltX = null, int? tiltY = null, int? twist = null, double? deltaX = null, double? deltaY = null, CefSharp.DevTools.Input.DispatchMouseEventPointerType? pointerType = null);
        /// <summary>
        /// Dispatches a mouse event to the page.
        /// </summary>
        /// <param name = "type">Type of the mouse event.</param>
        /// <param name = "x">X coordinate of the event relative to the main frame's viewport in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers tothe top of the viewport and Y increases as it proceeds towards the bottom of the viewport.</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <param name = "timestamp">Time at which the event occurred.</param>
        /// <param name = "button">Mouse button (default: "none").</param>
        /// <param name = "buttons">A number indicating which buttons are pressed on the mouse when a mouse event is triggered.Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.</param>
        /// <param name = "clickCount">Number of times the mouse button was clicked (default: 0).</param>
        /// <param name = "force">The normalized pressure, which has a range of [0,1] (default: 0).</param>
        /// <param name = "tangentialPressure">The normalized tangential pressure, which has a range of [-1,1] (default: 0).</param>
        /// <param name = "tiltX">The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).</param>
        /// <param name = "tiltY">The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).</param>
        /// <param name = "twist">The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).</param>
        /// <param name = "deltaX">X delta in CSS pixels for mouse wheel event (default: 0).</param>
        /// <param name = "deltaY">Y delta in CSS pixels for mouse wheel event (default: 0).</param>
        /// <param name = "pointerType">Pointer type (default: "mouse").</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchMouseEventAsync(CefSharp.DevTools.Input.DispatchMouseEventType type, double x, double y, int? modifiers = null, double? timestamp = null, CefSharp.DevTools.Input.MouseButton? button = null, int? buttons = null, int? clickCount = null, double? force = null, double? tangentialPressure = null, int? tiltX = null, int? tiltY = null, int? twist = null, double? deltaX = null, double? deltaY = null, CefSharp.DevTools.Input.DispatchMouseEventPointerType? pointerType = null)
        {
            ValidateDispatchMouseEvent(type, x, y, modifiers, timestamp, button, buttons, clickCount, force, tangentialPressure, tiltX, tiltY, twist, deltaX, deltaY, pointerType);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", EnumToString(type));
            dict.Add("x", x);
            dict.Add("y", y);
            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            if (timestamp.HasValue)
            {
                dict.Add("timestamp", timestamp.Value);
            }

            if (button.HasValue)
            {
                dict.Add("button", EnumToString(button));
            }

            if (buttons.HasValue)
            {
                dict.Add("buttons", buttons.Value);
            }

            if (clickCount.HasValue)
            {
                dict.Add("clickCount", clickCount.Value);
            }

            if (force.HasValue)
            {
                dict.Add("force", force.Value);
            }

            if (tangentialPressure.HasValue)
            {
                dict.Add("tangentialPressure", tangentialPressure.Value);
            }

            if (tiltX.HasValue)
            {
                dict.Add("tiltX", tiltX.Value);
            }

            if (tiltY.HasValue)
            {
                dict.Add("tiltY", tiltY.Value);
            }

            if (twist.HasValue)
            {
                dict.Add("twist", twist.Value);
            }

            if (deltaX.HasValue)
            {
                dict.Add("deltaX", deltaX.Value);
            }

            if (deltaY.HasValue)
            {
                dict.Add("deltaY", deltaY.Value);
            }

            if (pointerType.HasValue)
            {
                dict.Add("pointerType", EnumToString(pointerType));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.dispatchMouseEvent", dict);
        }

        partial void ValidateDispatchTouchEvent(CefSharp.DevTools.Input.DispatchTouchEventType type, System.Collections.Generic.IList<CefSharp.DevTools.Input.TouchPoint> touchPoints, int? modifiers = null, double? timestamp = null);
        /// <summary>
        /// Dispatches a touch event to the page.
        /// </summary>
        /// <param name = "type">Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, whileTouchStart and TouchMove must contains at least one.</param>
        /// <param name = "touchPoints">Active touch points on the touch device. One event per any changed point (compared toprevious touch event in a sequence) is generated, emulating pressing/moving/releasing pointsone by one.</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <param name = "timestamp">Time at which the event occurred.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchTouchEventAsync(CefSharp.DevTools.Input.DispatchTouchEventType type, System.Collections.Generic.IList<CefSharp.DevTools.Input.TouchPoint> touchPoints, int? modifiers = null, double? timestamp = null)
        {
            ValidateDispatchTouchEvent(type, touchPoints, modifiers, timestamp);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", EnumToString(type));
            dict.Add("touchPoints", touchPoints.Select(x => x.ToDictionary()));
            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            if (timestamp.HasValue)
            {
                dict.Add("timestamp", timestamp.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.dispatchTouchEvent", dict);
        }

        partial void ValidateEmulateTouchFromMouseEvent(CefSharp.DevTools.Input.EmulateTouchFromMouseEventType type, int x, int y, CefSharp.DevTools.Input.MouseButton button, double? timestamp = null, double? deltaX = null, double? deltaY = null, int? modifiers = null, int? clickCount = null);
        /// <summary>
        /// Emulates touch event from the mouse event parameters.
        /// </summary>
        /// <param name = "type">Type of the mouse event.</param>
        /// <param name = "x">X coordinate of the mouse pointer in DIP.</param>
        /// <param name = "y">Y coordinate of the mouse pointer in DIP.</param>
        /// <param name = "button">Mouse button. Only "none", "left", "right" are supported.</param>
        /// <param name = "timestamp">Time at which the event occurred (default: current time).</param>
        /// <param name = "deltaX">X delta in DIP for mouse wheel event (default: 0).</param>
        /// <param name = "deltaY">Y delta in DIP for mouse wheel event (default: 0).</param>
        /// <param name = "modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8(default: 0).</param>
        /// <param name = "clickCount">Number of times the mouse button was clicked (default: 0).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EmulateTouchFromMouseEventAsync(CefSharp.DevTools.Input.EmulateTouchFromMouseEventType type, int x, int y, CefSharp.DevTools.Input.MouseButton button, double? timestamp = null, double? deltaX = null, double? deltaY = null, int? modifiers = null, int? clickCount = null)
        {
            ValidateEmulateTouchFromMouseEvent(type, x, y, button, timestamp, deltaX, deltaY, modifiers, clickCount);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("type", EnumToString(type));
            dict.Add("x", x);
            dict.Add("y", y);
            dict.Add("button", EnumToString(button));
            if (timestamp.HasValue)
            {
                dict.Add("timestamp", timestamp.Value);
            }

            if (deltaX.HasValue)
            {
                dict.Add("deltaX", deltaX.Value);
            }

            if (deltaY.HasValue)
            {
                dict.Add("deltaY", deltaY.Value);
            }

            if (modifiers.HasValue)
            {
                dict.Add("modifiers", modifiers.Value);
            }

            if (clickCount.HasValue)
            {
                dict.Add("clickCount", clickCount.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.emulateTouchFromMouseEvent", dict);
        }

        partial void ValidateSetIgnoreInputEvents(bool ignore);
        /// <summary>
        /// Ignores input events (useful while auditing page).
        /// </summary>
        /// <param name = "ignore">Ignores input events processing when set to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetIgnoreInputEventsAsync(bool ignore)
        {
            ValidateSetIgnoreInputEvents(ignore);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ignore", ignore);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.setIgnoreInputEvents", dict);
        }

        partial void ValidateSetInterceptDrags(bool enabled);
        /// <summary>
        /// Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
        /// Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
        /// </summary>
        /// <param name = "enabled">enabled</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetInterceptDragsAsync(bool enabled)
        {
            ValidateSetInterceptDrags(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.setInterceptDrags", dict);
        }

        partial void ValidateSynthesizePinchGesture(double x, double y, double scaleFactor, int? relativeSpeed = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null);
        /// <summary>
        /// Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
        /// </summary>
        /// <param name = "x">X coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "scaleFactor">Relative scale factor after zooming (&gt;1.0 zooms in, &lt;1.0 zooms out).</param>
        /// <param name = "relativeSpeed">Relative pointer speed in pixels per second (default: 800).</param>
        /// <param name = "gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platformfor the preferred input type).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SynthesizePinchGestureAsync(double x, double y, double scaleFactor, int? relativeSpeed = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null)
        {
            ValidateSynthesizePinchGesture(x, y, scaleFactor, relativeSpeed, gestureSourceType);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            dict.Add("scaleFactor", scaleFactor);
            if (relativeSpeed.HasValue)
            {
                dict.Add("relativeSpeed", relativeSpeed.Value);
            }

            if (gestureSourceType.HasValue)
            {
                dict.Add("gestureSourceType", EnumToString(gestureSourceType));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.synthesizePinchGesture", dict);
        }

        partial void ValidateSynthesizeScrollGesture(double x, double y, double? xDistance = null, double? yDistance = null, double? xOverscroll = null, double? yOverscroll = null, bool? preventFling = null, int? speed = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null, int? repeatCount = null, int? repeatDelayMs = null, string interactionMarkerName = null);
        /// <summary>
        /// Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
        /// </summary>
        /// <param name = "x">X coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "xDistance">The distance to scroll along the X axis (positive to scroll left).</param>
        /// <param name = "yDistance">The distance to scroll along the Y axis (positive to scroll up).</param>
        /// <param name = "xOverscroll">The number of additional pixels to scroll back along the X axis, in addition to the givendistance.</param>
        /// <param name = "yOverscroll">The number of additional pixels to scroll back along the Y axis, in addition to the givendistance.</param>
        /// <param name = "preventFling">Prevent fling (default: true).</param>
        /// <param name = "speed">Swipe speed in pixels per second (default: 800).</param>
        /// <param name = "gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platformfor the preferred input type).</param>
        /// <param name = "repeatCount">The number of times to repeat the gesture (default: 0).</param>
        /// <param name = "repeatDelayMs">The number of milliseconds delay between each repeat. (default: 250).</param>
        /// <param name = "interactionMarkerName">The name of the interaction markers to generate, if not empty (default: "").</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SynthesizeScrollGestureAsync(double x, double y, double? xDistance = null, double? yDistance = null, double? xOverscroll = null, double? yOverscroll = null, bool? preventFling = null, int? speed = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null, int? repeatCount = null, int? repeatDelayMs = null, string interactionMarkerName = null)
        {
            ValidateSynthesizeScrollGesture(x, y, xDistance, yDistance, xOverscroll, yOverscroll, preventFling, speed, gestureSourceType, repeatCount, repeatDelayMs, interactionMarkerName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            if (xDistance.HasValue)
            {
                dict.Add("xDistance", xDistance.Value);
            }

            if (yDistance.HasValue)
            {
                dict.Add("yDistance", yDistance.Value);
            }

            if (xOverscroll.HasValue)
            {
                dict.Add("xOverscroll", xOverscroll.Value);
            }

            if (yOverscroll.HasValue)
            {
                dict.Add("yOverscroll", yOverscroll.Value);
            }

            if (preventFling.HasValue)
            {
                dict.Add("preventFling", preventFling.Value);
            }

            if (speed.HasValue)
            {
                dict.Add("speed", speed.Value);
            }

            if (gestureSourceType.HasValue)
            {
                dict.Add("gestureSourceType", EnumToString(gestureSourceType));
            }

            if (repeatCount.HasValue)
            {
                dict.Add("repeatCount", repeatCount.Value);
            }

            if (repeatDelayMs.HasValue)
            {
                dict.Add("repeatDelayMs", repeatDelayMs.Value);
            }

            if (!(string.IsNullOrEmpty(interactionMarkerName)))
            {
                dict.Add("interactionMarkerName", interactionMarkerName);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.synthesizeScrollGesture", dict);
        }

        partial void ValidateSynthesizeTapGesture(double x, double y, int? duration = null, int? tapCount = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null);
        /// <summary>
        /// Synthesizes a tap gesture over a time period by issuing appropriate touch events.
        /// </summary>
        /// <param name = "x">X coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "y">Y coordinate of the start of the gesture in CSS pixels.</param>
        /// <param name = "duration">Duration between touchdown and touchup events in ms (default: 50).</param>
        /// <param name = "tapCount">Number of times to perform the tap (e.g. 2 for double tap, default: 1).</param>
        /// <param name = "gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platformfor the preferred input type).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SynthesizeTapGestureAsync(double x, double y, int? duration = null, int? tapCount = null, CefSharp.DevTools.Input.GestureSourceType? gestureSourceType = null)
        {
            ValidateSynthesizeTapGesture(x, y, duration, tapCount, gestureSourceType);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            if (duration.HasValue)
            {
                dict.Add("duration", duration.Value);
            }

            if (tapCount.HasValue)
            {
                dict.Add("tapCount", tapCount.Value);
            }

            if (gestureSourceType.HasValue)
            {
                dict.Add("gestureSourceType", EnumToString(gestureSourceType));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Input.synthesizeTapGesture", dict);
        }
    }
}

namespace CefSharp.DevTools.Inspector
{
    using System.Linq;

    /// <summary>
    /// Inspector
    /// </summary>
    public partial class InspectorClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Inspector
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public InspectorClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Fired when remote debugging connection is about to be terminated. Contains detach reason.
        /// </summary>
        public event System.EventHandler<DetachedEventArgs> Detached
        {
            add
            {
                _client.AddEventHandler<DetachedEventArgs>("Inspector.detached", value);
            }

            remove
            {
                _client.RemoveEventHandler<DetachedEventArgs>("Inspector.detached", value);
            }
        }

        /// <summary>
        /// Fired when debugging target has crashed
        /// </summary>
        public event System.EventHandler<System.EventArgs> TargetCrashed
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Inspector.targetCrashed", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Inspector.targetCrashed", value);
            }
        }

        /// <summary>
        /// Fired when debugging target has reloaded after crash
        /// </summary>
        public event System.EventHandler<System.EventArgs> TargetReloadedAfterCrash
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Inspector.targetReloadedAfterCrash", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Inspector.targetReloadedAfterCrash", value);
            }
        }

        /// <summary>
        /// Disables inspector domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Inspector.disable", dict);
        }

        /// <summary>
        /// Enables inspector domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Inspector.enable", dict);
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// CompositingReasonsResponse
    /// </summary>
    public class CompositingReasonsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// compositingReasons
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("compositingReasons")]
        public string[] CompositingReasons
        {
            get;
            private set;
        }

        /// <summary>
        /// compositingReasonIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("compositingReasonIds")]
        public string[] CompositingReasonIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// LoadSnapshotResponse
    /// </summary>
    public class LoadSnapshotResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// snapshotId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("snapshotId")]
        public string SnapshotId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// MakeSnapshotResponse
    /// </summary>
    public class MakeSnapshotResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// snapshotId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("snapshotId")]
        public string SnapshotId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// ProfileSnapshotResponse
    /// </summary>
    public class ProfileSnapshotResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// timings
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timings")]
        public double[] Timings
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// ReplaySnapshotResponse
    /// </summary>
    public class ReplaySnapshotResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// dataURL
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("dataURL")]
        public string DataURL
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    /// <summary>
    /// SnapshotCommandLogResponse
    /// </summary>
    public class SnapshotCommandLogResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// commandLog
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("commandLog")]
        public System.Collections.Generic.IList<object> CommandLog
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.LayerTree
{
    using System.Linq;

    /// <summary>
    /// LayerTree
    /// </summary>
    public partial class LayerTreeClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// LayerTree
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public LayerTreeClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// LayerPainted
        /// </summary>
        public event System.EventHandler<LayerPaintedEventArgs> LayerPainted
        {
            add
            {
                _client.AddEventHandler<LayerPaintedEventArgs>("LayerTree.layerPainted", value);
            }

            remove
            {
                _client.RemoveEventHandler<LayerPaintedEventArgs>("LayerTree.layerPainted", value);
            }
        }

        /// <summary>
        /// LayerTreeDidChange
        /// </summary>
        public event System.EventHandler<LayerTreeDidChangeEventArgs> LayerTreeDidChange
        {
            add
            {
                _client.AddEventHandler<LayerTreeDidChangeEventArgs>("LayerTree.layerTreeDidChange", value);
            }

            remove
            {
                _client.RemoveEventHandler<LayerTreeDidChangeEventArgs>("LayerTree.layerTreeDidChange", value);
            }
        }

        partial void ValidateCompositingReasons(string layerId);
        /// <summary>
        /// Provides the reasons why the given layer was composited.
        /// </summary>
        /// <param name = "layerId">The id of the layer for which we want to get the reasons it was composited.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CompositingReasonsResponse&gt;</returns>
        public System.Threading.Tasks.Task<CompositingReasonsResponse> CompositingReasonsAsync(string layerId)
        {
            ValidateCompositingReasons(layerId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("layerId", layerId);
            return _client.ExecuteDevToolsMethodAsync<CompositingReasonsResponse>("LayerTree.compositingReasons", dict);
        }

        /// <summary>
        /// Disables compositing tree inspection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("LayerTree.disable", dict);
        }

        /// <summary>
        /// Enables compositing tree inspection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("LayerTree.enable", dict);
        }

        partial void ValidateLoadSnapshot(System.Collections.Generic.IList<CefSharp.DevTools.LayerTree.PictureTile> tiles);
        /// <summary>
        /// Returns the snapshot identifier.
        /// </summary>
        /// <param name = "tiles">An array of tiles composing the snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;LoadSnapshotResponse&gt;</returns>
        public System.Threading.Tasks.Task<LoadSnapshotResponse> LoadSnapshotAsync(System.Collections.Generic.IList<CefSharp.DevTools.LayerTree.PictureTile> tiles)
        {
            ValidateLoadSnapshot(tiles);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("tiles", tiles.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<LoadSnapshotResponse>("LayerTree.loadSnapshot", dict);
        }

        partial void ValidateMakeSnapshot(string layerId);
        /// <summary>
        /// Returns the layer snapshot identifier.
        /// </summary>
        /// <param name = "layerId">The id of the layer.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;MakeSnapshotResponse&gt;</returns>
        public System.Threading.Tasks.Task<MakeSnapshotResponse> MakeSnapshotAsync(string layerId)
        {
            ValidateMakeSnapshot(layerId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("layerId", layerId);
            return _client.ExecuteDevToolsMethodAsync<MakeSnapshotResponse>("LayerTree.makeSnapshot", dict);
        }

        partial void ValidateProfileSnapshot(string snapshotId, int? minRepeatCount = null, double? minDuration = null, CefSharp.DevTools.DOM.Rect clipRect = null);
        /// <summary>
        /// ProfileSnapshot
        /// </summary>
        /// <param name = "snapshotId">The id of the layer snapshot.</param>
        /// <param name = "minRepeatCount">The maximum number of times to replay the snapshot (1, if not specified).</param>
        /// <param name = "minDuration">The minimum duration (in seconds) to replay the snapshot.</param>
        /// <param name = "clipRect">The clip rectangle to apply when replaying the snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ProfileSnapshotResponse&gt;</returns>
        public System.Threading.Tasks.Task<ProfileSnapshotResponse> ProfileSnapshotAsync(string snapshotId, int? minRepeatCount = null, double? minDuration = null, CefSharp.DevTools.DOM.Rect clipRect = null)
        {
            ValidateProfileSnapshot(snapshotId, minRepeatCount, minDuration, clipRect);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("snapshotId", snapshotId);
            if (minRepeatCount.HasValue)
            {
                dict.Add("minRepeatCount", minRepeatCount.Value);
            }

            if (minDuration.HasValue)
            {
                dict.Add("minDuration", minDuration.Value);
            }

            if ((clipRect) != (null))
            {
                dict.Add("clipRect", clipRect.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<ProfileSnapshotResponse>("LayerTree.profileSnapshot", dict);
        }

        partial void ValidateReleaseSnapshot(string snapshotId);
        /// <summary>
        /// Releases layer snapshot captured by the back-end.
        /// </summary>
        /// <param name = "snapshotId">The id of the layer snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ReleaseSnapshotAsync(string snapshotId)
        {
            ValidateReleaseSnapshot(snapshotId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("snapshotId", snapshotId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("LayerTree.releaseSnapshot", dict);
        }

        partial void ValidateReplaySnapshot(string snapshotId, int? fromStep = null, int? toStep = null, double? scale = null);
        /// <summary>
        /// Replays the layer snapshot and returns the resulting bitmap.
        /// </summary>
        /// <param name = "snapshotId">The id of the layer snapshot.</param>
        /// <param name = "fromStep">The first step to replay from (replay from the very start if not specified).</param>
        /// <param name = "toStep">The last step to replay to (replay till the end if not specified).</param>
        /// <param name = "scale">The scale to apply while replaying (defaults to 1).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ReplaySnapshotResponse&gt;</returns>
        public System.Threading.Tasks.Task<ReplaySnapshotResponse> ReplaySnapshotAsync(string snapshotId, int? fromStep = null, int? toStep = null, double? scale = null)
        {
            ValidateReplaySnapshot(snapshotId, fromStep, toStep, scale);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("snapshotId", snapshotId);
            if (fromStep.HasValue)
            {
                dict.Add("fromStep", fromStep.Value);
            }

            if (toStep.HasValue)
            {
                dict.Add("toStep", toStep.Value);
            }

            if (scale.HasValue)
            {
                dict.Add("scale", scale.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<ReplaySnapshotResponse>("LayerTree.replaySnapshot", dict);
        }

        partial void ValidateSnapshotCommandLog(string snapshotId);
        /// <summary>
        /// Replays the layer snapshot and returns canvas log.
        /// </summary>
        /// <param name = "snapshotId">The id of the layer snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SnapshotCommandLogResponse&gt;</returns>
        public System.Threading.Tasks.Task<SnapshotCommandLogResponse> SnapshotCommandLogAsync(string snapshotId)
        {
            ValidateSnapshotCommandLog(snapshotId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("snapshotId", snapshotId);
            return _client.ExecuteDevToolsMethodAsync<SnapshotCommandLogResponse>("LayerTree.snapshotCommandLog", dict);
        }
    }
}

namespace CefSharp.DevTools.Log
{
    using System.Linq;

    /// <summary>
    /// Provides access to log entries.
    /// </summary>
    public partial class LogClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Log
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public LogClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Issued when new message was logged.
        /// </summary>
        public event System.EventHandler<EntryAddedEventArgs> EntryAdded
        {
            add
            {
                _client.AddEventHandler<EntryAddedEventArgs>("Log.entryAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<EntryAddedEventArgs>("Log.entryAdded", value);
            }
        }

        /// <summary>
        /// Clears the log.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Log.clear", dict);
        }

        /// <summary>
        /// Disables log domain, prevents further log entries from being reported to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Log.disable", dict);
        }

        /// <summary>
        /// Enables log domain, sends the entries collected so far to the client by means of the
        /// `entryAdded` notification.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Log.enable", dict);
        }

        partial void ValidateStartViolationsReport(System.Collections.Generic.IList<CefSharp.DevTools.Log.ViolationSetting> config);
        /// <summary>
        /// start violation reporting.
        /// </summary>
        /// <param name = "config">Configuration for violations.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartViolationsReportAsync(System.Collections.Generic.IList<CefSharp.DevTools.Log.ViolationSetting> config)
        {
            ValidateStartViolationsReport(config);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("config", config.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Log.startViolationsReport", dict);
        }

        /// <summary>
        /// Stop violation reporting.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopViolationsReportAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Log.stopViolationsReport", dict);
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// GetDOMCountersResponse
    /// </summary>
    public class GetDOMCountersResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// documents
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("documents")]
        public int Documents
        {
            get;
            private set;
        }

        /// <summary>
        /// nodes
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("nodes")]
        public int Nodes
        {
            get;
            private set;
        }

        /// <summary>
        /// jsEventListeners
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("jsEventListeners")]
        public int JsEventListeners
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// GetAllTimeSamplingProfileResponse
    /// </summary>
    public class GetAllTimeSamplingProfileResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("profile")]
        public CefSharp.DevTools.Memory.SamplingProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// GetBrowserSamplingProfileResponse
    /// </summary>
    public class GetBrowserSamplingProfileResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("profile")]
        public CefSharp.DevTools.Memory.SamplingProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    /// <summary>
    /// GetSamplingProfileResponse
    /// </summary>
    public class GetSamplingProfileResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("profile")]
        public CefSharp.DevTools.Memory.SamplingProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Memory
{
    using System.Linq;

    /// <summary>
    /// Memory
    /// </summary>
    public partial class MemoryClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Memory
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public MemoryClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// GetDOMCounters
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetDOMCountersResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetDOMCountersResponse> GetDOMCountersAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetDOMCountersResponse>("Memory.getDOMCounters", dict);
        }

        /// <summary>
        /// PrepareForLeakDetection
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> PrepareForLeakDetectionAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Memory.prepareForLeakDetection", dict);
        }

        /// <summary>
        /// Simulate OomIntervention by purging V8 memory.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ForciblyPurgeJavaScriptMemoryAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Memory.forciblyPurgeJavaScriptMemory", dict);
        }

        partial void ValidateSetPressureNotificationsSuppressed(bool suppressed);
        /// <summary>
        /// Enable/disable suppressing memory pressure notifications in all processes.
        /// </summary>
        /// <param name = "suppressed">If true, memory pressure notifications will be suppressed.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetPressureNotificationsSuppressedAsync(bool suppressed)
        {
            ValidateSetPressureNotificationsSuppressed(suppressed);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("suppressed", suppressed);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Memory.setPressureNotificationsSuppressed", dict);
        }

        partial void ValidateSimulatePressureNotification(CefSharp.DevTools.Memory.PressureLevel level);
        /// <summary>
        /// Simulate a memory pressure notification in all processes.
        /// </summary>
        /// <param name = "level">Memory pressure level of the notification.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SimulatePressureNotificationAsync(CefSharp.DevTools.Memory.PressureLevel level)
        {
            ValidateSimulatePressureNotification(level);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("level", EnumToString(level));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Memory.simulatePressureNotification", dict);
        }

        partial void ValidateStartSampling(int? samplingInterval = null, bool? suppressRandomness = null);
        /// <summary>
        /// Start collecting native memory profile.
        /// </summary>
        /// <param name = "samplingInterval">Average number of bytes between samples.</param>
        /// <param name = "suppressRandomness">Do not randomize intervals between samples.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartSamplingAsync(int? samplingInterval = null, bool? suppressRandomness = null)
        {
            ValidateStartSampling(samplingInterval, suppressRandomness);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (samplingInterval.HasValue)
            {
                dict.Add("samplingInterval", samplingInterval.Value);
            }

            if (suppressRandomness.HasValue)
            {
                dict.Add("suppressRandomness", suppressRandomness.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Memory.startSampling", dict);
        }

        /// <summary>
        /// Stop collecting native memory profile.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopSamplingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Memory.stopSampling", dict);
        }

        /// <summary>
        /// Retrieve native memory allocations profile
        /// collected since renderer process startup.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAllTimeSamplingProfileResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetAllTimeSamplingProfileResponse> GetAllTimeSamplingProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetAllTimeSamplingProfileResponse>("Memory.getAllTimeSamplingProfile", dict);
        }

        /// <summary>
        /// Retrieve native memory allocations profile
        /// collected since browser process startup.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBrowserSamplingProfileResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetBrowserSamplingProfileResponse> GetBrowserSamplingProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetBrowserSamplingProfileResponse>("Memory.getBrowserSamplingProfile", dict);
        }

        /// <summary>
        /// Retrieve native memory allocations profile collected since last
        /// `startSampling` call.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSamplingProfileResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetSamplingProfileResponse> GetSamplingProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetSamplingProfileResponse>("Memory.getSamplingProfile", dict);
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetCertificateResponse
    /// </summary>
    public class GetCertificateResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// tableNames
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("tableNames")]
        public string[] TableNames
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetCookiesResponse
    /// </summary>
    public class GetCookiesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// cookies
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cookies")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.Cookie> Cookies
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetResponseBodyResponse
    /// </summary>
    public class GetResponseBodyResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// body
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("body")]
        public string Body
        {
            get;
            private set;
        }

        /// <summary>
        /// base64Encoded
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("base64Encoded")]
        public bool Base64Encoded
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetRequestPostDataResponse
    /// </summary>
    public class GetRequestPostDataResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// postData
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("postData")]
        public string PostData
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetResponseBodyForInterceptionResponse
    /// </summary>
    public class GetResponseBodyForInterceptionResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// body
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("body")]
        public string Body
        {
            get;
            private set;
        }

        /// <summary>
        /// base64Encoded
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("base64Encoded")]
        public bool Base64Encoded
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// TakeResponseBodyForInterceptionAsStreamResponse
    /// </summary>
    public class TakeResponseBodyForInterceptionAsStreamResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// stream
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stream")]
        public string Stream
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// SearchInResponseBodyResponse
    /// </summary>
    public class SearchInResponseBodyResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.SearchMatch> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// SetCookieResponse
    /// </summary>
    public class SetCookieResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// success
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("success")]
        public bool Success
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// GetSecurityIsolationStatusResponse
    /// </summary>
    public class GetSecurityIsolationStatusResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// status
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("status")]
        public CefSharp.DevTools.Network.SecurityIsolationStatus Status
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    /// <summary>
    /// LoadNetworkResourceResponse
    /// </summary>
    public class LoadNetworkResourceResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// resource
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("resource")]
        public CefSharp.DevTools.Network.LoadNetworkResourcePageResult Resource
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Network
{
    using System.Linq;

    /// <summary>
    /// Network domain allows tracking network activities of the page. It exposes information about http,
    /// file, data and other requests and responses, their headers, bodies, timing, etc.
    /// </summary>
    public partial class NetworkClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Network
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public NetworkClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Fired when data chunk was received over the network.
        /// </summary>
        public event System.EventHandler<DataReceivedEventArgs> DataReceived
        {
            add
            {
                _client.AddEventHandler<DataReceivedEventArgs>("Network.dataReceived", value);
            }

            remove
            {
                _client.RemoveEventHandler<DataReceivedEventArgs>("Network.dataReceived", value);
            }
        }

        /// <summary>
        /// Fired when EventSource message is received.
        /// </summary>
        public event System.EventHandler<EventSourceMessageReceivedEventArgs> EventSourceMessageReceived
        {
            add
            {
                _client.AddEventHandler<EventSourceMessageReceivedEventArgs>("Network.eventSourceMessageReceived", value);
            }

            remove
            {
                _client.RemoveEventHandler<EventSourceMessageReceivedEventArgs>("Network.eventSourceMessageReceived", value);
            }
        }

        /// <summary>
        /// Fired when HTTP request has failed to load.
        /// </summary>
        public event System.EventHandler<LoadingFailedEventArgs> LoadingFailed
        {
            add
            {
                _client.AddEventHandler<LoadingFailedEventArgs>("Network.loadingFailed", value);
            }

            remove
            {
                _client.RemoveEventHandler<LoadingFailedEventArgs>("Network.loadingFailed", value);
            }
        }

        /// <summary>
        /// Fired when HTTP request has finished loading.
        /// </summary>
        public event System.EventHandler<LoadingFinishedEventArgs> LoadingFinished
        {
            add
            {
                _client.AddEventHandler<LoadingFinishedEventArgs>("Network.loadingFinished", value);
            }

            remove
            {
                _client.RemoveEventHandler<LoadingFinishedEventArgs>("Network.loadingFinished", value);
            }
        }

        /// <summary>
        /// Fired if request ended up loading from cache.
        /// </summary>
        public event System.EventHandler<RequestServedFromCacheEventArgs> RequestServedFromCache
        {
            add
            {
                _client.AddEventHandler<RequestServedFromCacheEventArgs>("Network.requestServedFromCache", value);
            }

            remove
            {
                _client.RemoveEventHandler<RequestServedFromCacheEventArgs>("Network.requestServedFromCache", value);
            }
        }

        /// <summary>
        /// Fired when page is about to send HTTP request.
        /// </summary>
        public event System.EventHandler<RequestWillBeSentEventArgs> RequestWillBeSent
        {
            add
            {
                _client.AddEventHandler<RequestWillBeSentEventArgs>("Network.requestWillBeSent", value);
            }

            remove
            {
                _client.RemoveEventHandler<RequestWillBeSentEventArgs>("Network.requestWillBeSent", value);
            }
        }

        /// <summary>
        /// Fired when resource loading priority is changed
        /// </summary>
        public event System.EventHandler<ResourceChangedPriorityEventArgs> ResourceChangedPriority
        {
            add
            {
                _client.AddEventHandler<ResourceChangedPriorityEventArgs>("Network.resourceChangedPriority", value);
            }

            remove
            {
                _client.RemoveEventHandler<ResourceChangedPriorityEventArgs>("Network.resourceChangedPriority", value);
            }
        }

        /// <summary>
        /// Fired when a signed exchange was received over the network
        /// </summary>
        public event System.EventHandler<SignedExchangeReceivedEventArgs> SignedExchangeReceived
        {
            add
            {
                _client.AddEventHandler<SignedExchangeReceivedEventArgs>("Network.signedExchangeReceived", value);
            }

            remove
            {
                _client.RemoveEventHandler<SignedExchangeReceivedEventArgs>("Network.signedExchangeReceived", value);
            }
        }

        /// <summary>
        /// Fired when HTTP response is available.
        /// </summary>
        public event System.EventHandler<ResponseReceivedEventArgs> ResponseReceived
        {
            add
            {
                _client.AddEventHandler<ResponseReceivedEventArgs>("Network.responseReceived", value);
            }

            remove
            {
                _client.RemoveEventHandler<ResponseReceivedEventArgs>("Network.responseReceived", value);
            }
        }

        /// <summary>
        /// Fired when WebSocket is closed.
        /// </summary>
        public event System.EventHandler<WebSocketClosedEventArgs> WebSocketClosed
        {
            add
            {
                _client.AddEventHandler<WebSocketClosedEventArgs>("Network.webSocketClosed", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebSocketClosedEventArgs>("Network.webSocketClosed", value);
            }
        }

        /// <summary>
        /// Fired upon WebSocket creation.
        /// </summary>
        public event System.EventHandler<WebSocketCreatedEventArgs> WebSocketCreated
        {
            add
            {
                _client.AddEventHandler<WebSocketCreatedEventArgs>("Network.webSocketCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebSocketCreatedEventArgs>("Network.webSocketCreated", value);
            }
        }

        /// <summary>
        /// Fired when WebSocket message error occurs.
        /// </summary>
        public event System.EventHandler<WebSocketFrameErrorEventArgs> WebSocketFrameError
        {
            add
            {
                _client.AddEventHandler<WebSocketFrameErrorEventArgs>("Network.webSocketFrameError", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebSocketFrameErrorEventArgs>("Network.webSocketFrameError", value);
            }
        }

        /// <summary>
        /// Fired when WebSocket message is received.
        /// </summary>
        public event System.EventHandler<WebSocketFrameReceivedEventArgs> WebSocketFrameReceived
        {
            add
            {
                _client.AddEventHandler<WebSocketFrameReceivedEventArgs>("Network.webSocketFrameReceived", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebSocketFrameReceivedEventArgs>("Network.webSocketFrameReceived", value);
            }
        }

        /// <summary>
        /// Fired when WebSocket message is sent.
        /// </summary>
        public event System.EventHandler<WebSocketFrameSentEventArgs> WebSocketFrameSent
        {
            add
            {
                _client.AddEventHandler<WebSocketFrameSentEventArgs>("Network.webSocketFrameSent", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebSocketFrameSentEventArgs>("Network.webSocketFrameSent", value);
            }
        }

        /// <summary>
        /// Fired when WebSocket handshake response becomes available.
        /// </summary>
        public event System.EventHandler<WebSocketHandshakeResponseReceivedEventArgs> WebSocketHandshakeResponseReceived
        {
            add
            {
                _client.AddEventHandler<WebSocketHandshakeResponseReceivedEventArgs>("Network.webSocketHandshakeResponseReceived", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebSocketHandshakeResponseReceivedEventArgs>("Network.webSocketHandshakeResponseReceived", value);
            }
        }

        /// <summary>
        /// Fired when WebSocket is about to initiate handshake.
        /// </summary>
        public event System.EventHandler<WebSocketWillSendHandshakeRequestEventArgs> WebSocketWillSendHandshakeRequest
        {
            add
            {
                _client.AddEventHandler<WebSocketWillSendHandshakeRequestEventArgs>("Network.webSocketWillSendHandshakeRequest", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebSocketWillSendHandshakeRequestEventArgs>("Network.webSocketWillSendHandshakeRequest", value);
            }
        }

        /// <summary>
        /// Fired upon WebTransport creation.
        /// </summary>
        public event System.EventHandler<WebTransportCreatedEventArgs> WebTransportCreated
        {
            add
            {
                _client.AddEventHandler<WebTransportCreatedEventArgs>("Network.webTransportCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebTransportCreatedEventArgs>("Network.webTransportCreated", value);
            }
        }

        /// <summary>
        /// Fired when WebTransport handshake is finished.
        /// </summary>
        public event System.EventHandler<WebTransportConnectionEstablishedEventArgs> WebTransportConnectionEstablished
        {
            add
            {
                _client.AddEventHandler<WebTransportConnectionEstablishedEventArgs>("Network.webTransportConnectionEstablished", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebTransportConnectionEstablishedEventArgs>("Network.webTransportConnectionEstablished", value);
            }
        }

        /// <summary>
        /// Fired when WebTransport is disposed.
        /// </summary>
        public event System.EventHandler<WebTransportClosedEventArgs> WebTransportClosed
        {
            add
            {
                _client.AddEventHandler<WebTransportClosedEventArgs>("Network.webTransportClosed", value);
            }

            remove
            {
                _client.RemoveEventHandler<WebTransportClosedEventArgs>("Network.webTransportClosed", value);
            }
        }

        /// <summary>
        /// Fired when additional information about a requestWillBeSent event is available from the
        /// network stack. Not every requestWillBeSent event will have an additional
        /// requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
        /// or requestWillBeSentExtraInfo will be fired first for the same request.
        /// </summary>
        public event System.EventHandler<RequestWillBeSentExtraInfoEventArgs> RequestWillBeSentExtraInfo
        {
            add
            {
                _client.AddEventHandler<RequestWillBeSentExtraInfoEventArgs>("Network.requestWillBeSentExtraInfo", value);
            }

            remove
            {
                _client.RemoveEventHandler<RequestWillBeSentExtraInfoEventArgs>("Network.requestWillBeSentExtraInfo", value);
            }
        }

        /// <summary>
        /// Fired when additional information about a responseReceived event is available from the network
        /// stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
        /// it, and responseReceivedExtraInfo may be fired before or after responseReceived.
        /// </summary>
        public event System.EventHandler<ResponseReceivedExtraInfoEventArgs> ResponseReceivedExtraInfo
        {
            add
            {
                _client.AddEventHandler<ResponseReceivedExtraInfoEventArgs>("Network.responseReceivedExtraInfo", value);
            }

            remove
            {
                _client.RemoveEventHandler<ResponseReceivedExtraInfoEventArgs>("Network.responseReceivedExtraInfo", value);
            }
        }

        /// <summary>
        /// Fired exactly once for each Trust Token operation. Depending on
        /// the type of the operation and whether the operation succeeded or
        /// failed, the event is fired before the corresponding request was sent
        /// or after the response was received.
        /// </summary>
        public event System.EventHandler<TrustTokenOperationDoneEventArgs> TrustTokenOperationDone
        {
            add
            {
                _client.AddEventHandler<TrustTokenOperationDoneEventArgs>("Network.trustTokenOperationDone", value);
            }

            remove
            {
                _client.RemoveEventHandler<TrustTokenOperationDoneEventArgs>("Network.trustTokenOperationDone", value);
            }
        }

        /// <summary>
        /// Fired once when parsing the .wbn file has succeeded.
        /// The event contains the information about the web bundle contents.
        /// </summary>
        public event System.EventHandler<SubresourceWebBundleMetadataReceivedEventArgs> SubresourceWebBundleMetadataReceived
        {
            add
            {
                _client.AddEventHandler<SubresourceWebBundleMetadataReceivedEventArgs>("Network.subresourceWebBundleMetadataReceived", value);
            }

            remove
            {
                _client.RemoveEventHandler<SubresourceWebBundleMetadataReceivedEventArgs>("Network.subresourceWebBundleMetadataReceived", value);
            }
        }

        /// <summary>
        /// Fired once when parsing the .wbn file has failed.
        /// </summary>
        public event System.EventHandler<SubresourceWebBundleMetadataErrorEventArgs> SubresourceWebBundleMetadataError
        {
            add
            {
                _client.AddEventHandler<SubresourceWebBundleMetadataErrorEventArgs>("Network.subresourceWebBundleMetadataError", value);
            }

            remove
            {
                _client.RemoveEventHandler<SubresourceWebBundleMetadataErrorEventArgs>("Network.subresourceWebBundleMetadataError", value);
            }
        }

        /// <summary>
        /// Fired when handling requests for resources within a .wbn file.
        /// Note: this will only be fired for resources that are requested by the webpage.
        /// </summary>
        public event System.EventHandler<SubresourceWebBundleInnerResponseParsedEventArgs> SubresourceWebBundleInnerResponseParsed
        {
            add
            {
                _client.AddEventHandler<SubresourceWebBundleInnerResponseParsedEventArgs>("Network.subresourceWebBundleInnerResponseParsed", value);
            }

            remove
            {
                _client.RemoveEventHandler<SubresourceWebBundleInnerResponseParsedEventArgs>("Network.subresourceWebBundleInnerResponseParsed", value);
            }
        }

        /// <summary>
        /// Fired when request for resources within a .wbn file failed.
        /// </summary>
        public event System.EventHandler<SubresourceWebBundleInnerResponseErrorEventArgs> SubresourceWebBundleInnerResponseError
        {
            add
            {
                _client.AddEventHandler<SubresourceWebBundleInnerResponseErrorEventArgs>("Network.subresourceWebBundleInnerResponseError", value);
            }

            remove
            {
                _client.RemoveEventHandler<SubresourceWebBundleInnerResponseErrorEventArgs>("Network.subresourceWebBundleInnerResponseError", value);
            }
        }

        /// <summary>
        /// Is sent whenever a new report is added.
        /// And after &apos;enableReportingApi&apos; for all existing reports.
        /// </summary>
        public event System.EventHandler<ReportingApiReportAddedEventArgs> ReportingApiReportAdded
        {
            add
            {
                _client.AddEventHandler<ReportingApiReportAddedEventArgs>("Network.reportingApiReportAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<ReportingApiReportAddedEventArgs>("Network.reportingApiReportAdded", value);
            }
        }

        /// <summary>
        /// ReportingApiReportUpdated
        /// </summary>
        public event System.EventHandler<ReportingApiReportUpdatedEventArgs> ReportingApiReportUpdated
        {
            add
            {
                _client.AddEventHandler<ReportingApiReportUpdatedEventArgs>("Network.reportingApiReportUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<ReportingApiReportUpdatedEventArgs>("Network.reportingApiReportUpdated", value);
            }
        }

        /// <summary>
        /// ReportingApiEndpointsChangedForOrigin
        /// </summary>
        public event System.EventHandler<ReportingApiEndpointsChangedForOriginEventArgs> ReportingApiEndpointsChangedForOrigin
        {
            add
            {
                _client.AddEventHandler<ReportingApiEndpointsChangedForOriginEventArgs>("Network.reportingApiEndpointsChangedForOrigin", value);
            }

            remove
            {
                _client.RemoveEventHandler<ReportingApiEndpointsChangedForOriginEventArgs>("Network.reportingApiEndpointsChangedForOrigin", value);
            }
        }

        partial void ValidateSetAcceptedEncodings(CefSharp.DevTools.Network.ContentEncoding[] encodings);
        /// <summary>
        /// Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
        /// </summary>
        /// <param name = "encodings">List of accepted content encodings.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAcceptedEncodingsAsync(CefSharp.DevTools.Network.ContentEncoding[] encodings)
        {
            ValidateSetAcceptedEncodings(encodings);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("encodings", EnumToString(encodings));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.setAcceptedEncodings", dict);
        }

        /// <summary>
        /// Clears accepted encodings set by setAcceptedEncodings
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearAcceptedEncodingsOverrideAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.clearAcceptedEncodingsOverride", dict);
        }

        /// <summary>
        /// Clears browser cache.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearBrowserCacheAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.clearBrowserCache", dict);
        }

        /// <summary>
        /// Clears browser cookies.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearBrowserCookiesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.clearBrowserCookies", dict);
        }

        partial void ValidateDeleteCookies(string name, string url = null, string domain = null, string path = null);
        /// <summary>
        /// Deletes browser cookies with matching name and url or domain/path pair.
        /// </summary>
        /// <param name = "name">Name of the cookies to remove.</param>
        /// <param name = "url">If specified, deletes all the cookies with the given name where domain and path matchprovided URL.</param>
        /// <param name = "domain">If specified, deletes only cookies with the exact domain.</param>
        /// <param name = "path">If specified, deletes only cookies with the exact path.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteCookiesAsync(string name, string url = null, string domain = null, string path = null)
        {
            ValidateDeleteCookies(name, url, domain, path);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            if (!(string.IsNullOrEmpty(url)))
            {
                dict.Add("url", url);
            }

            if (!(string.IsNullOrEmpty(domain)))
            {
                dict.Add("domain", domain);
            }

            if (!(string.IsNullOrEmpty(path)))
            {
                dict.Add("path", path);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.deleteCookies", dict);
        }

        /// <summary>
        /// Disables network tracking, prevents network events from being sent to the client.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.disable", dict);
        }

        partial void ValidateEmulateNetworkConditions(bool offline, double latency, double downloadThroughput, double uploadThroughput, CefSharp.DevTools.Network.ConnectionType? connectionType = null);
        /// <summary>
        /// Activates emulation of network conditions.
        /// </summary>
        /// <param name = "offline">True to emulate internet disconnection.</param>
        /// <param name = "latency">Minimum latency from request sent to response headers received (ms).</param>
        /// <param name = "downloadThroughput">Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.</param>
        /// <param name = "uploadThroughput">Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.</param>
        /// <param name = "connectionType">Connection type if known.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EmulateNetworkConditionsAsync(bool offline, double latency, double downloadThroughput, double uploadThroughput, CefSharp.DevTools.Network.ConnectionType? connectionType = null)
        {
            ValidateEmulateNetworkConditions(offline, latency, downloadThroughput, uploadThroughput, connectionType);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("offline", offline);
            dict.Add("latency", latency);
            dict.Add("downloadThroughput", downloadThroughput);
            dict.Add("uploadThroughput", uploadThroughput);
            if (connectionType.HasValue)
            {
                dict.Add("connectionType", EnumToString(connectionType));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.emulateNetworkConditions", dict);
        }

        partial void ValidateEnable(int? maxTotalBufferSize = null, int? maxResourceBufferSize = null, int? maxPostDataSize = null);
        /// <summary>
        /// Enables network tracking, network events will now be delivered to the client.
        /// </summary>
        /// <param name = "maxTotalBufferSize">Buffer size in bytes to use when preserving network payloads (XHRs, etc).</param>
        /// <param name = "maxResourceBufferSize">Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).</param>
        /// <param name = "maxPostDataSize">Longest post body size (in bytes) that would be included in requestWillBeSent notification</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(int? maxTotalBufferSize = null, int? maxResourceBufferSize = null, int? maxPostDataSize = null)
        {
            ValidateEnable(maxTotalBufferSize, maxResourceBufferSize, maxPostDataSize);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (maxTotalBufferSize.HasValue)
            {
                dict.Add("maxTotalBufferSize", maxTotalBufferSize.Value);
            }

            if (maxResourceBufferSize.HasValue)
            {
                dict.Add("maxResourceBufferSize", maxResourceBufferSize.Value);
            }

            if (maxPostDataSize.HasValue)
            {
                dict.Add("maxPostDataSize", maxPostDataSize.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.enable", dict);
        }

        partial void ValidateGetCertificate(string origin);
        /// <summary>
        /// Returns the DER-encoded certificate.
        /// </summary>
        /// <param name = "origin">Origin to get certificate for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCertificateResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetCertificateResponse> GetCertificateAsync(string origin)
        {
            ValidateGetCertificate(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            return _client.ExecuteDevToolsMethodAsync<GetCertificateResponse>("Network.getCertificate", dict);
        }

        partial void ValidateGetCookies(string[] urls = null);
        /// <summary>
        /// Returns all browser cookies for the current URL. Depending on the backend support, will return
        /// detailed cookie information in the `cookies` field.
        /// </summary>
        /// <param name = "urls">The list of URLs for which applicable cookies will be fetched.If not specified, it's assumed to be set to the list containingthe URLs of the page and all of its subframes.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCookiesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetCookiesResponse> GetCookiesAsync(string[] urls = null)
        {
            ValidateGetCookies(urls);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((urls) != (null))
            {
                dict.Add("urls", urls);
            }

            return _client.ExecuteDevToolsMethodAsync<GetCookiesResponse>("Network.getCookies", dict);
        }

        partial void ValidateGetResponseBody(string requestId);
        /// <summary>
        /// Returns content served for the given request.
        /// </summary>
        /// <param name = "requestId">Identifier of the network request to get content for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResponseBodyResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetResponseBodyResponse> GetResponseBodyAsync(string requestId)
        {
            ValidateGetResponseBody(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            return _client.ExecuteDevToolsMethodAsync<GetResponseBodyResponse>("Network.getResponseBody", dict);
        }

        partial void ValidateGetRequestPostData(string requestId);
        /// <summary>
        /// Returns post data sent with the request. Returns an error when no data was sent with the request.
        /// </summary>
        /// <param name = "requestId">Identifier of the network request to get content for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetRequestPostDataResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetRequestPostDataResponse> GetRequestPostDataAsync(string requestId)
        {
            ValidateGetRequestPostData(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            return _client.ExecuteDevToolsMethodAsync<GetRequestPostDataResponse>("Network.getRequestPostData", dict);
        }

        partial void ValidateGetResponseBodyForInterception(string interceptionId);
        /// <summary>
        /// Returns content served for the given currently intercepted request.
        /// </summary>
        /// <param name = "interceptionId">Identifier for the intercepted request to get body for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResponseBodyForInterceptionResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetResponseBodyForInterceptionResponse> GetResponseBodyForInterceptionAsync(string interceptionId)
        {
            ValidateGetResponseBodyForInterception(interceptionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("interceptionId", interceptionId);
            return _client.ExecuteDevToolsMethodAsync<GetResponseBodyForInterceptionResponse>("Network.getResponseBodyForInterception", dict);
        }

        partial void ValidateTakeResponseBodyForInterceptionAsStream(string interceptionId);
        /// <summary>
        /// Returns a handle to the stream representing the response body. Note that after this command,
        /// the intercepted request can&apos;t be continued as is -- you either need to cancel it or to provide
        /// the response body. The stream only supports sequential read, IO.read will fail if the position
        /// is specified.
        /// </summary>
        /// <param name = "interceptionId">interceptionId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeResponseBodyForInterceptionAsStreamResponse&gt;</returns>
        public System.Threading.Tasks.Task<TakeResponseBodyForInterceptionAsStreamResponse> TakeResponseBodyForInterceptionAsStreamAsync(string interceptionId)
        {
            ValidateTakeResponseBodyForInterceptionAsStream(interceptionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("interceptionId", interceptionId);
            return _client.ExecuteDevToolsMethodAsync<TakeResponseBodyForInterceptionAsStreamResponse>("Network.takeResponseBodyForInterceptionAsStream", dict);
        }

        partial void ValidateReplayXHR(string requestId);
        /// <summary>
        /// This method sends a new XMLHttpRequest which is identical to the original one. The following
        /// parameters should be identical: method, url, async, request body, extra headers, withCredentials
        /// attribute, user, password.
        /// </summary>
        /// <param name = "requestId">Identifier of XHR to replay.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ReplayXHRAsync(string requestId)
        {
            ValidateReplayXHR(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.replayXHR", dict);
        }

        partial void ValidateSearchInResponseBody(string requestId, string query, bool? caseSensitive = null, bool? isRegex = null);
        /// <summary>
        /// Searches for given string in response content.
        /// </summary>
        /// <param name = "requestId">Identifier of the network response to search.</param>
        /// <param name = "query">String to search for.</param>
        /// <param name = "caseSensitive">If true, search is case sensitive.</param>
        /// <param name = "isRegex">If true, treats string parameter as regex.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SearchInResponseBodyResponse&gt;</returns>
        public System.Threading.Tasks.Task<SearchInResponseBodyResponse> SearchInResponseBodyAsync(string requestId, string query, bool? caseSensitive = null, bool? isRegex = null)
        {
            ValidateSearchInResponseBody(requestId, query, caseSensitive, isRegex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("query", query);
            if (caseSensitive.HasValue)
            {
                dict.Add("caseSensitive", caseSensitive.Value);
            }

            if (isRegex.HasValue)
            {
                dict.Add("isRegex", isRegex.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<SearchInResponseBodyResponse>("Network.searchInResponseBody", dict);
        }

        partial void ValidateSetBlockedURLs(string[] urls);
        /// <summary>
        /// Blocks URLs from loading.
        /// </summary>
        /// <param name = "urls">URL patterns to block. Wildcards ('*') are allowed.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetBlockedURLsAsync(string[] urls)
        {
            ValidateSetBlockedURLs(urls);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("urls", urls);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.setBlockedURLs", dict);
        }

        partial void ValidateSetBypassServiceWorker(bool bypass);
        /// <summary>
        /// Toggles ignoring of service worker for each request.
        /// </summary>
        /// <param name = "bypass">Bypass service worker and load from network.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetBypassServiceWorkerAsync(bool bypass)
        {
            ValidateSetBypassServiceWorker(bypass);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("bypass", bypass);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.setBypassServiceWorker", dict);
        }

        partial void ValidateSetCacheDisabled(bool cacheDisabled);
        /// <summary>
        /// Toggles ignoring cache for each request. If `true`, cache will not be used.
        /// </summary>
        /// <param name = "cacheDisabled">Cache disabled state.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetCacheDisabledAsync(bool cacheDisabled)
        {
            ValidateSetCacheDisabled(cacheDisabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cacheDisabled", cacheDisabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.setCacheDisabled", dict);
        }

        partial void ValidateSetCookie(string name, string value, string url = null, string domain = null, string path = null, bool? secure = null, bool? httpOnly = null, CefSharp.DevTools.Network.CookieSameSite? sameSite = null, double? expires = null, CefSharp.DevTools.Network.CookiePriority? priority = null, bool? sameParty = null, CefSharp.DevTools.Network.CookieSourceScheme? sourceScheme = null, int? sourcePort = null, string partitionKey = null);
        /// <summary>
        /// Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
        /// </summary>
        /// <param name = "name">Cookie name.</param>
        /// <param name = "value">Cookie value.</param>
        /// <param name = "url">The request-URI to associate with the setting of the cookie. This value can affect thedefault domain, path, source port, and source scheme values of the created cookie.</param>
        /// <param name = "domain">Cookie domain.</param>
        /// <param name = "path">Cookie path.</param>
        /// <param name = "secure">True if cookie is secure.</param>
        /// <param name = "httpOnly">True if cookie is http-only.</param>
        /// <param name = "sameSite">Cookie SameSite type.</param>
        /// <param name = "expires">Cookie expiration date, session cookie if not set</param>
        /// <param name = "priority">Cookie Priority type.</param>
        /// <param name = "sameParty">True if cookie is SameParty.</param>
        /// <param name = "sourceScheme">Cookie source scheme type.</param>
        /// <param name = "sourcePort">Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.This is a temporary ability and it will be removed in the future.</param>
        /// <param name = "partitionKey">Cookie partition key. The site of the top-level URL the browser was visiting at the startof the request to the endpoint that set the cookie.If not set, the cookie will be set as not partitioned.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetCookieResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetCookieResponse> SetCookieAsync(string name, string value, string url = null, string domain = null, string path = null, bool? secure = null, bool? httpOnly = null, CefSharp.DevTools.Network.CookieSameSite? sameSite = null, double? expires = null, CefSharp.DevTools.Network.CookiePriority? priority = null, bool? sameParty = null, CefSharp.DevTools.Network.CookieSourceScheme? sourceScheme = null, int? sourcePort = null, string partitionKey = null)
        {
            ValidateSetCookie(name, value, url, domain, path, secure, httpOnly, sameSite, expires, priority, sameParty, sourceScheme, sourcePort, partitionKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            dict.Add("value", value);
            if (!(string.IsNullOrEmpty(url)))
            {
                dict.Add("url", url);
            }

            if (!(string.IsNullOrEmpty(domain)))
            {
                dict.Add("domain", domain);
            }

            if (!(string.IsNullOrEmpty(path)))
            {
                dict.Add("path", path);
            }

            if (secure.HasValue)
            {
                dict.Add("secure", secure.Value);
            }

            if (httpOnly.HasValue)
            {
                dict.Add("httpOnly", httpOnly.Value);
            }

            if (sameSite.HasValue)
            {
                dict.Add("sameSite", EnumToString(sameSite));
            }

            if (expires.HasValue)
            {
                dict.Add("expires", expires.Value);
            }

            if (priority.HasValue)
            {
                dict.Add("priority", EnumToString(priority));
            }

            if (sameParty.HasValue)
            {
                dict.Add("sameParty", sameParty.Value);
            }

            if (sourceScheme.HasValue)
            {
                dict.Add("sourceScheme", EnumToString(sourceScheme));
            }

            if (sourcePort.HasValue)
            {
                dict.Add("sourcePort", sourcePort.Value);
            }

            if (!(string.IsNullOrEmpty(partitionKey)))
            {
                dict.Add("partitionKey", partitionKey);
            }

            return _client.ExecuteDevToolsMethodAsync<SetCookieResponse>("Network.setCookie", dict);
        }

        partial void ValidateSetCookies(System.Collections.Generic.IList<CefSharp.DevTools.Network.CookieParam> cookies);
        /// <summary>
        /// Sets given cookies.
        /// </summary>
        /// <param name = "cookies">Cookies to be set.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetCookiesAsync(System.Collections.Generic.IList<CefSharp.DevTools.Network.CookieParam> cookies)
        {
            ValidateSetCookies(cookies);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cookies", cookies.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.setCookies", dict);
        }

        partial void ValidateSetExtraHTTPHeaders(CefSharp.DevTools.Network.Headers headers);
        /// <summary>
        /// Specifies whether to always send extra HTTP headers with the requests from this page.
        /// </summary>
        /// <param name = "headers">Map with extra HTTP headers.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetExtraHTTPHeadersAsync(CefSharp.DevTools.Network.Headers headers)
        {
            ValidateSetExtraHTTPHeaders(headers);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("headers", headers.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.setExtraHTTPHeaders", dict);
        }

        partial void ValidateSetAttachDebugStack(bool enabled);
        /// <summary>
        /// Specifies whether to attach a page script stack id in requests
        /// </summary>
        /// <param name = "enabled">Whether to attach a page script stack for debugging purpose.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAttachDebugStackAsync(bool enabled)
        {
            ValidateSetAttachDebugStack(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.setAttachDebugStack", dict);
        }

        partial void ValidateSetUserAgentOverride(string userAgent, string acceptLanguage = null, string platform = null, CefSharp.DevTools.Emulation.UserAgentMetadata userAgentMetadata = null);
        /// <summary>
        /// Allows overriding user agent with the given string.
        /// </summary>
        /// <param name = "userAgent">User agent to use.</param>
        /// <param name = "acceptLanguage">Browser langugage to emulate.</param>
        /// <param name = "platform">The platform navigator.platform should return.</param>
        /// <param name = "userAgentMetadata">To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetUserAgentOverrideAsync(string userAgent, string acceptLanguage = null, string platform = null, CefSharp.DevTools.Emulation.UserAgentMetadata userAgentMetadata = null)
        {
            ValidateSetUserAgentOverride(userAgent, acceptLanguage, platform, userAgentMetadata);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("userAgent", userAgent);
            if (!(string.IsNullOrEmpty(acceptLanguage)))
            {
                dict.Add("acceptLanguage", acceptLanguage);
            }

            if (!(string.IsNullOrEmpty(platform)))
            {
                dict.Add("platform", platform);
            }

            if ((userAgentMetadata) != (null))
            {
                dict.Add("userAgentMetadata", userAgentMetadata.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.setUserAgentOverride", dict);
        }

        partial void ValidateGetSecurityIsolationStatus(string frameId = null);
        /// <summary>
        /// Returns information about the COEP/COOP isolation status.
        /// </summary>
        /// <param name = "frameId">If no frameId is provided, the status of the target is provided.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSecurityIsolationStatusResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetSecurityIsolationStatusResponse> GetSecurityIsolationStatusAsync(string frameId = null)
        {
            ValidateGetSecurityIsolationStatus(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(frameId)))
            {
                dict.Add("frameId", frameId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetSecurityIsolationStatusResponse>("Network.getSecurityIsolationStatus", dict);
        }

        partial void ValidateEnableReportingApi(bool enable);
        /// <summary>
        /// Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
        /// Enabling triggers &apos;reportingApiReportAdded&apos; for all existing reports.
        /// </summary>
        /// <param name = "enable">Whether to enable or disable events for the Reporting API</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableReportingApiAsync(bool enable)
        {
            ValidateEnableReportingApi(enable);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enable", enable);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Network.enableReportingApi", dict);
        }

        partial void ValidateLoadNetworkResource(string url, CefSharp.DevTools.Network.LoadNetworkResourceOptions options, string frameId = null);
        /// <summary>
        /// Fetches the resource and returns the content.
        /// </summary>
        /// <param name = "url">URL of the resource to get content for.</param>
        /// <param name = "options">Options for the request.</param>
        /// <param name = "frameId">Frame id to get the resource for. Mandatory for frame targets, andshould be omitted for worker targets.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;LoadNetworkResourceResponse&gt;</returns>
        public System.Threading.Tasks.Task<LoadNetworkResourceResponse> LoadNetworkResourceAsync(string url, CefSharp.DevTools.Network.LoadNetworkResourceOptions options, string frameId = null)
        {
            ValidateLoadNetworkResource(url, options, frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            dict.Add("options", options.ToDictionary());
            if (!(string.IsNullOrEmpty(frameId)))
            {
                dict.Add("frameId", frameId);
            }

            return _client.ExecuteDevToolsMethodAsync<LoadNetworkResourceResponse>("Network.loadNetworkResource", dict);
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// GetHighlightObjectForTestResponse
    /// </summary>
    public class GetHighlightObjectForTestResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// highlight
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("highlight")]
        public object Highlight
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// GetGridHighlightObjectsForTestResponse
    /// </summary>
    public class GetGridHighlightObjectsForTestResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// highlights
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("highlights")]
        public object Highlights
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    /// <summary>
    /// GetSourceOrderHighlightObjectForTestResponse
    /// </summary>
    public class GetSourceOrderHighlightObjectForTestResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// highlight
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("highlight")]
        public object Highlight
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Overlay
{
    using System.Linq;

    /// <summary>
    /// This domain provides various functionality related to drawing atop the inspected page.
    /// </summary>
    public partial class OverlayClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Overlay
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public OverlayClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Fired when the node should be inspected. This happens after call to `setInspectMode` or when
        /// user manually inspects an element.
        /// </summary>
        public event System.EventHandler<InspectNodeRequestedEventArgs> InspectNodeRequested
        {
            add
            {
                _client.AddEventHandler<InspectNodeRequestedEventArgs>("Overlay.inspectNodeRequested", value);
            }

            remove
            {
                _client.RemoveEventHandler<InspectNodeRequestedEventArgs>("Overlay.inspectNodeRequested", value);
            }
        }

        /// <summary>
        /// Fired when the node should be highlighted. This happens after call to `setInspectMode`.
        /// </summary>
        public event System.EventHandler<NodeHighlightRequestedEventArgs> NodeHighlightRequested
        {
            add
            {
                _client.AddEventHandler<NodeHighlightRequestedEventArgs>("Overlay.nodeHighlightRequested", value);
            }

            remove
            {
                _client.RemoveEventHandler<NodeHighlightRequestedEventArgs>("Overlay.nodeHighlightRequested", value);
            }
        }

        /// <summary>
        /// Fired when user asks to capture screenshot of some area on the page.
        /// </summary>
        public event System.EventHandler<ScreenshotRequestedEventArgs> ScreenshotRequested
        {
            add
            {
                _client.AddEventHandler<ScreenshotRequestedEventArgs>("Overlay.screenshotRequested", value);
            }

            remove
            {
                _client.RemoveEventHandler<ScreenshotRequestedEventArgs>("Overlay.screenshotRequested", value);
            }
        }

        /// <summary>
        /// Fired when user cancels the inspect mode.
        /// </summary>
        public event System.EventHandler<System.EventArgs> InspectModeCanceled
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Overlay.inspectModeCanceled", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Overlay.inspectModeCanceled", value);
            }
        }

        /// <summary>
        /// Disables domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.disable", dict);
        }

        /// <summary>
        /// Enables domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.enable", dict);
        }

        partial void ValidateGetHighlightObjectForTest(int nodeId, bool? includeDistance = null, bool? includeStyle = null, CefSharp.DevTools.Overlay.ColorFormat? colorFormat = null, bool? showAccessibilityInfo = null);
        /// <summary>
        /// For testing.
        /// </summary>
        /// <param name = "nodeId">Id of the node to get highlight object for.</param>
        /// <param name = "includeDistance">Whether to include distance info.</param>
        /// <param name = "includeStyle">Whether to include style info.</param>
        /// <param name = "colorFormat">The color format to get config with (default: hex).</param>
        /// <param name = "showAccessibilityInfo">Whether to show accessibility info (default: true).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHighlightObjectForTestResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetHighlightObjectForTestResponse> GetHighlightObjectForTestAsync(int nodeId, bool? includeDistance = null, bool? includeStyle = null, CefSharp.DevTools.Overlay.ColorFormat? colorFormat = null, bool? showAccessibilityInfo = null)
        {
            ValidateGetHighlightObjectForTest(nodeId, includeDistance, includeStyle, colorFormat, showAccessibilityInfo);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            if (includeDistance.HasValue)
            {
                dict.Add("includeDistance", includeDistance.Value);
            }

            if (includeStyle.HasValue)
            {
                dict.Add("includeStyle", includeStyle.Value);
            }

            if (colorFormat.HasValue)
            {
                dict.Add("colorFormat", EnumToString(colorFormat));
            }

            if (showAccessibilityInfo.HasValue)
            {
                dict.Add("showAccessibilityInfo", showAccessibilityInfo.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetHighlightObjectForTestResponse>("Overlay.getHighlightObjectForTest", dict);
        }

        partial void ValidateGetGridHighlightObjectsForTest(int[] nodeIds);
        /// <summary>
        /// For Persistent Grid testing.
        /// </summary>
        /// <param name = "nodeIds">Ids of the node to get highlight object for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetGridHighlightObjectsForTestResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetGridHighlightObjectsForTestResponse> GetGridHighlightObjectsForTestAsync(int[] nodeIds)
        {
            ValidateGetGridHighlightObjectsForTest(nodeIds);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeIds", nodeIds);
            return _client.ExecuteDevToolsMethodAsync<GetGridHighlightObjectsForTestResponse>("Overlay.getGridHighlightObjectsForTest", dict);
        }

        partial void ValidateGetSourceOrderHighlightObjectForTest(int nodeId);
        /// <summary>
        /// For Source Order Viewer testing.
        /// </summary>
        /// <param name = "nodeId">Id of the node to highlight.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSourceOrderHighlightObjectForTestResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetSourceOrderHighlightObjectForTestResponse> GetSourceOrderHighlightObjectForTestAsync(int nodeId)
        {
            ValidateGetSourceOrderHighlightObjectForTest(nodeId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("nodeId", nodeId);
            return _client.ExecuteDevToolsMethodAsync<GetSourceOrderHighlightObjectForTestResponse>("Overlay.getSourceOrderHighlightObjectForTest", dict);
        }

        /// <summary>
        /// Hides any highlight.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HideHighlightAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.hideHighlight", dict);
        }

        partial void ValidateHighlightNode(CefSharp.DevTools.Overlay.HighlightConfig highlightConfig, int? nodeId = null, int? backendNodeId = null, string objectId = null, string selector = null);
        /// <summary>
        /// Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
        /// objectId must be specified.
        /// </summary>
        /// <param name = "highlightConfig">A descriptor for the highlight appearance.</param>
        /// <param name = "nodeId">Identifier of the node to highlight.</param>
        /// <param name = "backendNodeId">Identifier of the backend node to highlight.</param>
        /// <param name = "objectId">JavaScript object id of the node to be highlighted.</param>
        /// <param name = "selector">Selectors to highlight relevant nodes.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightNodeAsync(CefSharp.DevTools.Overlay.HighlightConfig highlightConfig, int? nodeId = null, int? backendNodeId = null, string objectId = null, string selector = null)
        {
            ValidateHighlightNode(highlightConfig, nodeId, backendNodeId, objectId, selector);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("highlightConfig", highlightConfig.ToDictionary());
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if (!(string.IsNullOrEmpty(selector)))
            {
                dict.Add("selector", selector);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.highlightNode", dict);
        }

        partial void ValidateHighlightQuad(double[] quad, CefSharp.DevTools.DOM.RGBA color = null, CefSharp.DevTools.DOM.RGBA outlineColor = null);
        /// <summary>
        /// Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
        /// </summary>
        /// <param name = "quad">Quad to highlight</param>
        /// <param name = "color">The highlight fill color (default: transparent).</param>
        /// <param name = "outlineColor">The highlight outline color (default: transparent).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightQuadAsync(double[] quad, CefSharp.DevTools.DOM.RGBA color = null, CefSharp.DevTools.DOM.RGBA outlineColor = null)
        {
            ValidateHighlightQuad(quad, color, outlineColor);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("quad", quad);
            if ((color) != (null))
            {
                dict.Add("color", color.ToDictionary());
            }

            if ((outlineColor) != (null))
            {
                dict.Add("outlineColor", outlineColor.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.highlightQuad", dict);
        }

        partial void ValidateHighlightRect(int x, int y, int width, int height, CefSharp.DevTools.DOM.RGBA color = null, CefSharp.DevTools.DOM.RGBA outlineColor = null);
        /// <summary>
        /// Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
        /// </summary>
        /// <param name = "x">X coordinate</param>
        /// <param name = "y">Y coordinate</param>
        /// <param name = "width">Rectangle width</param>
        /// <param name = "height">Rectangle height</param>
        /// <param name = "color">The highlight fill color (default: transparent).</param>
        /// <param name = "outlineColor">The highlight outline color (default: transparent).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightRectAsync(int x, int y, int width, int height, CefSharp.DevTools.DOM.RGBA color = null, CefSharp.DevTools.DOM.RGBA outlineColor = null)
        {
            ValidateHighlightRect(x, y, width, height, color, outlineColor);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("x", x);
            dict.Add("y", y);
            dict.Add("width", width);
            dict.Add("height", height);
            if ((color) != (null))
            {
                dict.Add("color", color.ToDictionary());
            }

            if ((outlineColor) != (null))
            {
                dict.Add("outlineColor", outlineColor.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.highlightRect", dict);
        }

        partial void ValidateHighlightSourceOrder(CefSharp.DevTools.Overlay.SourceOrderConfig sourceOrderConfig, int? nodeId = null, int? backendNodeId = null, string objectId = null);
        /// <summary>
        /// Highlights the source order of the children of the DOM node with given id or with the given
        /// JavaScript object wrapper. Either nodeId or objectId must be specified.
        /// </summary>
        /// <param name = "sourceOrderConfig">A descriptor for the appearance of the overlay drawing.</param>
        /// <param name = "nodeId">Identifier of the node to highlight.</param>
        /// <param name = "backendNodeId">Identifier of the backend node to highlight.</param>
        /// <param name = "objectId">JavaScript object id of the node to be highlighted.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HighlightSourceOrderAsync(CefSharp.DevTools.Overlay.SourceOrderConfig sourceOrderConfig, int? nodeId = null, int? backendNodeId = null, string objectId = null)
        {
            ValidateHighlightSourceOrder(sourceOrderConfig, nodeId, backendNodeId, objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sourceOrderConfig", sourceOrderConfig.ToDictionary());
            if (nodeId.HasValue)
            {
                dict.Add("nodeId", nodeId.Value);
            }

            if (backendNodeId.HasValue)
            {
                dict.Add("backendNodeId", backendNodeId.Value);
            }

            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.highlightSourceOrder", dict);
        }

        partial void ValidateSetInspectMode(CefSharp.DevTools.Overlay.InspectMode mode, CefSharp.DevTools.Overlay.HighlightConfig highlightConfig = null);
        /// <summary>
        /// Enters the &apos;inspect&apos; mode. In this mode, elements that user is hovering over are highlighted.
        /// Backend then generates &apos;inspectNodeRequested&apos; event upon element selection.
        /// </summary>
        /// <param name = "mode">Set an inspection mode.</param>
        /// <param name = "highlightConfig">A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled== false`.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetInspectModeAsync(CefSharp.DevTools.Overlay.InspectMode mode, CefSharp.DevTools.Overlay.HighlightConfig highlightConfig = null)
        {
            ValidateSetInspectMode(mode, highlightConfig);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("mode", EnumToString(mode));
            if ((highlightConfig) != (null))
            {
                dict.Add("highlightConfig", highlightConfig.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setInspectMode", dict);
        }

        partial void ValidateSetShowAdHighlights(bool show);
        /// <summary>
        /// Highlights owner element of all frames detected to be ads.
        /// </summary>
        /// <param name = "show">True for showing ad highlights</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowAdHighlightsAsync(bool show)
        {
            ValidateSetShowAdHighlights(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowAdHighlights", dict);
        }

        partial void ValidateSetPausedInDebuggerMessage(string message = null);
        /// <summary>
        /// SetPausedInDebuggerMessage
        /// </summary>
        /// <param name = "message">The message to display, also triggers resume and step over controls.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetPausedInDebuggerMessageAsync(string message = null)
        {
            ValidateSetPausedInDebuggerMessage(message);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(message)))
            {
                dict.Add("message", message);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setPausedInDebuggerMessage", dict);
        }

        partial void ValidateSetShowDebugBorders(bool show);
        /// <summary>
        /// Requests that backend shows debug borders on layers
        /// </summary>
        /// <param name = "show">True for showing debug borders</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowDebugBordersAsync(bool show)
        {
            ValidateSetShowDebugBorders(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowDebugBorders", dict);
        }

        partial void ValidateSetShowFPSCounter(bool show);
        /// <summary>
        /// Requests that backend shows the FPS counter
        /// </summary>
        /// <param name = "show">True for showing the FPS counter</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowFPSCounterAsync(bool show)
        {
            ValidateSetShowFPSCounter(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowFPSCounter", dict);
        }

        partial void ValidateSetShowGridOverlays(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.GridNodeHighlightConfig> gridNodeHighlightConfigs);
        /// <summary>
        /// Highlight multiple elements with the CSS Grid overlay.
        /// </summary>
        /// <param name = "gridNodeHighlightConfigs">An array of node identifiers and descriptors for the highlight appearance.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowGridOverlaysAsync(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.GridNodeHighlightConfig> gridNodeHighlightConfigs)
        {
            ValidateSetShowGridOverlays(gridNodeHighlightConfigs);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("gridNodeHighlightConfigs", gridNodeHighlightConfigs.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowGridOverlays", dict);
        }

        partial void ValidateSetShowFlexOverlays(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.FlexNodeHighlightConfig> flexNodeHighlightConfigs);
        /// <summary>
        /// SetShowFlexOverlays
        /// </summary>
        /// <param name = "flexNodeHighlightConfigs">An array of node identifiers and descriptors for the highlight appearance.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowFlexOverlaysAsync(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.FlexNodeHighlightConfig> flexNodeHighlightConfigs)
        {
            ValidateSetShowFlexOverlays(flexNodeHighlightConfigs);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("flexNodeHighlightConfigs", flexNodeHighlightConfigs.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowFlexOverlays", dict);
        }

        partial void ValidateSetShowScrollSnapOverlays(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.ScrollSnapHighlightConfig> scrollSnapHighlightConfigs);
        /// <summary>
        /// SetShowScrollSnapOverlays
        /// </summary>
        /// <param name = "scrollSnapHighlightConfigs">An array of node identifiers and descriptors for the highlight appearance.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowScrollSnapOverlaysAsync(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.ScrollSnapHighlightConfig> scrollSnapHighlightConfigs)
        {
            ValidateSetShowScrollSnapOverlays(scrollSnapHighlightConfigs);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scrollSnapHighlightConfigs", scrollSnapHighlightConfigs.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowScrollSnapOverlays", dict);
        }

        partial void ValidateSetShowContainerQueryOverlays(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.ContainerQueryHighlightConfig> containerQueryHighlightConfigs);
        /// <summary>
        /// SetShowContainerQueryOverlays
        /// </summary>
        /// <param name = "containerQueryHighlightConfigs">An array of node identifiers and descriptors for the highlight appearance.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowContainerQueryOverlaysAsync(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.ContainerQueryHighlightConfig> containerQueryHighlightConfigs)
        {
            ValidateSetShowContainerQueryOverlays(containerQueryHighlightConfigs);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("containerQueryHighlightConfigs", containerQueryHighlightConfigs.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowContainerQueryOverlays", dict);
        }

        partial void ValidateSetShowPaintRects(bool result);
        /// <summary>
        /// Requests that backend shows paint rectangles
        /// </summary>
        /// <param name = "result">True for showing paint rectangles</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowPaintRectsAsync(bool result)
        {
            ValidateSetShowPaintRects(result);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("result", result);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowPaintRects", dict);
        }

        partial void ValidateSetShowLayoutShiftRegions(bool result);
        /// <summary>
        /// Requests that backend shows layout shift regions
        /// </summary>
        /// <param name = "result">True for showing layout shift regions</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowLayoutShiftRegionsAsync(bool result)
        {
            ValidateSetShowLayoutShiftRegions(result);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("result", result);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowLayoutShiftRegions", dict);
        }

        partial void ValidateSetShowScrollBottleneckRects(bool show);
        /// <summary>
        /// Requests that backend shows scroll bottleneck rects
        /// </summary>
        /// <param name = "show">True for showing scroll bottleneck rects</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowScrollBottleneckRectsAsync(bool show)
        {
            ValidateSetShowScrollBottleneckRects(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowScrollBottleneckRects", dict);
        }

        partial void ValidateSetShowWebVitals(bool show);
        /// <summary>
        /// Request that backend shows an overlay with web vital metrics.
        /// </summary>
        /// <param name = "show">show</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowWebVitalsAsync(bool show)
        {
            ValidateSetShowWebVitals(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowWebVitals", dict);
        }

        partial void ValidateSetShowViewportSizeOnResize(bool show);
        /// <summary>
        /// Paints viewport size upon main frame resize.
        /// </summary>
        /// <param name = "show">Whether to paint size or not.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowViewportSizeOnResizeAsync(bool show)
        {
            ValidateSetShowViewportSizeOnResize(show);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("show", show);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowViewportSizeOnResize", dict);
        }

        partial void ValidateSetShowHinge(CefSharp.DevTools.Overlay.HingeConfig hingeConfig = null);
        /// <summary>
        /// Add a dual screen device hinge
        /// </summary>
        /// <param name = "hingeConfig">hinge data, null means hideHinge</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowHingeAsync(CefSharp.DevTools.Overlay.HingeConfig hingeConfig = null)
        {
            ValidateSetShowHinge(hingeConfig);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((hingeConfig) != (null))
            {
                dict.Add("hingeConfig", hingeConfig.ToDictionary());
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowHinge", dict);
        }

        partial void ValidateSetShowIsolatedElements(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.IsolatedElementHighlightConfig> isolatedElementHighlightConfigs);
        /// <summary>
        /// Show elements in isolation mode with overlays.
        /// </summary>
        /// <param name = "isolatedElementHighlightConfigs">An array of node identifiers and descriptors for the highlight appearance.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetShowIsolatedElementsAsync(System.Collections.Generic.IList<CefSharp.DevTools.Overlay.IsolatedElementHighlightConfig> isolatedElementHighlightConfigs)
        {
            ValidateSetShowIsolatedElements(isolatedElementHighlightConfigs);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("isolatedElementHighlightConfigs", isolatedElementHighlightConfigs.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Overlay.setShowIsolatedElements", dict);
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// AddScriptToEvaluateOnNewDocumentResponse
    /// </summary>
    public class AddScriptToEvaluateOnNewDocumentResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// identifier
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("identifier")]
        public string Identifier
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// CaptureScreenshotResponse
    /// </summary>
    public class CaptureScreenshotResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// data
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        public byte[] Data
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// CaptureSnapshotResponse
    /// </summary>
    public class CaptureSnapshotResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// data
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        public string Data
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// CreateIsolatedWorldResponse
    /// </summary>
    public class CreateIsolatedWorldResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// executionContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("executionContextId")]
        public int ExecutionContextId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetAppManifestResponse
    /// </summary>
    public class GetAppManifestResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// url
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("url")]
        public string Url
        {
            get;
            private set;
        }

        /// <summary>
        /// errors
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errors")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.AppManifestError> Errors
        {
            get;
            private set;
        }

        /// <summary>
        /// data
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        public string Data
        {
            get;
            private set;
        }

        /// <summary>
        /// parsed
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("parsed")]
        public CefSharp.DevTools.Page.AppManifestParsedProperties Parsed
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetInstallabilityErrorsResponse
    /// </summary>
    public class GetInstallabilityErrorsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// installabilityErrors
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("installabilityErrors")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.InstallabilityError> InstallabilityErrors
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetAppIdResponse
    /// </summary>
    public class GetAppIdResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// appId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("appId")]
        public string AppId
        {
            get;
            private set;
        }

        /// <summary>
        /// recommendedId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("recommendedId")]
        public string RecommendedId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetAdScriptIdResponse
    /// </summary>
    public class GetAdScriptIdResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// adScriptId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("adScriptId")]
        public CefSharp.DevTools.Page.AdScriptId AdScriptId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetFrameTreeResponse
    /// </summary>
    public class GetFrameTreeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// frameTree
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameTree")]
        public CefSharp.DevTools.Page.FrameTree FrameTree
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetLayoutMetricsResponse
    /// </summary>
    public class GetLayoutMetricsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// layoutViewport
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("layoutViewport")]
        public CefSharp.DevTools.Page.LayoutViewport LayoutViewport
        {
            get;
            private set;
        }

        /// <summary>
        /// visualViewport
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("visualViewport")]
        public CefSharp.DevTools.Page.VisualViewport VisualViewport
        {
            get;
            private set;
        }

        /// <summary>
        /// contentSize
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("contentSize")]
        public CefSharp.DevTools.DOM.Rect ContentSize
        {
            get;
            private set;
        }

        /// <summary>
        /// cssLayoutViewport
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cssLayoutViewport")]
        public CefSharp.DevTools.Page.LayoutViewport CssLayoutViewport
        {
            get;
            private set;
        }

        /// <summary>
        /// cssVisualViewport
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cssVisualViewport")]
        public CefSharp.DevTools.Page.VisualViewport CssVisualViewport
        {
            get;
            private set;
        }

        /// <summary>
        /// cssContentSize
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cssContentSize")]
        public CefSharp.DevTools.DOM.Rect CssContentSize
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetNavigationHistoryResponse
    /// </summary>
    public class GetNavigationHistoryResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// currentIndex
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("currentIndex")]
        public int CurrentIndex
        {
            get;
            private set;
        }

        /// <summary>
        /// entries
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("entries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.NavigationEntry> Entries
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetResourceContentResponse
    /// </summary>
    public class GetResourceContentResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// content
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("content")]
        public string Content
        {
            get;
            private set;
        }

        /// <summary>
        /// base64Encoded
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("base64Encoded")]
        public bool Base64Encoded
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetResourceTreeResponse
    /// </summary>
    public class GetResourceTreeResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// frameTree
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameTree")]
        public CefSharp.DevTools.Page.FrameResourceTree FrameTree
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// NavigateResponse
    /// </summary>
    public class NavigateResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// frameId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("frameId")]
        public string FrameId
        {
            get;
            private set;
        }

        /// <summary>
        /// loaderId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("loaderId")]
        public string LoaderId
        {
            get;
            private set;
        }

        /// <summary>
        /// errorText
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("errorText")]
        public string ErrorText
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// PrintToPDFResponse
    /// </summary>
    public class PrintToPDFResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// data
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("data")]
        public byte[] Data
        {
            get;
            private set;
        }

        /// <summary>
        /// stream
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stream")]
        public string Stream
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// SearchInResourceResponse
    /// </summary>
    public class SearchInResourceResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.SearchMatch> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetPermissionsPolicyStateResponse
    /// </summary>
    public class GetPermissionsPolicyStateResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// states
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("states")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.PermissionsPolicyFeatureState> States
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    /// <summary>
    /// GetOriginTrialsResponse
    /// </summary>
    public class GetOriginTrialsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// originTrials
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("originTrials")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Page.OriginTrial> OriginTrials
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Page
{
    using System.Linq;

    /// <summary>
    /// Image compression format (defaults to png).
    /// </summary>
    public enum CaptureScreenshotFormat
    {
        /// <summary>
        /// jpeg
        /// </summary>
        [JsonPropertyName("jpeg")]
        Jpeg,
        /// <summary>
        /// png
        /// </summary>
        [JsonPropertyName("png")]
        Png,
        /// <summary>
        /// webp
        /// </summary>
        [JsonPropertyName("webp")]
        Webp
    }

    /// <summary>
    /// Format (defaults to mhtml).
    /// </summary>
    public enum CaptureSnapshotFormat
    {
        /// <summary>
        /// mhtml
        /// </summary>
        [JsonPropertyName("mhtml")]
        Mhtml
    }

    /// <summary>
    /// return as stream
    /// </summary>
    public enum PrintToPDFTransferMode
    {
        /// <summary>
        /// ReturnAsBase64
        /// </summary>
        [JsonPropertyName("ReturnAsBase64")]
        ReturnAsBase64,
        /// <summary>
        /// ReturnAsStream
        /// </summary>
        [JsonPropertyName("ReturnAsStream")]
        ReturnAsStream
    }

    /// <summary>
    /// Image compression format.
    /// </summary>
    public enum StartScreencastFormat
    {
        /// <summary>
        /// jpeg
        /// </summary>
        [JsonPropertyName("jpeg")]
        Jpeg,
        /// <summary>
        /// png
        /// </summary>
        [JsonPropertyName("png")]
        Png
    }

    /// <summary>
    /// Target lifecycle state
    /// </summary>
    public enum SetWebLifecycleStateState
    {
        /// <summary>
        /// frozen
        /// </summary>
        [JsonPropertyName("frozen")]
        Frozen,
        /// <summary>
        /// active
        /// </summary>
        [JsonPropertyName("active")]
        Active
    }

    /// <summary>
    /// Actions and events related to the inspected page belong to the page domain.
    /// </summary>
    public partial class PageClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Page
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public PageClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// DomContentEventFired
        /// </summary>
        public event System.EventHandler<DomContentEventFiredEventArgs> DomContentEventFired
        {
            add
            {
                _client.AddEventHandler<DomContentEventFiredEventArgs>("Page.domContentEventFired", value);
            }

            remove
            {
                _client.RemoveEventHandler<DomContentEventFiredEventArgs>("Page.domContentEventFired", value);
            }
        }

        /// <summary>
        /// Emitted only when `page.interceptFileChooser` is enabled.
        /// </summary>
        public event System.EventHandler<FileChooserOpenedEventArgs> FileChooserOpened
        {
            add
            {
                _client.AddEventHandler<FileChooserOpenedEventArgs>("Page.fileChooserOpened", value);
            }

            remove
            {
                _client.RemoveEventHandler<FileChooserOpenedEventArgs>("Page.fileChooserOpened", value);
            }
        }

        /// <summary>
        /// Fired when frame has been attached to its parent.
        /// </summary>
        public event System.EventHandler<FrameAttachedEventArgs> FrameAttached
        {
            add
            {
                _client.AddEventHandler<FrameAttachedEventArgs>("Page.frameAttached", value);
            }

            remove
            {
                _client.RemoveEventHandler<FrameAttachedEventArgs>("Page.frameAttached", value);
            }
        }

        /// <summary>
        /// Fired when frame has been detached from its parent.
        /// </summary>
        public event System.EventHandler<FrameDetachedEventArgs> FrameDetached
        {
            add
            {
                _client.AddEventHandler<FrameDetachedEventArgs>("Page.frameDetached", value);
            }

            remove
            {
                _client.RemoveEventHandler<FrameDetachedEventArgs>("Page.frameDetached", value);
            }
        }

        /// <summary>
        /// Fired once navigation of the frame has completed. Frame is now associated with the new loader.
        /// </summary>
        public event System.EventHandler<FrameNavigatedEventArgs> FrameNavigated
        {
            add
            {
                _client.AddEventHandler<FrameNavigatedEventArgs>("Page.frameNavigated", value);
            }

            remove
            {
                _client.RemoveEventHandler<FrameNavigatedEventArgs>("Page.frameNavigated", value);
            }
        }

        /// <summary>
        /// Fired when opening document to write to.
        /// </summary>
        public event System.EventHandler<DocumentOpenedEventArgs> DocumentOpened
        {
            add
            {
                _client.AddEventHandler<DocumentOpenedEventArgs>("Page.documentOpened", value);
            }

            remove
            {
                _client.RemoveEventHandler<DocumentOpenedEventArgs>("Page.documentOpened", value);
            }
        }

        /// <summary>
        /// FrameResized
        /// </summary>
        public event System.EventHandler<System.EventArgs> FrameResized
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Page.frameResized", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Page.frameResized", value);
            }
        }

        /// <summary>
        /// Fired when a renderer-initiated navigation is requested.
        /// Navigation may still be cancelled after the event is issued.
        /// </summary>
        public event System.EventHandler<FrameRequestedNavigationEventArgs> FrameRequestedNavigation
        {
            add
            {
                _client.AddEventHandler<FrameRequestedNavigationEventArgs>("Page.frameRequestedNavigation", value);
            }

            remove
            {
                _client.RemoveEventHandler<FrameRequestedNavigationEventArgs>("Page.frameRequestedNavigation", value);
            }
        }

        /// <summary>
        /// Fired when frame has started loading.
        /// </summary>
        public event System.EventHandler<FrameStartedLoadingEventArgs> FrameStartedLoading
        {
            add
            {
                _client.AddEventHandler<FrameStartedLoadingEventArgs>("Page.frameStartedLoading", value);
            }

            remove
            {
                _client.RemoveEventHandler<FrameStartedLoadingEventArgs>("Page.frameStartedLoading", value);
            }
        }

        /// <summary>
        /// Fired when frame has stopped loading.
        /// </summary>
        public event System.EventHandler<FrameStoppedLoadingEventArgs> FrameStoppedLoading
        {
            add
            {
                _client.AddEventHandler<FrameStoppedLoadingEventArgs>("Page.frameStoppedLoading", value);
            }

            remove
            {
                _client.RemoveEventHandler<FrameStoppedLoadingEventArgs>("Page.frameStoppedLoading", value);
            }
        }

        /// <summary>
        /// Fired when interstitial page was hidden
        /// </summary>
        public event System.EventHandler<System.EventArgs> InterstitialHidden
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Page.interstitialHidden", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Page.interstitialHidden", value);
            }
        }

        /// <summary>
        /// Fired when interstitial page was shown
        /// </summary>
        public event System.EventHandler<System.EventArgs> InterstitialShown
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Page.interstitialShown", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Page.interstitialShown", value);
            }
        }

        /// <summary>
        /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
        /// closed.
        /// </summary>
        public event System.EventHandler<JavascriptDialogClosedEventArgs> JavascriptDialogClosed
        {
            add
            {
                _client.AddEventHandler<JavascriptDialogClosedEventArgs>("Page.javascriptDialogClosed", value);
            }

            remove
            {
                _client.RemoveEventHandler<JavascriptDialogClosedEventArgs>("Page.javascriptDialogClosed", value);
            }
        }

        /// <summary>
        /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
        /// open.
        /// </summary>
        public event System.EventHandler<JavascriptDialogOpeningEventArgs> JavascriptDialogOpening
        {
            add
            {
                _client.AddEventHandler<JavascriptDialogOpeningEventArgs>("Page.javascriptDialogOpening", value);
            }

            remove
            {
                _client.RemoveEventHandler<JavascriptDialogOpeningEventArgs>("Page.javascriptDialogOpening", value);
            }
        }

        /// <summary>
        /// Fired for top level page lifecycle events such as navigation, load, paint, etc.
        /// </summary>
        public event System.EventHandler<LifecycleEventEventArgs> LifecycleEvent
        {
            add
            {
                _client.AddEventHandler<LifecycleEventEventArgs>("Page.lifecycleEvent", value);
            }

            remove
            {
                _client.RemoveEventHandler<LifecycleEventEventArgs>("Page.lifecycleEvent", value);
            }
        }

        /// <summary>
        /// Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
        /// not assume any ordering with the Page.frameNavigated event. This event is fired only for
        /// main-frame history navigation where the document changes (non-same-document navigations),
        /// when bfcache navigation fails.
        /// </summary>
        public event System.EventHandler<BackForwardCacheNotUsedEventArgs> BackForwardCacheNotUsed
        {
            add
            {
                _client.AddEventHandler<BackForwardCacheNotUsedEventArgs>("Page.backForwardCacheNotUsed", value);
            }

            remove
            {
                _client.RemoveEventHandler<BackForwardCacheNotUsedEventArgs>("Page.backForwardCacheNotUsed", value);
            }
        }

        /// <summary>
        /// LoadEventFired
        /// </summary>
        public event System.EventHandler<LoadEventFiredEventArgs> LoadEventFired
        {
            add
            {
                _client.AddEventHandler<LoadEventFiredEventArgs>("Page.loadEventFired", value);
            }

            remove
            {
                _client.RemoveEventHandler<LoadEventFiredEventArgs>("Page.loadEventFired", value);
            }
        }

        /// <summary>
        /// Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
        /// </summary>
        public event System.EventHandler<NavigatedWithinDocumentEventArgs> NavigatedWithinDocument
        {
            add
            {
                _client.AddEventHandler<NavigatedWithinDocumentEventArgs>("Page.navigatedWithinDocument", value);
            }

            remove
            {
                _client.RemoveEventHandler<NavigatedWithinDocumentEventArgs>("Page.navigatedWithinDocument", value);
            }
        }

        /// <summary>
        /// Compressed image data requested by the `startScreencast`.
        /// </summary>
        public event System.EventHandler<ScreencastFrameEventArgs> ScreencastFrame
        {
            add
            {
                _client.AddEventHandler<ScreencastFrameEventArgs>("Page.screencastFrame", value);
            }

            remove
            {
                _client.RemoveEventHandler<ScreencastFrameEventArgs>("Page.screencastFrame", value);
            }
        }

        /// <summary>
        /// Fired when the page with currently enabled screencast was shown or hidden `.
        /// </summary>
        public event System.EventHandler<ScreencastVisibilityChangedEventArgs> ScreencastVisibilityChanged
        {
            add
            {
                _client.AddEventHandler<ScreencastVisibilityChangedEventArgs>("Page.screencastVisibilityChanged", value);
            }

            remove
            {
                _client.RemoveEventHandler<ScreencastVisibilityChangedEventArgs>("Page.screencastVisibilityChanged", value);
            }
        }

        /// <summary>
        /// Fired when a new window is going to be opened, via window.open(), link click, form submission,
        /// etc.
        /// </summary>
        public event System.EventHandler<WindowOpenEventArgs> WindowOpen
        {
            add
            {
                _client.AddEventHandler<WindowOpenEventArgs>("Page.windowOpen", value);
            }

            remove
            {
                _client.RemoveEventHandler<WindowOpenEventArgs>("Page.windowOpen", value);
            }
        }

        /// <summary>
        /// Issued for every compilation cache generated. Is only available
        /// if Page.setGenerateCompilationCache is enabled.
        /// </summary>
        public event System.EventHandler<CompilationCacheProducedEventArgs> CompilationCacheProduced
        {
            add
            {
                _client.AddEventHandler<CompilationCacheProducedEventArgs>("Page.compilationCacheProduced", value);
            }

            remove
            {
                _client.RemoveEventHandler<CompilationCacheProducedEventArgs>("Page.compilationCacheProduced", value);
            }
        }

        partial void ValidateAddScriptToEvaluateOnNewDocument(string source, string worldName = null, bool? includeCommandLineAPI = null);
        /// <summary>
        /// Evaluates given script in every frame upon creation (before loading frame&apos;s scripts).
        /// </summary>
        /// <param name = "source">source</param>
        /// <param name = "worldName">If specified, creates an isolated world with the given name and evaluates given script in it.This world name will be used as the ExecutionContextDescription::name when the correspondingevent is emitted.</param>
        /// <param name = "includeCommandLineAPI">Specifies whether command line API should be available to the script, defaultsto false.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AddScriptToEvaluateOnNewDocumentResponse&gt;</returns>
        public System.Threading.Tasks.Task<AddScriptToEvaluateOnNewDocumentResponse> AddScriptToEvaluateOnNewDocumentAsync(string source, string worldName = null, bool? includeCommandLineAPI = null)
        {
            ValidateAddScriptToEvaluateOnNewDocument(source, worldName, includeCommandLineAPI);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("source", source);
            if (!(string.IsNullOrEmpty(worldName)))
            {
                dict.Add("worldName", worldName);
            }

            if (includeCommandLineAPI.HasValue)
            {
                dict.Add("includeCommandLineAPI", includeCommandLineAPI.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<AddScriptToEvaluateOnNewDocumentResponse>("Page.addScriptToEvaluateOnNewDocument", dict);
        }

        /// <summary>
        /// Brings page to front (activates tab).
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> BringToFrontAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.bringToFront", dict);
        }

        partial void ValidateCaptureScreenshot(CefSharp.DevTools.Page.CaptureScreenshotFormat? format = null, int? quality = null, CefSharp.DevTools.Page.Viewport clip = null, bool? fromSurface = null, bool? captureBeyondViewport = null, bool? optimizeForSpeed = null);
        /// <summary>
        /// Capture page screenshot.
        /// </summary>
        /// <param name = "format">Image compression format (defaults to png).</param>
        /// <param name = "quality">Compression quality from range [0..100] (jpeg only).</param>
        /// <param name = "clip">Capture the screenshot of a given region only.</param>
        /// <param name = "fromSurface">Capture the screenshot from the surface, rather than the view. Defaults to true.</param>
        /// <param name = "captureBeyondViewport">Capture the screenshot beyond the viewport. Defaults to false.</param>
        /// <param name = "optimizeForSpeed">Optimize image encoding for speed, not for resulting size (defaults to false)</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CaptureScreenshotResponse&gt;</returns>
        public System.Threading.Tasks.Task<CaptureScreenshotResponse> CaptureScreenshotAsync(CefSharp.DevTools.Page.CaptureScreenshotFormat? format = null, int? quality = null, CefSharp.DevTools.Page.Viewport clip = null, bool? fromSurface = null, bool? captureBeyondViewport = null, bool? optimizeForSpeed = null)
        {
            ValidateCaptureScreenshot(format, quality, clip, fromSurface, captureBeyondViewport, optimizeForSpeed);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (format.HasValue)
            {
                dict.Add("format", EnumToString(format));
            }

            if (quality.HasValue)
            {
                dict.Add("quality", quality.Value);
            }

            if ((clip) != (null))
            {
                dict.Add("clip", clip.ToDictionary());
            }

            if (fromSurface.HasValue)
            {
                dict.Add("fromSurface", fromSurface.Value);
            }

            if (captureBeyondViewport.HasValue)
            {
                dict.Add("captureBeyondViewport", captureBeyondViewport.Value);
            }

            if (optimizeForSpeed.HasValue)
            {
                dict.Add("optimizeForSpeed", optimizeForSpeed.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<CaptureScreenshotResponse>("Page.captureScreenshot", dict);
        }

        partial void ValidateCaptureSnapshot(CefSharp.DevTools.Page.CaptureSnapshotFormat? format = null);
        /// <summary>
        /// Returns a snapshot of the page as a string. For MHTML format, the serialization includes
        /// iframes, shadow DOM, external resources, and element-inline styles.
        /// </summary>
        /// <param name = "format">Format (defaults to mhtml).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CaptureSnapshotResponse&gt;</returns>
        public System.Threading.Tasks.Task<CaptureSnapshotResponse> CaptureSnapshotAsync(CefSharp.DevTools.Page.CaptureSnapshotFormat? format = null)
        {
            ValidateCaptureSnapshot(format);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (format.HasValue)
            {
                dict.Add("format", EnumToString(format));
            }

            return _client.ExecuteDevToolsMethodAsync<CaptureSnapshotResponse>("Page.captureSnapshot", dict);
        }

        partial void ValidateCreateIsolatedWorld(string frameId, string worldName = null, bool? grantUniveralAccess = null);
        /// <summary>
        /// Creates an isolated world for the given frame.
        /// </summary>
        /// <param name = "frameId">Id of the frame in which the isolated world should be created.</param>
        /// <param name = "worldName">An optional name which is reported in the Execution Context.</param>
        /// <param name = "grantUniveralAccess">Whether or not universal access should be granted to the isolated world. This is a powerfuloption, use with caution.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CreateIsolatedWorldResponse&gt;</returns>
        public System.Threading.Tasks.Task<CreateIsolatedWorldResponse> CreateIsolatedWorldAsync(string frameId, string worldName = null, bool? grantUniveralAccess = null)
        {
            ValidateCreateIsolatedWorld(frameId, worldName, grantUniveralAccess);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            if (!(string.IsNullOrEmpty(worldName)))
            {
                dict.Add("worldName", worldName);
            }

            if (grantUniveralAccess.HasValue)
            {
                dict.Add("grantUniveralAccess", grantUniveralAccess.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<CreateIsolatedWorldResponse>("Page.createIsolatedWorld", dict);
        }

        /// <summary>
        /// Disables page domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.disable", dict);
        }

        /// <summary>
        /// Enables page domain notifications.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.enable", dict);
        }

        /// <summary>
        /// GetAppManifest
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAppManifestResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetAppManifestResponse> GetAppManifestAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetAppManifestResponse>("Page.getAppManifest", dict);
        }

        /// <summary>
        /// GetInstallabilityErrors
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetInstallabilityErrorsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetInstallabilityErrorsResponse> GetInstallabilityErrorsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetInstallabilityErrorsResponse>("Page.getInstallabilityErrors", dict);
        }

        /// <summary>
        /// Returns the unique (PWA) app id.
        /// Only returns values if the feature flag &apos;WebAppEnableManifestId&apos; is enabled
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAppIdResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetAppIdResponse> GetAppIdAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetAppIdResponse>("Page.getAppId", dict);
        }

        partial void ValidateGetAdScriptId(string frameId);
        /// <summary>
        /// GetAdScriptId
        /// </summary>
        /// <param name = "frameId">frameId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetAdScriptIdResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetAdScriptIdResponse> GetAdScriptIdAsync(string frameId)
        {
            ValidateGetAdScriptId(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            return _client.ExecuteDevToolsMethodAsync<GetAdScriptIdResponse>("Page.getAdScriptId", dict);
        }

        /// <summary>
        /// Returns present frame tree structure.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFrameTreeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetFrameTreeResponse> GetFrameTreeAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetFrameTreeResponse>("Page.getFrameTree", dict);
        }

        /// <summary>
        /// Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetLayoutMetricsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetLayoutMetricsResponse> GetLayoutMetricsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetLayoutMetricsResponse>("Page.getLayoutMetrics", dict);
        }

        /// <summary>
        /// Returns navigation history for the current page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetNavigationHistoryResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetNavigationHistoryResponse> GetNavigationHistoryAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetNavigationHistoryResponse>("Page.getNavigationHistory", dict);
        }

        /// <summary>
        /// Resets navigation history for the current page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ResetNavigationHistoryAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.resetNavigationHistory", dict);
        }

        partial void ValidateGetResourceContent(string frameId, string url);
        /// <summary>
        /// Returns content of the given resource.
        /// </summary>
        /// <param name = "frameId">Frame id to get resource for.</param>
        /// <param name = "url">URL of the resource to get content for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResourceContentResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetResourceContentResponse> GetResourceContentAsync(string frameId, string url)
        {
            ValidateGetResourceContent(frameId, url);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            dict.Add("url", url);
            return _client.ExecuteDevToolsMethodAsync<GetResourceContentResponse>("Page.getResourceContent", dict);
        }

        /// <summary>
        /// Returns present frame / resource tree structure.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResourceTreeResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetResourceTreeResponse> GetResourceTreeAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetResourceTreeResponse>("Page.getResourceTree", dict);
        }

        partial void ValidateHandleJavaScriptDialog(bool accept, string promptText = null);
        /// <summary>
        /// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
        /// </summary>
        /// <param name = "accept">Whether to accept or dismiss the dialog.</param>
        /// <param name = "promptText">The text to enter into the dialog prompt before accepting. Used only if this is a promptdialog.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> HandleJavaScriptDialogAsync(bool accept, string promptText = null)
        {
            ValidateHandleJavaScriptDialog(accept, promptText);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("accept", accept);
            if (!(string.IsNullOrEmpty(promptText)))
            {
                dict.Add("promptText", promptText);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.handleJavaScriptDialog", dict);
        }

        partial void ValidateNavigate(string url, string referrer = null, CefSharp.DevTools.Page.TransitionType? transitionType = null, string frameId = null, CefSharp.DevTools.Page.ReferrerPolicy? referrerPolicy = null);
        /// <summary>
        /// Navigates current page to the given URL.
        /// </summary>
        /// <param name = "url">URL to navigate the page to.</param>
        /// <param name = "referrer">Referrer URL.</param>
        /// <param name = "transitionType">Intended transition type.</param>
        /// <param name = "frameId">Frame id to navigate, if not specified navigates the top frame.</param>
        /// <param name = "referrerPolicy">Referrer-policy used for the navigation.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;NavigateResponse&gt;</returns>
        public System.Threading.Tasks.Task<NavigateResponse> NavigateAsync(string url, string referrer = null, CefSharp.DevTools.Page.TransitionType? transitionType = null, string frameId = null, CefSharp.DevTools.Page.ReferrerPolicy? referrerPolicy = null)
        {
            ValidateNavigate(url, referrer, transitionType, frameId, referrerPolicy);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            if (!(string.IsNullOrEmpty(referrer)))
            {
                dict.Add("referrer", referrer);
            }

            if (transitionType.HasValue)
            {
                dict.Add("transitionType", EnumToString(transitionType));
            }

            if (!(string.IsNullOrEmpty(frameId)))
            {
                dict.Add("frameId", frameId);
            }

            if (referrerPolicy.HasValue)
            {
                dict.Add("referrerPolicy", EnumToString(referrerPolicy));
            }

            return _client.ExecuteDevToolsMethodAsync<NavigateResponse>("Page.navigate", dict);
        }

        partial void ValidateNavigateToHistoryEntry(int entryId);
        /// <summary>
        /// Navigates current page to the given history entry.
        /// </summary>
        /// <param name = "entryId">Unique id of the entry to navigate to.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> NavigateToHistoryEntryAsync(int entryId)
        {
            ValidateNavigateToHistoryEntry(entryId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("entryId", entryId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.navigateToHistoryEntry", dict);
        }

        partial void ValidatePrintToPDF(bool? landscape = null, bool? displayHeaderFooter = null, bool? printBackground = null, double? scale = null, double? paperWidth = null, double? paperHeight = null, double? marginTop = null, double? marginBottom = null, double? marginLeft = null, double? marginRight = null, string pageRanges = null, string headerTemplate = null, string footerTemplate = null, bool? preferCSSPageSize = null, CefSharp.DevTools.Page.PrintToPDFTransferMode? transferMode = null);
        /// <summary>
        /// Print page as PDF.
        /// </summary>
        /// <param name = "landscape">Paper orientation. Defaults to false.</param>
        /// <param name = "displayHeaderFooter">Display header and footer. Defaults to false.</param>
        /// <param name = "printBackground">Print background graphics. Defaults to false.</param>
        /// <param name = "scale">Scale of the webpage rendering. Defaults to 1.</param>
        /// <param name = "paperWidth">Paper width in inches. Defaults to 8.5 inches.</param>
        /// <param name = "paperHeight">Paper height in inches. Defaults to 11 inches.</param>
        /// <param name = "marginTop">Top margin in inches. Defaults to 1cm (~0.4 inches).</param>
        /// <param name = "marginBottom">Bottom margin in inches. Defaults to 1cm (~0.4 inches).</param>
        /// <param name = "marginLeft">Left margin in inches. Defaults to 1cm (~0.4 inches).</param>
        /// <param name = "marginRight">Right margin in inches. Defaults to 1cm (~0.4 inches).</param>
        /// <param name = "pageRanges">Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages areprinted in the document order, not in the order specified, and nomore than once.Defaults to empty string, which implies the entire document is printed.The page numbers are quietly capped to actual page count of thedocument, and ranges beyond the end of the document are ignored.If this results in no pages to print, an error is reported.It is an error to specify a range with start greater than end.</param>
        /// <param name = "headerTemplate">HTML template for the print header. Should be valid HTML markup with followingclasses used to inject printing values into them:- `date`: formatted print date- `title`: document title- `url`: document location- `pageNumber`: current page number- `totalPages`: total pages in the documentFor example, `&lt;span class=title&gt; &lt;/span&gt;` would generate span containing the title.</param>
        /// <param name = "footerTemplate">HTML template for the print footer. Should use the same format as the `headerTemplate`.</param>
        /// <param name = "preferCSSPageSize">Whether or not to prefer page size as defined by css. Defaults to false,in which case the content will be scaled to fit the paper size.</param>
        /// <param name = "transferMode">return as stream</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;PrintToPDFResponse&gt;</returns>
        public System.Threading.Tasks.Task<PrintToPDFResponse> PrintToPDFAsync(bool? landscape = null, bool? displayHeaderFooter = null, bool? printBackground = null, double? scale = null, double? paperWidth = null, double? paperHeight = null, double? marginTop = null, double? marginBottom = null, double? marginLeft = null, double? marginRight = null, string pageRanges = null, string headerTemplate = null, string footerTemplate = null, bool? preferCSSPageSize = null, CefSharp.DevTools.Page.PrintToPDFTransferMode? transferMode = null)
        {
            ValidatePrintToPDF(landscape, displayHeaderFooter, printBackground, scale, paperWidth, paperHeight, marginTop, marginBottom, marginLeft, marginRight, pageRanges, headerTemplate, footerTemplate, preferCSSPageSize, transferMode);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (landscape.HasValue)
            {
                dict.Add("landscape", landscape.Value);
            }

            if (displayHeaderFooter.HasValue)
            {
                dict.Add("displayHeaderFooter", displayHeaderFooter.Value);
            }

            if (printBackground.HasValue)
            {
                dict.Add("printBackground", printBackground.Value);
            }

            if (scale.HasValue)
            {
                dict.Add("scale", scale.Value);
            }

            if (paperWidth.HasValue)
            {
                dict.Add("paperWidth", paperWidth.Value);
            }

            if (paperHeight.HasValue)
            {
                dict.Add("paperHeight", paperHeight.Value);
            }

            if (marginTop.HasValue)
            {
                dict.Add("marginTop", marginTop.Value);
            }

            if (marginBottom.HasValue)
            {
                dict.Add("marginBottom", marginBottom.Value);
            }

            if (marginLeft.HasValue)
            {
                dict.Add("marginLeft", marginLeft.Value);
            }

            if (marginRight.HasValue)
            {
                dict.Add("marginRight", marginRight.Value);
            }

            if (!(string.IsNullOrEmpty(pageRanges)))
            {
                dict.Add("pageRanges", pageRanges);
            }

            if (!(string.IsNullOrEmpty(headerTemplate)))
            {
                dict.Add("headerTemplate", headerTemplate);
            }

            if (!(string.IsNullOrEmpty(footerTemplate)))
            {
                dict.Add("footerTemplate", footerTemplate);
            }

            if (preferCSSPageSize.HasValue)
            {
                dict.Add("preferCSSPageSize", preferCSSPageSize.Value);
            }

            if (transferMode.HasValue)
            {
                dict.Add("transferMode", EnumToString(transferMode));
            }

            return _client.ExecuteDevToolsMethodAsync<PrintToPDFResponse>("Page.printToPDF", dict);
        }

        partial void ValidateReload(bool? ignoreCache = null, string scriptToEvaluateOnLoad = null);
        /// <summary>
        /// Reloads given page optionally ignoring the cache.
        /// </summary>
        /// <param name = "ignoreCache">If true, browser cache is ignored (as if the user pressed Shift+refresh).</param>
        /// <param name = "scriptToEvaluateOnLoad">If set, the script will be injected into all frames of the inspected page after reload.Argument will be ignored if reloading dataURL origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ReloadAsync(bool? ignoreCache = null, string scriptToEvaluateOnLoad = null)
        {
            ValidateReload(ignoreCache, scriptToEvaluateOnLoad);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (ignoreCache.HasValue)
            {
                dict.Add("ignoreCache", ignoreCache.Value);
            }

            if (!(string.IsNullOrEmpty(scriptToEvaluateOnLoad)))
            {
                dict.Add("scriptToEvaluateOnLoad", scriptToEvaluateOnLoad);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.reload", dict);
        }

        partial void ValidateRemoveScriptToEvaluateOnNewDocument(string identifier);
        /// <summary>
        /// Removes given script from the list.
        /// </summary>
        /// <param name = "identifier">identifier</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveScriptToEvaluateOnNewDocumentAsync(string identifier)
        {
            ValidateRemoveScriptToEvaluateOnNewDocument(identifier);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("identifier", identifier);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.removeScriptToEvaluateOnNewDocument", dict);
        }

        partial void ValidateScreencastFrameAck(int sessionId);
        /// <summary>
        /// Acknowledges that a screencast frame has been received by the frontend.
        /// </summary>
        /// <param name = "sessionId">Frame number.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ScreencastFrameAckAsync(int sessionId)
        {
            ValidateScreencastFrameAck(sessionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("sessionId", sessionId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.screencastFrameAck", dict);
        }

        partial void ValidateSearchInResource(string frameId, string url, string query, bool? caseSensitive = null, bool? isRegex = null);
        /// <summary>
        /// Searches for given string in resource content.
        /// </summary>
        /// <param name = "frameId">Frame id for resource to search in.</param>
        /// <param name = "url">URL of the resource to search in.</param>
        /// <param name = "query">String to search for.</param>
        /// <param name = "caseSensitive">If true, search is case sensitive.</param>
        /// <param name = "isRegex">If true, treats string parameter as regex.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SearchInResourceResponse&gt;</returns>
        public System.Threading.Tasks.Task<SearchInResourceResponse> SearchInResourceAsync(string frameId, string url, string query, bool? caseSensitive = null, bool? isRegex = null)
        {
            ValidateSearchInResource(frameId, url, query, caseSensitive, isRegex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            dict.Add("url", url);
            dict.Add("query", query);
            if (caseSensitive.HasValue)
            {
                dict.Add("caseSensitive", caseSensitive.Value);
            }

            if (isRegex.HasValue)
            {
                dict.Add("isRegex", isRegex.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<SearchInResourceResponse>("Page.searchInResource", dict);
        }

        partial void ValidateSetAdBlockingEnabled(bool enabled);
        /// <summary>
        /// Enable Chrome&apos;s experimental ad filter on all sites.
        /// </summary>
        /// <param name = "enabled">Whether to block ads.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAdBlockingEnabledAsync(bool enabled)
        {
            ValidateSetAdBlockingEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setAdBlockingEnabled", dict);
        }

        partial void ValidateSetBypassCSP(bool enabled);
        /// <summary>
        /// Enable page Content Security Policy by-passing.
        /// </summary>
        /// <param name = "enabled">Whether to bypass page CSP.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetBypassCSPAsync(bool enabled)
        {
            ValidateSetBypassCSP(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setBypassCSP", dict);
        }

        partial void ValidateGetPermissionsPolicyState(string frameId);
        /// <summary>
        /// Get Permissions Policy state on given frame.
        /// </summary>
        /// <param name = "frameId">frameId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPermissionsPolicyStateResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetPermissionsPolicyStateResponse> GetPermissionsPolicyStateAsync(string frameId)
        {
            ValidateGetPermissionsPolicyState(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            return _client.ExecuteDevToolsMethodAsync<GetPermissionsPolicyStateResponse>("Page.getPermissionsPolicyState", dict);
        }

        partial void ValidateGetOriginTrials(string frameId);
        /// <summary>
        /// Get Origin Trials on given frame.
        /// </summary>
        /// <param name = "frameId">frameId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetOriginTrialsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetOriginTrialsResponse> GetOriginTrialsAsync(string frameId)
        {
            ValidateGetOriginTrials(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            return _client.ExecuteDevToolsMethodAsync<GetOriginTrialsResponse>("Page.getOriginTrials", dict);
        }

        partial void ValidateSetFontFamilies(CefSharp.DevTools.Page.FontFamilies fontFamilies, System.Collections.Generic.IList<CefSharp.DevTools.Page.ScriptFontFamilies> forScripts = null);
        /// <summary>
        /// Set generic font families.
        /// </summary>
        /// <param name = "fontFamilies">Specifies font families to set. If a font family is not specified, it won't be changed.</param>
        /// <param name = "forScripts">Specifies font families to set for individual scripts.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetFontFamiliesAsync(CefSharp.DevTools.Page.FontFamilies fontFamilies, System.Collections.Generic.IList<CefSharp.DevTools.Page.ScriptFontFamilies> forScripts = null)
        {
            ValidateSetFontFamilies(fontFamilies, forScripts);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("fontFamilies", fontFamilies.ToDictionary());
            if ((forScripts) != (null))
            {
                dict.Add("forScripts", forScripts.Select(x => x.ToDictionary()));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setFontFamilies", dict);
        }

        partial void ValidateSetFontSizes(CefSharp.DevTools.Page.FontSizes fontSizes);
        /// <summary>
        /// Set default font sizes.
        /// </summary>
        /// <param name = "fontSizes">Specifies font sizes to set. If a font size is not specified, it won't be changed.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetFontSizesAsync(CefSharp.DevTools.Page.FontSizes fontSizes)
        {
            ValidateSetFontSizes(fontSizes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("fontSizes", fontSizes.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setFontSizes", dict);
        }

        partial void ValidateSetDocumentContent(string frameId, string html);
        /// <summary>
        /// Sets given markup as the document&apos;s HTML.
        /// </summary>
        /// <param name = "frameId">Frame id to set HTML for.</param>
        /// <param name = "html">HTML content to set.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDocumentContentAsync(string frameId, string html)
        {
            ValidateSetDocumentContent(frameId, html);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            dict.Add("html", html);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setDocumentContent", dict);
        }

        partial void ValidateSetLifecycleEventsEnabled(bool enabled);
        /// <summary>
        /// Controls whether page will emit lifecycle events.
        /// </summary>
        /// <param name = "enabled">If true, starts emitting lifecycle events.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetLifecycleEventsEnabledAsync(bool enabled)
        {
            ValidateSetLifecycleEventsEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setLifecycleEventsEnabled", dict);
        }

        partial void ValidateStartScreencast(CefSharp.DevTools.Page.StartScreencastFormat? format = null, int? quality = null, int? maxWidth = null, int? maxHeight = null, int? everyNthFrame = null);
        /// <summary>
        /// Starts sending each frame using the `screencastFrame` event.
        /// </summary>
        /// <param name = "format">Image compression format.</param>
        /// <param name = "quality">Compression quality from range [0..100].</param>
        /// <param name = "maxWidth">Maximum screenshot width.</param>
        /// <param name = "maxHeight">Maximum screenshot height.</param>
        /// <param name = "everyNthFrame">Send every n-th frame.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartScreencastAsync(CefSharp.DevTools.Page.StartScreencastFormat? format = null, int? quality = null, int? maxWidth = null, int? maxHeight = null, int? everyNthFrame = null)
        {
            ValidateStartScreencast(format, quality, maxWidth, maxHeight, everyNthFrame);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (format.HasValue)
            {
                dict.Add("format", EnumToString(format));
            }

            if (quality.HasValue)
            {
                dict.Add("quality", quality.Value);
            }

            if (maxWidth.HasValue)
            {
                dict.Add("maxWidth", maxWidth.Value);
            }

            if (maxHeight.HasValue)
            {
                dict.Add("maxHeight", maxHeight.Value);
            }

            if (everyNthFrame.HasValue)
            {
                dict.Add("everyNthFrame", everyNthFrame.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.startScreencast", dict);
        }

        /// <summary>
        /// Force the page stop all navigations and pending resource fetches.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopLoadingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.stopLoading", dict);
        }

        /// <summary>
        /// Crashes renderer on the IO thread, generates minidumps.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CrashAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.crash", dict);
        }

        /// <summary>
        /// Tries to close page, running its beforeunload hooks, if any.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CloseAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.close", dict);
        }

        partial void ValidateSetWebLifecycleState(CefSharp.DevTools.Page.SetWebLifecycleStateState state);
        /// <summary>
        /// Tries to update the web lifecycle state of the page.
        /// It will transition the page to the given state according to:
        /// https://github.com/WICG/web-lifecycle/
        /// </summary>
        /// <param name = "state">Target lifecycle state</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetWebLifecycleStateAsync(CefSharp.DevTools.Page.SetWebLifecycleStateState state)
        {
            ValidateSetWebLifecycleState(state);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("state", EnumToString(state));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setWebLifecycleState", dict);
        }

        /// <summary>
        /// Stops sending each frame in the `screencastFrame`.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopScreencastAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.stopScreencast", dict);
        }

        partial void ValidateProduceCompilationCache(System.Collections.Generic.IList<CefSharp.DevTools.Page.CompilationCacheParams> scripts);
        /// <summary>
        /// Requests backend to produce compilation cache for the specified scripts.
        /// `scripts` are appeneded to the list of scripts for which the cache
        /// would be produced. The list may be reset during page navigation.
        /// When script with a matching URL is encountered, the cache is optionally
        /// produced upon backend discretion, based on internal heuristics.
        /// See also: `Page.compilationCacheProduced`.
        /// </summary>
        /// <param name = "scripts">scripts</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ProduceCompilationCacheAsync(System.Collections.Generic.IList<CefSharp.DevTools.Page.CompilationCacheParams> scripts)
        {
            ValidateProduceCompilationCache(scripts);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scripts", scripts.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.produceCompilationCache", dict);
        }

        partial void ValidateAddCompilationCache(string url, byte[] data);
        /// <summary>
        /// Seeds compilation cache for given url. Compilation cache does not survive
        /// cross-process navigation.
        /// </summary>
        /// <param name = "url">url</param>
        /// <param name = "data">Base64-encoded data</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> AddCompilationCacheAsync(string url, byte[] data)
        {
            ValidateAddCompilationCache(url, data);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            dict.Add("data", ToBase64String(data));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.addCompilationCache", dict);
        }

        /// <summary>
        /// Clears seeded compilation cache.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearCompilationCacheAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.clearCompilationCache", dict);
        }

        partial void ValidateSetSPCTransactionMode(CefSharp.DevTools.Page.AutoResponseMode mode);
        /// <summary>
        /// Sets the Secure Payment Confirmation transaction mode.
        /// https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
        /// </summary>
        /// <param name = "mode">mode</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetSPCTransactionModeAsync(CefSharp.DevTools.Page.AutoResponseMode mode)
        {
            ValidateSetSPCTransactionMode(mode);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("mode", EnumToString(mode));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setSPCTransactionMode", dict);
        }

        partial void ValidateSetRPHRegistrationMode(CefSharp.DevTools.Page.AutoResponseMode mode);
        /// <summary>
        /// Extensions for Custom Handlers API:
        /// https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
        /// </summary>
        /// <param name = "mode">mode</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetRPHRegistrationModeAsync(CefSharp.DevTools.Page.AutoResponseMode mode)
        {
            ValidateSetRPHRegistrationMode(mode);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("mode", EnumToString(mode));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setRPHRegistrationMode", dict);
        }

        partial void ValidateGenerateTestReport(string message, string group = null);
        /// <summary>
        /// Generates a report for testing.
        /// </summary>
        /// <param name = "message">Message to be displayed in the report.</param>
        /// <param name = "group">Specifies the endpoint group to deliver the report to.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> GenerateTestReportAsync(string message, string group = null)
        {
            ValidateGenerateTestReport(message, group);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("message", message);
            if (!(string.IsNullOrEmpty(group)))
            {
                dict.Add("group", group);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.generateTestReport", dict);
        }

        /// <summary>
        /// Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> WaitForDebuggerAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.waitForDebugger", dict);
        }

        partial void ValidateSetInterceptFileChooserDialog(bool enabled);
        /// <summary>
        /// Intercept file chooser requests and transfer control to protocol clients.
        /// When file chooser interception is enabled, native file chooser dialog is not shown.
        /// Instead, a protocol event `Page.fileChooserOpened` is emitted.
        /// </summary>
        /// <param name = "enabled">enabled</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetInterceptFileChooserDialogAsync(bool enabled)
        {
            ValidateSetInterceptFileChooserDialog(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Page.setInterceptFileChooserDialog", dict);
        }
    }
}

namespace CefSharp.DevTools.Performance
{
    /// <summary>
    /// GetMetricsResponse
    /// </summary>
    public class GetMetricsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// metrics
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("metrics")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Performance.Metric> Metrics
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Performance
{
    using System.Linq;

    /// <summary>
    /// Time domain to use for collecting and reporting duration metrics.
    /// </summary>
    public enum EnableTimeDomain
    {
        /// <summary>
        /// timeTicks
        /// </summary>
        [JsonPropertyName("timeTicks")]
        TimeTicks,
        /// <summary>
        /// threadTicks
        /// </summary>
        [JsonPropertyName("threadTicks")]
        ThreadTicks
    }

    /// <summary>
    /// Performance
    /// </summary>
    public partial class PerformanceClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Performance
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public PerformanceClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Current values of the metrics.
        /// </summary>
        public event System.EventHandler<MetricsEventArgs> Metrics
        {
            add
            {
                _client.AddEventHandler<MetricsEventArgs>("Performance.metrics", value);
            }

            remove
            {
                _client.RemoveEventHandler<MetricsEventArgs>("Performance.metrics", value);
            }
        }

        /// <summary>
        /// Disable collecting and reporting metrics.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Performance.disable", dict);
        }

        partial void ValidateEnable(CefSharp.DevTools.Performance.EnableTimeDomain? timeDomain = null);
        /// <summary>
        /// Enable collecting and reporting metrics.
        /// </summary>
        /// <param name = "timeDomain">Time domain to use for collecting and reporting duration metrics.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(CefSharp.DevTools.Performance.EnableTimeDomain? timeDomain = null)
        {
            ValidateEnable(timeDomain);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (timeDomain.HasValue)
            {
                dict.Add("timeDomain", EnumToString(timeDomain));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Performance.enable", dict);
        }

        /// <summary>
        /// Retrieve current values of run-time metrics.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetMetricsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetMetricsResponse> GetMetricsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetMetricsResponse>("Performance.getMetrics", dict);
        }
    }
}

namespace CefSharp.DevTools.PerformanceTimeline
{
    using System.Linq;

    /// <summary>
    /// Reporting of performance timeline events, as specified in
    /// https://w3c.github.io/performance-timeline/#dom-performanceobserver.
    /// </summary>
    public partial class PerformanceTimelineClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// PerformanceTimeline
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public PerformanceTimelineClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Sent when a performance timeline event is added. See reportPerformanceTimeline method.
        /// </summary>
        public event System.EventHandler<TimelineEventAddedEventArgs> TimelineEventAdded
        {
            add
            {
                _client.AddEventHandler<TimelineEventAddedEventArgs>("PerformanceTimeline.timelineEventAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<TimelineEventAddedEventArgs>("PerformanceTimeline.timelineEventAdded", value);
            }
        }

        partial void ValidateEnable(string[] eventTypes);
        /// <summary>
        /// Previously buffered events would be reported before method returns.
        /// See also: timelineEventAdded
        /// </summary>
        /// <param name = "eventTypes">The types of event to report, as specified inhttps://w3c.github.io/performance-timeline/#dom-performanceentry-entrytypeThe specified filter overrides any previous filters, passing emptyfilter disables recording.Note that not all types exposed to the web platform are currently supported.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(string[] eventTypes)
        {
            ValidateEnable(eventTypes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("eventTypes", eventTypes);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("PerformanceTimeline.enable", dict);
        }
    }
}

namespace CefSharp.DevTools.Security
{
    using System.Linq;

    /// <summary>
    /// Security
    /// </summary>
    public partial class SecurityClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Security
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public SecurityClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// The security state of the page changed.
        /// </summary>
        public event System.EventHandler<VisibleSecurityStateChangedEventArgs> VisibleSecurityStateChanged
        {
            add
            {
                _client.AddEventHandler<VisibleSecurityStateChangedEventArgs>("Security.visibleSecurityStateChanged", value);
            }

            remove
            {
                _client.RemoveEventHandler<VisibleSecurityStateChangedEventArgs>("Security.visibleSecurityStateChanged", value);
            }
        }

        /// <summary>
        /// Disables tracking security state changes.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Security.disable", dict);
        }

        /// <summary>
        /// Enables tracking security state changes.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Security.enable", dict);
        }

        partial void ValidateSetIgnoreCertificateErrors(bool ignore);
        /// <summary>
        /// Enable/disable whether all certificate errors should be ignored.
        /// </summary>
        /// <param name = "ignore">If true, all certificate errors will be ignored.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetIgnoreCertificateErrorsAsync(bool ignore)
        {
            ValidateSetIgnoreCertificateErrors(ignore);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ignore", ignore);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Security.setIgnoreCertificateErrors", dict);
        }
    }
}

namespace CefSharp.DevTools.ServiceWorker
{
    using System.Linq;

    /// <summary>
    /// ServiceWorker
    /// </summary>
    public partial class ServiceWorkerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// ServiceWorker
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public ServiceWorkerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// WorkerErrorReported
        /// </summary>
        public event System.EventHandler<WorkerErrorReportedEventArgs> WorkerErrorReported
        {
            add
            {
                _client.AddEventHandler<WorkerErrorReportedEventArgs>("ServiceWorker.workerErrorReported", value);
            }

            remove
            {
                _client.RemoveEventHandler<WorkerErrorReportedEventArgs>("ServiceWorker.workerErrorReported", value);
            }
        }

        /// <summary>
        /// WorkerRegistrationUpdated
        /// </summary>
        public event System.EventHandler<WorkerRegistrationUpdatedEventArgs> WorkerRegistrationUpdated
        {
            add
            {
                _client.AddEventHandler<WorkerRegistrationUpdatedEventArgs>("ServiceWorker.workerRegistrationUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<WorkerRegistrationUpdatedEventArgs>("ServiceWorker.workerRegistrationUpdated", value);
            }
        }

        /// <summary>
        /// WorkerVersionUpdated
        /// </summary>
        public event System.EventHandler<WorkerVersionUpdatedEventArgs> WorkerVersionUpdated
        {
            add
            {
                _client.AddEventHandler<WorkerVersionUpdatedEventArgs>("ServiceWorker.workerVersionUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<WorkerVersionUpdatedEventArgs>("ServiceWorker.workerVersionUpdated", value);
            }
        }

        partial void ValidateDeliverPushMessage(string origin, string registrationId, string data);
        /// <summary>
        /// DeliverPushMessage
        /// </summary>
        /// <param name = "origin">origin</param>
        /// <param name = "registrationId">registrationId</param>
        /// <param name = "data">data</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DeliverPushMessageAsync(string origin, string registrationId, string data)
        {
            ValidateDeliverPushMessage(origin, registrationId, data);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            dict.Add("registrationId", registrationId);
            dict.Add("data", data);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.deliverPushMessage", dict);
        }

        /// <summary>
        /// Disable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.disable", dict);
        }

        partial void ValidateDispatchSyncEvent(string origin, string registrationId, string tag, bool lastChance);
        /// <summary>
        /// DispatchSyncEvent
        /// </summary>
        /// <param name = "origin">origin</param>
        /// <param name = "registrationId">registrationId</param>
        /// <param name = "tag">tag</param>
        /// <param name = "lastChance">lastChance</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchSyncEventAsync(string origin, string registrationId, string tag, bool lastChance)
        {
            ValidateDispatchSyncEvent(origin, registrationId, tag, lastChance);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            dict.Add("registrationId", registrationId);
            dict.Add("tag", tag);
            dict.Add("lastChance", lastChance);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.dispatchSyncEvent", dict);
        }

        partial void ValidateDispatchPeriodicSyncEvent(string origin, string registrationId, string tag);
        /// <summary>
        /// DispatchPeriodicSyncEvent
        /// </summary>
        /// <param name = "origin">origin</param>
        /// <param name = "registrationId">registrationId</param>
        /// <param name = "tag">tag</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DispatchPeriodicSyncEventAsync(string origin, string registrationId, string tag)
        {
            ValidateDispatchPeriodicSyncEvent(origin, registrationId, tag);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            dict.Add("registrationId", registrationId);
            dict.Add("tag", tag);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.dispatchPeriodicSyncEvent", dict);
        }

        /// <summary>
        /// Enable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.enable", dict);
        }

        partial void ValidateInspectWorker(string versionId);
        /// <summary>
        /// InspectWorker
        /// </summary>
        /// <param name = "versionId">versionId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> InspectWorkerAsync(string versionId)
        {
            ValidateInspectWorker(versionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("versionId", versionId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.inspectWorker", dict);
        }

        partial void ValidateSetForceUpdateOnPageLoad(bool forceUpdateOnPageLoad);
        /// <summary>
        /// SetForceUpdateOnPageLoad
        /// </summary>
        /// <param name = "forceUpdateOnPageLoad">forceUpdateOnPageLoad</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetForceUpdateOnPageLoadAsync(bool forceUpdateOnPageLoad)
        {
            ValidateSetForceUpdateOnPageLoad(forceUpdateOnPageLoad);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("forceUpdateOnPageLoad", forceUpdateOnPageLoad);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.setForceUpdateOnPageLoad", dict);
        }

        partial void ValidateSkipWaiting(string scopeURL);
        /// <summary>
        /// SkipWaiting
        /// </summary>
        /// <param name = "scopeURL">scopeURL</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SkipWaitingAsync(string scopeURL)
        {
            ValidateSkipWaiting(scopeURL);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeURL", scopeURL);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.skipWaiting", dict);
        }

        partial void ValidateStartWorker(string scopeURL);
        /// <summary>
        /// StartWorker
        /// </summary>
        /// <param name = "scopeURL">scopeURL</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartWorkerAsync(string scopeURL)
        {
            ValidateStartWorker(scopeURL);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeURL", scopeURL);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.startWorker", dict);
        }

        /// <summary>
        /// StopAllWorkers
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopAllWorkersAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.stopAllWorkers", dict);
        }

        partial void ValidateStopWorker(string versionId);
        /// <summary>
        /// StopWorker
        /// </summary>
        /// <param name = "versionId">versionId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopWorkerAsync(string versionId)
        {
            ValidateStopWorker(versionId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("versionId", versionId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.stopWorker", dict);
        }

        partial void ValidateUnregister(string scopeURL);
        /// <summary>
        /// Unregister
        /// </summary>
        /// <param name = "scopeURL">scopeURL</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> UnregisterAsync(string scopeURL)
        {
            ValidateUnregister(scopeURL);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeURL", scopeURL);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.unregister", dict);
        }

        partial void ValidateUpdateRegistration(string scopeURL);
        /// <summary>
        /// UpdateRegistration
        /// </summary>
        /// <param name = "scopeURL">scopeURL</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> UpdateRegistrationAsync(string scopeURL)
        {
            ValidateUpdateRegistration(scopeURL);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeURL", scopeURL);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("ServiceWorker.updateRegistration", dict);
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetStorageKeyForFrameResponse
    /// </summary>
    public class GetStorageKeyForFrameResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// storageKey
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("storageKey")]
        public string StorageKey
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetCookiesResponse
    /// </summary>
    public class GetCookiesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// cookies
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("cookies")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Network.Cookie> Cookies
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetUsageAndQuotaResponse
    /// </summary>
    public class GetUsageAndQuotaResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// usage
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("usage")]
        public double Usage
        {
            get;
            private set;
        }

        /// <summary>
        /// quota
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("quota")]
        public double Quota
        {
            get;
            private set;
        }

        /// <summary>
        /// overrideActive
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("overrideActive")]
        public bool OverrideActive
        {
            get;
            private set;
        }

        /// <summary>
        /// usageBreakdown
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("usageBreakdown")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Storage.UsageForType> UsageBreakdown
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetTrustTokensResponse
    /// </summary>
    public class GetTrustTokensResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// tokens
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("tokens")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Storage.TrustTokens> Tokens
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// ClearTrustTokensResponse
    /// </summary>
    public class ClearTrustTokensResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// didDeleteTokens
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("didDeleteTokens")]
        public bool DidDeleteTokens
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetInterestGroupDetailsResponse
    /// </summary>
    public class GetInterestGroupDetailsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// details
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("details")]
        public CefSharp.DevTools.Storage.InterestGroupDetails Details
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetSharedStorageMetadataResponse
    /// </summary>
    public class GetSharedStorageMetadataResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// metadata
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("metadata")]
        public CefSharp.DevTools.Storage.SharedStorageMetadata Metadata
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// GetSharedStorageEntriesResponse
    /// </summary>
    public class GetSharedStorageEntriesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// entries
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("entries")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Storage.SharedStorageEntry> Entries
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    /// <summary>
    /// RunBounceTrackingMitigationsResponse
    /// </summary>
    public class RunBounceTrackingMitigationsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// deletedSites
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("deletedSites")]
        public string[] DeletedSites
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Storage
{
    using System.Linq;

    /// <summary>
    /// Storage
    /// </summary>
    public partial class StorageClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Storage
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public StorageClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// A cache&apos;s contents have been modified.
        /// </summary>
        public event System.EventHandler<CacheStorageContentUpdatedEventArgs> CacheStorageContentUpdated
        {
            add
            {
                _client.AddEventHandler<CacheStorageContentUpdatedEventArgs>("Storage.cacheStorageContentUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<CacheStorageContentUpdatedEventArgs>("Storage.cacheStorageContentUpdated", value);
            }
        }

        /// <summary>
        /// A cache has been added/deleted.
        /// </summary>
        public event System.EventHandler<CacheStorageListUpdatedEventArgs> CacheStorageListUpdated
        {
            add
            {
                _client.AddEventHandler<CacheStorageListUpdatedEventArgs>("Storage.cacheStorageListUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<CacheStorageListUpdatedEventArgs>("Storage.cacheStorageListUpdated", value);
            }
        }

        /// <summary>
        /// The origin&apos;s IndexedDB object store has been modified.
        /// </summary>
        public event System.EventHandler<IndexedDBContentUpdatedEventArgs> IndexedDBContentUpdated
        {
            add
            {
                _client.AddEventHandler<IndexedDBContentUpdatedEventArgs>("Storage.indexedDBContentUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<IndexedDBContentUpdatedEventArgs>("Storage.indexedDBContentUpdated", value);
            }
        }

        /// <summary>
        /// The origin&apos;s IndexedDB database list has been modified.
        /// </summary>
        public event System.EventHandler<IndexedDBListUpdatedEventArgs> IndexedDBListUpdated
        {
            add
            {
                _client.AddEventHandler<IndexedDBListUpdatedEventArgs>("Storage.indexedDBListUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<IndexedDBListUpdatedEventArgs>("Storage.indexedDBListUpdated", value);
            }
        }

        /// <summary>
        /// One of the interest groups was accessed by the associated page.
        /// </summary>
        public event System.EventHandler<InterestGroupAccessedEventArgs> InterestGroupAccessed
        {
            add
            {
                _client.AddEventHandler<InterestGroupAccessedEventArgs>("Storage.interestGroupAccessed", value);
            }

            remove
            {
                _client.RemoveEventHandler<InterestGroupAccessedEventArgs>("Storage.interestGroupAccessed", value);
            }
        }

        /// <summary>
        /// Shared storage was accessed by the associated page.
        /// The following parameters are included in all events.
        /// </summary>
        public event System.EventHandler<SharedStorageAccessedEventArgs> SharedStorageAccessed
        {
            add
            {
                _client.AddEventHandler<SharedStorageAccessedEventArgs>("Storage.sharedStorageAccessed", value);
            }

            remove
            {
                _client.RemoveEventHandler<SharedStorageAccessedEventArgs>("Storage.sharedStorageAccessed", value);
            }
        }

        /// <summary>
        /// StorageBucketCreatedOrUpdated
        /// </summary>
        public event System.EventHandler<StorageBucketCreatedOrUpdatedEventArgs> StorageBucketCreatedOrUpdated
        {
            add
            {
                _client.AddEventHandler<StorageBucketCreatedOrUpdatedEventArgs>("Storage.storageBucketCreatedOrUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<StorageBucketCreatedOrUpdatedEventArgs>("Storage.storageBucketCreatedOrUpdated", value);
            }
        }

        /// <summary>
        /// StorageBucketDeleted
        /// </summary>
        public event System.EventHandler<StorageBucketDeletedEventArgs> StorageBucketDeleted
        {
            add
            {
                _client.AddEventHandler<StorageBucketDeletedEventArgs>("Storage.storageBucketDeleted", value);
            }

            remove
            {
                _client.RemoveEventHandler<StorageBucketDeletedEventArgs>("Storage.storageBucketDeleted", value);
            }
        }

        partial void ValidateGetStorageKeyForFrame(string frameId);
        /// <summary>
        /// Returns a storage key given a frame id.
        /// </summary>
        /// <param name = "frameId">frameId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetStorageKeyForFrameResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetStorageKeyForFrameResponse> GetStorageKeyForFrameAsync(string frameId)
        {
            ValidateGetStorageKeyForFrame(frameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("frameId", frameId);
            return _client.ExecuteDevToolsMethodAsync<GetStorageKeyForFrameResponse>("Storage.getStorageKeyForFrame", dict);
        }

        partial void ValidateClearDataForOrigin(string origin, string storageTypes);
        /// <summary>
        /// Clears storage for origin.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <param name = "storageTypes">Comma separated list of StorageType to clear.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearDataForOriginAsync(string origin, string storageTypes)
        {
            ValidateClearDataForOrigin(origin, storageTypes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            dict.Add("storageTypes", storageTypes);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.clearDataForOrigin", dict);
        }

        partial void ValidateClearDataForStorageKey(string storageKey, string storageTypes);
        /// <summary>
        /// Clears storage for storage key.
        /// </summary>
        /// <param name = "storageKey">Storage key.</param>
        /// <param name = "storageTypes">Comma separated list of StorageType to clear.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearDataForStorageKeyAsync(string storageKey, string storageTypes)
        {
            ValidateClearDataForStorageKey(storageKey, storageTypes);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageKey", storageKey);
            dict.Add("storageTypes", storageTypes);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.clearDataForStorageKey", dict);
        }

        partial void ValidateGetCookies(string browserContextId = null);
        /// <summary>
        /// Returns all browser cookies.
        /// </summary>
        /// <param name = "browserContextId">Browser context to use when called on the browser endpoint.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCookiesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetCookiesResponse> GetCookiesAsync(string browserContextId = null)
        {
            ValidateGetCookies(browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetCookiesResponse>("Storage.getCookies", dict);
        }

        partial void ValidateSetCookies(System.Collections.Generic.IList<CefSharp.DevTools.Network.CookieParam> cookies, string browserContextId = null);
        /// <summary>
        /// Sets given cookies.
        /// </summary>
        /// <param name = "cookies">Cookies to be set.</param>
        /// <param name = "browserContextId">Browser context to use when called on the browser endpoint.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetCookiesAsync(System.Collections.Generic.IList<CefSharp.DevTools.Network.CookieParam> cookies, string browserContextId = null)
        {
            ValidateSetCookies(cookies, browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("cookies", cookies.Select(x => x.ToDictionary()));
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.setCookies", dict);
        }

        partial void ValidateClearCookies(string browserContextId = null);
        /// <summary>
        /// Clears cookies.
        /// </summary>
        /// <param name = "browserContextId">Browser context to use when called on the browser endpoint.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearCookiesAsync(string browserContextId = null)
        {
            ValidateClearCookies(browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.clearCookies", dict);
        }

        partial void ValidateGetUsageAndQuota(string origin);
        /// <summary>
        /// Returns usage and quota in bytes.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetUsageAndQuotaResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetUsageAndQuotaResponse> GetUsageAndQuotaAsync(string origin)
        {
            ValidateGetUsageAndQuota(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            return _client.ExecuteDevToolsMethodAsync<GetUsageAndQuotaResponse>("Storage.getUsageAndQuota", dict);
        }

        partial void ValidateOverrideQuotaForOrigin(string origin, double? quotaSize = null);
        /// <summary>
        /// Override quota for the specified origin
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <param name = "quotaSize">The quota size (in bytes) to override the original quota with.If this is called multiple times, the overridden quota will be equal tothe quotaSize provided in the final call. If this is called withoutspecifying a quotaSize, the quota will be reset to the default value forthe specified origin. If this is called multiple times with differentorigins, the override will be maintained for each origin until it isdisabled (called without a quotaSize).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> OverrideQuotaForOriginAsync(string origin, double? quotaSize = null)
        {
            ValidateOverrideQuotaForOrigin(origin, quotaSize);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            if (quotaSize.HasValue)
            {
                dict.Add("quotaSize", quotaSize.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.overrideQuotaForOrigin", dict);
        }

        partial void ValidateTrackCacheStorageForOrigin(string origin);
        /// <summary>
        /// Registers origin to be notified when an update occurs to its cache storage list.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> TrackCacheStorageForOriginAsync(string origin)
        {
            ValidateTrackCacheStorageForOrigin(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.trackCacheStorageForOrigin", dict);
        }

        partial void ValidateTrackCacheStorageForStorageKey(string storageKey);
        /// <summary>
        /// Registers storage key to be notified when an update occurs to its cache storage list.
        /// </summary>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> TrackCacheStorageForStorageKeyAsync(string storageKey)
        {
            ValidateTrackCacheStorageForStorageKey(storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageKey", storageKey);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.trackCacheStorageForStorageKey", dict);
        }

        partial void ValidateTrackIndexedDBForOrigin(string origin);
        /// <summary>
        /// Registers origin to be notified when an update occurs to its IndexedDB.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> TrackIndexedDBForOriginAsync(string origin)
        {
            ValidateTrackIndexedDBForOrigin(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.trackIndexedDBForOrigin", dict);
        }

        partial void ValidateTrackIndexedDBForStorageKey(string storageKey);
        /// <summary>
        /// Registers storage key to be notified when an update occurs to its IndexedDB.
        /// </summary>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> TrackIndexedDBForStorageKeyAsync(string storageKey)
        {
            ValidateTrackIndexedDBForStorageKey(storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageKey", storageKey);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.trackIndexedDBForStorageKey", dict);
        }

        partial void ValidateUntrackCacheStorageForOrigin(string origin);
        /// <summary>
        /// Unregisters origin from receiving notifications for cache storage.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> UntrackCacheStorageForOriginAsync(string origin)
        {
            ValidateUntrackCacheStorageForOrigin(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.untrackCacheStorageForOrigin", dict);
        }

        partial void ValidateUntrackCacheStorageForStorageKey(string storageKey);
        /// <summary>
        /// Unregisters storage key from receiving notifications for cache storage.
        /// </summary>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> UntrackCacheStorageForStorageKeyAsync(string storageKey)
        {
            ValidateUntrackCacheStorageForStorageKey(storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageKey", storageKey);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.untrackCacheStorageForStorageKey", dict);
        }

        partial void ValidateUntrackIndexedDBForOrigin(string origin);
        /// <summary>
        /// Unregisters origin from receiving notifications for IndexedDB.
        /// </summary>
        /// <param name = "origin">Security origin.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> UntrackIndexedDBForOriginAsync(string origin)
        {
            ValidateUntrackIndexedDBForOrigin(origin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("origin", origin);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.untrackIndexedDBForOrigin", dict);
        }

        partial void ValidateUntrackIndexedDBForStorageKey(string storageKey);
        /// <summary>
        /// Unregisters storage key from receiving notifications for IndexedDB.
        /// </summary>
        /// <param name = "storageKey">Storage key.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> UntrackIndexedDBForStorageKeyAsync(string storageKey)
        {
            ValidateUntrackIndexedDBForStorageKey(storageKey);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageKey", storageKey);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.untrackIndexedDBForStorageKey", dict);
        }

        /// <summary>
        /// Returns the number of stored Trust Tokens per issuer for the
        /// current browsing context.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetTrustTokensResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetTrustTokensResponse> GetTrustTokensAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetTrustTokensResponse>("Storage.getTrustTokens", dict);
        }

        partial void ValidateClearTrustTokens(string issuerOrigin);
        /// <summary>
        /// Removes all Trust Tokens issued by the provided issuerOrigin.
        /// Leaves other stored data, including the issuer&apos;s Redemption Records, intact.
        /// </summary>
        /// <param name = "issuerOrigin">issuerOrigin</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;ClearTrustTokensResponse&gt;</returns>
        public System.Threading.Tasks.Task<ClearTrustTokensResponse> ClearTrustTokensAsync(string issuerOrigin)
        {
            ValidateClearTrustTokens(issuerOrigin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("issuerOrigin", issuerOrigin);
            return _client.ExecuteDevToolsMethodAsync<ClearTrustTokensResponse>("Storage.clearTrustTokens", dict);
        }

        partial void ValidateGetInterestGroupDetails(string ownerOrigin, string name);
        /// <summary>
        /// Gets details for a named interest group.
        /// </summary>
        /// <param name = "ownerOrigin">ownerOrigin</param>
        /// <param name = "name">name</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetInterestGroupDetailsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetInterestGroupDetailsResponse> GetInterestGroupDetailsAsync(string ownerOrigin, string name)
        {
            ValidateGetInterestGroupDetails(ownerOrigin, name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ownerOrigin", ownerOrigin);
            dict.Add("name", name);
            return _client.ExecuteDevToolsMethodAsync<GetInterestGroupDetailsResponse>("Storage.getInterestGroupDetails", dict);
        }

        partial void ValidateSetInterestGroupTracking(bool enable);
        /// <summary>
        /// Enables/Disables issuing of interestGroupAccessed events.
        /// </summary>
        /// <param name = "enable">enable</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetInterestGroupTrackingAsync(bool enable)
        {
            ValidateSetInterestGroupTracking(enable);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enable", enable);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.setInterestGroupTracking", dict);
        }

        partial void ValidateGetSharedStorageMetadata(string ownerOrigin);
        /// <summary>
        /// Gets metadata for an origin&apos;s shared storage.
        /// </summary>
        /// <param name = "ownerOrigin">ownerOrigin</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSharedStorageMetadataResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetSharedStorageMetadataResponse> GetSharedStorageMetadataAsync(string ownerOrigin)
        {
            ValidateGetSharedStorageMetadata(ownerOrigin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ownerOrigin", ownerOrigin);
            return _client.ExecuteDevToolsMethodAsync<GetSharedStorageMetadataResponse>("Storage.getSharedStorageMetadata", dict);
        }

        partial void ValidateGetSharedStorageEntries(string ownerOrigin);
        /// <summary>
        /// Gets the entries in an given origin&apos;s shared storage.
        /// </summary>
        /// <param name = "ownerOrigin">ownerOrigin</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSharedStorageEntriesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetSharedStorageEntriesResponse> GetSharedStorageEntriesAsync(string ownerOrigin)
        {
            ValidateGetSharedStorageEntries(ownerOrigin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ownerOrigin", ownerOrigin);
            return _client.ExecuteDevToolsMethodAsync<GetSharedStorageEntriesResponse>("Storage.getSharedStorageEntries", dict);
        }

        partial void ValidateSetSharedStorageEntry(string ownerOrigin, string key, string value, bool? ignoreIfPresent = null);
        /// <summary>
        /// Sets entry with `key` and `value` for a given origin&apos;s shared storage.
        /// </summary>
        /// <param name = "ownerOrigin">ownerOrigin</param>
        /// <param name = "key">key</param>
        /// <param name = "value">value</param>
        /// <param name = "ignoreIfPresent">If `ignoreIfPresent` is included and true, then only sets the entry if`key` doesn't already exist.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetSharedStorageEntryAsync(string ownerOrigin, string key, string value, bool? ignoreIfPresent = null)
        {
            ValidateSetSharedStorageEntry(ownerOrigin, key, value, ignoreIfPresent);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ownerOrigin", ownerOrigin);
            dict.Add("key", key);
            dict.Add("value", value);
            if (ignoreIfPresent.HasValue)
            {
                dict.Add("ignoreIfPresent", ignoreIfPresent.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.setSharedStorageEntry", dict);
        }

        partial void ValidateDeleteSharedStorageEntry(string ownerOrigin, string key);
        /// <summary>
        /// Deletes entry for `key` (if it exists) for a given origin&apos;s shared storage.
        /// </summary>
        /// <param name = "ownerOrigin">ownerOrigin</param>
        /// <param name = "key">key</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteSharedStorageEntryAsync(string ownerOrigin, string key)
        {
            ValidateDeleteSharedStorageEntry(ownerOrigin, key);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ownerOrigin", ownerOrigin);
            dict.Add("key", key);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.deleteSharedStorageEntry", dict);
        }

        partial void ValidateClearSharedStorageEntries(string ownerOrigin);
        /// <summary>
        /// Clears all entries for a given origin&apos;s shared storage.
        /// </summary>
        /// <param name = "ownerOrigin">ownerOrigin</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearSharedStorageEntriesAsync(string ownerOrigin)
        {
            ValidateClearSharedStorageEntries(ownerOrigin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ownerOrigin", ownerOrigin);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.clearSharedStorageEntries", dict);
        }

        partial void ValidateResetSharedStorageBudget(string ownerOrigin);
        /// <summary>
        /// Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
        /// </summary>
        /// <param name = "ownerOrigin">ownerOrigin</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ResetSharedStorageBudgetAsync(string ownerOrigin)
        {
            ValidateResetSharedStorageBudget(ownerOrigin);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("ownerOrigin", ownerOrigin);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.resetSharedStorageBudget", dict);
        }

        partial void ValidateSetSharedStorageTracking(bool enable);
        /// <summary>
        /// Enables/disables issuing of sharedStorageAccessed events.
        /// </summary>
        /// <param name = "enable">enable</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetSharedStorageTrackingAsync(bool enable)
        {
            ValidateSetSharedStorageTracking(enable);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enable", enable);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.setSharedStorageTracking", dict);
        }

        partial void ValidateSetStorageBucketTracking(string storageKey, bool enable);
        /// <summary>
        /// Set tracking for a storage key&apos;s buckets.
        /// </summary>
        /// <param name = "storageKey">storageKey</param>
        /// <param name = "enable">enable</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetStorageBucketTrackingAsync(string storageKey, bool enable)
        {
            ValidateSetStorageBucketTracking(storageKey, enable);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageKey", storageKey);
            dict.Add("enable", enable);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.setStorageBucketTracking", dict);
        }

        partial void ValidateDeleteStorageBucket(string storageKey, string bucketName);
        /// <summary>
        /// Deletes the Storage Bucket with the given storage key and bucket name.
        /// </summary>
        /// <param name = "storageKey">storageKey</param>
        /// <param name = "bucketName">bucketName</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DeleteStorageBucketAsync(string storageKey, string bucketName)
        {
            ValidateDeleteStorageBucket(storageKey, bucketName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("storageKey", storageKey);
            dict.Add("bucketName", bucketName);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Storage.deleteStorageBucket", dict);
        }

        /// <summary>
        /// Deletes state for sites identified as potential bounce trackers, immediately.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;RunBounceTrackingMitigationsResponse&gt;</returns>
        public System.Threading.Tasks.Task<RunBounceTrackingMitigationsResponse> RunBounceTrackingMitigationsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<RunBounceTrackingMitigationsResponse>("Storage.runBounceTrackingMitigations", dict);
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// GetInfoResponse
    /// </summary>
    public class GetInfoResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// gpu
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("gpu")]
        public CefSharp.DevTools.SystemInfo.GPUInfo Gpu
        {
            get;
            private set;
        }

        /// <summary>
        /// modelName
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("modelName")]
        public string ModelName
        {
            get;
            private set;
        }

        /// <summary>
        /// modelVersion
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("modelVersion")]
        public string ModelVersion
        {
            get;
            private set;
        }

        /// <summary>
        /// commandLine
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("commandLine")]
        public string CommandLine
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// GetFeatureStateResponse
    /// </summary>
    public class GetFeatureStateResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// featureEnabled
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("featureEnabled")]
        public bool FeatureEnabled
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    /// <summary>
    /// GetProcessInfoResponse
    /// </summary>
    public class GetProcessInfoResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// processInfo
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("processInfo")]
        public System.Collections.Generic.IList<CefSharp.DevTools.SystemInfo.ProcessInfo> ProcessInfo
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.SystemInfo
{
    using System.Linq;

    /// <summary>
    /// The SystemInfo domain defines methods and events for querying low-level system information.
    /// </summary>
    public partial class SystemInfoClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// SystemInfo
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public SystemInfoClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Returns information about the system.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetInfoResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetInfoResponse> GetInfoAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetInfoResponse>("SystemInfo.getInfo", dict);
        }

        partial void ValidateGetFeatureState(string featureState);
        /// <summary>
        /// Returns information about the feature state.
        /// </summary>
        /// <param name = "featureState">featureState</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetFeatureStateResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetFeatureStateResponse> GetFeatureStateAsync(string featureState)
        {
            ValidateGetFeatureState(featureState);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("featureState", featureState);
            return _client.ExecuteDevToolsMethodAsync<GetFeatureStateResponse>("SystemInfo.getFeatureState", dict);
        }

        /// <summary>
        /// Returns information about all running processes.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetProcessInfoResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetProcessInfoResponse> GetProcessInfoAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetProcessInfoResponse>("SystemInfo.getProcessInfo", dict);
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// AttachToTargetResponse
    /// </summary>
    public class AttachToTargetResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// sessionId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sessionId")]
        public string SessionId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// AttachToBrowserTargetResponse
    /// </summary>
    public class AttachToBrowserTargetResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// sessionId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("sessionId")]
        public string SessionId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// CloseTargetResponse
    /// </summary>
    public class CloseTargetResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// success
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("success")]
        public bool Success
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// CreateBrowserContextResponse
    /// </summary>
    public class CreateBrowserContextResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// browserContextId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("browserContextId")]
        public string BrowserContextId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// GetBrowserContextsResponse
    /// </summary>
    public class GetBrowserContextsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// browserContextIds
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("browserContextIds")]
        public string[] BrowserContextIds
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// CreateTargetResponse
    /// </summary>
    public class CreateTargetResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// targetId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetId")]
        public string TargetId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// GetTargetInfoResponse
    /// </summary>
    public class GetTargetInfoResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// targetInfo
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetInfo")]
        public CefSharp.DevTools.Target.TargetInfo TargetInfo
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    /// <summary>
    /// GetTargetsResponse
    /// </summary>
    public class GetTargetsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// targetInfos
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("targetInfos")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetInfo> TargetInfos
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Target
{
    using System.Linq;

    /// <summary>
    /// Supports additional targets discovery and allows to attach to them.
    /// </summary>
    public partial class TargetClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Target
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public TargetClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Issued when attached to target because of auto-attach or `attachToTarget` command.
        /// </summary>
        public event System.EventHandler<AttachedToTargetEventArgs> AttachedToTarget
        {
            add
            {
                _client.AddEventHandler<AttachedToTargetEventArgs>("Target.attachedToTarget", value);
            }

            remove
            {
                _client.RemoveEventHandler<AttachedToTargetEventArgs>("Target.attachedToTarget", value);
            }
        }

        /// <summary>
        /// Issued when detached from target for any reason (including `detachFromTarget` command). Can be
        /// issued multiple times per target if multiple sessions have been attached to it.
        /// </summary>
        public event System.EventHandler<DetachedFromTargetEventArgs> DetachedFromTarget
        {
            add
            {
                _client.AddEventHandler<DetachedFromTargetEventArgs>("Target.detachedFromTarget", value);
            }

            remove
            {
                _client.RemoveEventHandler<DetachedFromTargetEventArgs>("Target.detachedFromTarget", value);
            }
        }

        /// <summary>
        /// Notifies about a new protocol message received from the session (as reported in
        /// `attachedToTarget` event).
        /// </summary>
        public event System.EventHandler<ReceivedMessageFromTargetEventArgs> ReceivedMessageFromTarget
        {
            add
            {
                _client.AddEventHandler<ReceivedMessageFromTargetEventArgs>("Target.receivedMessageFromTarget", value);
            }

            remove
            {
                _client.RemoveEventHandler<ReceivedMessageFromTargetEventArgs>("Target.receivedMessageFromTarget", value);
            }
        }

        /// <summary>
        /// Issued when a possible inspection target is created.
        /// </summary>
        public event System.EventHandler<TargetCreatedEventArgs> TargetCreated
        {
            add
            {
                _client.AddEventHandler<TargetCreatedEventArgs>("Target.targetCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<TargetCreatedEventArgs>("Target.targetCreated", value);
            }
        }

        /// <summary>
        /// Issued when a target is destroyed.
        /// </summary>
        public event System.EventHandler<TargetDestroyedEventArgs> TargetDestroyed
        {
            add
            {
                _client.AddEventHandler<TargetDestroyedEventArgs>("Target.targetDestroyed", value);
            }

            remove
            {
                _client.RemoveEventHandler<TargetDestroyedEventArgs>("Target.targetDestroyed", value);
            }
        }

        /// <summary>
        /// Issued when a target has crashed.
        /// </summary>
        public event System.EventHandler<TargetCrashedEventArgs> TargetCrashed
        {
            add
            {
                _client.AddEventHandler<TargetCrashedEventArgs>("Target.targetCrashed", value);
            }

            remove
            {
                _client.RemoveEventHandler<TargetCrashedEventArgs>("Target.targetCrashed", value);
            }
        }

        /// <summary>
        /// Issued when some information about a target has changed. This only happens between
        /// `targetCreated` and `targetDestroyed`.
        /// </summary>
        public event System.EventHandler<TargetInfoChangedEventArgs> TargetInfoChanged
        {
            add
            {
                _client.AddEventHandler<TargetInfoChangedEventArgs>("Target.targetInfoChanged", value);
            }

            remove
            {
                _client.RemoveEventHandler<TargetInfoChangedEventArgs>("Target.targetInfoChanged", value);
            }
        }

        partial void ValidateActivateTarget(string targetId);
        /// <summary>
        /// Activates (focuses) the target.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ActivateTargetAsync(string targetId)
        {
            ValidateActivateTarget(targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Target.activateTarget", dict);
        }

        partial void ValidateAttachToTarget(string targetId, bool? flatten = null);
        /// <summary>
        /// Attaches to the target with given id.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <param name = "flatten">Enables "flat" access to the session via specifying sessionId attribute in the commands.We plan to make this the default, deprecate non-flattened mode,and eventually retire it. See crbug.com/991325.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AttachToTargetResponse&gt;</returns>
        public System.Threading.Tasks.Task<AttachToTargetResponse> AttachToTargetAsync(string targetId, bool? flatten = null)
        {
            ValidateAttachToTarget(targetId, flatten);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            if (flatten.HasValue)
            {
                dict.Add("flatten", flatten.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<AttachToTargetResponse>("Target.attachToTarget", dict);
        }

        /// <summary>
        /// Attaches to the browser target, only uses flat sessionId mode.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;AttachToBrowserTargetResponse&gt;</returns>
        public System.Threading.Tasks.Task<AttachToBrowserTargetResponse> AttachToBrowserTargetAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<AttachToBrowserTargetResponse>("Target.attachToBrowserTarget", dict);
        }

        partial void ValidateCloseTarget(string targetId);
        /// <summary>
        /// Closes the target. If the target is a page that gets closed too.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CloseTargetResponse&gt;</returns>
        public System.Threading.Tasks.Task<CloseTargetResponse> CloseTargetAsync(string targetId)
        {
            ValidateCloseTarget(targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            return _client.ExecuteDevToolsMethodAsync<CloseTargetResponse>("Target.closeTarget", dict);
        }

        partial void ValidateExposeDevToolsProtocol(string targetId, string bindingName = null);
        /// <summary>
        /// Inject object to the target&apos;s main frame that provides a communication
        /// channel with browser target.
        /// 
        /// Injected object will be available as `window[bindingName]`.
        /// 
        /// The object has the follwing API:
        /// - `binding.send(json)` - a method to send messages over the remote debugging protocol
        /// - `binding.onmessage = json =&gt; handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <param name = "bindingName">Binding name, 'cdp' if not specified.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ExposeDevToolsProtocolAsync(string targetId, string bindingName = null)
        {
            ValidateExposeDevToolsProtocol(targetId, bindingName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            if (!(string.IsNullOrEmpty(bindingName)))
            {
                dict.Add("bindingName", bindingName);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Target.exposeDevToolsProtocol", dict);
        }

        partial void ValidateCreateBrowserContext(bool? disposeOnDetach = null, string proxyServer = null, string proxyBypassList = null, string[] originsWithUniversalNetworkAccess = null);
        /// <summary>
        /// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
        /// one.
        /// </summary>
        /// <param name = "disposeOnDetach">If specified, disposes this context when debugging session disconnects.</param>
        /// <param name = "proxyServer">Proxy server, similar to the one passed to --proxy-server</param>
        /// <param name = "proxyBypassList">Proxy bypass list, similar to the one passed to --proxy-bypass-list</param>
        /// <param name = "originsWithUniversalNetworkAccess">An optional list of origins to grant unlimited cross-origin access to.Parts of the URL other than those constituting origin are ignored.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CreateBrowserContextResponse&gt;</returns>
        public System.Threading.Tasks.Task<CreateBrowserContextResponse> CreateBrowserContextAsync(bool? disposeOnDetach = null, string proxyServer = null, string proxyBypassList = null, string[] originsWithUniversalNetworkAccess = null)
        {
            ValidateCreateBrowserContext(disposeOnDetach, proxyServer, proxyBypassList, originsWithUniversalNetworkAccess);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (disposeOnDetach.HasValue)
            {
                dict.Add("disposeOnDetach", disposeOnDetach.Value);
            }

            if (!(string.IsNullOrEmpty(proxyServer)))
            {
                dict.Add("proxyServer", proxyServer);
            }

            if (!(string.IsNullOrEmpty(proxyBypassList)))
            {
                dict.Add("proxyBypassList", proxyBypassList);
            }

            if ((originsWithUniversalNetworkAccess) != (null))
            {
                dict.Add("originsWithUniversalNetworkAccess", originsWithUniversalNetworkAccess);
            }

            return _client.ExecuteDevToolsMethodAsync<CreateBrowserContextResponse>("Target.createBrowserContext", dict);
        }

        /// <summary>
        /// Returns all browser contexts created with `Target.createBrowserContext` method.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBrowserContextsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetBrowserContextsResponse> GetBrowserContextsAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetBrowserContextsResponse>("Target.getBrowserContexts", dict);
        }

        partial void ValidateCreateTarget(string url, int? width = null, int? height = null, string browserContextId = null, bool? enableBeginFrameControl = null, bool? newWindow = null, bool? background = null, bool? forTab = null);
        /// <summary>
        /// Creates a new page.
        /// </summary>
        /// <param name = "url">The initial URL the page will be navigated to. An empty string indicates about:blank.</param>
        /// <param name = "width">Frame width in DIP (headless chrome only).</param>
        /// <param name = "height">Frame height in DIP (headless chrome only).</param>
        /// <param name = "browserContextId">The browser context to create the page in.</param>
        /// <param name = "enableBeginFrameControl">Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,not supported on MacOS yet, false by default).</param>
        /// <param name = "newWindow">Whether to create a new Window or Tab (chrome-only, false by default).</param>
        /// <param name = "background">Whether to create the target in background or foreground (chrome-only,false by default).</param>
        /// <param name = "forTab">Whether to create the target of type "tab".</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CreateTargetResponse&gt;</returns>
        public System.Threading.Tasks.Task<CreateTargetResponse> CreateTargetAsync(string url, int? width = null, int? height = null, string browserContextId = null, bool? enableBeginFrameControl = null, bool? newWindow = null, bool? background = null, bool? forTab = null)
        {
            ValidateCreateTarget(url, width, height, browserContextId, enableBeginFrameControl, newWindow, background, forTab);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("url", url);
            if (width.HasValue)
            {
                dict.Add("width", width.Value);
            }

            if (height.HasValue)
            {
                dict.Add("height", height.Value);
            }

            if (!(string.IsNullOrEmpty(browserContextId)))
            {
                dict.Add("browserContextId", browserContextId);
            }

            if (enableBeginFrameControl.HasValue)
            {
                dict.Add("enableBeginFrameControl", enableBeginFrameControl.Value);
            }

            if (newWindow.HasValue)
            {
                dict.Add("newWindow", newWindow.Value);
            }

            if (background.HasValue)
            {
                dict.Add("background", background.Value);
            }

            if (forTab.HasValue)
            {
                dict.Add("forTab", forTab.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<CreateTargetResponse>("Target.createTarget", dict);
        }

        partial void ValidateDetachFromTarget(string sessionId = null, string targetId = null);
        /// <summary>
        /// Detaches session with given id.
        /// </summary>
        /// <param name = "sessionId">Session to detach.</param>
        /// <param name = "targetId">Deprecated.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DetachFromTargetAsync(string sessionId = null, string targetId = null)
        {
            ValidateDetachFromTarget(sessionId, targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(sessionId)))
            {
                dict.Add("sessionId", sessionId);
            }

            if (!(string.IsNullOrEmpty(targetId)))
            {
                dict.Add("targetId", targetId);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Target.detachFromTarget", dict);
        }

        partial void ValidateDisposeBrowserContext(string browserContextId);
        /// <summary>
        /// Deletes a BrowserContext. All the belonging pages will be closed without calling their
        /// beforeunload hooks.
        /// </summary>
        /// <param name = "browserContextId">browserContextId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisposeBrowserContextAsync(string browserContextId)
        {
            ValidateDisposeBrowserContext(browserContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("browserContextId", browserContextId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Target.disposeBrowserContext", dict);
        }

        partial void ValidateGetTargetInfo(string targetId = null);
        /// <summary>
        /// Returns information about a target.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetTargetInfoResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetTargetInfoResponse> GetTargetInfoAsync(string targetId = null)
        {
            ValidateGetTargetInfo(targetId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(targetId)))
            {
                dict.Add("targetId", targetId);
            }

            return _client.ExecuteDevToolsMethodAsync<GetTargetInfoResponse>("Target.getTargetInfo", dict);
        }

        partial void ValidateGetTargets(System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetFilter> filter = null);
        /// <summary>
        /// Retrieves a list of available targets.
        /// </summary>
        /// <param name = "filter">Only targets matching filter will be reported. If filter is not specifiedand target discovery is currently enabled, a filter used for target discoveryis used for consistency.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetTargetsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetTargetsResponse> GetTargetsAsync(System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetFilter> filter = null)
        {
            ValidateGetTargets(filter);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((filter) != (null))
            {
                dict.Add("filter", filter.Select(x => x.ToDictionary()));
            }

            return _client.ExecuteDevToolsMethodAsync<GetTargetsResponse>("Target.getTargets", dict);
        }

        partial void ValidateSetAutoAttach(bool autoAttach, bool waitForDebuggerOnStart, bool? flatten = null, System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetFilter> filter = null);
        /// <summary>
        /// Controls whether to automatically attach to new targets which are considered to be related to
        /// this one. When turned on, attaches to all existing related targets as well. When turned off,
        /// automatically detaches from all currently attached targets.
        /// This also clears all targets added by `autoAttachRelated` from the list of targets to watch
        /// for creation of related targets.
        /// </summary>
        /// <param name = "autoAttach">Whether to auto-attach to related targets.</param>
        /// <param name = "waitForDebuggerOnStart">Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`to run paused targets.</param>
        /// <param name = "flatten">Enables "flat" access to the session via specifying sessionId attribute in the commands.We plan to make this the default, deprecate non-flattened mode,and eventually retire it. See crbug.com/991325.</param>
        /// <param name = "filter">Only targets matching filter will be attached.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAutoAttachAsync(bool autoAttach, bool waitForDebuggerOnStart, bool? flatten = null, System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetFilter> filter = null)
        {
            ValidateSetAutoAttach(autoAttach, waitForDebuggerOnStart, flatten, filter);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("autoAttach", autoAttach);
            dict.Add("waitForDebuggerOnStart", waitForDebuggerOnStart);
            if (flatten.HasValue)
            {
                dict.Add("flatten", flatten.Value);
            }

            if ((filter) != (null))
            {
                dict.Add("filter", filter.Select(x => x.ToDictionary()));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Target.setAutoAttach", dict);
        }

        partial void ValidateAutoAttachRelated(string targetId, bool waitForDebuggerOnStart, System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetFilter> filter = null);
        /// <summary>
        /// Adds the specified target to the list of targets that will be monitored for any related target
        /// creation (such as child frames, child workers and new versions of service worker) and reported
        /// through `attachedToTarget`. The specified target is also auto-attached.
        /// This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
        /// `setAutoAttach`. Only available at the Browser target.
        /// </summary>
        /// <param name = "targetId">targetId</param>
        /// <param name = "waitForDebuggerOnStart">Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`to run paused targets.</param>
        /// <param name = "filter">Only targets matching filter will be attached.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> AutoAttachRelatedAsync(string targetId, bool waitForDebuggerOnStart, System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetFilter> filter = null)
        {
            ValidateAutoAttachRelated(targetId, waitForDebuggerOnStart, filter);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("targetId", targetId);
            dict.Add("waitForDebuggerOnStart", waitForDebuggerOnStart);
            if ((filter) != (null))
            {
                dict.Add("filter", filter.Select(x => x.ToDictionary()));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Target.autoAttachRelated", dict);
        }

        partial void ValidateSetDiscoverTargets(bool discover, System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetFilter> filter = null);
        /// <summary>
        /// Controls whether to discover available targets and notify via
        /// `targetCreated/targetInfoChanged/targetDestroyed` events.
        /// </summary>
        /// <param name = "discover">Whether to discover available targets.</param>
        /// <param name = "filter">Only targets matching filter will be attached. If `discover` is false,`filter` must be omitted or empty.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetDiscoverTargetsAsync(bool discover, System.Collections.Generic.IList<CefSharp.DevTools.Target.TargetFilter> filter = null)
        {
            ValidateSetDiscoverTargets(discover, filter);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("discover", discover);
            if ((filter) != (null))
            {
                dict.Add("filter", filter.Select(x => x.ToDictionary()));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Target.setDiscoverTargets", dict);
        }

        partial void ValidateSetRemoteLocations(System.Collections.Generic.IList<CefSharp.DevTools.Target.RemoteLocation> locations);
        /// <summary>
        /// Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
        /// `true`.
        /// </summary>
        /// <param name = "locations">List of remote locations.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetRemoteLocationsAsync(System.Collections.Generic.IList<CefSharp.DevTools.Target.RemoteLocation> locations)
        {
            ValidateSetRemoteLocations(locations);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("locations", locations.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Target.setRemoteLocations", dict);
        }
    }
}

namespace CefSharp.DevTools.Tethering
{
    using System.Linq;

    /// <summary>
    /// The Tethering domain defines methods and events for browser port binding.
    /// </summary>
    public partial class TetheringClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Tethering
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public TetheringClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Informs that port was successfully bound and got a specified connection id.
        /// </summary>
        public event System.EventHandler<AcceptedEventArgs> Accepted
        {
            add
            {
                _client.AddEventHandler<AcceptedEventArgs>("Tethering.accepted", value);
            }

            remove
            {
                _client.RemoveEventHandler<AcceptedEventArgs>("Tethering.accepted", value);
            }
        }

        partial void ValidateBind(int port);
        /// <summary>
        /// Request browser port binding.
        /// </summary>
        /// <param name = "port">Port number to bind.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> BindAsync(int port)
        {
            ValidateBind(port);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("port", port);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Tethering.bind", dict);
        }

        partial void ValidateUnbind(int port);
        /// <summary>
        /// Request browser port unbinding.
        /// </summary>
        /// <param name = "port">Port number to unbind.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> UnbindAsync(int port)
        {
            ValidateUnbind(port);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("port", port);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Tethering.unbind", dict);
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    /// <summary>
    /// GetCategoriesResponse
    /// </summary>
    public class GetCategoriesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// categories
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("categories")]
        public string[] Categories
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    /// <summary>
    /// RequestMemoryDumpResponse
    /// </summary>
    public class RequestMemoryDumpResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// dumpGuid
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("dumpGuid")]
        public string DumpGuid
        {
            get;
            private set;
        }

        /// <summary>
        /// success
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("success")]
        public bool Success
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Tracing
{
    using System.Linq;

    /// <summary>
    /// Whether to report trace events as series of dataCollected events or to save trace to a
    /// stream (defaults to `ReportEvents`).
    /// </summary>
    public enum StartTransferMode
    {
        /// <summary>
        /// ReportEvents
        /// </summary>
        [JsonPropertyName("ReportEvents")]
        ReportEvents,
        /// <summary>
        /// ReturnAsStream
        /// </summary>
        [JsonPropertyName("ReturnAsStream")]
        ReturnAsStream
    }

    /// <summary>
    /// Tracing
    /// </summary>
    public partial class TracingClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Tracing
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public TracingClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// BufferUsage
        /// </summary>
        public event System.EventHandler<BufferUsageEventArgs> BufferUsage
        {
            add
            {
                _client.AddEventHandler<BufferUsageEventArgs>("Tracing.bufferUsage", value);
            }

            remove
            {
                _client.RemoveEventHandler<BufferUsageEventArgs>("Tracing.bufferUsage", value);
            }
        }

        /// <summary>
        /// Contains a bucket of collected trace events. When tracing is stopped collected events will be
        /// sent as a sequence of dataCollected events followed by tracingComplete event.
        /// </summary>
        public event System.EventHandler<DataCollectedEventArgs> DataCollected
        {
            add
            {
                _client.AddEventHandler<DataCollectedEventArgs>("Tracing.dataCollected", value);
            }

            remove
            {
                _client.RemoveEventHandler<DataCollectedEventArgs>("Tracing.dataCollected", value);
            }
        }

        /// <summary>
        /// Signals that tracing is stopped and there is no trace buffers pending flush, all data were
        /// delivered via dataCollected events.
        /// </summary>
        public event System.EventHandler<TracingCompleteEventArgs> TracingComplete
        {
            add
            {
                _client.AddEventHandler<TracingCompleteEventArgs>("Tracing.tracingComplete", value);
            }

            remove
            {
                _client.RemoveEventHandler<TracingCompleteEventArgs>("Tracing.tracingComplete", value);
            }
        }

        /// <summary>
        /// Stop trace events collection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EndAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Tracing.end", dict);
        }

        /// <summary>
        /// Gets supported tracing categories.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCategoriesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetCategoriesResponse> GetCategoriesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetCategoriesResponse>("Tracing.getCategories", dict);
        }

        partial void ValidateRecordClockSyncMarker(string syncId);
        /// <summary>
        /// Record a clock sync marker in the trace.
        /// </summary>
        /// <param name = "syncId">The ID of this clock sync marker</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RecordClockSyncMarkerAsync(string syncId)
        {
            ValidateRecordClockSyncMarker(syncId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("syncId", syncId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Tracing.recordClockSyncMarker", dict);
        }

        partial void ValidateRequestMemoryDump(bool? deterministic = null, CefSharp.DevTools.Tracing.MemoryDumpLevelOfDetail? levelOfDetail = null);
        /// <summary>
        /// Request a global memory dump.
        /// </summary>
        /// <param name = "deterministic">Enables more deterministic results by forcing garbage collection</param>
        /// <param name = "levelOfDetail">Specifies level of details in memory dump. Defaults to "detailed".</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RequestMemoryDumpResponse&gt;</returns>
        public System.Threading.Tasks.Task<RequestMemoryDumpResponse> RequestMemoryDumpAsync(bool? deterministic = null, CefSharp.DevTools.Tracing.MemoryDumpLevelOfDetail? levelOfDetail = null)
        {
            ValidateRequestMemoryDump(deterministic, levelOfDetail);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (deterministic.HasValue)
            {
                dict.Add("deterministic", deterministic.Value);
            }

            if (levelOfDetail.HasValue)
            {
                dict.Add("levelOfDetail", EnumToString(levelOfDetail));
            }

            return _client.ExecuteDevToolsMethodAsync<RequestMemoryDumpResponse>("Tracing.requestMemoryDump", dict);
        }

        partial void ValidateStart(string categories = null, string options = null, double? bufferUsageReportingInterval = null, CefSharp.DevTools.Tracing.StartTransferMode? transferMode = null, CefSharp.DevTools.Tracing.StreamFormat? streamFormat = null, CefSharp.DevTools.Tracing.StreamCompression? streamCompression = null, CefSharp.DevTools.Tracing.TraceConfig traceConfig = null, byte[] perfettoConfig = null, CefSharp.DevTools.Tracing.TracingBackend? tracingBackend = null);
        /// <summary>
        /// Start trace events collection.
        /// </summary>
        /// <param name = "categories">Category/tag filter</param>
        /// <param name = "options">Tracing options</param>
        /// <param name = "bufferUsageReportingInterval">If set, the agent will issue bufferUsage events at this interval, specified in milliseconds</param>
        /// <param name = "transferMode">Whether to report trace events as series of dataCollected events or to save trace to astream (defaults to `ReportEvents`).</param>
        /// <param name = "streamFormat">Trace data format to use. This only applies when using `ReturnAsStream`transfer mode (defaults to `json`).</param>
        /// <param name = "streamCompression">Compression format to use. This only applies when using `ReturnAsStream`transfer mode (defaults to `none`)</param>
        /// <param name = "traceConfig">traceConfig</param>
        /// <param name = "perfettoConfig">Base64-encoded serialized perfetto.protos.TraceConfig protobuf messageWhen specified, the parameters `categories`, `options`, `traceConfig`are ignored.</param>
        /// <param name = "tracingBackend">Backend type (defaults to `auto`)</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartAsync(string categories = null, string options = null, double? bufferUsageReportingInterval = null, CefSharp.DevTools.Tracing.StartTransferMode? transferMode = null, CefSharp.DevTools.Tracing.StreamFormat? streamFormat = null, CefSharp.DevTools.Tracing.StreamCompression? streamCompression = null, CefSharp.DevTools.Tracing.TraceConfig traceConfig = null, byte[] perfettoConfig = null, CefSharp.DevTools.Tracing.TracingBackend? tracingBackend = null)
        {
            ValidateStart(categories, options, bufferUsageReportingInterval, transferMode, streamFormat, streamCompression, traceConfig, perfettoConfig, tracingBackend);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (!(string.IsNullOrEmpty(categories)))
            {
                dict.Add("categories", categories);
            }

            if (!(string.IsNullOrEmpty(options)))
            {
                dict.Add("options", options);
            }

            if (bufferUsageReportingInterval.HasValue)
            {
                dict.Add("bufferUsageReportingInterval", bufferUsageReportingInterval.Value);
            }

            if (transferMode.HasValue)
            {
                dict.Add("transferMode", EnumToString(transferMode));
            }

            if (streamFormat.HasValue)
            {
                dict.Add("streamFormat", EnumToString(streamFormat));
            }

            if (streamCompression.HasValue)
            {
                dict.Add("streamCompression", EnumToString(streamCompression));
            }

            if ((traceConfig) != (null))
            {
                dict.Add("traceConfig", traceConfig.ToDictionary());
            }

            if ((perfettoConfig) != (null))
            {
                dict.Add("perfettoConfig", ToBase64String(perfettoConfig));
            }

            if (tracingBackend.HasValue)
            {
                dict.Add("tracingBackend", EnumToString(tracingBackend));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Tracing.start", dict);
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// GetResponseBodyResponse
    /// </summary>
    public class GetResponseBodyResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// body
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("body")]
        public string Body
        {
            get;
            private set;
        }

        /// <summary>
        /// base64Encoded
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("base64Encoded")]
        public bool Base64Encoded
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    /// <summary>
    /// TakeResponseBodyAsStreamResponse
    /// </summary>
    public class TakeResponseBodyAsStreamResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// stream
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stream")]
        public string Stream
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Fetch
{
    using System.Linq;

    /// <summary>
    /// A domain for letting clients substitute browser&apos;s network layer with client code.
    /// </summary>
    public partial class FetchClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Fetch
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public FetchClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Issued when the domain is enabled and the request URL matches the
        /// specified filter. The request is paused until the client responds
        /// with one of continueRequest, failRequest or fulfillRequest.
        /// The stage of the request can be determined by presence of responseErrorReason
        /// and responseStatusCode -- the request is at the response stage if either
        /// of these fields is present and in the request stage otherwise.
        /// </summary>
        public event System.EventHandler<RequestPausedEventArgs> RequestPaused
        {
            add
            {
                _client.AddEventHandler<RequestPausedEventArgs>("Fetch.requestPaused", value);
            }

            remove
            {
                _client.RemoveEventHandler<RequestPausedEventArgs>("Fetch.requestPaused", value);
            }
        }

        /// <summary>
        /// Issued when the domain is enabled with handleAuthRequests set to true.
        /// The request is paused until client responds with continueWithAuth.
        /// </summary>
        public event System.EventHandler<AuthRequiredEventArgs> AuthRequired
        {
            add
            {
                _client.AddEventHandler<AuthRequiredEventArgs>("Fetch.authRequired", value);
            }

            remove
            {
                _client.RemoveEventHandler<AuthRequiredEventArgs>("Fetch.authRequired", value);
            }
        }

        /// <summary>
        /// Disables the fetch domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Fetch.disable", dict);
        }

        partial void ValidateEnable(System.Collections.Generic.IList<CefSharp.DevTools.Fetch.RequestPattern> patterns = null, bool? handleAuthRequests = null);
        /// <summary>
        /// Enables issuing of requestPaused events. A request will be paused until client
        /// calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
        /// </summary>
        /// <param name = "patterns">If specified, only requests matching any of these patterns will producefetchRequested event and will be paused until clients response. If not set,all requests will be affected.</param>
        /// <param name = "handleAuthRequests">If true, authRequired events will be issued and requests will be pausedexpecting a call to continueWithAuth.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(System.Collections.Generic.IList<CefSharp.DevTools.Fetch.RequestPattern> patterns = null, bool? handleAuthRequests = null)
        {
            ValidateEnable(patterns, handleAuthRequests);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((patterns) != (null))
            {
                dict.Add("patterns", patterns.Select(x => x.ToDictionary()));
            }

            if (handleAuthRequests.HasValue)
            {
                dict.Add("handleAuthRequests", handleAuthRequests.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Fetch.enable", dict);
        }

        partial void ValidateFailRequest(string requestId, CefSharp.DevTools.Network.ErrorReason errorReason);
        /// <summary>
        /// Causes the request to fail with specified reason.
        /// </summary>
        /// <param name = "requestId">An id the client received in requestPaused event.</param>
        /// <param name = "errorReason">Causes the request to fail with the given reason.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> FailRequestAsync(string requestId, CefSharp.DevTools.Network.ErrorReason errorReason)
        {
            ValidateFailRequest(requestId, errorReason);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("errorReason", EnumToString(errorReason));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Fetch.failRequest", dict);
        }

        partial void ValidateFulfillRequest(string requestId, int responseCode, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> responseHeaders = null, byte[] binaryResponseHeaders = null, byte[] body = null, string responsePhrase = null);
        /// <summary>
        /// Provides response to the request.
        /// </summary>
        /// <param name = "requestId">An id the client received in requestPaused event.</param>
        /// <param name = "responseCode">An HTTP response code.</param>
        /// <param name = "responseHeaders">Response headers.</param>
        /// <param name = "binaryResponseHeaders">Alternative way of specifying response headers as a \0-separatedseries of name: value pairs. Prefer the above method unless youneed to represent some non-UTF8 values that can't be transmittedover the protocol as text.</param>
        /// <param name = "body">A response body. If absent, original response body will be used ifthe request is intercepted at the response stage and empty bodywill be used if the request is intercepted at the request stage.</param>
        /// <param name = "responsePhrase">A textual representation of responseCode.If absent, a standard phrase matching responseCode is used.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> FulfillRequestAsync(string requestId, int responseCode, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> responseHeaders = null, byte[] binaryResponseHeaders = null, byte[] body = null, string responsePhrase = null)
        {
            ValidateFulfillRequest(requestId, responseCode, responseHeaders, binaryResponseHeaders, body, responsePhrase);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("responseCode", responseCode);
            if ((responseHeaders) != (null))
            {
                dict.Add("responseHeaders", responseHeaders.Select(x => x.ToDictionary()));
            }

            if ((binaryResponseHeaders) != (null))
            {
                dict.Add("binaryResponseHeaders", ToBase64String(binaryResponseHeaders));
            }

            if ((body) != (null))
            {
                dict.Add("body", ToBase64String(body));
            }

            if (!(string.IsNullOrEmpty(responsePhrase)))
            {
                dict.Add("responsePhrase", responsePhrase);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Fetch.fulfillRequest", dict);
        }

        partial void ValidateContinueRequest(string requestId, string url = null, string method = null, byte[] postData = null, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> headers = null, bool? interceptResponse = null);
        /// <summary>
        /// Continues the request, optionally modifying some of its parameters.
        /// </summary>
        /// <param name = "requestId">An id the client received in requestPaused event.</param>
        /// <param name = "url">If set, the request url will be modified in a way that's not observable by page.</param>
        /// <param name = "method">If set, the request method is overridden.</param>
        /// <param name = "postData">If set, overrides the post data in the request.</param>
        /// <param name = "headers">If set, overrides the request headers. Note that the overrides do notextend to subsequent redirect hops, if a redirect happens. Another overridemay be applied to a different request produced by a redirect.</param>
        /// <param name = "interceptResponse">If set, overrides response interception behavior for this request.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ContinueRequestAsync(string requestId, string url = null, string method = null, byte[] postData = null, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> headers = null, bool? interceptResponse = null)
        {
            ValidateContinueRequest(requestId, url, method, postData, headers, interceptResponse);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            if (!(string.IsNullOrEmpty(url)))
            {
                dict.Add("url", url);
            }

            if (!(string.IsNullOrEmpty(method)))
            {
                dict.Add("method", method);
            }

            if ((postData) != (null))
            {
                dict.Add("postData", ToBase64String(postData));
            }

            if ((headers) != (null))
            {
                dict.Add("headers", headers.Select(x => x.ToDictionary()));
            }

            if (interceptResponse.HasValue)
            {
                dict.Add("interceptResponse", interceptResponse.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Fetch.continueRequest", dict);
        }

        partial void ValidateContinueWithAuth(string requestId, CefSharp.DevTools.Fetch.AuthChallengeResponse authChallengeResponse);
        /// <summary>
        /// Continues a request supplying authChallengeResponse following authRequired event.
        /// </summary>
        /// <param name = "requestId">An id the client received in authRequired event.</param>
        /// <param name = "authChallengeResponse">Response to  with an authChallenge.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ContinueWithAuthAsync(string requestId, CefSharp.DevTools.Fetch.AuthChallengeResponse authChallengeResponse)
        {
            ValidateContinueWithAuth(requestId, authChallengeResponse);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            dict.Add("authChallengeResponse", authChallengeResponse.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Fetch.continueWithAuth", dict);
        }

        partial void ValidateContinueResponse(string requestId, int? responseCode = null, string responsePhrase = null, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> responseHeaders = null, byte[] binaryResponseHeaders = null);
        /// <summary>
        /// Continues loading of the paused response, optionally modifying the
        /// response headers. If either responseCode or headers are modified, all of them
        /// must be present.
        /// </summary>
        /// <param name = "requestId">An id the client received in requestPaused event.</param>
        /// <param name = "responseCode">An HTTP response code. If absent, original response code will be used.</param>
        /// <param name = "responsePhrase">A textual representation of responseCode.If absent, a standard phrase matching responseCode is used.</param>
        /// <param name = "responseHeaders">Response headers. If absent, original response headers will be used.</param>
        /// <param name = "binaryResponseHeaders">Alternative way of specifying response headers as a \0-separatedseries of name: value pairs. Prefer the above method unless youneed to represent some non-UTF8 values that can't be transmittedover the protocol as text.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ContinueResponseAsync(string requestId, int? responseCode = null, string responsePhrase = null, System.Collections.Generic.IList<CefSharp.DevTools.Fetch.HeaderEntry> responseHeaders = null, byte[] binaryResponseHeaders = null)
        {
            ValidateContinueResponse(requestId, responseCode, responsePhrase, responseHeaders, binaryResponseHeaders);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            if (responseCode.HasValue)
            {
                dict.Add("responseCode", responseCode.Value);
            }

            if (!(string.IsNullOrEmpty(responsePhrase)))
            {
                dict.Add("responsePhrase", responsePhrase);
            }

            if ((responseHeaders) != (null))
            {
                dict.Add("responseHeaders", responseHeaders.Select(x => x.ToDictionary()));
            }

            if ((binaryResponseHeaders) != (null))
            {
                dict.Add("binaryResponseHeaders", ToBase64String(binaryResponseHeaders));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Fetch.continueResponse", dict);
        }

        partial void ValidateGetResponseBody(string requestId);
        /// <summary>
        /// Causes the body of the response to be received from the server and
        /// returned as a single string. May only be issued for a request that
        /// is paused in the Response stage and is mutually exclusive with
        /// takeResponseBodyForInterceptionAsStream. Calling other methods that
        /// affect the request or disabling fetch domain before body is received
        /// results in an undefined behavior.
        /// </summary>
        /// <param name = "requestId">Identifier for the intercepted request to get body for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetResponseBodyResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetResponseBodyResponse> GetResponseBodyAsync(string requestId)
        {
            ValidateGetResponseBody(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            return _client.ExecuteDevToolsMethodAsync<GetResponseBodyResponse>("Fetch.getResponseBody", dict);
        }

        partial void ValidateTakeResponseBodyAsStream(string requestId);
        /// <summary>
        /// Returns a handle to the stream representing the response body.
        /// The request must be paused in the HeadersReceived stage.
        /// Note that after this command the request can&apos;t be continued
        /// as is -- client either needs to cancel it or to provide the
        /// response body.
        /// The stream only supports sequential read, IO.read will fail if the position
        /// is specified.
        /// This method is mutually exclusive with getResponseBody.
        /// Calling other methods that affect the request or disabling fetch
        /// domain before body is received results in an undefined behavior.
        /// </summary>
        /// <param name = "requestId">requestId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakeResponseBodyAsStreamResponse&gt;</returns>
        public System.Threading.Tasks.Task<TakeResponseBodyAsStreamResponse> TakeResponseBodyAsStreamAsync(string requestId)
        {
            ValidateTakeResponseBodyAsStream(requestId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("requestId", requestId);
            return _client.ExecuteDevToolsMethodAsync<TakeResponseBodyAsStreamResponse>("Fetch.takeResponseBodyAsStream", dict);
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    /// <summary>
    /// GetRealtimeDataResponse
    /// </summary>
    public class GetRealtimeDataResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// realtimeData
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("realtimeData")]
        public CefSharp.DevTools.WebAudio.ContextRealtimeData RealtimeData
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAudio
{
    using System.Linq;

    /// <summary>
    /// This domain allows inspection of Web Audio API.
    /// https://webaudio.github.io/web-audio-api/
    /// </summary>
    public partial class WebAudioClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// WebAudio
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public WebAudioClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Notifies that a new BaseAudioContext has been created.
        /// </summary>
        public event System.EventHandler<ContextCreatedEventArgs> ContextCreated
        {
            add
            {
                _client.AddEventHandler<ContextCreatedEventArgs>("WebAudio.contextCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<ContextCreatedEventArgs>("WebAudio.contextCreated", value);
            }
        }

        /// <summary>
        /// Notifies that an existing BaseAudioContext will be destroyed.
        /// </summary>
        public event System.EventHandler<ContextWillBeDestroyedEventArgs> ContextWillBeDestroyed
        {
            add
            {
                _client.AddEventHandler<ContextWillBeDestroyedEventArgs>("WebAudio.contextWillBeDestroyed", value);
            }

            remove
            {
                _client.RemoveEventHandler<ContextWillBeDestroyedEventArgs>("WebAudio.contextWillBeDestroyed", value);
            }
        }

        /// <summary>
        /// Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
        /// </summary>
        public event System.EventHandler<ContextChangedEventArgs> ContextChanged
        {
            add
            {
                _client.AddEventHandler<ContextChangedEventArgs>("WebAudio.contextChanged", value);
            }

            remove
            {
                _client.RemoveEventHandler<ContextChangedEventArgs>("WebAudio.contextChanged", value);
            }
        }

        /// <summary>
        /// Notifies that the construction of an AudioListener has finished.
        /// </summary>
        public event System.EventHandler<AudioListenerCreatedEventArgs> AudioListenerCreated
        {
            add
            {
                _client.AddEventHandler<AudioListenerCreatedEventArgs>("WebAudio.audioListenerCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<AudioListenerCreatedEventArgs>("WebAudio.audioListenerCreated", value);
            }
        }

        /// <summary>
        /// Notifies that a new AudioListener has been created.
        /// </summary>
        public event System.EventHandler<AudioListenerWillBeDestroyedEventArgs> AudioListenerWillBeDestroyed
        {
            add
            {
                _client.AddEventHandler<AudioListenerWillBeDestroyedEventArgs>("WebAudio.audioListenerWillBeDestroyed", value);
            }

            remove
            {
                _client.RemoveEventHandler<AudioListenerWillBeDestroyedEventArgs>("WebAudio.audioListenerWillBeDestroyed", value);
            }
        }

        /// <summary>
        /// Notifies that a new AudioNode has been created.
        /// </summary>
        public event System.EventHandler<AudioNodeCreatedEventArgs> AudioNodeCreated
        {
            add
            {
                _client.AddEventHandler<AudioNodeCreatedEventArgs>("WebAudio.audioNodeCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<AudioNodeCreatedEventArgs>("WebAudio.audioNodeCreated", value);
            }
        }

        /// <summary>
        /// Notifies that an existing AudioNode has been destroyed.
        /// </summary>
        public event System.EventHandler<AudioNodeWillBeDestroyedEventArgs> AudioNodeWillBeDestroyed
        {
            add
            {
                _client.AddEventHandler<AudioNodeWillBeDestroyedEventArgs>("WebAudio.audioNodeWillBeDestroyed", value);
            }

            remove
            {
                _client.RemoveEventHandler<AudioNodeWillBeDestroyedEventArgs>("WebAudio.audioNodeWillBeDestroyed", value);
            }
        }

        /// <summary>
        /// Notifies that a new AudioParam has been created.
        /// </summary>
        public event System.EventHandler<AudioParamCreatedEventArgs> AudioParamCreated
        {
            add
            {
                _client.AddEventHandler<AudioParamCreatedEventArgs>("WebAudio.audioParamCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<AudioParamCreatedEventArgs>("WebAudio.audioParamCreated", value);
            }
        }

        /// <summary>
        /// Notifies that an existing AudioParam has been destroyed.
        /// </summary>
        public event System.EventHandler<AudioParamWillBeDestroyedEventArgs> AudioParamWillBeDestroyed
        {
            add
            {
                _client.AddEventHandler<AudioParamWillBeDestroyedEventArgs>("WebAudio.audioParamWillBeDestroyed", value);
            }

            remove
            {
                _client.RemoveEventHandler<AudioParamWillBeDestroyedEventArgs>("WebAudio.audioParamWillBeDestroyed", value);
            }
        }

        /// <summary>
        /// Notifies that two AudioNodes are connected.
        /// </summary>
        public event System.EventHandler<NodesConnectedEventArgs> NodesConnected
        {
            add
            {
                _client.AddEventHandler<NodesConnectedEventArgs>("WebAudio.nodesConnected", value);
            }

            remove
            {
                _client.RemoveEventHandler<NodesConnectedEventArgs>("WebAudio.nodesConnected", value);
            }
        }

        /// <summary>
        /// Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
        /// </summary>
        public event System.EventHandler<NodesDisconnectedEventArgs> NodesDisconnected
        {
            add
            {
                _client.AddEventHandler<NodesDisconnectedEventArgs>("WebAudio.nodesDisconnected", value);
            }

            remove
            {
                _client.RemoveEventHandler<NodesDisconnectedEventArgs>("WebAudio.nodesDisconnected", value);
            }
        }

        /// <summary>
        /// Notifies that an AudioNode is connected to an AudioParam.
        /// </summary>
        public event System.EventHandler<NodeParamConnectedEventArgs> NodeParamConnected
        {
            add
            {
                _client.AddEventHandler<NodeParamConnectedEventArgs>("WebAudio.nodeParamConnected", value);
            }

            remove
            {
                _client.RemoveEventHandler<NodeParamConnectedEventArgs>("WebAudio.nodeParamConnected", value);
            }
        }

        /// <summary>
        /// Notifies that an AudioNode is disconnected to an AudioParam.
        /// </summary>
        public event System.EventHandler<NodeParamDisconnectedEventArgs> NodeParamDisconnected
        {
            add
            {
                _client.AddEventHandler<NodeParamDisconnectedEventArgs>("WebAudio.nodeParamDisconnected", value);
            }

            remove
            {
                _client.RemoveEventHandler<NodeParamDisconnectedEventArgs>("WebAudio.nodeParamDisconnected", value);
            }
        }

        /// <summary>
        /// Enables the WebAudio domain and starts sending context lifetime events.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAudio.enable", dict);
        }

        /// <summary>
        /// Disables the WebAudio domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAudio.disable", dict);
        }

        partial void ValidateGetRealtimeData(string contextId);
        /// <summary>
        /// Fetch the realtime data from the registered contexts.
        /// </summary>
        /// <param name = "contextId">contextId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetRealtimeDataResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetRealtimeDataResponse> GetRealtimeDataAsync(string contextId)
        {
            ValidateGetRealtimeData(contextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("contextId", contextId);
            return _client.ExecuteDevToolsMethodAsync<GetRealtimeDataResponse>("WebAudio.getRealtimeData", dict);
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// AddVirtualAuthenticatorResponse
    /// </summary>
    public class AddVirtualAuthenticatorResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// authenticatorId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("authenticatorId")]
        public string AuthenticatorId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// GetCredentialResponse
    /// </summary>
    public class GetCredentialResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// credential
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("credential")]
        public CefSharp.DevTools.WebAuthn.Credential Credential
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    /// <summary>
    /// GetCredentialsResponse
    /// </summary>
    public class GetCredentialsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// credentials
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("credentials")]
        public System.Collections.Generic.IList<CefSharp.DevTools.WebAuthn.Credential> Credentials
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.WebAuthn
{
    using System.Linq;

    /// <summary>
    /// This domain allows configuring virtual authenticators to test the WebAuthn
    /// API.
    /// </summary>
    public partial class WebAuthnClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// WebAuthn
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public WebAuthnClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Triggered when a credential is added to an authenticator.
        /// </summary>
        public event System.EventHandler<CredentialAddedEventArgs> CredentialAdded
        {
            add
            {
                _client.AddEventHandler<CredentialAddedEventArgs>("WebAuthn.credentialAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<CredentialAddedEventArgs>("WebAuthn.credentialAdded", value);
            }
        }

        /// <summary>
        /// Triggered when a credential is used in a webauthn assertion.
        /// </summary>
        public event System.EventHandler<CredentialAssertedEventArgs> CredentialAsserted
        {
            add
            {
                _client.AddEventHandler<CredentialAssertedEventArgs>("WebAuthn.credentialAsserted", value);
            }

            remove
            {
                _client.RemoveEventHandler<CredentialAssertedEventArgs>("WebAuthn.credentialAsserted", value);
            }
        }

        partial void ValidateEnable(bool? enableUI = null);
        /// <summary>
        /// Enable the WebAuthn domain and start intercepting credential storage and
        /// retrieval with a virtual authenticator.
        /// </summary>
        /// <param name = "enableUI">Whether to enable the WebAuthn user interface. Enabling the UI isrecommended for debugging and demo purposes, as it is closer to the realexperience. Disabling the UI is recommended for automated testing.Supported at the embedder's discretion if UI is available.Defaults to false.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(bool? enableUI = null)
        {
            ValidateEnable(enableUI);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (enableUI.HasValue)
            {
                dict.Add("enableUI", enableUI.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.enable", dict);
        }

        /// <summary>
        /// Disable the WebAuthn domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.disable", dict);
        }

        partial void ValidateAddVirtualAuthenticator(CefSharp.DevTools.WebAuthn.VirtualAuthenticatorOptions options);
        /// <summary>
        /// Creates and adds a virtual authenticator.
        /// </summary>
        /// <param name = "options">options</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AddVirtualAuthenticatorResponse&gt;</returns>
        public System.Threading.Tasks.Task<AddVirtualAuthenticatorResponse> AddVirtualAuthenticatorAsync(CefSharp.DevTools.WebAuthn.VirtualAuthenticatorOptions options)
        {
            ValidateAddVirtualAuthenticator(options);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("options", options.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<AddVirtualAuthenticatorResponse>("WebAuthn.addVirtualAuthenticator", dict);
        }

        partial void ValidateSetResponseOverrideBits(string authenticatorId, bool? isBogusSignature = null, bool? isBadUV = null, bool? isBadUP = null);
        /// <summary>
        /// Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "isBogusSignature">If isBogusSignature is set, overrides the signature in the authenticator response to be zero.Defaults to false.</param>
        /// <param name = "isBadUV">If isBadUV is set, overrides the UV bit in the flags in the authenticator response tobe zero. Defaults to false.</param>
        /// <param name = "isBadUP">If isBadUP is set, overrides the UP bit in the flags in the authenticator response tobe zero. Defaults to false.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetResponseOverrideBitsAsync(string authenticatorId, bool? isBogusSignature = null, bool? isBadUV = null, bool? isBadUP = null)
        {
            ValidateSetResponseOverrideBits(authenticatorId, isBogusSignature, isBadUV, isBadUP);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            if (isBogusSignature.HasValue)
            {
                dict.Add("isBogusSignature", isBogusSignature.Value);
            }

            if (isBadUV.HasValue)
            {
                dict.Add("isBadUV", isBadUV.Value);
            }

            if (isBadUP.HasValue)
            {
                dict.Add("isBadUP", isBadUP.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.setResponseOverrideBits", dict);
        }

        partial void ValidateRemoveVirtualAuthenticator(string authenticatorId);
        /// <summary>
        /// Removes the given authenticator.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveVirtualAuthenticatorAsync(string authenticatorId)
        {
            ValidateRemoveVirtualAuthenticator(authenticatorId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.removeVirtualAuthenticator", dict);
        }

        partial void ValidateAddCredential(string authenticatorId, CefSharp.DevTools.WebAuthn.Credential credential);
        /// <summary>
        /// Adds the credential to the specified authenticator.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "credential">credential</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> AddCredentialAsync(string authenticatorId, CefSharp.DevTools.WebAuthn.Credential credential)
        {
            ValidateAddCredential(authenticatorId, credential);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("credential", credential.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.addCredential", dict);
        }

        partial void ValidateGetCredential(string authenticatorId, byte[] credentialId);
        /// <summary>
        /// Returns a single credential stored in the given virtual authenticator that
        /// matches the credential ID.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "credentialId">credentialId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCredentialResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetCredentialResponse> GetCredentialAsync(string authenticatorId, byte[] credentialId)
        {
            ValidateGetCredential(authenticatorId, credentialId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("credentialId", ToBase64String(credentialId));
            return _client.ExecuteDevToolsMethodAsync<GetCredentialResponse>("WebAuthn.getCredential", dict);
        }

        partial void ValidateGetCredentials(string authenticatorId);
        /// <summary>
        /// Returns all the credentials stored in the given virtual authenticator.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetCredentialsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetCredentialsResponse> GetCredentialsAsync(string authenticatorId)
        {
            ValidateGetCredentials(authenticatorId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            return _client.ExecuteDevToolsMethodAsync<GetCredentialsResponse>("WebAuthn.getCredentials", dict);
        }

        partial void ValidateRemoveCredential(string authenticatorId, byte[] credentialId);
        /// <summary>
        /// Removes a credential from the authenticator.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "credentialId">credentialId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveCredentialAsync(string authenticatorId, byte[] credentialId)
        {
            ValidateRemoveCredential(authenticatorId, credentialId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("credentialId", ToBase64String(credentialId));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.removeCredential", dict);
        }

        partial void ValidateClearCredentials(string authenticatorId);
        /// <summary>
        /// Clears all the credentials from the specified device.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ClearCredentialsAsync(string authenticatorId)
        {
            ValidateClearCredentials(authenticatorId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.clearCredentials", dict);
        }

        partial void ValidateSetUserVerified(string authenticatorId, bool isUserVerified);
        /// <summary>
        /// Sets whether User Verification succeeds or fails for an authenticator.
        /// The default is true.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "isUserVerified">isUserVerified</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetUserVerifiedAsync(string authenticatorId, bool isUserVerified)
        {
            ValidateSetUserVerified(authenticatorId, isUserVerified);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("isUserVerified", isUserVerified);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.setUserVerified", dict);
        }

        partial void ValidateSetAutomaticPresenceSimulation(string authenticatorId, bool enabled);
        /// <summary>
        /// Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
        /// The default is true.
        /// </summary>
        /// <param name = "authenticatorId">authenticatorId</param>
        /// <param name = "enabled">enabled</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAutomaticPresenceSimulationAsync(string authenticatorId, bool enabled)
        {
            ValidateSetAutomaticPresenceSimulation(authenticatorId, enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("authenticatorId", authenticatorId);
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("WebAuthn.setAutomaticPresenceSimulation", dict);
        }
    }
}

namespace CefSharp.DevTools.Media
{
    using System.Linq;

    /// <summary>
    /// This domain allows detailed inspection of media elements
    /// </summary>
    public partial class MediaClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Media
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public MediaClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// This can be called multiple times, and can be used to set / override /
        /// remove player properties. A null propValue indicates removal.
        /// </summary>
        public event System.EventHandler<PlayerPropertiesChangedEventArgs> PlayerPropertiesChanged
        {
            add
            {
                _client.AddEventHandler<PlayerPropertiesChangedEventArgs>("Media.playerPropertiesChanged", value);
            }

            remove
            {
                _client.RemoveEventHandler<PlayerPropertiesChangedEventArgs>("Media.playerPropertiesChanged", value);
            }
        }

        /// <summary>
        /// Send events as a list, allowing them to be batched on the browser for less
        /// congestion. If batched, events must ALWAYS be in chronological order.
        /// </summary>
        public event System.EventHandler<PlayerEventsAddedEventArgs> PlayerEventsAdded
        {
            add
            {
                _client.AddEventHandler<PlayerEventsAddedEventArgs>("Media.playerEventsAdded", value);
            }

            remove
            {
                _client.RemoveEventHandler<PlayerEventsAddedEventArgs>("Media.playerEventsAdded", value);
            }
        }

        /// <summary>
        /// Send a list of any messages that need to be delivered.
        /// </summary>
        public event System.EventHandler<PlayerMessagesLoggedEventArgs> PlayerMessagesLogged
        {
            add
            {
                _client.AddEventHandler<PlayerMessagesLoggedEventArgs>("Media.playerMessagesLogged", value);
            }

            remove
            {
                _client.RemoveEventHandler<PlayerMessagesLoggedEventArgs>("Media.playerMessagesLogged", value);
            }
        }

        /// <summary>
        /// Send a list of any errors that need to be delivered.
        /// </summary>
        public event System.EventHandler<PlayerErrorsRaisedEventArgs> PlayerErrorsRaised
        {
            add
            {
                _client.AddEventHandler<PlayerErrorsRaisedEventArgs>("Media.playerErrorsRaised", value);
            }

            remove
            {
                _client.RemoveEventHandler<PlayerErrorsRaisedEventArgs>("Media.playerErrorsRaised", value);
            }
        }

        /// <summary>
        /// Called whenever a player is created, or when a new agent joins and receives
        /// a list of active players. If an agent is restored, it will receive the full
        /// list of player ids and all events again.
        /// </summary>
        public event System.EventHandler<PlayersCreatedEventArgs> PlayersCreated
        {
            add
            {
                _client.AddEventHandler<PlayersCreatedEventArgs>("Media.playersCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<PlayersCreatedEventArgs>("Media.playersCreated", value);
            }
        }

        /// <summary>
        /// Enables the Media domain
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Media.enable", dict);
        }

        /// <summary>
        /// Disables the Media domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Media.disable", dict);
        }
    }
}

namespace CefSharp.DevTools.DeviceAccess
{
    using System.Linq;

    /// <summary>
    /// DeviceAccess
    /// </summary>
    public partial class DeviceAccessClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// DeviceAccess
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public DeviceAccessClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// A device request opened a user prompt to select a device. Respond with the
        /// selectPrompt or cancelPrompt command.
        /// </summary>
        public event System.EventHandler<DeviceRequestPromptedEventArgs> DeviceRequestPrompted
        {
            add
            {
                _client.AddEventHandler<DeviceRequestPromptedEventArgs>("DeviceAccess.deviceRequestPrompted", value);
            }

            remove
            {
                _client.RemoveEventHandler<DeviceRequestPromptedEventArgs>("DeviceAccess.deviceRequestPrompted", value);
            }
        }

        /// <summary>
        /// Enable events in this domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DeviceAccess.enable", dict);
        }

        /// <summary>
        /// Disable events in this domain.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DeviceAccess.disable", dict);
        }

        partial void ValidateSelectPrompt(string id, string deviceId);
        /// <summary>
        /// Select a device in response to a DeviceAccess.deviceRequestPrompted event.
        /// </summary>
        /// <param name = "id">id</param>
        /// <param name = "deviceId">deviceId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SelectPromptAsync(string id, string deviceId)
        {
            ValidateSelectPrompt(id, deviceId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("id", id);
            dict.Add("deviceId", deviceId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DeviceAccess.selectPrompt", dict);
        }

        partial void ValidateCancelPrompt(string id);
        /// <summary>
        /// Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
        /// </summary>
        /// <param name = "id">id</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CancelPromptAsync(string id)
        {
            ValidateCancelPrompt(id);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("id", id);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("DeviceAccess.cancelPrompt", dict);
        }
    }
}

namespace CefSharp.DevTools.Preload
{
    using System.Linq;

    /// <summary>
    /// Preload
    /// </summary>
    public partial class PreloadClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Preload
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public PreloadClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Upsert. Currently, it is only emitted when a rule set added.
        /// </summary>
        public event System.EventHandler<RuleSetUpdatedEventArgs> RuleSetUpdated
        {
            add
            {
                _client.AddEventHandler<RuleSetUpdatedEventArgs>("Preload.ruleSetUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<RuleSetUpdatedEventArgs>("Preload.ruleSetUpdated", value);
            }
        }

        /// <summary>
        /// RuleSetRemoved
        /// </summary>
        public event System.EventHandler<RuleSetRemovedEventArgs> RuleSetRemoved
        {
            add
            {
                _client.AddEventHandler<RuleSetRemovedEventArgs>("Preload.ruleSetRemoved", value);
            }

            remove
            {
                _client.RemoveEventHandler<RuleSetRemovedEventArgs>("Preload.ruleSetRemoved", value);
            }
        }

        /// <summary>
        /// Fired when a prerender attempt is completed.
        /// </summary>
        public event System.EventHandler<PrerenderAttemptCompletedEventArgs> PrerenderAttemptCompleted
        {
            add
            {
                _client.AddEventHandler<PrerenderAttemptCompletedEventArgs>("Preload.prerenderAttemptCompleted", value);
            }

            remove
            {
                _client.RemoveEventHandler<PrerenderAttemptCompletedEventArgs>("Preload.prerenderAttemptCompleted", value);
            }
        }

        /// <summary>
        /// Fired when a preload enabled state is updated.
        /// </summary>
        public event System.EventHandler<PreloadEnabledStateUpdatedEventArgs> PreloadEnabledStateUpdated
        {
            add
            {
                _client.AddEventHandler<PreloadEnabledStateUpdatedEventArgs>("Preload.preloadEnabledStateUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<PreloadEnabledStateUpdatedEventArgs>("Preload.preloadEnabledStateUpdated", value);
            }
        }

        /// <summary>
        /// Fired when a prefetch attempt is updated.
        /// </summary>
        public event System.EventHandler<PrefetchStatusUpdatedEventArgs> PrefetchStatusUpdated
        {
            add
            {
                _client.AddEventHandler<PrefetchStatusUpdatedEventArgs>("Preload.prefetchStatusUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<PrefetchStatusUpdatedEventArgs>("Preload.prefetchStatusUpdated", value);
            }
        }

        /// <summary>
        /// Fired when a prerender attempt is updated.
        /// </summary>
        public event System.EventHandler<PrerenderStatusUpdatedEventArgs> PrerenderStatusUpdated
        {
            add
            {
                _client.AddEventHandler<PrerenderStatusUpdatedEventArgs>("Preload.prerenderStatusUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<PrerenderStatusUpdatedEventArgs>("Preload.prerenderStatusUpdated", value);
            }
        }

        /// <summary>
        /// Send a list of sources for all preloading attempts in a document.
        /// </summary>
        public event System.EventHandler<PreloadingAttemptSourcesUpdatedEventArgs> PreloadingAttemptSourcesUpdated
        {
            add
            {
                _client.AddEventHandler<PreloadingAttemptSourcesUpdatedEventArgs>("Preload.preloadingAttemptSourcesUpdated", value);
            }

            remove
            {
                _client.RemoveEventHandler<PreloadingAttemptSourcesUpdatedEventArgs>("Preload.preloadingAttemptSourcesUpdated", value);
            }
        }

        /// <summary>
        /// Enable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Preload.enable", dict);
        }

        /// <summary>
        /// Disable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Preload.disable", dict);
        }
    }
}

namespace CefSharp.DevTools.FedCm
{
    using System.Linq;

    /// <summary>
    /// This domain allows interacting with the FedCM dialog.
    /// </summary>
    public partial class FedCmClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// FedCm
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public FedCmClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// DialogShown
        /// </summary>
        public event System.EventHandler<DialogShownEventArgs> DialogShown
        {
            add
            {
                _client.AddEventHandler<DialogShownEventArgs>("FedCm.dialogShown", value);
            }

            remove
            {
                _client.RemoveEventHandler<DialogShownEventArgs>("FedCm.dialogShown", value);
            }
        }

        partial void ValidateEnable(bool? disableRejectionDelay = null);
        /// <summary>
        /// Enable
        /// </summary>
        /// <param name = "disableRejectionDelay">Allows callers to disable the promise rejection delay that wouldnormally happen, if this is unimportant to what's being tested.(step 4 of https://fedidcg.github.io/FedCM/#browser-api-rp-sign-in)</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync(bool? disableRejectionDelay = null)
        {
            ValidateEnable(disableRejectionDelay);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (disableRejectionDelay.HasValue)
            {
                dict.Add("disableRejectionDelay", disableRejectionDelay.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("FedCm.enable", dict);
        }

        /// <summary>
        /// Disable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("FedCm.disable", dict);
        }

        partial void ValidateSelectAccount(string dialogId, int accountIndex);
        /// <summary>
        /// SelectAccount
        /// </summary>
        /// <param name = "dialogId">dialogId</param>
        /// <param name = "accountIndex">accountIndex</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SelectAccountAsync(string dialogId, int accountIndex)
        {
            ValidateSelectAccount(dialogId, accountIndex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("dialogId", dialogId);
            dict.Add("accountIndex", accountIndex);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("FedCm.selectAccount", dict);
        }

        partial void ValidateDismissDialog(string dialogId, bool? triggerCooldown = null);
        /// <summary>
        /// DismissDialog
        /// </summary>
        /// <param name = "dialogId">dialogId</param>
        /// <param name = "triggerCooldown">triggerCooldown</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DismissDialogAsync(string dialogId, bool? triggerCooldown = null)
        {
            ValidateDismissDialog(dialogId, triggerCooldown);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("dialogId", dialogId);
            if (triggerCooldown.HasValue)
            {
                dict.Add("triggerCooldown", triggerCooldown.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("FedCm.dismissDialog", dict);
        }

        /// <summary>
        /// Resets the cooldown time, if any, to allow the next FedCM call to show
        /// a dialog even if one was recently dismissed by the user.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ResetCooldownAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("FedCm.resetCooldown", dict);
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// EnableResponse
    /// </summary>
    public class EnableResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// debuggerId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("debuggerId")]
        public string DebuggerId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// EvaluateOnCallFrameResponse
    /// </summary>
    public class EvaluateOnCallFrameResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// GetPossibleBreakpointsResponse
    /// </summary>
    public class GetPossibleBreakpointsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// locations
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("locations")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.BreakLocation> Locations
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// GetScriptSourceResponse
    /// </summary>
    public class GetScriptSourceResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// scriptSource
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("scriptSource")]
        public string ScriptSource
        {
            get;
            private set;
        }

        /// <summary>
        /// bytecode
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("bytecode")]
        public byte[] Bytecode
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// DisassembleWasmModuleResponse
    /// </summary>
    public class DisassembleWasmModuleResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// streamId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("streamId")]
        public string StreamId
        {
            get;
            private set;
        }

        /// <summary>
        /// totalNumberOfLines
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("totalNumberOfLines")]
        public int TotalNumberOfLines
        {
            get;
            private set;
        }

        /// <summary>
        /// functionBodyOffsets
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("functionBodyOffsets")]
        public int[] FunctionBodyOffsets
        {
            get;
            private set;
        }

        /// <summary>
        /// chunk
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("chunk")]
        public CefSharp.DevTools.Debugger.WasmDisassemblyChunk Chunk
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// NextWasmDisassemblyChunkResponse
    /// </summary>
    public class NextWasmDisassemblyChunkResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// chunk
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("chunk")]
        public CefSharp.DevTools.Debugger.WasmDisassemblyChunk Chunk
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// GetStackTraceResponse
    /// </summary>
    public class GetStackTraceResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// stackTrace
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace StackTrace
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// RestartFrameResponse
    /// </summary>
    public class RestartFrameResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// callFrames
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("callFrames")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.CallFrame> CallFrames
        {
            get;
            private set;
        }

        /// <summary>
        /// asyncStackTrace
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("asyncStackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace AsyncStackTrace
        {
            get;
            private set;
        }

        /// <summary>
        /// asyncStackTraceId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("asyncStackTraceId")]
        public CefSharp.DevTools.Runtime.StackTraceId AsyncStackTraceId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SearchInContentResponse
    /// </summary>
    public class SearchInContentResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.SearchMatch> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetBreakpointResponse
    /// </summary>
    public class SetBreakpointResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// breakpointId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("breakpointId")]
        public string BreakpointId
        {
            get;
            private set;
        }

        /// <summary>
        /// actualLocation
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("actualLocation")]
        public CefSharp.DevTools.Debugger.Location ActualLocation
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetInstrumentationBreakpointResponse
    /// </summary>
    public class SetInstrumentationBreakpointResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// breakpointId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("breakpointId")]
        public string BreakpointId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetBreakpointByUrlResponse
    /// </summary>
    public class SetBreakpointByUrlResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// breakpointId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("breakpointId")]
        public string BreakpointId
        {
            get;
            private set;
        }

        /// <summary>
        /// locations
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("locations")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.Location> Locations
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetBreakpointOnFunctionCallResponse
    /// </summary>
    public class SetBreakpointOnFunctionCallResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// breakpointId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("breakpointId")]
        public string BreakpointId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    /// <summary>
    /// SetScriptSourceResponse
    /// </summary>
    public class SetScriptSourceResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// callFrames
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("callFrames")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Debugger.CallFrame> CallFrames
        {
            get;
            private set;
        }

        /// <summary>
        /// stackChanged
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("stackChanged")]
        public bool? StackChanged
        {
            get;
            private set;
        }

        /// <summary>
        /// asyncStackTrace
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("asyncStackTrace")]
        public CefSharp.DevTools.Runtime.StackTrace AsyncStackTrace
        {
            get;
            private set;
        }

        /// <summary>
        /// asyncStackTraceId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("asyncStackTraceId")]
        public CefSharp.DevTools.Runtime.StackTraceId AsyncStackTraceId
        {
            get;
            private set;
        }

        /// <summary>
        /// status
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("status")]
        public string Status
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Debugger
{
    using System.Linq;

    /// <summary>
    /// ContinueToLocationTargetCallFrames
    /// </summary>
    public enum ContinueToLocationTargetCallFrames
    {
        /// <summary>
        /// any
        /// </summary>
        [JsonPropertyName("any")]
        Any,
        /// <summary>
        /// current
        /// </summary>
        [JsonPropertyName("current")]
        Current
    }

    /// <summary>
    /// The `mode` parameter must be present and set to &apos;StepInto&apos;, otherwise
    /// `restartFrame` will error out.
    /// </summary>
    public enum RestartFrameMode
    {
        /// <summary>
        /// StepInto
        /// </summary>
        [JsonPropertyName("StepInto")]
        StepInto
    }

    /// <summary>
    /// Instrumentation name.
    /// </summary>
    public enum SetInstrumentationBreakpointInstrumentation
    {
        /// <summary>
        /// beforeScriptExecution
        /// </summary>
        [JsonPropertyName("beforeScriptExecution")]
        BeforeScriptExecution,
        /// <summary>
        /// beforeScriptWithSourceMapExecution
        /// </summary>
        [JsonPropertyName("beforeScriptWithSourceMapExecution")]
        BeforeScriptWithSourceMapExecution
    }

    /// <summary>
    /// Pause on exceptions mode.
    /// </summary>
    public enum SetPauseOnExceptionsState
    {
        /// <summary>
        /// none
        /// </summary>
        [JsonPropertyName("none")]
        None,
        /// <summary>
        /// caught
        /// </summary>
        [JsonPropertyName("caught")]
        Caught,
        /// <summary>
        /// uncaught
        /// </summary>
        [JsonPropertyName("uncaught")]
        Uncaught,
        /// <summary>
        /// all
        /// </summary>
        [JsonPropertyName("all")]
        All
    }

    /// <summary>
    /// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
    /// breakpoints, stepping through execution, exploring stack traces, etc.
    /// </summary>
    public partial class DebuggerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Debugger
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public DebuggerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Fired when breakpoint is resolved to an actual script and location.
        /// </summary>
        public event System.EventHandler<BreakpointResolvedEventArgs> BreakpointResolved
        {
            add
            {
                _client.AddEventHandler<BreakpointResolvedEventArgs>("Debugger.breakpointResolved", value);
            }

            remove
            {
                _client.RemoveEventHandler<BreakpointResolvedEventArgs>("Debugger.breakpointResolved", value);
            }
        }

        /// <summary>
        /// Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
        /// </summary>
        public event System.EventHandler<PausedEventArgs> Paused
        {
            add
            {
                _client.AddEventHandler<PausedEventArgs>("Debugger.paused", value);
            }

            remove
            {
                _client.RemoveEventHandler<PausedEventArgs>("Debugger.paused", value);
            }
        }

        /// <summary>
        /// Fired when the virtual machine resumed execution.
        /// </summary>
        public event System.EventHandler<System.EventArgs> Resumed
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Debugger.resumed", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Debugger.resumed", value);
            }
        }

        /// <summary>
        /// Fired when virtual machine fails to parse the script.
        /// </summary>
        public event System.EventHandler<ScriptFailedToParseEventArgs> ScriptFailedToParse
        {
            add
            {
                _client.AddEventHandler<ScriptFailedToParseEventArgs>("Debugger.scriptFailedToParse", value);
            }

            remove
            {
                _client.RemoveEventHandler<ScriptFailedToParseEventArgs>("Debugger.scriptFailedToParse", value);
            }
        }

        /// <summary>
        /// Fired when virtual machine parses script. This event is also fired for all known and uncollected
        /// scripts upon enabling debugger.
        /// </summary>
        public event System.EventHandler<ScriptParsedEventArgs> ScriptParsed
        {
            add
            {
                _client.AddEventHandler<ScriptParsedEventArgs>("Debugger.scriptParsed", value);
            }

            remove
            {
                _client.RemoveEventHandler<ScriptParsedEventArgs>("Debugger.scriptParsed", value);
            }
        }

        partial void ValidateContinueToLocation(CefSharp.DevTools.Debugger.Location location, CefSharp.DevTools.Debugger.ContinueToLocationTargetCallFrames? targetCallFrames = null);
        /// <summary>
        /// Continues execution until specific location is reached.
        /// </summary>
        /// <param name = "location">Location to continue to.</param>
        /// <param name = "targetCallFrames">targetCallFrames</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ContinueToLocationAsync(CefSharp.DevTools.Debugger.Location location, CefSharp.DevTools.Debugger.ContinueToLocationTargetCallFrames? targetCallFrames = null)
        {
            ValidateContinueToLocation(location, targetCallFrames);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("location", location.ToDictionary());
            if (targetCallFrames.HasValue)
            {
                dict.Add("targetCallFrames", EnumToString(targetCallFrames));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.continueToLocation", dict);
        }

        /// <summary>
        /// Disables debugger for given page.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.disable", dict);
        }

        partial void ValidateEnable(double? maxScriptsCacheSize = null);
        /// <summary>
        /// Enables debugger for the given page. Clients should not assume that the debugging has been
        /// enabled until the result for this command is received.
        /// </summary>
        /// <param name = "maxScriptsCacheSize">The maximum size in bytes of collected scripts (not referenced by other heap objects)the debugger can hold. Puts no limit if parameter is omitted.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;EnableResponse&gt;</returns>
        public System.Threading.Tasks.Task<EnableResponse> EnableAsync(double? maxScriptsCacheSize = null)
        {
            ValidateEnable(maxScriptsCacheSize);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (maxScriptsCacheSize.HasValue)
            {
                dict.Add("maxScriptsCacheSize", maxScriptsCacheSize.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<EnableResponse>("Debugger.enable", dict);
        }

        partial void ValidateEvaluateOnCallFrame(string callFrameId, string expression, string objectGroup = null, bool? includeCommandLineAPI = null, bool? silent = null, bool? returnByValue = null, bool? generatePreview = null, bool? throwOnSideEffect = null, double? timeout = null);
        /// <summary>
        /// Evaluates expression on a given call frame.
        /// </summary>
        /// <param name = "callFrameId">Call frame identifier to evaluate on.</param>
        /// <param name = "expression">Expression to evaluate.</param>
        /// <param name = "objectGroup">String object group name to put result into (allows rapid releasing resulting object handlesusing `releaseObjectGroup`).</param>
        /// <param name = "includeCommandLineAPI">Specifies whether command line API should be available to the evaluated expression, defaultsto false.</param>
        /// <param name = "silent">In silent mode exceptions thrown during evaluation are not reported and do not pauseexecution. Overrides `setPauseOnException` state.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <param name = "throwOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.</param>
        /// <param name = "timeout">Terminate execution after timing out (number of milliseconds).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;EvaluateOnCallFrameResponse&gt;</returns>
        public System.Threading.Tasks.Task<EvaluateOnCallFrameResponse> EvaluateOnCallFrameAsync(string callFrameId, string expression, string objectGroup = null, bool? includeCommandLineAPI = null, bool? silent = null, bool? returnByValue = null, bool? generatePreview = null, bool? throwOnSideEffect = null, double? timeout = null)
        {
            ValidateEvaluateOnCallFrame(callFrameId, expression, objectGroup, includeCommandLineAPI, silent, returnByValue, generatePreview, throwOnSideEffect, timeout);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("callFrameId", callFrameId);
            dict.Add("expression", expression);
            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (includeCommandLineAPI.HasValue)
            {
                dict.Add("includeCommandLineAPI", includeCommandLineAPI.Value);
            }

            if (silent.HasValue)
            {
                dict.Add("silent", silent.Value);
            }

            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (throwOnSideEffect.HasValue)
            {
                dict.Add("throwOnSideEffect", throwOnSideEffect.Value);
            }

            if (timeout.HasValue)
            {
                dict.Add("timeout", timeout.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<EvaluateOnCallFrameResponse>("Debugger.evaluateOnCallFrame", dict);
        }

        partial void ValidateGetPossibleBreakpoints(CefSharp.DevTools.Debugger.Location start, CefSharp.DevTools.Debugger.Location end = null, bool? restrictToFunction = null);
        /// <summary>
        /// Returns possible locations for breakpoint. scriptId in start and end range locations should be
        /// the same.
        /// </summary>
        /// <param name = "start">Start of range to search possible breakpoint locations in.</param>
        /// <param name = "end">End of range to search possible breakpoint locations in (excluding). When not specified, endof scripts is used as end of range.</param>
        /// <param name = "restrictToFunction">Only consider locations which are in the same (non-nested) function as start.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPossibleBreakpointsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetPossibleBreakpointsResponse> GetPossibleBreakpointsAsync(CefSharp.DevTools.Debugger.Location start, CefSharp.DevTools.Debugger.Location end = null, bool? restrictToFunction = null)
        {
            ValidateGetPossibleBreakpoints(start, end, restrictToFunction);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("start", start.ToDictionary());
            if ((end) != (null))
            {
                dict.Add("end", end.ToDictionary());
            }

            if (restrictToFunction.HasValue)
            {
                dict.Add("restrictToFunction", restrictToFunction.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetPossibleBreakpointsResponse>("Debugger.getPossibleBreakpoints", dict);
        }

        partial void ValidateGetScriptSource(string scriptId);
        /// <summary>
        /// Returns source for the script with given id.
        /// </summary>
        /// <param name = "scriptId">Id of the script to get source for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetScriptSourceResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetScriptSourceResponse> GetScriptSourceAsync(string scriptId)
        {
            ValidateGetScriptSource(scriptId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            return _client.ExecuteDevToolsMethodAsync<GetScriptSourceResponse>("Debugger.getScriptSource", dict);
        }

        partial void ValidateDisassembleWasmModule(string scriptId);
        /// <summary>
        /// DisassembleWasmModule
        /// </summary>
        /// <param name = "scriptId">Id of the script to disassemble</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DisassembleWasmModuleResponse&gt;</returns>
        public System.Threading.Tasks.Task<DisassembleWasmModuleResponse> DisassembleWasmModuleAsync(string scriptId)
        {
            ValidateDisassembleWasmModule(scriptId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            return _client.ExecuteDevToolsMethodAsync<DisassembleWasmModuleResponse>("Debugger.disassembleWasmModule", dict);
        }

        partial void ValidateNextWasmDisassemblyChunk(string streamId);
        /// <summary>
        /// Disassemble the next chunk of lines for the module corresponding to the
        /// stream. If disassembly is complete, this API will invalidate the streamId
        /// and return an empty chunk. Any subsequent calls for the now invalid stream
        /// will return errors.
        /// </summary>
        /// <param name = "streamId">streamId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;NextWasmDisassemblyChunkResponse&gt;</returns>
        public System.Threading.Tasks.Task<NextWasmDisassemblyChunkResponse> NextWasmDisassemblyChunkAsync(string streamId)
        {
            ValidateNextWasmDisassemblyChunk(streamId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("streamId", streamId);
            return _client.ExecuteDevToolsMethodAsync<NextWasmDisassemblyChunkResponse>("Debugger.nextWasmDisassemblyChunk", dict);
        }

        partial void ValidateGetStackTrace(CefSharp.DevTools.Runtime.StackTraceId stackTraceId);
        /// <summary>
        /// Returns stack trace with given `stackTraceId`.
        /// </summary>
        /// <param name = "stackTraceId">stackTraceId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetStackTraceResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetStackTraceResponse> GetStackTraceAsync(CefSharp.DevTools.Runtime.StackTraceId stackTraceId)
        {
            ValidateGetStackTrace(stackTraceId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("stackTraceId", stackTraceId.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<GetStackTraceResponse>("Debugger.getStackTrace", dict);
        }

        /// <summary>
        /// Stops on the next JavaScript statement.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> PauseAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.pause", dict);
        }

        partial void ValidateRemoveBreakpoint(string breakpointId);
        /// <summary>
        /// Removes JavaScript breakpoint.
        /// </summary>
        /// <param name = "breakpointId">breakpointId</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveBreakpointAsync(string breakpointId)
        {
            ValidateRemoveBreakpoint(breakpointId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("breakpointId", breakpointId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.removeBreakpoint", dict);
        }

        partial void ValidateRestartFrame(string callFrameId, CefSharp.DevTools.Debugger.RestartFrameMode? mode = null);
        /// <summary>
        /// Restarts particular call frame from the beginning. The old, deprecated
        /// behavior of `restartFrame` is to stay paused and allow further CDP commands
        /// after a restart was scheduled. This can cause problems with restarting, so
        /// we now continue execution immediatly after it has been scheduled until we
        /// reach the beginning of the restarted frame.
        /// 
        /// To stay back-wards compatible, `restartFrame` now expects a `mode`
        /// parameter to be present. If the `mode` parameter is missing, `restartFrame`
        /// errors out.
        /// 
        /// The various return values are deprecated and `callFrames` is always empty.
        /// Use the call frames from the `Debugger#paused` events instead, that fires
        /// once V8 pauses at the beginning of the restarted function.
        /// </summary>
        /// <param name = "callFrameId">Call frame identifier to evaluate on.</param>
        /// <param name = "mode">The `mode` parameter must be present and set to 'StepInto', otherwise`restartFrame` will error out.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RestartFrameResponse&gt;</returns>
        public System.Threading.Tasks.Task<RestartFrameResponse> RestartFrameAsync(string callFrameId, CefSharp.DevTools.Debugger.RestartFrameMode? mode = null)
        {
            ValidateRestartFrame(callFrameId, mode);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("callFrameId", callFrameId);
            if (mode.HasValue)
            {
                dict.Add("mode", EnumToString(mode));
            }

            return _client.ExecuteDevToolsMethodAsync<RestartFrameResponse>("Debugger.restartFrame", dict);
        }

        partial void ValidateResume(bool? terminateOnResume = null);
        /// <summary>
        /// Resumes JavaScript execution.
        /// </summary>
        /// <param name = "terminateOnResume">Set to true to terminate execution upon resuming execution. In contrastto Runtime.terminateExecution, this will allows to execute furtherJavaScript (i.e. via evaluation) until execution of the paused codeis actually resumed, at which point termination is triggered.If execution is currently not paused, this parameter has no effect.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ResumeAsync(bool? terminateOnResume = null)
        {
            ValidateResume(terminateOnResume);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (terminateOnResume.HasValue)
            {
                dict.Add("terminateOnResume", terminateOnResume.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.resume", dict);
        }

        partial void ValidateSearchInContent(string scriptId, string query, bool? caseSensitive = null, bool? isRegex = null);
        /// <summary>
        /// Searches for given string in script content.
        /// </summary>
        /// <param name = "scriptId">Id of the script to search in.</param>
        /// <param name = "query">String to search for.</param>
        /// <param name = "caseSensitive">If true, search is case sensitive.</param>
        /// <param name = "isRegex">If true, treats string parameter as regex.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SearchInContentResponse&gt;</returns>
        public System.Threading.Tasks.Task<SearchInContentResponse> SearchInContentAsync(string scriptId, string query, bool? caseSensitive = null, bool? isRegex = null)
        {
            ValidateSearchInContent(scriptId, query, caseSensitive, isRegex);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            dict.Add("query", query);
            if (caseSensitive.HasValue)
            {
                dict.Add("caseSensitive", caseSensitive.Value);
            }

            if (isRegex.HasValue)
            {
                dict.Add("isRegex", isRegex.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<SearchInContentResponse>("Debugger.searchInContent", dict);
        }

        partial void ValidateSetAsyncCallStackDepth(int maxDepth);
        /// <summary>
        /// Enables or disables async call stacks tracking.
        /// </summary>
        /// <param name = "maxDepth">Maximum depth of async call stacks. Setting to `0` will effectively disable collecting asynccall stacks (default).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAsyncCallStackDepthAsync(int maxDepth)
        {
            ValidateSetAsyncCallStackDepth(maxDepth);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("maxDepth", maxDepth);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.setAsyncCallStackDepth", dict);
        }

        partial void ValidateSetBlackboxPatterns(string[] patterns);
        /// <summary>
        /// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
        /// scripts with url matching one of the patterns. VM will try to leave blackboxed script by
        /// performing &apos;step in&apos; several times, finally resorting to &apos;step out&apos; if unsuccessful.
        /// </summary>
        /// <param name = "patterns">Array of regexps that will be used to check script url for blackbox state.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetBlackboxPatternsAsync(string[] patterns)
        {
            ValidateSetBlackboxPatterns(patterns);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("patterns", patterns);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.setBlackboxPatterns", dict);
        }

        partial void ValidateSetBlackboxedRanges(string scriptId, System.Collections.Generic.IList<CefSharp.DevTools.Debugger.ScriptPosition> positions);
        /// <summary>
        /// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
        /// scripts by performing &apos;step in&apos; several times, finally resorting to &apos;step out&apos; if unsuccessful.
        /// Positions array contains positions where blackbox state is changed. First interval isn&apos;t
        /// blackboxed. Array should be sorted.
        /// </summary>
        /// <param name = "scriptId">Id of the script.</param>
        /// <param name = "positions">positions</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetBlackboxedRangesAsync(string scriptId, System.Collections.Generic.IList<CefSharp.DevTools.Debugger.ScriptPosition> positions)
        {
            ValidateSetBlackboxedRanges(scriptId, positions);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            dict.Add("positions", positions.Select(x => x.ToDictionary()));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.setBlackboxedRanges", dict);
        }

        partial void ValidateSetBreakpoint(CefSharp.DevTools.Debugger.Location location, string condition = null);
        /// <summary>
        /// Sets JavaScript breakpoint at a given location.
        /// </summary>
        /// <param name = "location">Location to set breakpoint in.</param>
        /// <param name = "condition">Expression to use as a breakpoint condition. When specified, debugger will only stop on thebreakpoint if this expression evaluates to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetBreakpointResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetBreakpointResponse> SetBreakpointAsync(CefSharp.DevTools.Debugger.Location location, string condition = null)
        {
            ValidateSetBreakpoint(location, condition);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("location", location.ToDictionary());
            if (!(string.IsNullOrEmpty(condition)))
            {
                dict.Add("condition", condition);
            }

            return _client.ExecuteDevToolsMethodAsync<SetBreakpointResponse>("Debugger.setBreakpoint", dict);
        }

        partial void ValidateSetInstrumentationBreakpoint(CefSharp.DevTools.Debugger.SetInstrumentationBreakpointInstrumentation instrumentation);
        /// <summary>
        /// Sets instrumentation breakpoint.
        /// </summary>
        /// <param name = "instrumentation">Instrumentation name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetInstrumentationBreakpointResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetInstrumentationBreakpointResponse> SetInstrumentationBreakpointAsync(CefSharp.DevTools.Debugger.SetInstrumentationBreakpointInstrumentation instrumentation)
        {
            ValidateSetInstrumentationBreakpoint(instrumentation);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("instrumentation", EnumToString(instrumentation));
            return _client.ExecuteDevToolsMethodAsync<SetInstrumentationBreakpointResponse>("Debugger.setInstrumentationBreakpoint", dict);
        }

        partial void ValidateSetBreakpointByUrl(int lineNumber, string url = null, string urlRegex = null, string scriptHash = null, int? columnNumber = null, string condition = null);
        /// <summary>
        /// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
        /// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
        /// `locations` property. Further matching script parsing will result in subsequent
        /// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
        /// </summary>
        /// <param name = "lineNumber">Line number to set breakpoint at.</param>
        /// <param name = "url">URL of the resources to set breakpoint on.</param>
        /// <param name = "urlRegex">Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or`urlRegex` must be specified.</param>
        /// <param name = "scriptHash">Script hash of the resources to set breakpoint on.</param>
        /// <param name = "columnNumber">Offset in the line to set breakpoint at.</param>
        /// <param name = "condition">Expression to use as a breakpoint condition. When specified, debugger will only stop on thebreakpoint if this expression evaluates to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetBreakpointByUrlResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetBreakpointByUrlResponse> SetBreakpointByUrlAsync(int lineNumber, string url = null, string urlRegex = null, string scriptHash = null, int? columnNumber = null, string condition = null)
        {
            ValidateSetBreakpointByUrl(lineNumber, url, urlRegex, scriptHash, columnNumber, condition);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("lineNumber", lineNumber);
            if (!(string.IsNullOrEmpty(url)))
            {
                dict.Add("url", url);
            }

            if (!(string.IsNullOrEmpty(urlRegex)))
            {
                dict.Add("urlRegex", urlRegex);
            }

            if (!(string.IsNullOrEmpty(scriptHash)))
            {
                dict.Add("scriptHash", scriptHash);
            }

            if (columnNumber.HasValue)
            {
                dict.Add("columnNumber", columnNumber.Value);
            }

            if (!(string.IsNullOrEmpty(condition)))
            {
                dict.Add("condition", condition);
            }

            return _client.ExecuteDevToolsMethodAsync<SetBreakpointByUrlResponse>("Debugger.setBreakpointByUrl", dict);
        }

        partial void ValidateSetBreakpointOnFunctionCall(string objectId, string condition = null);
        /// <summary>
        /// Sets JavaScript breakpoint before each call to the given function.
        /// If another function was created from the same source as a given one,
        /// calling it will also trigger the breakpoint.
        /// </summary>
        /// <param name = "objectId">Function object id.</param>
        /// <param name = "condition">Expression to use as a breakpoint condition. When specified, debugger willstop on the breakpoint if this expression evaluates to true.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetBreakpointOnFunctionCallResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetBreakpointOnFunctionCallResponse> SetBreakpointOnFunctionCallAsync(string objectId, string condition = null)
        {
            ValidateSetBreakpointOnFunctionCall(objectId, condition);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            if (!(string.IsNullOrEmpty(condition)))
            {
                dict.Add("condition", condition);
            }

            return _client.ExecuteDevToolsMethodAsync<SetBreakpointOnFunctionCallResponse>("Debugger.setBreakpointOnFunctionCall", dict);
        }

        partial void ValidateSetBreakpointsActive(bool active);
        /// <summary>
        /// Activates / deactivates all breakpoints on the page.
        /// </summary>
        /// <param name = "active">New value for breakpoints active state.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetBreakpointsActiveAsync(bool active)
        {
            ValidateSetBreakpointsActive(active);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("active", active);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.setBreakpointsActive", dict);
        }

        partial void ValidateSetPauseOnExceptions(CefSharp.DevTools.Debugger.SetPauseOnExceptionsState state);
        /// <summary>
        /// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
        /// or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
        /// </summary>
        /// <param name = "state">Pause on exceptions mode.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetPauseOnExceptionsAsync(CefSharp.DevTools.Debugger.SetPauseOnExceptionsState state)
        {
            ValidateSetPauseOnExceptions(state);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("state", EnumToString(state));
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.setPauseOnExceptions", dict);
        }

        partial void ValidateSetReturnValue(CefSharp.DevTools.Runtime.CallArgument newValue);
        /// <summary>
        /// Changes return value in top frame. Available only at return break position.
        /// </summary>
        /// <param name = "newValue">New return value.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetReturnValueAsync(CefSharp.DevTools.Runtime.CallArgument newValue)
        {
            ValidateSetReturnValue(newValue);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("newValue", newValue.ToDictionary());
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.setReturnValue", dict);
        }

        partial void ValidateSetScriptSource(string scriptId, string scriptSource, bool? dryRun = null, bool? allowTopFrameEditing = null);
        /// <summary>
        /// Edits JavaScript source live.
        /// 
        /// In general, functions that are currently on the stack can not be edited with
        /// a single exception: If the edited function is the top-most stack frame and
        /// that is the only activation of that function on the stack. In this case
        /// the live edit will be successful and a `Debugger.restartFrame` for the
        /// top-most function is automatically triggered.
        /// </summary>
        /// <param name = "scriptId">Id of the script to edit.</param>
        /// <param name = "scriptSource">New content of the script.</param>
        /// <param name = "dryRun">If true the change will not actually be applied. Dry run may be used to get resultdescription without actually modifying the code.</param>
        /// <param name = "allowTopFrameEditing">If true, then `scriptSource` is allowed to change the function on top of the stackas long as the top-most stack frame is the only activation of that function.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;SetScriptSourceResponse&gt;</returns>
        public System.Threading.Tasks.Task<SetScriptSourceResponse> SetScriptSourceAsync(string scriptId, string scriptSource, bool? dryRun = null, bool? allowTopFrameEditing = null)
        {
            ValidateSetScriptSource(scriptId, scriptSource, dryRun, allowTopFrameEditing);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            dict.Add("scriptSource", scriptSource);
            if (dryRun.HasValue)
            {
                dict.Add("dryRun", dryRun.Value);
            }

            if (allowTopFrameEditing.HasValue)
            {
                dict.Add("allowTopFrameEditing", allowTopFrameEditing.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<SetScriptSourceResponse>("Debugger.setScriptSource", dict);
        }

        partial void ValidateSetSkipAllPauses(bool skip);
        /// <summary>
        /// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
        /// </summary>
        /// <param name = "skip">New value for skip pauses state.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetSkipAllPausesAsync(bool skip)
        {
            ValidateSetSkipAllPauses(skip);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("skip", skip);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.setSkipAllPauses", dict);
        }

        partial void ValidateSetVariableValue(int scopeNumber, string variableName, CefSharp.DevTools.Runtime.CallArgument newValue, string callFrameId);
        /// <summary>
        /// Changes value of variable in a callframe. Object-based scopes are not supported and must be
        /// mutated manually.
        /// </summary>
        /// <param name = "scopeNumber">0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'scope types are allowed. Other scopes could be manipulated manually.</param>
        /// <param name = "variableName">Variable name.</param>
        /// <param name = "newValue">New variable value.</param>
        /// <param name = "callFrameId">Id of callframe that holds variable.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetVariableValueAsync(int scopeNumber, string variableName, CefSharp.DevTools.Runtime.CallArgument newValue, string callFrameId)
        {
            ValidateSetVariableValue(scopeNumber, variableName, newValue, callFrameId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scopeNumber", scopeNumber);
            dict.Add("variableName", variableName);
            dict.Add("newValue", newValue.ToDictionary());
            dict.Add("callFrameId", callFrameId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.setVariableValue", dict);
        }

        partial void ValidateStepInto(bool? breakOnAsyncCall = null, System.Collections.Generic.IList<CefSharp.DevTools.Debugger.LocationRange> skipList = null);
        /// <summary>
        /// Steps into the function call.
        /// </summary>
        /// <param name = "breakOnAsyncCall">Debugger will pause on the execution of the first async task which was scheduledbefore next pause.</param>
        /// <param name = "skipList">The skipList specifies location ranges that should be skipped on step into.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StepIntoAsync(bool? breakOnAsyncCall = null, System.Collections.Generic.IList<CefSharp.DevTools.Debugger.LocationRange> skipList = null)
        {
            ValidateStepInto(breakOnAsyncCall, skipList);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (breakOnAsyncCall.HasValue)
            {
                dict.Add("breakOnAsyncCall", breakOnAsyncCall.Value);
            }

            if ((skipList) != (null))
            {
                dict.Add("skipList", skipList.Select(x => x.ToDictionary()));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.stepInto", dict);
        }

        /// <summary>
        /// Steps out of the function call.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StepOutAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.stepOut", dict);
        }

        partial void ValidateStepOver(System.Collections.Generic.IList<CefSharp.DevTools.Debugger.LocationRange> skipList = null);
        /// <summary>
        /// Steps over the statement.
        /// </summary>
        /// <param name = "skipList">The skipList specifies location ranges that should be skipped on step over.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StepOverAsync(System.Collections.Generic.IList<CefSharp.DevTools.Debugger.LocationRange> skipList = null)
        {
            ValidateStepOver(skipList);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if ((skipList) != (null))
            {
                dict.Add("skipList", skipList.Select(x => x.ToDictionary()));
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Debugger.stepOver", dict);
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// GetHeapObjectIdResponse
    /// </summary>
    public class GetHeapObjectIdResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// heapSnapshotObjectId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("heapSnapshotObjectId")]
        public string HeapSnapshotObjectId
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// GetObjectByHeapObjectIdResponse
    /// </summary>
    public class GetObjectByHeapObjectIdResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// GetSamplingProfileResponse
    /// </summary>
    public class GetSamplingProfileResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("profile")]
        public CefSharp.DevTools.HeapProfiler.SamplingHeapProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    /// <summary>
    /// StopSamplingResponse
    /// </summary>
    public class StopSamplingResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("profile")]
        public CefSharp.DevTools.HeapProfiler.SamplingHeapProfile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.HeapProfiler
{
    using System.Linq;

    /// <summary>
    /// HeapProfiler
    /// </summary>
    public partial class HeapProfilerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// HeapProfiler
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public HeapProfilerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// AddHeapSnapshotChunk
        /// </summary>
        public event System.EventHandler<AddHeapSnapshotChunkEventArgs> AddHeapSnapshotChunk
        {
            add
            {
                _client.AddEventHandler<AddHeapSnapshotChunkEventArgs>("HeapProfiler.addHeapSnapshotChunk", value);
            }

            remove
            {
                _client.RemoveEventHandler<AddHeapSnapshotChunkEventArgs>("HeapProfiler.addHeapSnapshotChunk", value);
            }
        }

        /// <summary>
        /// If heap objects tracking has been started then backend may send update for one or more fragments
        /// </summary>
        public event System.EventHandler<HeapStatsUpdateEventArgs> HeapStatsUpdate
        {
            add
            {
                _client.AddEventHandler<HeapStatsUpdateEventArgs>("HeapProfiler.heapStatsUpdate", value);
            }

            remove
            {
                _client.RemoveEventHandler<HeapStatsUpdateEventArgs>("HeapProfiler.heapStatsUpdate", value);
            }
        }

        /// <summary>
        /// If heap objects tracking has been started then backend regularly sends a current value for last
        /// seen object id and corresponding timestamp. If the were changes in the heap since last event
        /// then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
        /// </summary>
        public event System.EventHandler<LastSeenObjectIdEventArgs> LastSeenObjectId
        {
            add
            {
                _client.AddEventHandler<LastSeenObjectIdEventArgs>("HeapProfiler.lastSeenObjectId", value);
            }

            remove
            {
                _client.RemoveEventHandler<LastSeenObjectIdEventArgs>("HeapProfiler.lastSeenObjectId", value);
            }
        }

        /// <summary>
        /// ReportHeapSnapshotProgress
        /// </summary>
        public event System.EventHandler<ReportHeapSnapshotProgressEventArgs> ReportHeapSnapshotProgress
        {
            add
            {
                _client.AddEventHandler<ReportHeapSnapshotProgressEventArgs>("HeapProfiler.reportHeapSnapshotProgress", value);
            }

            remove
            {
                _client.RemoveEventHandler<ReportHeapSnapshotProgressEventArgs>("HeapProfiler.reportHeapSnapshotProgress", value);
            }
        }

        /// <summary>
        /// ResetProfiles
        /// </summary>
        public event System.EventHandler<System.EventArgs> ResetProfiles
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("HeapProfiler.resetProfiles", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("HeapProfiler.resetProfiles", value);
            }
        }

        partial void ValidateAddInspectedHeapObject(string heapObjectId);
        /// <summary>
        /// Enables console to refer to the node with given id via $x (see Command Line API for more details
        /// $x functions).
        /// </summary>
        /// <param name = "heapObjectId">Heap snapshot object id to be accessible by means of $x command line API.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> AddInspectedHeapObjectAsync(string heapObjectId)
        {
            ValidateAddInspectedHeapObject(heapObjectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("heapObjectId", heapObjectId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("HeapProfiler.addInspectedHeapObject", dict);
        }

        /// <summary>
        /// CollectGarbage
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> CollectGarbageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("HeapProfiler.collectGarbage", dict);
        }

        /// <summary>
        /// Disable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("HeapProfiler.disable", dict);
        }

        /// <summary>
        /// Enable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("HeapProfiler.enable", dict);
        }

        partial void ValidateGetHeapObjectId(string objectId);
        /// <summary>
        /// GetHeapObjectId
        /// </summary>
        /// <param name = "objectId">Identifier of the object to get heap object id for.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHeapObjectIdResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetHeapObjectIdResponse> GetHeapObjectIdAsync(string objectId)
        {
            ValidateGetHeapObjectId(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            return _client.ExecuteDevToolsMethodAsync<GetHeapObjectIdResponse>("HeapProfiler.getHeapObjectId", dict);
        }

        partial void ValidateGetObjectByHeapObjectId(string objectId, string objectGroup = null);
        /// <summary>
        /// GetObjectByHeapObjectId
        /// </summary>
        /// <param name = "objectId">objectId</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetObjectByHeapObjectIdResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetObjectByHeapObjectIdResponse> GetObjectByHeapObjectIdAsync(string objectId, string objectGroup = null)
        {
            ValidateGetObjectByHeapObjectId(objectId, objectGroup);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            return _client.ExecuteDevToolsMethodAsync<GetObjectByHeapObjectIdResponse>("HeapProfiler.getObjectByHeapObjectId", dict);
        }

        /// <summary>
        /// GetSamplingProfile
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetSamplingProfileResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetSamplingProfileResponse> GetSamplingProfileAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetSamplingProfileResponse>("HeapProfiler.getSamplingProfile", dict);
        }

        partial void ValidateStartSampling(double? samplingInterval = null, bool? includeObjectsCollectedByMajorGC = null, bool? includeObjectsCollectedByMinorGC = null);
        /// <summary>
        /// StartSampling
        /// </summary>
        /// <param name = "samplingInterval">Average sample interval in bytes. Poisson distribution is used for the intervals. Thedefault value is 32768 bytes.</param>
        /// <param name = "includeObjectsCollectedByMajorGC">By default, the sampling heap profiler reports only objects which arestill alive when the profile is returned via getSamplingProfile orstopSampling, which is useful for determining what functions contributethe most to steady-state memory usage. This flag instructs the samplingheap profiler to also include information about objects discarded bymajor GC, which will show which functions cause large temporary memoryusage or long GC pauses.</param>
        /// <param name = "includeObjectsCollectedByMinorGC">By default, the sampling heap profiler reports only objects which arestill alive when the profile is returned via getSamplingProfile orstopSampling, which is useful for determining what functions contributethe most to steady-state memory usage. This flag instructs the samplingheap profiler to also include information about objects discarded byminor GC, which is useful when tuning a latency-sensitive applicationfor minimal GC activity.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartSamplingAsync(double? samplingInterval = null, bool? includeObjectsCollectedByMajorGC = null, bool? includeObjectsCollectedByMinorGC = null)
        {
            ValidateStartSampling(samplingInterval, includeObjectsCollectedByMajorGC, includeObjectsCollectedByMinorGC);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (samplingInterval.HasValue)
            {
                dict.Add("samplingInterval", samplingInterval.Value);
            }

            if (includeObjectsCollectedByMajorGC.HasValue)
            {
                dict.Add("includeObjectsCollectedByMajorGC", includeObjectsCollectedByMajorGC.Value);
            }

            if (includeObjectsCollectedByMinorGC.HasValue)
            {
                dict.Add("includeObjectsCollectedByMinorGC", includeObjectsCollectedByMinorGC.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("HeapProfiler.startSampling", dict);
        }

        partial void ValidateStartTrackingHeapObjects(bool? trackAllocations = null);
        /// <summary>
        /// StartTrackingHeapObjects
        /// </summary>
        /// <param name = "trackAllocations">trackAllocations</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartTrackingHeapObjectsAsync(bool? trackAllocations = null)
        {
            ValidateStartTrackingHeapObjects(trackAllocations);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (trackAllocations.HasValue)
            {
                dict.Add("trackAllocations", trackAllocations.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("HeapProfiler.startTrackingHeapObjects", dict);
        }

        /// <summary>
        /// StopSampling
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;StopSamplingResponse&gt;</returns>
        public System.Threading.Tasks.Task<StopSamplingResponse> StopSamplingAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<StopSamplingResponse>("HeapProfiler.stopSampling", dict);
        }

        partial void ValidateStopTrackingHeapObjects(bool? reportProgress = null, bool? treatGlobalObjectsAsRoots = null, bool? captureNumericValue = null, bool? exposeInternals = null);
        /// <summary>
        /// StopTrackingHeapObjects
        /// </summary>
        /// <param name = "reportProgress">If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being takenwhen the tracking is stopped.</param>
        /// <param name = "treatGlobalObjectsAsRoots">Deprecated in favor of `exposeInternals`.</param>
        /// <param name = "captureNumericValue">If true, numerical values are included in the snapshot</param>
        /// <param name = "exposeInternals">If true, exposes internals of the snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopTrackingHeapObjectsAsync(bool? reportProgress = null, bool? treatGlobalObjectsAsRoots = null, bool? captureNumericValue = null, bool? exposeInternals = null)
        {
            ValidateStopTrackingHeapObjects(reportProgress, treatGlobalObjectsAsRoots, captureNumericValue, exposeInternals);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (reportProgress.HasValue)
            {
                dict.Add("reportProgress", reportProgress.Value);
            }

            if (treatGlobalObjectsAsRoots.HasValue)
            {
                dict.Add("treatGlobalObjectsAsRoots", treatGlobalObjectsAsRoots.Value);
            }

            if (captureNumericValue.HasValue)
            {
                dict.Add("captureNumericValue", captureNumericValue.Value);
            }

            if (exposeInternals.HasValue)
            {
                dict.Add("exposeInternals", exposeInternals.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("HeapProfiler.stopTrackingHeapObjects", dict);
        }

        partial void ValidateTakeHeapSnapshot(bool? reportProgress = null, bool? treatGlobalObjectsAsRoots = null, bool? captureNumericValue = null, bool? exposeInternals = null);
        /// <summary>
        /// TakeHeapSnapshot
        /// </summary>
        /// <param name = "reportProgress">If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.</param>
        /// <param name = "treatGlobalObjectsAsRoots">If true, a raw snapshot without artificial roots will be generated.Deprecated in favor of `exposeInternals`.</param>
        /// <param name = "captureNumericValue">If true, numerical values are included in the snapshot</param>
        /// <param name = "exposeInternals">If true, exposes internals of the snapshot.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> TakeHeapSnapshotAsync(bool? reportProgress = null, bool? treatGlobalObjectsAsRoots = null, bool? captureNumericValue = null, bool? exposeInternals = null)
        {
            ValidateTakeHeapSnapshot(reportProgress, treatGlobalObjectsAsRoots, captureNumericValue, exposeInternals);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (reportProgress.HasValue)
            {
                dict.Add("reportProgress", reportProgress.Value);
            }

            if (treatGlobalObjectsAsRoots.HasValue)
            {
                dict.Add("treatGlobalObjectsAsRoots", treatGlobalObjectsAsRoots.Value);
            }

            if (captureNumericValue.HasValue)
            {
                dict.Add("captureNumericValue", captureNumericValue.Value);
            }

            if (exposeInternals.HasValue)
            {
                dict.Add("exposeInternals", exposeInternals.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("HeapProfiler.takeHeapSnapshot", dict);
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// GetBestEffortCoverageResponse
    /// </summary>
    public class GetBestEffortCoverageResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.ScriptCoverage> Result
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// StartPreciseCoverageResponse
    /// </summary>
    public class StartPreciseCoverageResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// timestamp
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// StopResponse
    /// </summary>
    public class StopResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// profile
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("profile")]
        public CefSharp.DevTools.Profiler.Profile Profile
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    /// <summary>
    /// TakePreciseCoverageResponse
    /// </summary>
    public class TakePreciseCoverageResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Profiler.ScriptCoverage> Result
        {
            get;
            private set;
        }

        /// <summary>
        /// timestamp
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("timestamp")]
        public double Timestamp
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Profiler
{
    using System.Linq;

    /// <summary>
    /// Profiler
    /// </summary>
    public partial class ProfilerClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Profiler
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public ProfilerClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// ConsoleProfileFinished
        /// </summary>
        public event System.EventHandler<ConsoleProfileFinishedEventArgs> ConsoleProfileFinished
        {
            add
            {
                _client.AddEventHandler<ConsoleProfileFinishedEventArgs>("Profiler.consoleProfileFinished", value);
            }

            remove
            {
                _client.RemoveEventHandler<ConsoleProfileFinishedEventArgs>("Profiler.consoleProfileFinished", value);
            }
        }

        /// <summary>
        /// Sent when new profile recording is started using console.profile() call.
        /// </summary>
        public event System.EventHandler<ConsoleProfileStartedEventArgs> ConsoleProfileStarted
        {
            add
            {
                _client.AddEventHandler<ConsoleProfileStartedEventArgs>("Profiler.consoleProfileStarted", value);
            }

            remove
            {
                _client.RemoveEventHandler<ConsoleProfileStartedEventArgs>("Profiler.consoleProfileStarted", value);
            }
        }

        /// <summary>
        /// Reports coverage delta since the last poll (either from an event like this, or from
        /// `takePreciseCoverage` for the current isolate. May only be sent if precise code
        /// coverage has been started. This event can be trigged by the embedder to, for example,
        /// trigger collection of coverage data immediately at a certain point in time.
        /// </summary>
        public event System.EventHandler<PreciseCoverageDeltaUpdateEventArgs> PreciseCoverageDeltaUpdate
        {
            add
            {
                _client.AddEventHandler<PreciseCoverageDeltaUpdateEventArgs>("Profiler.preciseCoverageDeltaUpdate", value);
            }

            remove
            {
                _client.RemoveEventHandler<PreciseCoverageDeltaUpdateEventArgs>("Profiler.preciseCoverageDeltaUpdate", value);
            }
        }

        /// <summary>
        /// Disable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Profiler.disable", dict);
        }

        /// <summary>
        /// Enable
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Profiler.enable", dict);
        }

        /// <summary>
        /// Collect coverage data for the current isolate. The coverage data may be incomplete due to
        /// garbage collection.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetBestEffortCoverageResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetBestEffortCoverageResponse> GetBestEffortCoverageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetBestEffortCoverageResponse>("Profiler.getBestEffortCoverage", dict);
        }

        partial void ValidateSetSamplingInterval(int interval);
        /// <summary>
        /// Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
        /// </summary>
        /// <param name = "interval">New sampling interval in microseconds.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetSamplingIntervalAsync(int interval)
        {
            ValidateSetSamplingInterval(interval);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("interval", interval);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Profiler.setSamplingInterval", dict);
        }

        /// <summary>
        /// Start
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StartAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Profiler.start", dict);
        }

        partial void ValidateStartPreciseCoverage(bool? callCount = null, bool? detailed = null, bool? allowTriggeredUpdates = null);
        /// <summary>
        /// Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
        /// coverage may be incomplete. Enabling prevents running optimized code and resets execution
        /// counters.
        /// </summary>
        /// <param name = "callCount">Collect accurate call counts beyond simple 'covered' or 'not covered'.</param>
        /// <param name = "detailed">Collect block-based coverage.</param>
        /// <param name = "allowTriggeredUpdates">Allow the backend to send updates on its own initiative</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;StartPreciseCoverageResponse&gt;</returns>
        public System.Threading.Tasks.Task<StartPreciseCoverageResponse> StartPreciseCoverageAsync(bool? callCount = null, bool? detailed = null, bool? allowTriggeredUpdates = null)
        {
            ValidateStartPreciseCoverage(callCount, detailed, allowTriggeredUpdates);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (callCount.HasValue)
            {
                dict.Add("callCount", callCount.Value);
            }

            if (detailed.HasValue)
            {
                dict.Add("detailed", detailed.Value);
            }

            if (allowTriggeredUpdates.HasValue)
            {
                dict.Add("allowTriggeredUpdates", allowTriggeredUpdates.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<StartPreciseCoverageResponse>("Profiler.startPreciseCoverage", dict);
        }

        /// <summary>
        /// Stop
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;StopResponse&gt;</returns>
        public System.Threading.Tasks.Task<StopResponse> StopAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<StopResponse>("Profiler.stop", dict);
        }

        /// <summary>
        /// Disable precise code coverage. Disabling releases unnecessary execution count records and allows
        /// executing optimized code.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> StopPreciseCoverageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Profiler.stopPreciseCoverage", dict);
        }

        /// <summary>
        /// Collect coverage data for the current isolate, and resets execution counters. Precise code
        /// coverage needs to have started.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;TakePreciseCoverageResponse&gt;</returns>
        public System.Threading.Tasks.Task<TakePreciseCoverageResponse> TakePreciseCoverageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<TakePreciseCoverageResponse>("Profiler.takePreciseCoverage", dict);
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// AwaitPromiseResponse
    /// </summary>
    public class AwaitPromiseResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// CallFunctionOnResponse
    /// </summary>
    public class CallFunctionOnResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// CompileScriptResponse
    /// </summary>
    public class CompileScriptResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// scriptId
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("scriptId")]
        public string ScriptId
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// EvaluateResponse
    /// </summary>
    public class EvaluateResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GetIsolateIdResponse
    /// </summary>
    public class GetIsolateIdResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// id
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("id")]
        public string Id
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GetHeapUsageResponse
    /// </summary>
    public class GetHeapUsageResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// usedSize
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("usedSize")]
        public double UsedSize
        {
            get;
            private set;
        }

        /// <summary>
        /// totalSize
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("totalSize")]
        public double TotalSize
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GetPropertiesResponse
    /// </summary>
    public class GetPropertiesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.PropertyDescriptor> Result
        {
            get;
            private set;
        }

        /// <summary>
        /// internalProperties
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("internalProperties")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.InternalPropertyDescriptor> InternalProperties
        {
            get;
            private set;
        }

        /// <summary>
        /// privateProperties
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("privateProperties")]
        public System.Collections.Generic.IList<CefSharp.DevTools.Runtime.PrivatePropertyDescriptor> PrivateProperties
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GlobalLexicalScopeNamesResponse
    /// </summary>
    public class GlobalLexicalScopeNamesResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// names
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("names")]
        public string[] Names
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// QueryObjectsResponse
    /// </summary>
    public class QueryObjectsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// objects
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("objects")]
        public CefSharp.DevTools.Runtime.RemoteObject Objects
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// RunScriptResponse
    /// </summary>
    public class RunScriptResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// result
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("result")]
        public CefSharp.DevTools.Runtime.RemoteObject Result
        {
            get;
            private set;
        }

        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    /// <summary>
    /// GetExceptionDetailsResponse
    /// </summary>
    public class GetExceptionDetailsResponse : DevToolsDomainResponseBase
    {
        /// <summary>
        /// exceptionDetails
        /// </summary>
        [JsonInclude]
        [JsonPropertyName("exceptionDetails")]
        public CefSharp.DevTools.Runtime.ExceptionDetails ExceptionDetails
        {
            get;
            private set;
        }
    }
}

namespace CefSharp.DevTools.Runtime
{
    using System.Linq;

    /// <summary>
    /// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
    /// Evaluation results are returned as mirror object that expose object type, string representation
    /// and unique identifier that can be used for further object reference. Original objects are
    /// maintained in memory unless they are either explicitly released or are released along with the
    /// other objects in their object group.
    /// </summary>
    public partial class RuntimeClient : DevToolsDomainBase
    {
        private CefSharp.DevTools.IDevToolsClient _client;
        /// <summary>
        /// Runtime
        /// </summary>
        /// <param name = "client">DevToolsClient</param>
        public RuntimeClient(CefSharp.DevTools.IDevToolsClient client)
        {
            _client = (client);
        }

        /// <summary>
        /// Notification is issued every time when binding is called.
        /// </summary>
        public event System.EventHandler<BindingCalledEventArgs> BindingCalled
        {
            add
            {
                _client.AddEventHandler<BindingCalledEventArgs>("Runtime.bindingCalled", value);
            }

            remove
            {
                _client.RemoveEventHandler<BindingCalledEventArgs>("Runtime.bindingCalled", value);
            }
        }

        /// <summary>
        /// Issued when console API was called.
        /// </summary>
        public event System.EventHandler<ConsoleAPICalledEventArgs> ConsoleAPICalled
        {
            add
            {
                _client.AddEventHandler<ConsoleAPICalledEventArgs>("Runtime.consoleAPICalled", value);
            }

            remove
            {
                _client.RemoveEventHandler<ConsoleAPICalledEventArgs>("Runtime.consoleAPICalled", value);
            }
        }

        /// <summary>
        /// Issued when unhandled exception was revoked.
        /// </summary>
        public event System.EventHandler<ExceptionRevokedEventArgs> ExceptionRevoked
        {
            add
            {
                _client.AddEventHandler<ExceptionRevokedEventArgs>("Runtime.exceptionRevoked", value);
            }

            remove
            {
                _client.RemoveEventHandler<ExceptionRevokedEventArgs>("Runtime.exceptionRevoked", value);
            }
        }

        /// <summary>
        /// Issued when exception was thrown and unhandled.
        /// </summary>
        public event System.EventHandler<ExceptionThrownEventArgs> ExceptionThrown
        {
            add
            {
                _client.AddEventHandler<ExceptionThrownEventArgs>("Runtime.exceptionThrown", value);
            }

            remove
            {
                _client.RemoveEventHandler<ExceptionThrownEventArgs>("Runtime.exceptionThrown", value);
            }
        }

        /// <summary>
        /// Issued when new execution context is created.
        /// </summary>
        public event System.EventHandler<ExecutionContextCreatedEventArgs> ExecutionContextCreated
        {
            add
            {
                _client.AddEventHandler<ExecutionContextCreatedEventArgs>("Runtime.executionContextCreated", value);
            }

            remove
            {
                _client.RemoveEventHandler<ExecutionContextCreatedEventArgs>("Runtime.executionContextCreated", value);
            }
        }

        /// <summary>
        /// Issued when execution context is destroyed.
        /// </summary>
        public event System.EventHandler<ExecutionContextDestroyedEventArgs> ExecutionContextDestroyed
        {
            add
            {
                _client.AddEventHandler<ExecutionContextDestroyedEventArgs>("Runtime.executionContextDestroyed", value);
            }

            remove
            {
                _client.RemoveEventHandler<ExecutionContextDestroyedEventArgs>("Runtime.executionContextDestroyed", value);
            }
        }

        /// <summary>
        /// Issued when all executionContexts were cleared in browser
        /// </summary>
        public event System.EventHandler<System.EventArgs> ExecutionContextsCleared
        {
            add
            {
                _client.AddEventHandler<System.EventArgs>("Runtime.executionContextsCleared", value);
            }

            remove
            {
                _client.RemoveEventHandler<System.EventArgs>("Runtime.executionContextsCleared", value);
            }
        }

        /// <summary>
        /// Issued when object should be inspected (for example, as a result of inspect() command line API
        /// call).
        /// </summary>
        public event System.EventHandler<InspectRequestedEventArgs> InspectRequested
        {
            add
            {
                _client.AddEventHandler<InspectRequestedEventArgs>("Runtime.inspectRequested", value);
            }

            remove
            {
                _client.RemoveEventHandler<InspectRequestedEventArgs>("Runtime.inspectRequested", value);
            }
        }

        partial void ValidateAwaitPromise(string promiseObjectId, bool? returnByValue = null, bool? generatePreview = null);
        /// <summary>
        /// Add handler to promise with given promise object id.
        /// </summary>
        /// <param name = "promiseObjectId">Identifier of the promise.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;AwaitPromiseResponse&gt;</returns>
        public System.Threading.Tasks.Task<AwaitPromiseResponse> AwaitPromiseAsync(string promiseObjectId, bool? returnByValue = null, bool? generatePreview = null)
        {
            ValidateAwaitPromise(promiseObjectId, returnByValue, generatePreview);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("promiseObjectId", promiseObjectId);
            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<AwaitPromiseResponse>("Runtime.awaitPromise", dict);
        }

        partial void ValidateCallFunctionOn(string functionDeclaration, string objectId = null, System.Collections.Generic.IList<CefSharp.DevTools.Runtime.CallArgument> arguments = null, bool? silent = null, bool? returnByValue = null, bool? generatePreview = null, bool? userGesture = null, bool? awaitPromise = null, int? executionContextId = null, string objectGroup = null, bool? throwOnSideEffect = null, string uniqueContextId = null, bool? generateWebDriverValue = null);
        /// <summary>
        /// Calls function with given declaration on the given object. Object group of the result is
        /// inherited from the target object.
        /// </summary>
        /// <param name = "functionDeclaration">Declaration of the function to call.</param>
        /// <param name = "objectId">Identifier of the object to call function on. Either objectId or executionContextId shouldbe specified.</param>
        /// <param name = "arguments">Call arguments. All call arguments must belong to the same JavaScript world as the targetobject.</param>
        /// <param name = "silent">In silent mode exceptions thrown during evaluation are not reported and do not pauseexecution. Overrides `setPauseOnException` state.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object which should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <param name = "userGesture">Whether execution should be treated as initiated by user in the UI.</param>
        /// <param name = "awaitPromise">Whether execution should `await` for resulting value and return once awaited promise isresolved.</param>
        /// <param name = "executionContextId">Specifies execution context which global object will be used to call function on. EitherexecutionContextId or objectId should be specified.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects. If objectGroup is notspecified and objectId is, objectGroup will be inherited from object.</param>
        /// <param name = "throwOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.</param>
        /// <param name = "uniqueContextId">An alternative way to specify the execution context to call function on.Compared to contextId that may be reused across processes, this is guaranteed to besystem-unique, so it can be used to prevent accidental function callin context different than intended (e.g. as a result of navigation across processboundaries).This is mutually exclusive with `executionContextId`.</param>
        /// <param name = "generateWebDriverValue">Whether the result should contain `webDriverValue`, serialized according tohttps://w3c.github.io/webdriver-bidi. This is mutually exclusive with `returnByValue`, butresulting `objectId` is still provided.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CallFunctionOnResponse&gt;</returns>
        public System.Threading.Tasks.Task<CallFunctionOnResponse> CallFunctionOnAsync(string functionDeclaration, string objectId = null, System.Collections.Generic.IList<CefSharp.DevTools.Runtime.CallArgument> arguments = null, bool? silent = null, bool? returnByValue = null, bool? generatePreview = null, bool? userGesture = null, bool? awaitPromise = null, int? executionContextId = null, string objectGroup = null, bool? throwOnSideEffect = null, string uniqueContextId = null, bool? generateWebDriverValue = null)
        {
            ValidateCallFunctionOn(functionDeclaration, objectId, arguments, silent, returnByValue, generatePreview, userGesture, awaitPromise, executionContextId, objectGroup, throwOnSideEffect, uniqueContextId, generateWebDriverValue);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("functionDeclaration", functionDeclaration);
            if (!(string.IsNullOrEmpty(objectId)))
            {
                dict.Add("objectId", objectId);
            }

            if ((arguments) != (null))
            {
                dict.Add("arguments", arguments.Select(x => x.ToDictionary()));
            }

            if (silent.HasValue)
            {
                dict.Add("silent", silent.Value);
            }

            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (userGesture.HasValue)
            {
                dict.Add("userGesture", userGesture.Value);
            }

            if (awaitPromise.HasValue)
            {
                dict.Add("awaitPromise", awaitPromise.Value);
            }

            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (throwOnSideEffect.HasValue)
            {
                dict.Add("throwOnSideEffect", throwOnSideEffect.Value);
            }

            if (!(string.IsNullOrEmpty(uniqueContextId)))
            {
                dict.Add("uniqueContextId", uniqueContextId);
            }

            if (generateWebDriverValue.HasValue)
            {
                dict.Add("generateWebDriverValue", generateWebDriverValue.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<CallFunctionOnResponse>("Runtime.callFunctionOn", dict);
        }

        partial void ValidateCompileScript(string expression, string sourceURL, bool persistScript, int? executionContextId = null);
        /// <summary>
        /// Compiles expression.
        /// </summary>
        /// <param name = "expression">Expression to compile.</param>
        /// <param name = "sourceURL">Source url to be set for the script.</param>
        /// <param name = "persistScript">Specifies whether the compiled script should be persisted.</param>
        /// <param name = "executionContextId">Specifies in which execution context to perform script run. If the parameter is omitted theevaluation will be performed in the context of the inspected page.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;CompileScriptResponse&gt;</returns>
        public System.Threading.Tasks.Task<CompileScriptResponse> CompileScriptAsync(string expression, string sourceURL, bool persistScript, int? executionContextId = null)
        {
            ValidateCompileScript(expression, sourceURL, persistScript, executionContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("expression", expression);
            dict.Add("sourceURL", sourceURL);
            dict.Add("persistScript", persistScript);
            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<CompileScriptResponse>("Runtime.compileScript", dict);
        }

        /// <summary>
        /// Disables reporting of execution contexts creation.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DisableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.disable", dict);
        }

        /// <summary>
        /// Discards collected exceptions and console API calls.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> DiscardConsoleEntriesAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.discardConsoleEntries", dict);
        }

        /// <summary>
        /// Enables reporting of execution contexts creation by means of `executionContextCreated` event.
        /// When the reporting gets enabled the event will be sent immediately for each existing execution
        /// context.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> EnableAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.enable", dict);
        }

        partial void ValidateEvaluate(string expression, string objectGroup = null, bool? includeCommandLineAPI = null, bool? silent = null, int? contextId = null, bool? returnByValue = null, bool? generatePreview = null, bool? userGesture = null, bool? awaitPromise = null, bool? throwOnSideEffect = null, double? timeout = null, bool? disableBreaks = null, bool? replMode = null, bool? allowUnsafeEvalBlockedByCSP = null, string uniqueContextId = null, bool? generateWebDriverValue = null);
        /// <summary>
        /// Evaluates expression on global object.
        /// </summary>
        /// <param name = "expression">Expression to evaluate.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects.</param>
        /// <param name = "includeCommandLineAPI">Determines whether Command Line API should be available during the evaluation.</param>
        /// <param name = "silent">In silent mode exceptions thrown during evaluation are not reported and do not pauseexecution. Overrides `setPauseOnException` state.</param>
        /// <param name = "contextId">Specifies in which execution context to perform evaluation. If the parameter is omitted theevaluation will be performed in the context of the inspected page.This is mutually exclusive with `uniqueContextId`, which offers analternative way to identify the execution context that is more reliablein a multi-process environment.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <param name = "userGesture">Whether execution should be treated as initiated by user in the UI.</param>
        /// <param name = "awaitPromise">Whether execution should `await` for resulting value and return once awaited promise isresolved.</param>
        /// <param name = "throwOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.This implies `disableBreaks` below.</param>
        /// <param name = "timeout">Terminate execution after timing out (number of milliseconds).</param>
        /// <param name = "disableBreaks">Disable breakpoints during execution.</param>
        /// <param name = "replMode">Setting this flag to true enables `let` re-declaration and top-level `await`.Note that `let` variables can only be re-declared if they originate from`replMode` themselves.</param>
        /// <param name = "allowUnsafeEvalBlockedByCSP">The Content Security Policy (CSP) for the target might block 'unsafe-eval'which includes eval(), Function(), setTimeout() and setInterval()when called with non-callable arguments. This flag bypasses CSP for thisevaluation and allows unsafe-eval. Defaults to true.</param>
        /// <param name = "uniqueContextId">An alternative way to specify the execution context to evaluate in.Compared to contextId that may be reused across processes, this is guaranteed to besystem-unique, so it can be used to prevent accidental evaluation of the expressionin context different than intended (e.g. as a result of navigation across processboundaries).This is mutually exclusive with `contextId`.</param>
        /// <param name = "generateWebDriverValue">Whether the result should be serialized according to https://w3c.github.io/webdriver-bidi.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;EvaluateResponse&gt;</returns>
        public System.Threading.Tasks.Task<EvaluateResponse> EvaluateAsync(string expression, string objectGroup = null, bool? includeCommandLineAPI = null, bool? silent = null, int? contextId = null, bool? returnByValue = null, bool? generatePreview = null, bool? userGesture = null, bool? awaitPromise = null, bool? throwOnSideEffect = null, double? timeout = null, bool? disableBreaks = null, bool? replMode = null, bool? allowUnsafeEvalBlockedByCSP = null, string uniqueContextId = null, bool? generateWebDriverValue = null)
        {
            ValidateEvaluate(expression, objectGroup, includeCommandLineAPI, silent, contextId, returnByValue, generatePreview, userGesture, awaitPromise, throwOnSideEffect, timeout, disableBreaks, replMode, allowUnsafeEvalBlockedByCSP, uniqueContextId, generateWebDriverValue);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("expression", expression);
            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (includeCommandLineAPI.HasValue)
            {
                dict.Add("includeCommandLineAPI", includeCommandLineAPI.Value);
            }

            if (silent.HasValue)
            {
                dict.Add("silent", silent.Value);
            }

            if (contextId.HasValue)
            {
                dict.Add("contextId", contextId.Value);
            }

            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (userGesture.HasValue)
            {
                dict.Add("userGesture", userGesture.Value);
            }

            if (awaitPromise.HasValue)
            {
                dict.Add("awaitPromise", awaitPromise.Value);
            }

            if (throwOnSideEffect.HasValue)
            {
                dict.Add("throwOnSideEffect", throwOnSideEffect.Value);
            }

            if (timeout.HasValue)
            {
                dict.Add("timeout", timeout.Value);
            }

            if (disableBreaks.HasValue)
            {
                dict.Add("disableBreaks", disableBreaks.Value);
            }

            if (replMode.HasValue)
            {
                dict.Add("replMode", replMode.Value);
            }

            if (allowUnsafeEvalBlockedByCSP.HasValue)
            {
                dict.Add("allowUnsafeEvalBlockedByCSP", allowUnsafeEvalBlockedByCSP.Value);
            }

            if (!(string.IsNullOrEmpty(uniqueContextId)))
            {
                dict.Add("uniqueContextId", uniqueContextId);
            }

            if (generateWebDriverValue.HasValue)
            {
                dict.Add("generateWebDriverValue", generateWebDriverValue.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<EvaluateResponse>("Runtime.evaluate", dict);
        }

        /// <summary>
        /// Returns the isolate id.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetIsolateIdResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetIsolateIdResponse> GetIsolateIdAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetIsolateIdResponse>("Runtime.getIsolateId", dict);
        }

        /// <summary>
        /// Returns the JavaScript heap usage.
        /// It is the total usage of the corresponding isolate not scoped to a particular Runtime.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetHeapUsageResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetHeapUsageResponse> GetHeapUsageAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<GetHeapUsageResponse>("Runtime.getHeapUsage", dict);
        }

        partial void ValidateGetProperties(string objectId, bool? ownProperties = null, bool? accessorPropertiesOnly = null, bool? generatePreview = null, bool? nonIndexedPropertiesOnly = null);
        /// <summary>
        /// Returns properties of a given object. Object group of the result is inherited from the target
        /// object.
        /// </summary>
        /// <param name = "objectId">Identifier of the object to return properties for.</param>
        /// <param name = "ownProperties">If true, returns properties belonging only to the element itself, not to its prototypechain.</param>
        /// <param name = "accessorPropertiesOnly">If true, returns accessor properties (with getter/setter) only; internal properties are notreturned either.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the results.</param>
        /// <param name = "nonIndexedPropertiesOnly">If true, returns non-indexed properties only.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetPropertiesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetPropertiesResponse> GetPropertiesAsync(string objectId, bool? ownProperties = null, bool? accessorPropertiesOnly = null, bool? generatePreview = null, bool? nonIndexedPropertiesOnly = null)
        {
            ValidateGetProperties(objectId, ownProperties, accessorPropertiesOnly, generatePreview, nonIndexedPropertiesOnly);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            if (ownProperties.HasValue)
            {
                dict.Add("ownProperties", ownProperties.Value);
            }

            if (accessorPropertiesOnly.HasValue)
            {
                dict.Add("accessorPropertiesOnly", accessorPropertiesOnly.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (nonIndexedPropertiesOnly.HasValue)
            {
                dict.Add("nonIndexedPropertiesOnly", nonIndexedPropertiesOnly.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GetPropertiesResponse>("Runtime.getProperties", dict);
        }

        partial void ValidateGlobalLexicalScopeNames(int? executionContextId = null);
        /// <summary>
        /// Returns all let, const and class variables from global scope.
        /// </summary>
        /// <param name = "executionContextId">Specifies in which execution context to lookup global scope variables.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GlobalLexicalScopeNamesResponse&gt;</returns>
        public System.Threading.Tasks.Task<GlobalLexicalScopeNamesResponse> GlobalLexicalScopeNamesAsync(int? executionContextId = null)
        {
            ValidateGlobalLexicalScopeNames(executionContextId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<GlobalLexicalScopeNamesResponse>("Runtime.globalLexicalScopeNames", dict);
        }

        partial void ValidateQueryObjects(string prototypeObjectId, string objectGroup = null);
        /// <summary>
        /// QueryObjects
        /// </summary>
        /// <param name = "prototypeObjectId">Identifier of the prototype to return objects for.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release the results.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;QueryObjectsResponse&gt;</returns>
        public System.Threading.Tasks.Task<QueryObjectsResponse> QueryObjectsAsync(string prototypeObjectId, string objectGroup = null)
        {
            ValidateQueryObjects(prototypeObjectId, objectGroup);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("prototypeObjectId", prototypeObjectId);
            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            return _client.ExecuteDevToolsMethodAsync<QueryObjectsResponse>("Runtime.queryObjects", dict);
        }

        partial void ValidateReleaseObject(string objectId);
        /// <summary>
        /// Releases remote object with given id.
        /// </summary>
        /// <param name = "objectId">Identifier of the object to release.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ReleaseObjectAsync(string objectId)
        {
            ValidateReleaseObject(objectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectId", objectId);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.releaseObject", dict);
        }

        partial void ValidateReleaseObjectGroup(string objectGroup);
        /// <summary>
        /// Releases all remote objects that belong to a given group.
        /// </summary>
        /// <param name = "objectGroup">Symbolic object group name.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> ReleaseObjectGroupAsync(string objectGroup)
        {
            ValidateReleaseObjectGroup(objectGroup);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("objectGroup", objectGroup);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.releaseObjectGroup", dict);
        }

        /// <summary>
        /// Tells inspected instance to run if it was waiting for debugger to attach.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RunIfWaitingForDebuggerAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.runIfWaitingForDebugger", dict);
        }

        partial void ValidateRunScript(string scriptId, int? executionContextId = null, string objectGroup = null, bool? silent = null, bool? includeCommandLineAPI = null, bool? returnByValue = null, bool? generatePreview = null, bool? awaitPromise = null);
        /// <summary>
        /// Runs script with given id in a given context.
        /// </summary>
        /// <param name = "scriptId">Id of the script to run.</param>
        /// <param name = "executionContextId">Specifies in which execution context to perform script run. If the parameter is omitted theevaluation will be performed in the context of the inspected page.</param>
        /// <param name = "objectGroup">Symbolic group name that can be used to release multiple objects.</param>
        /// <param name = "silent">In silent mode exceptions thrown during evaluation are not reported and do not pauseexecution. Overrides `setPauseOnException` state.</param>
        /// <param name = "includeCommandLineAPI">Determines whether Command Line API should be available during the evaluation.</param>
        /// <param name = "returnByValue">Whether the result is expected to be a JSON object which should be sent by value.</param>
        /// <param name = "generatePreview">Whether preview should be generated for the result.</param>
        /// <param name = "awaitPromise">Whether execution should `await` for resulting value and return once awaited promise isresolved.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;RunScriptResponse&gt;</returns>
        public System.Threading.Tasks.Task<RunScriptResponse> RunScriptAsync(string scriptId, int? executionContextId = null, string objectGroup = null, bool? silent = null, bool? includeCommandLineAPI = null, bool? returnByValue = null, bool? generatePreview = null, bool? awaitPromise = null)
        {
            ValidateRunScript(scriptId, executionContextId, objectGroup, silent, includeCommandLineAPI, returnByValue, generatePreview, awaitPromise);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("scriptId", scriptId);
            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            if (!(string.IsNullOrEmpty(objectGroup)))
            {
                dict.Add("objectGroup", objectGroup);
            }

            if (silent.HasValue)
            {
                dict.Add("silent", silent.Value);
            }

            if (includeCommandLineAPI.HasValue)
            {
                dict.Add("includeCommandLineAPI", includeCommandLineAPI.Value);
            }

            if (returnByValue.HasValue)
            {
                dict.Add("returnByValue", returnByValue.Value);
            }

            if (generatePreview.HasValue)
            {
                dict.Add("generatePreview", generatePreview.Value);
            }

            if (awaitPromise.HasValue)
            {
                dict.Add("awaitPromise", awaitPromise.Value);
            }

            return _client.ExecuteDevToolsMethodAsync<RunScriptResponse>("Runtime.runScript", dict);
        }

        partial void ValidateSetAsyncCallStackDepth(int maxDepth);
        /// <summary>
        /// Enables or disables async call stacks tracking.
        /// </summary>
        /// <param name = "maxDepth">Maximum depth of async call stacks. Setting to `0` will effectively disable collecting asynccall stacks (default).</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetAsyncCallStackDepthAsync(int maxDepth)
        {
            ValidateSetAsyncCallStackDepth(maxDepth);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("maxDepth", maxDepth);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.setAsyncCallStackDepth", dict);
        }

        partial void ValidateSetCustomObjectFormatterEnabled(bool enabled);
        /// <summary>
        /// SetCustomObjectFormatterEnabled
        /// </summary>
        /// <param name = "enabled">enabled</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetCustomObjectFormatterEnabledAsync(bool enabled)
        {
            ValidateSetCustomObjectFormatterEnabled(enabled);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("enabled", enabled);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.setCustomObjectFormatterEnabled", dict);
        }

        partial void ValidateSetMaxCallStackSizeToCapture(int size);
        /// <summary>
        /// SetMaxCallStackSizeToCapture
        /// </summary>
        /// <param name = "size">size</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> SetMaxCallStackSizeToCaptureAsync(int size)
        {
            ValidateSetMaxCallStackSizeToCapture(size);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("size", size);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.setMaxCallStackSizeToCapture", dict);
        }

        /// <summary>
        /// Terminate current or next JavaScript execution.
        /// Will cancel the termination when the outer-most script execution ends.
        /// </summary>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> TerminateExecutionAsync()
        {
            System.Collections.Generic.Dictionary<string, object> dict = null;
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.terminateExecution", dict);
        }

        partial void ValidateAddBinding(string name, int? executionContextId = null, string executionContextName = null);
        /// <summary>
        /// If executionContextId is empty, adds binding with the given name on the
        /// global objects of all inspected contexts, including those created later,
        /// bindings survive reloads.
        /// Binding function takes exactly one argument, this argument should be string,
        /// in case of any other input, function throws an exception.
        /// Each binding function call produces Runtime.bindingCalled notification.
        /// </summary>
        /// <param name = "name">name</param>
        /// <param name = "executionContextId">If specified, the binding would only be exposed to the specifiedexecution context. If omitted and `executionContextName` is not set,the binding is exposed to all execution contexts of the target.This parameter is mutually exclusive with `executionContextName`.Deprecated in favor of `executionContextName` due to an unclear use caseand bugs in implementation (crbug.com/1169639). `executionContextId` will beremoved in the future.</param>
        /// <param name = "executionContextName">If specified, the binding is exposed to the executionContext withmatching name, even for contexts created after the binding is added.See also `ExecutionContext.name` and `worldName` parameter to`Page.addScriptToEvaluateOnNewDocument`.This parameter is mutually exclusive with `executionContextId`.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> AddBindingAsync(string name, int? executionContextId = null, string executionContextName = null)
        {
            ValidateAddBinding(name, executionContextId, executionContextName);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            if (executionContextId.HasValue)
            {
                dict.Add("executionContextId", executionContextId.Value);
            }

            if (!(string.IsNullOrEmpty(executionContextName)))
            {
                dict.Add("executionContextName", executionContextName);
            }

            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.addBinding", dict);
        }

        partial void ValidateRemoveBinding(string name);
        /// <summary>
        /// This method does not remove binding function from global object but
        /// unsubscribes current runtime agent from Runtime.bindingCalled notifications.
        /// </summary>
        /// <param name = "name">name</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;DevToolsMethodResponse&gt;</returns>
        public System.Threading.Tasks.Task<DevToolsMethodResponse> RemoveBindingAsync(string name)
        {
            ValidateRemoveBinding(name);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("name", name);
            return _client.ExecuteDevToolsMethodAsync<DevToolsMethodResponse>("Runtime.removeBinding", dict);
        }

        partial void ValidateGetExceptionDetails(string errorObjectId);
        /// <summary>
        /// This method tries to lookup and populate exception details for a
        /// JavaScript Error object.
        /// Note that the stackTrace portion of the resulting exceptionDetails will
        /// only be populated if the Runtime domain was enabled at the time when the
        /// Error was thrown.
        /// </summary>
        /// <param name = "errorObjectId">The error object for which to resolve the exception details.</param>
        /// <returns>returns System.Threading.Tasks.Task&lt;GetExceptionDetailsResponse&gt;</returns>
        public System.Threading.Tasks.Task<GetExceptionDetailsResponse> GetExceptionDetailsAsync(string errorObjectId)
        {
            ValidateGetExceptionDetails(errorObjectId);
            var dict = new System.Collections.Generic.Dictionary<string, object>();
            dict.Add("errorObjectId", errorObjectId);
            return _client.ExecuteDevToolsMethodAsync<GetExceptionDetailsResponse>("Runtime.getExceptionDetails", dict);
        }
    }
}

namespace CefSharp.DevTools
{
    /// <summary>
    /// Generated DevToolsClient methods
    /// </summary>
    public partial class DevToolsClient
    {
        private CefSharp.DevTools.Accessibility.AccessibilityClient _Accessibility;
        /// <summary>
        /// Accessibility
        /// </summary>
        public CefSharp.DevTools.Accessibility.AccessibilityClient Accessibility
        {
            get
            {
                if ((_Accessibility) == (null))
                {
                    _Accessibility = (new CefSharp.DevTools.Accessibility.AccessibilityClient(this));
                }

                return _Accessibility;
            }
        }

        private CefSharp.DevTools.Animation.AnimationClient _Animation;
        /// <summary>
        /// Animation
        /// </summary>
        public CefSharp.DevTools.Animation.AnimationClient Animation
        {
            get
            {
                if ((_Animation) == (null))
                {
                    _Animation = (new CefSharp.DevTools.Animation.AnimationClient(this));
                }

                return _Animation;
            }
        }

        private CefSharp.DevTools.Audits.AuditsClient _Audits;
        /// <summary>
        /// Audits domain allows investigation of page violations and possible improvements.
        /// </summary>
        public CefSharp.DevTools.Audits.AuditsClient Audits
        {
            get
            {
                if ((_Audits) == (null))
                {
                    _Audits = (new CefSharp.DevTools.Audits.AuditsClient(this));
                }

                return _Audits;
            }
        }

        private CefSharp.DevTools.BackgroundService.BackgroundServiceClient _BackgroundService;
        /// <summary>
        /// Defines events for background web platform features.
        /// </summary>
        public CefSharp.DevTools.BackgroundService.BackgroundServiceClient BackgroundService
        {
            get
            {
                if ((_BackgroundService) == (null))
                {
                    _BackgroundService = (new CefSharp.DevTools.BackgroundService.BackgroundServiceClient(this));
                }

                return _BackgroundService;
            }
        }

        private CefSharp.DevTools.Browser.BrowserClient _Browser;
        /// <summary>
        /// The Browser domain defines methods and events for browser managing.
        /// </summary>
        public CefSharp.DevTools.Browser.BrowserClient Browser
        {
            get
            {
                if ((_Browser) == (null))
                {
                    _Browser = (new CefSharp.DevTools.Browser.BrowserClient(this));
                }

                return _Browser;
            }
        }

        private CefSharp.DevTools.CSS.CSSClient _CSS;
        /// <summary>
        /// This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
        /// have an associated `id` used in subsequent operations on the related object. Each object type has
        /// a specific `id` structure, and those are not interchangeable between objects of different kinds.
        /// CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
        /// can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
        /// subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods.
        /// </summary>
        public CefSharp.DevTools.CSS.CSSClient CSS
        {
            get
            {
                if ((_CSS) == (null))
                {
                    _CSS = (new CefSharp.DevTools.CSS.CSSClient(this));
                }

                return _CSS;
            }
        }

        private CefSharp.DevTools.CacheStorage.CacheStorageClient _CacheStorage;
        /// <summary>
        /// CacheStorage
        /// </summary>
        public CefSharp.DevTools.CacheStorage.CacheStorageClient CacheStorage
        {
            get
            {
                if ((_CacheStorage) == (null))
                {
                    _CacheStorage = (new CefSharp.DevTools.CacheStorage.CacheStorageClient(this));
                }

                return _CacheStorage;
            }
        }

        private CefSharp.DevTools.Cast.CastClient _Cast;
        /// <summary>
        /// A domain for interacting with Cast, Presentation API, and Remote Playback API
        /// functionalities.
        /// </summary>
        public CefSharp.DevTools.Cast.CastClient Cast
        {
            get
            {
                if ((_Cast) == (null))
                {
                    _Cast = (new CefSharp.DevTools.Cast.CastClient(this));
                }

                return _Cast;
            }
        }

        private CefSharp.DevTools.DOM.DOMClient _DOM;
        /// <summary>
        /// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
        /// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
        /// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
        /// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
        /// and never sends the same node twice. It is client&apos;s responsibility to collect information about
        /// the nodes that were sent to the client.&lt;p&gt;Note that `iframe` owner elements will return
        /// corresponding document elements as their child nodes.&lt;/p&gt;
        /// </summary>
        public CefSharp.DevTools.DOM.DOMClient DOM
        {
            get
            {
                if ((_DOM) == (null))
                {
                    _DOM = (new CefSharp.DevTools.DOM.DOMClient(this));
                }

                return _DOM;
            }
        }

        private CefSharp.DevTools.DOMDebugger.DOMDebuggerClient _DOMDebugger;
        /// <summary>
        /// DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
        /// execution will stop on these operations as if there was a regular breakpoint set.
        /// </summary>
        public CefSharp.DevTools.DOMDebugger.DOMDebuggerClient DOMDebugger
        {
            get
            {
                if ((_DOMDebugger) == (null))
                {
                    _DOMDebugger = (new CefSharp.DevTools.DOMDebugger.DOMDebuggerClient(this));
                }

                return _DOMDebugger;
            }
        }

        private CefSharp.DevTools.EventBreakpoints.EventBreakpointsClient _EventBreakpoints;
        /// <summary>
        /// EventBreakpoints permits setting breakpoints on particular operations and
        /// events in targets that run JavaScript but do not have a DOM.
        /// JavaScript execution will stop on these operations as if there was a regular
        /// breakpoint set.
        /// </summary>
        public CefSharp.DevTools.EventBreakpoints.EventBreakpointsClient EventBreakpoints
        {
            get
            {
                if ((_EventBreakpoints) == (null))
                {
                    _EventBreakpoints = (new CefSharp.DevTools.EventBreakpoints.EventBreakpointsClient(this));
                }

                return _EventBreakpoints;
            }
        }

        private CefSharp.DevTools.DOMSnapshot.DOMSnapshotClient _DOMSnapshot;
        /// <summary>
        /// This domain facilitates obtaining document snapshots with DOM, layout, and style information.
        /// </summary>
        public CefSharp.DevTools.DOMSnapshot.DOMSnapshotClient DOMSnapshot
        {
            get
            {
                if ((_DOMSnapshot) == (null))
                {
                    _DOMSnapshot = (new CefSharp.DevTools.DOMSnapshot.DOMSnapshotClient(this));
                }

                return _DOMSnapshot;
            }
        }

        private CefSharp.DevTools.DOMStorage.DOMStorageClient _DOMStorage;
        /// <summary>
        /// Query and modify DOM storage.
        /// </summary>
        public CefSharp.DevTools.DOMStorage.DOMStorageClient DOMStorage
        {
            get
            {
                if ((_DOMStorage) == (null))
                {
                    _DOMStorage = (new CefSharp.DevTools.DOMStorage.DOMStorageClient(this));
                }

                return _DOMStorage;
            }
        }

        private CefSharp.DevTools.Database.DatabaseClient _Database;
        /// <summary>
        /// Database
        /// </summary>
        public CefSharp.DevTools.Database.DatabaseClient Database
        {
            get
            {
                if ((_Database) == (null))
                {
                    _Database = (new CefSharp.DevTools.Database.DatabaseClient(this));
                }

                return _Database;
            }
        }

        private CefSharp.DevTools.DeviceOrientation.DeviceOrientationClient _DeviceOrientation;
        /// <summary>
        /// DeviceOrientation
        /// </summary>
        public CefSharp.DevTools.DeviceOrientation.DeviceOrientationClient DeviceOrientation
        {
            get
            {
                if ((_DeviceOrientation) == (null))
                {
                    _DeviceOrientation = (new CefSharp.DevTools.DeviceOrientation.DeviceOrientationClient(this));
                }

                return _DeviceOrientation;
            }
        }

        private CefSharp.DevTools.Emulation.EmulationClient _Emulation;
        /// <summary>
        /// This domain emulates different environments for the page.
        /// </summary>
        public CefSharp.DevTools.Emulation.EmulationClient Emulation
        {
            get
            {
                if ((_Emulation) == (null))
                {
                    _Emulation = (new CefSharp.DevTools.Emulation.EmulationClient(this));
                }

                return _Emulation;
            }
        }

        private CefSharp.DevTools.HeadlessExperimental.HeadlessExperimentalClient _HeadlessExperimental;
        /// <summary>
        /// This domain provides experimental commands only supported in headless mode.
        /// </summary>
        public CefSharp.DevTools.HeadlessExperimental.HeadlessExperimentalClient HeadlessExperimental
        {
            get
            {
                if ((_HeadlessExperimental) == (null))
                {
                    _HeadlessExperimental = (new CefSharp.DevTools.HeadlessExperimental.HeadlessExperimentalClient(this));
                }

                return _HeadlessExperimental;
            }
        }

        private CefSharp.DevTools.IO.IOClient _IO;
        /// <summary>
        /// Input/Output operations for streams produced by DevTools.
        /// </summary>
        public CefSharp.DevTools.IO.IOClient IO
        {
            get
            {
                if ((_IO) == (null))
                {
                    _IO = (new CefSharp.DevTools.IO.IOClient(this));
                }

                return _IO;
            }
        }

        private CefSharp.DevTools.IndexedDB.IndexedDBClient _IndexedDB;
        /// <summary>
        /// IndexedDB
        /// </summary>
        public CefSharp.DevTools.IndexedDB.IndexedDBClient IndexedDB
        {
            get
            {
                if ((_IndexedDB) == (null))
                {
                    _IndexedDB = (new CefSharp.DevTools.IndexedDB.IndexedDBClient(this));
                }

                return _IndexedDB;
            }
        }

        private CefSharp.DevTools.Input.InputClient _Input;
        /// <summary>
        /// Input
        /// </summary>
        public CefSharp.DevTools.Input.InputClient Input
        {
            get
            {
                if ((_Input) == (null))
                {
                    _Input = (new CefSharp.DevTools.Input.InputClient(this));
                }

                return _Input;
            }
        }

        private CefSharp.DevTools.Inspector.InspectorClient _Inspector;
        /// <summary>
        /// Inspector
        /// </summary>
        public CefSharp.DevTools.Inspector.InspectorClient Inspector
        {
            get
            {
                if ((_Inspector) == (null))
                {
                    _Inspector = (new CefSharp.DevTools.Inspector.InspectorClient(this));
                }

                return _Inspector;
            }
        }

        private CefSharp.DevTools.LayerTree.LayerTreeClient _LayerTree;
        /// <summary>
        /// LayerTree
        /// </summary>
        public CefSharp.DevTools.LayerTree.LayerTreeClient LayerTree
        {
            get
            {
                if ((_LayerTree) == (null))
                {
                    _LayerTree = (new CefSharp.DevTools.LayerTree.LayerTreeClient(this));
                }

                return _LayerTree;
            }
        }

        private CefSharp.DevTools.Log.LogClient _Log;
        /// <summary>
        /// Provides access to log entries.
        /// </summary>
        public CefSharp.DevTools.Log.LogClient Log
        {
            get
            {
                if ((_Log) == (null))
                {
                    _Log = (new CefSharp.DevTools.Log.LogClient(this));
                }

                return _Log;
            }
        }

        private CefSharp.DevTools.Memory.MemoryClient _Memory;
        /// <summary>
        /// Memory
        /// </summary>
        public CefSharp.DevTools.Memory.MemoryClient Memory
        {
            get
            {
                if ((_Memory) == (null))
                {
                    _Memory = (new CefSharp.DevTools.Memory.MemoryClient(this));
                }

                return _Memory;
            }
        }

        private CefSharp.DevTools.Network.NetworkClient _Network;
        /// <summary>
        /// Network domain allows tracking network activities of the page. It exposes information about http,
        /// file, data and other requests and responses, their headers, bodies, timing, etc.
        /// </summary>
        public CefSharp.DevTools.Network.NetworkClient Network
        {
            get
            {
                if ((_Network) == (null))
                {
                    _Network = (new CefSharp.DevTools.Network.NetworkClient(this));
                }

                return _Network;
            }
        }

        private CefSharp.DevTools.Overlay.OverlayClient _Overlay;
        /// <summary>
        /// This domain provides various functionality related to drawing atop the inspected page.
        /// </summary>
        public CefSharp.DevTools.Overlay.OverlayClient Overlay
        {
            get
            {
                if ((_Overlay) == (null))
                {
                    _Overlay = (new CefSharp.DevTools.Overlay.OverlayClient(this));
                }

                return _Overlay;
            }
        }

        private CefSharp.DevTools.Page.PageClient _Page;
        /// <summary>
        /// Actions and events related to the inspected page belong to the page domain.
        /// </summary>
        public CefSharp.DevTools.Page.PageClient Page
        {
            get
            {
                if ((_Page) == (null))
                {
                    _Page = (new CefSharp.DevTools.Page.PageClient(this));
                }

                return _Page;
            }
        }

        private CefSharp.DevTools.Performance.PerformanceClient _Performance;
        /// <summary>
        /// Performance
        /// </summary>
        public CefSharp.DevTools.Performance.PerformanceClient Performance
        {
            get
            {
                if ((_Performance) == (null))
                {
                    _Performance = (new CefSharp.DevTools.Performance.PerformanceClient(this));
                }

                return _Performance;
            }
        }

        private CefSharp.DevTools.PerformanceTimeline.PerformanceTimelineClient _PerformanceTimeline;
        /// <summary>
        /// Reporting of performance timeline events, as specified in
        /// https://w3c.github.io/performance-timeline/#dom-performanceobserver.
        /// </summary>
        public CefSharp.DevTools.PerformanceTimeline.PerformanceTimelineClient PerformanceTimeline
        {
            get
            {
                if ((_PerformanceTimeline) == (null))
                {
                    _PerformanceTimeline = (new CefSharp.DevTools.PerformanceTimeline.PerformanceTimelineClient(this));
                }

                return _PerformanceTimeline;
            }
        }

        private CefSharp.DevTools.Security.SecurityClient _Security;
        /// <summary>
        /// Security
        /// </summary>
        public CefSharp.DevTools.Security.SecurityClient Security
        {
            get
            {
                if ((_Security) == (null))
                {
                    _Security = (new CefSharp.DevTools.Security.SecurityClient(this));
                }

                return _Security;
            }
        }

        private CefSharp.DevTools.ServiceWorker.ServiceWorkerClient _ServiceWorker;
        /// <summary>
        /// ServiceWorker
        /// </summary>
        public CefSharp.DevTools.ServiceWorker.ServiceWorkerClient ServiceWorker
        {
            get
            {
                if ((_ServiceWorker) == (null))
                {
                    _ServiceWorker = (new CefSharp.DevTools.ServiceWorker.ServiceWorkerClient(this));
                }

                return _ServiceWorker;
            }
        }

        private CefSharp.DevTools.Storage.StorageClient _Storage;
        /// <summary>
        /// Storage
        /// </summary>
        public CefSharp.DevTools.Storage.StorageClient Storage
        {
            get
            {
                if ((_Storage) == (null))
                {
                    _Storage = (new CefSharp.DevTools.Storage.StorageClient(this));
                }

                return _Storage;
            }
        }

        private CefSharp.DevTools.SystemInfo.SystemInfoClient _SystemInfo;
        /// <summary>
        /// The SystemInfo domain defines methods and events for querying low-level system information.
        /// </summary>
        public CefSharp.DevTools.SystemInfo.SystemInfoClient SystemInfo
        {
            get
            {
                if ((_SystemInfo) == (null))
                {
                    _SystemInfo = (new CefSharp.DevTools.SystemInfo.SystemInfoClient(this));
                }

                return _SystemInfo;
            }
        }

        private CefSharp.DevTools.Target.TargetClient _Target;
        /// <summary>
        /// Supports additional targets discovery and allows to attach to them.
        /// </summary>
        public CefSharp.DevTools.Target.TargetClient Target
        {
            get
            {
                if ((_Target) == (null))
                {
                    _Target = (new CefSharp.DevTools.Target.TargetClient(this));
                }

                return _Target;
            }
        }

        private CefSharp.DevTools.Tethering.TetheringClient _Tethering;
        /// <summary>
        /// The Tethering domain defines methods and events for browser port binding.
        /// </summary>
        public CefSharp.DevTools.Tethering.TetheringClient Tethering
        {
            get
            {
                if ((_Tethering) == (null))
                {
                    _Tethering = (new CefSharp.DevTools.Tethering.TetheringClient(this));
                }

                return _Tethering;
            }
        }

        private CefSharp.DevTools.Tracing.TracingClient _Tracing;
        /// <summary>
        /// Tracing
        /// </summary>
        public CefSharp.DevTools.Tracing.TracingClient Tracing
        {
            get
            {
                if ((_Tracing) == (null))
                {
                    _Tracing = (new CefSharp.DevTools.Tracing.TracingClient(this));
                }

                return _Tracing;
            }
        }

        private CefSharp.DevTools.Fetch.FetchClient _Fetch;
        /// <summary>
        /// A domain for letting clients substitute browser&apos;s network layer with client code.
        /// </summary>
        public CefSharp.DevTools.Fetch.FetchClient Fetch
        {
            get
            {
                if ((_Fetch) == (null))
                {
                    _Fetch = (new CefSharp.DevTools.Fetch.FetchClient(this));
                }

                return _Fetch;
            }
        }

        private CefSharp.DevTools.WebAudio.WebAudioClient _WebAudio;
        /// <summary>
        /// This domain allows inspection of Web Audio API.
        /// https://webaudio.github.io/web-audio-api/
        /// </summary>
        public CefSharp.DevTools.WebAudio.WebAudioClient WebAudio
        {
            get
            {
                if ((_WebAudio) == (null))
                {
                    _WebAudio = (new CefSharp.DevTools.WebAudio.WebAudioClient(this));
                }

                return _WebAudio;
            }
        }

        private CefSharp.DevTools.WebAuthn.WebAuthnClient _WebAuthn;
        /// <summary>
        /// This domain allows configuring virtual authenticators to test the WebAuthn
        /// API.
        /// </summary>
        public CefSharp.DevTools.WebAuthn.WebAuthnClient WebAuthn
        {
            get
            {
                if ((_WebAuthn) == (null))
                {
                    _WebAuthn = (new CefSharp.DevTools.WebAuthn.WebAuthnClient(this));
                }

                return _WebAuthn;
            }
        }

        private CefSharp.DevTools.Media.MediaClient _Media;
        /// <summary>
        /// This domain allows detailed inspection of media elements
        /// </summary>
        public CefSharp.DevTools.Media.MediaClient Media
        {
            get
            {
                if ((_Media) == (null))
                {
                    _Media = (new CefSharp.DevTools.Media.MediaClient(this));
                }

                return _Media;
            }
        }

        private CefSharp.DevTools.DeviceAccess.DeviceAccessClient _DeviceAccess;
        /// <summary>
        /// DeviceAccess
        /// </summary>
        public CefSharp.DevTools.DeviceAccess.DeviceAccessClient DeviceAccess
        {
            get
            {
                if ((_DeviceAccess) == (null))
                {
                    _DeviceAccess = (new CefSharp.DevTools.DeviceAccess.DeviceAccessClient(this));
                }

                return _DeviceAccess;
            }
        }

        private CefSharp.DevTools.Preload.PreloadClient _Preload;
        /// <summary>
        /// Preload
        /// </summary>
        public CefSharp.DevTools.Preload.PreloadClient Preload
        {
            get
            {
                if ((_Preload) == (null))
                {
                    _Preload = (new CefSharp.DevTools.Preload.PreloadClient(this));
                }

                return _Preload;
            }
        }

        private CefSharp.DevTools.FedCm.FedCmClient _FedCm;
        /// <summary>
        /// This domain allows interacting with the FedCM dialog.
        /// </summary>
        public CefSharp.DevTools.FedCm.FedCmClient FedCm
        {
            get
            {
                if ((_FedCm) == (null))
                {
                    _FedCm = (new CefSharp.DevTools.FedCm.FedCmClient(this));
                }

                return _FedCm;
            }
        }

        private CefSharp.DevTools.Debugger.DebuggerClient _Debugger;
        /// <summary>
        /// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
        /// breakpoints, stepping through execution, exploring stack traces, etc.
        /// </summary>
        public CefSharp.DevTools.Debugger.DebuggerClient Debugger
        {
            get
            {
                if ((_Debugger) == (null))
                {
                    _Debugger = (new CefSharp.DevTools.Debugger.DebuggerClient(this));
                }

                return _Debugger;
            }
        }

        private CefSharp.DevTools.HeapProfiler.HeapProfilerClient _HeapProfiler;
        /// <summary>
        /// HeapProfiler
        /// </summary>
        public CefSharp.DevTools.HeapProfiler.HeapProfilerClient HeapProfiler
        {
            get
            {
                if ((_HeapProfiler) == (null))
                {
                    _HeapProfiler = (new CefSharp.DevTools.HeapProfiler.HeapProfilerClient(this));
                }

                return _HeapProfiler;
            }
        }

        private CefSharp.DevTools.Profiler.ProfilerClient _Profiler;
        /// <summary>
        /// Profiler
        /// </summary>
        public CefSharp.DevTools.Profiler.ProfilerClient Profiler
        {
            get
            {
                if ((_Profiler) == (null))
                {
                    _Profiler = (new CefSharp.DevTools.Profiler.ProfilerClient(this));
                }

                return _Profiler;
            }
        }

        private CefSharp.DevTools.Runtime.RuntimeClient _Runtime;
        /// <summary>
        /// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
        /// Evaluation results are returned as mirror object that expose object type, string representation
        /// and unique identifier that can be used for further object reference. Original objects are
        /// maintained in memory unless they are either explicitly released or are released along with the
        /// other objects in their object group.
        /// </summary>
        public CefSharp.DevTools.Runtime.RuntimeClient Runtime
        {
            get
            {
                if ((_Runtime) == (null))
                {
                    _Runtime = (new CefSharp.DevTools.Runtime.RuntimeClient(this));
                }

                return _Runtime;
            }
        }
    }
}