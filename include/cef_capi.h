// Copyright (c) 2010 Marshall A. Greenblatt. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the name Chromium Embedded
// Framework nor the names of its contributors may be used to endorse
// or promote products derived from this software without specific prior
// written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//

#ifndef _CEF_CAPI_H
#define _CEF_CAPI_H

#ifdef __cplusplus
extern "C" {
#endif

#include "cef_export.h"
#include "cef_string.h"
#include "cef_string_list.h"
#include "cef_string_map.h"
#include "cef_types.h"


// This function should be called on the main application thread to initialize
// CEF when the application is started.  A return value of true (1) indicates
// that it succeeded and false (0) indicates that it failed.
CEF_EXPORT int cef_initialize(const struct _cef_settings_t* settings,
    const struct _cef_browser_settings_t* browser_defaults);

// This function should be called on the main application thread to shut down
// CEF before the application exits.
CEF_EXPORT void cef_shutdown();

// Perform message loop processing. This function must be called on the main
// application thread if cef_initialize() is called with a
// CefSettings.multi_threaded_message_loop value of false (0).
CEF_EXPORT void cef_do_message_loop_work();

// Register a new V8 extension with the specified JavaScript extension code and
// handler. Functions implemented by the handler are prototyped using the
// keyword 'native'. The calling of a native function is restricted to the scope
// in which the prototype of the native function is defined. This function may
// be called on any thread.
//
// Example JavaScript extension code:
//
//   // create the 'example' global object if it doesn't already exist.
//   if (!example)
//     example = {};
//   // create the 'example.test' global object if it doesn't already exist.
//   if (!example.test)
//     example.test = {};
//   (function() {
//     // Define the function 'example.test.myfunction'.
//     example.test.myfunction = function() {
//       // Call CefV8Handler::Execute() with the function name 'MyFunction'
//       // and no arguments.
//       native function MyFunction();
//       return MyFunction();
//     };
//     // Define the getter function for parameter 'example.test.myparam'.
//     example.test.__defineGetter__('myparam', function() {
//       // Call CefV8Handler::Execute() with the function name 'GetMyParam'
//       // and no arguments.
//       native function GetMyParam();
//       return GetMyParam();
//     });
//     // Define the setter function for parameter 'example.test.myparam'.
//     example.test.__defineSetter__('myparam', function(b) {
//       // Call CefV8Handler::Execute() with the function name 'SetMyParam'
//       // and a single argument.
//       native function SetMyParam();
//       if(b) SetMyParam(b);
//     });
//
//     // Extension definitions can also contain normal JavaScript variables
//     // and functions.
//     var myint = 0;
//     example.test.increment = function() {
//       myint += 1;
//       return myint;
//     };
//   })();
//
// Example usage in the page:
//
//   // Call the function.
//   example.test.myfunction();
//   // Set the parameter.
//   example.test.myparam = value;
//   // Get the parameter.
//   value = example.test.myparam;
//   // Call another function.
//   example.test.increment();
//
CEF_EXPORT int cef_register_extension(const cef_string_t* extension_name,
    const cef_string_t* javascript_code, struct _cef_v8handler_t* handler);

// Register a custom scheme handler factory for the specified |scheme_name| and
// |host_name|. All URLs beginning with scheme_name://host_name/ can be handled
// by cef_scheme_handler_t instances returned by the factory. Specify an NULL
// |host_name| value to match all host names. This function may be called on any
// thread.
CEF_EXPORT int cef_register_scheme(const cef_string_t* scheme_name,
    const cef_string_t* host_name,
    struct _cef_scheme_handler_factory_t* factory);

// CEF maintains multiple internal threads that are used for handling different
// types of tasks. The UI thread creates the browser window and is used for all
// interaction with the WebKit rendering engine and V8 JavaScript engine (The UI
// thread will be the same as the main application thread if cef_initialize() is
// called with a CefSettings.multi_threaded_message_loop value of false (0).)
// The IO thread is used for handling schema and network requests. The FILE
// thread is used for the application cache and other miscellaneous activities.
// This function will return true (1) if called on the specified thread.
CEF_EXPORT int cef_currently_on(cef_thread_id_t threadId);

// Post a task for execution on the specified thread. This function may be
// called on any thread.
CEF_EXPORT int cef_post_task(cef_thread_id_t threadId,
    struct _cef_task_t* task);

// Post a task for delayed execution on the specified thread. This function may
// be called on any thread.
CEF_EXPORT int cef_post_delayed_task(cef_thread_id_t threadId,
    struct _cef_task_t* task, long delay_ms);

// Parse the specified |url| into its component parts. Returns false (0) if the
// URL is NULL or invalid.
CEF_EXPORT int cef_parse_url(const cef_string_t* url,
    struct _cef_urlparts_t* parts);

// Creates a URL from the specified |parts|, which must contain a non-NULL spec
// or a non-NULL host and path (at a minimum), but not both. Returns false (0)
// if |parts| isn't initialized as described.
CEF_EXPORT int cef_create_url(const struct _cef_urlparts_t* parts,
    cef_string_t* url);

typedef struct _cef_base_t
{
  // Size of the data structure.
  size_t size;

  // Increment the reference count.
  int (CEF_CALLBACK *add_ref)(struct _cef_base_t* self);
  // Decrement the reference count.  Delete this object when no references
  // remain.
  int (CEF_CALLBACK *release)(struct _cef_base_t* self);
  // Returns the current number of references.
  int (CEF_CALLBACK *get_refct)(struct _cef_base_t* self);

} cef_base_t;


// Check that the structure |s|, which is defined with a cef_base_t member named
// |base|, is large enough to contain the specified member |f|.
#define CEF_MEMBER_EXISTS(s, f)   \
  ((int)&((s)->f) - (int)(s) + sizeof((s)->f) <= (s)->base.size)

// Implement this structure for V8 javascript task execution.
typedef struct _cef_v8task_t
{
  // Base structure.
  cef_base_t base;

  // Script that will be executed.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_script)(struct _cef_v8task_t* self);

  // name/url of the script for error reporting purposes
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_script_name)(
      struct _cef_v8task_t* self);

  // starting line number of the script for error reporting purposes
  int (CEF_CALLBACK *get_start_line)(struct _cef_v8task_t* self);

  // executed on successful completion of the script
  void (CEF_CALLBACK *handle_success)(struct _cef_v8task_t* self,
      struct _cef_v8value_t* result);

  // executed on successful completion of the script
  void (CEF_CALLBACK *handle_error)(struct _cef_v8task_t* self);

} cef_v8task_t;


#define CEF_MEMBER_MISSING(s, f)  (!CEF_MEMBER_EXISTS(s, f) || !((s)->f))


// Implement this structure for task execution. The functions of this structure
// may be called on any thread.
typedef struct _cef_task_t
{
  // Base structure.
  cef_base_t base;

  // Method that will be executed. |threadId| is the thread executing the call.
  void (CEF_CALLBACK *execute)(struct _cef_task_t* self,
      cef_thread_id_t threadId);

} cef_task_t;


// Structure used to represent a browser window. The functions of this structure
// may be called on any thread unless otherwise indicated in the comments.
typedef struct _cef_browser_t
{
  // Base structure.
  cef_base_t base;

  // Returns true (1) if the browser can navigate backwards.
  int (CEF_CALLBACK *can_go_back)(struct _cef_browser_t* self);

  // Navigate backwards.
  void (CEF_CALLBACK *go_back)(struct _cef_browser_t* self);

  // Returns true (1) if the browser can navigate forwards.
  int (CEF_CALLBACK *can_go_forward)(struct _cef_browser_t* self);

  // Navigate backwards.
  void (CEF_CALLBACK *go_forward)(struct _cef_browser_t* self);

  // Reload the current page.
  void (CEF_CALLBACK *reload)(struct _cef_browser_t* self);

  // Reload the current page ignoring any cached data.
  void (CEF_CALLBACK *reload_ignore_cache)(struct _cef_browser_t* self);

  // Stop loading the page.
  void (CEF_CALLBACK *stop_load)(struct _cef_browser_t* self);

  // Set focus for the browser window. If |enable| is true (1) focus will be set
  // to the window. Otherwise, focus will be removed.
  void (CEF_CALLBACK *set_focus)(struct _cef_browser_t* self, int enable);

  // Retrieve the window handle for this browser.
  cef_window_handle_t (CEF_CALLBACK *get_window_handle)(
      struct _cef_browser_t* self);

  // Returns true (1) if the window is a popup window.
  int (CEF_CALLBACK *is_popup)(struct _cef_browser_t* self);

  // Returns the handler for this browser.
  struct _cef_handler_t* (CEF_CALLBACK *get_handler)(
      struct _cef_browser_t* self);

  // Returns the main (top-level) frame for the browser window.
  struct _cef_frame_t* (CEF_CALLBACK *get_main_frame)(
      struct _cef_browser_t* self);

  // Returns the focused frame for the browser window. This function should only
  // be called on the UI thread.
  struct _cef_frame_t* (CEF_CALLBACK *get_focused_frame)(
      struct _cef_browser_t* self);

  // Returns the frame with the specified name, or NULL if not found. This
  // function should only be called on the UI thread.
  struct _cef_frame_t* (CEF_CALLBACK *get_frame)(struct _cef_browser_t* self,
      const cef_string_t* name);

  // Returns the names of all existing frames. This function should only be
  // called on the UI thread.
  void (CEF_CALLBACK *get_frame_names)(struct _cef_browser_t* self,
      cef_string_list_t names);

  // Search for |searchText|. |identifier| can be used to have multiple searches
  // running simultaniously. |forward| indicates whether to search forward or
  // backward within the page. |matchCase| indicates whether the search should
  // be case-sensitive. |findNext| indicates whether this is the first request
  // or a follow-up.
  void (CEF_CALLBACK *find)(struct _cef_browser_t* self, int identifier,
      const cef_string_t* searchText, int forward, int matchCase,
      int findNext);

  // Cancel all searches that are currently going on.
  void (CEF_CALLBACK *stop_finding)(struct _cef_browser_t* self,
      int clearSelection);

  // Get the zoom level.
  double (CEF_CALLBACK *get_zoom_level)(struct _cef_browser_t* self);

  // Change the zoom level to the specified value.
  void (CEF_CALLBACK *set_zoom_level)(struct _cef_browser_t* self,
      double zoomLevel);

  // Open developer tools in its own window.
  void (CEF_CALLBACK *show_dev_tools)(struct _cef_browser_t* self);

  // Explicitly close the developer tools window if one exists for this browser
  // instance.
  void (CEF_CALLBACK *close_dev_tools)(struct _cef_browser_t* self);

} cef_browser_t;


// Create a new browser window using the window parameters specified by
// |windowInfo|. All values will be copied internally and the actual window will
// be created on the UI thread. The |popup| parameter should be true (1) if the
// new window is a popup window. This function call will not block.
CEF_EXPORT int cef_browser_create(cef_window_info_t* windowInfo, int popup,
    struct _cef_handler_t* handler, const cef_string_t* url);

// Create a new browser window using the window parameters specified by
// |windowInfo|. The |popup| parameter should be true (1) if the new window is a
// popup window. This function should only be called on the UI thread.
CEF_EXPORT cef_browser_t* cef_browser_create_sync(cef_window_info_t* windowInfo,
    int popup, struct _cef_handler_t* handler, const cef_string_t* url);


// Structure used to represent a frame in the browser window. The functions of
// this structure may be called on any thread unless otherwise indicated in the
// comments.
typedef struct _cef_frame_t
{
  // Base structure.
  cef_base_t base;

  // Execute undo in this frame.
  void (CEF_CALLBACK *undo)(struct _cef_frame_t* self);

  // Execute redo in this frame.
  void (CEF_CALLBACK *redo)(struct _cef_frame_t* self);

  // Execute cut in this frame.
  void (CEF_CALLBACK *cut)(struct _cef_frame_t* self);

  // Execute copy in this frame.
  void (CEF_CALLBACK *copy)(struct _cef_frame_t* self);

  // Execute paste in this frame.
  void (CEF_CALLBACK *paste)(struct _cef_frame_t* self);

  // Execute delete in this frame.
  void (CEF_CALLBACK *del)(struct _cef_frame_t* self);

  // Execute select all in this frame.
  void (CEF_CALLBACK *select_all)(struct _cef_frame_t* self);

  // Execute printing in the this frame.  The user will be prompted with the
  // print dialog appropriate to the operating system.
  void (CEF_CALLBACK *print)(struct _cef_frame_t* self);

  // Save this frame's HTML source to a temporary file and open it in the
  // default text viewing application.
  void (CEF_CALLBACK *view_source)(struct _cef_frame_t* self);

  // Returns this frame's HTML source as a string. This function should only be
  // called on the UI thread.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_source)(struct _cef_frame_t* self);

  // Returns this frame's display text as a string. This function should only be
  // called on the UI thread.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_text)(struct _cef_frame_t* self);

  // Load the request represented by the |request| object.
  void (CEF_CALLBACK *load_request)(struct _cef_frame_t* self,
      struct _cef_request_t* request);

  // Load the specified |url|.
  void (CEF_CALLBACK *load_url)(struct _cef_frame_t* self,
      const cef_string_t* url);

  // Load the contents of |string| with the optional dummy target |url|.
  void (CEF_CALLBACK *load_string)(struct _cef_frame_t* self,
      const cef_string_t* string, const cef_string_t* url);

  // Load the contents of |stream| with the optional dummy target |url|.
  void (CEF_CALLBACK *load_stream)(struct _cef_frame_t* self,
      struct _cef_stream_reader_t* stream, const cef_string_t* url);

  // Execute a string of JavaScript code in this frame. The |script_url|
  // parameter is the URL where the script in question can be found, if any. The
  // renderer may request this URL to show the developer the source of the
  // error.  The |start_line| parameter is the base line number to use for error
  // reporting.
  void (CEF_CALLBACK *execute_java_script)(struct _cef_frame_t* self,
      const cef_string_t* jsCode, const cef_string_t* scriptUrl,
      int startLine);

  // Execute the cef_v8task_t code in this frame.
  void (CEF_CALLBACK *execute_java_script_task)(struct _cef_frame_t* self,
      struct _cef_v8task_t* jsTask);

  // Returns true (1) if this is the main frame.
  int (CEF_CALLBACK *is_main)(struct _cef_frame_t* self);

  // Returns true (1) if this is the focused frame. This function should only be
  // called on the UI thread.
  int (CEF_CALLBACK *is_focused)(struct _cef_frame_t* self);

  // Returns this frame's name.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_name)(struct _cef_frame_t* self);

  // Return the URL currently loaded in this frame. This function should only be
  // called on the UI thread.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_url)(struct _cef_frame_t* self);

} cef_frame_t;


// Structure that should be implemented to handle events generated by the
// browser window. The functions of this structure will be called on the thread
// indicated in the function comments.
typedef struct _cef_handler_t
{
  // Base structure.
  cef_base_t base;

  // Called on the UI thread before a new window is created. The |parentBrowser|
  // parameter will point to the parent browser window, if any. The |popup|
  // parameter will be true (1) if the new window is a popup window, in which
  // case |popupFeatures| will contain information about the style of popup
  // window requested. If you create the window yourself you should populate the
  // window handle member of |createInfo| and return RV_HANDLED.  Otherwise,
  // return RV_CONTINUE and the framework will create the window.  By default, a
  // newly created window will recieve the same handler as the parent window.
  // To change the handler for the new window modify the object that |handler|
  // points to.
  enum cef_retval_t (CEF_CALLBACK *handle_before_created)(
      struct _cef_handler_t* self, struct _cef_browser_t* parentBrowser,
      struct _cef_window_info_t* windowInfo, int popup,
      const struct _cef_popup_features_t* popupFeatures,
      struct _cef_handler_t** handler, cef_string_t* url,
      struct _cef_browser_settings_t* settings);

  // Called on the UI thread after a new window is created. The return value is
  // currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_after_created)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser);

  // Called on the UI thread when a frame's address has changed. The return
  // value is currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_address_change)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_frame_t* frame, const cef_string_t* url);

  // Called on the UI thread when the page title changes. The return value is
  // currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_title_change)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      const cef_string_t* title);

  // Called on the UI thread before browser navigation. The client has an
  // opportunity to modify the |request| object if desired.  Return RV_HANDLED
  // to cancel navigation.
  enum cef_retval_t (CEF_CALLBACK *handle_before_browse)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_frame_t* frame, struct _cef_request_t* request,
      enum cef_handler_navtype_t navType, int isRedirect);

  // Called on the UI thread when the browser begins loading a page. The |frame|
  // pointer will be NULL if the event represents the overall load status and
  // not the load status for a particular frame. |isMainContent| will be true
  // (1) if this load is for the main content area and not an iframe. This
  // function may not be called if the load request fails. The return value is
  // currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_load_start)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_frame_t* frame, int isMainContent);

  // Called on the UI thread when the browser is done loading a page. The
  // |frame| pointer will be NULL if the event represents the overall load
  // status and not the load status for a particular frame. |isMainContent| will
  // be true (1) if this load is for the main content area and not an iframe.
  // This function will be called irrespective of whether the request completes
  // successfully. The return value is currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_load_end)(struct _cef_handler_t* self,
      struct _cef_browser_t* browser, struct _cef_frame_t* frame,
      int isMainContent, int httpStatusCode);

  // Called on the UI thread when the browser fails to load a resource.
  // |errorCode| is the error code number and |failedUrl| is the URL that failed
  // to load. To provide custom error text assign the text to |errorText| and
  // return RV_HANDLED.  Otherwise, return RV_CONTINUE for the default error
  // text.
  enum cef_retval_t (CEF_CALLBACK *handle_load_error)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_frame_t* frame, enum cef_handler_errorcode_t errorCode,
      const cef_string_t* failedUrl, cef_string_t* errorText);

  // Called on the IO thread before a resource is loaded.  To allow the resource
  // to load normally return RV_CONTINUE. To redirect the resource to a new url
  // populate the |redirectUrl| value and return RV_CONTINUE.  To specify data
  // for the resource return a CefStream object in |resourceStream|, set
  // |mimeType| to the resource stream's mime type, and return RV_CONTINUE. To
  // cancel loading of the resource return RV_HANDLED. Any modifications to
  // |request| will be observed.  If the URL in |request| is changed and
  // |redirectUrl| is also set, the URL in |request| will be used.
  enum cef_retval_t (CEF_CALLBACK *handle_before_resource_load)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_request_t* request, cef_string_t* redirectUrl,
      struct _cef_stream_reader_t** resourceStream, cef_string_t* mimeType,
      int loadFlags);

  // Called on the IO thread to handle requests for URLs with an unknown
  // protocol component. Return RV_HANDLED to indicate that the request should
  // succeed because it was externally handled. Set |allow_os_execution| to true
  // (1) and return RV_CONTINUE to attempt execution via the registered OS
  // protocol handler, if any. If RV_CONTINUE is returned and either
  // |allow_os_execution| is false (0) or OS protocol handler execution fails
  // then the request will fail with an error condition. SECURITY WARNING: YOU
  // SHOULD USE THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR
  // OTHER URL ANALYSIS BEFORE ALLOWING OS EXECUTION.
  enum cef_retval_t (CEF_CALLBACK *handle_protocol_execution)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      const cef_string_t* url, int* allow_os_execution);

  // Called on the UI thread when a server indicates via the 'Content-
  // Disposition' header that a response represents a file to download.
  // |mimeType| is the mime type for the download, |fileName| is the suggested
  // target file name and |contentLength| is either the value of the 'Content-
  // Size' header or -1 if no size was provided. Set |handler| to the
  // cef_download_handler_t instance that will recieve the file contents. Return
  // RV_CONTINUE to download the file or RV_HANDLED to cancel the file download.
  enum cef_retval_t (CEF_CALLBACK *handle_download_response)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      const cef_string_t* mimeType, const cef_string_t* fileName,
      int64 contentLength, struct _cef_download_handler_t** handler);

  // Called on the IO thread when the browser needs credentials from the user.
  // |isProxy| indicates whether the host is a proxy server. |host| contains the
  // hostname and port number. Set |username| and |password| and return
  // RV_HANDLED to handle the request. Return RV_CONTINUE to cancel the request.
  enum cef_retval_t (CEF_CALLBACK *handle_authentication_request)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser, int isProxy,
      const cef_string_t* host, const cef_string_t* realm,
      const cef_string_t* scheme, cef_string_t* username,
      cef_string_t* password);

  // Called on the UI thread before a context menu is displayed. To cancel
  // display of the default context menu return RV_HANDLED.
  enum cef_retval_t (CEF_CALLBACK *handle_before_menu)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      const struct _cef_handler_menuinfo_t* menuInfo);

  // Called on the UI thread to optionally override the default text for a
  // context menu item. |label| contains the default text and may be modified to
  // substitute alternate text. The return value is currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_get_menu_label)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      enum cef_handler_menuid_t menuId, cef_string_t* label);

  // Called on the UI thread when an option is selected from the default context
  // menu. Return RV_HANDLED to cancel default handling of the action.
  enum cef_retval_t (CEF_CALLBACK *handle_menu_action)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      enum cef_handler_menuid_t menuId);

  // Called on the UI thread to allow customization of standard print options
  // before the print dialog is displayed. |printOptions| allows specification
  // of paper size, orientation and margins. Note that the specified margins may
  // be adjusted if they are outside the range supported by the printer. All
  // units are in inches. Return RV_CONTINUE to display the default print
  // options or RV_HANDLED to display the modified |printOptions|.
  enum cef_retval_t (CEF_CALLBACK *handle_print_options)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_print_options_t* printOptions);

  // Called on the UI thread to format print headers and footers. |printInfo|
  // contains platform-specific information about the printer context. |url| is
  // the URL if the currently printing page, |title| is the title of the
  // currently printing page, |currentPage| is the current page number and
  // |maxPages| is the total number of pages. Six default header locations are
  // provided by the implementation: top left, top center, top right, bottom
  // left, bottom center and bottom right. To use one of these default locations
  // just assign a string to the appropriate variable. To draw the header and
  // footer yourself return RV_HANDLED. Otherwise, populate the approprate
  // variables and return RV_CONTINUE.
  enum cef_retval_t (CEF_CALLBACK *handle_print_header_footer)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_frame_t* frame, struct _cef_print_info_t* printInfo,
      const cef_string_t* url, const cef_string_t* title, int currentPage,
      int maxPages, cef_string_t* topLeft, cef_string_t* topCenter,
      cef_string_t* topRight, cef_string_t* bottomLeft,
      cef_string_t* bottomCenter, cef_string_t* bottomRight);

  // Called on the UI thread to run a JS alert message. Return RV_CONTINUE to
  // display the default alert or RV_HANDLED if you displayed a custom alert.
  enum cef_retval_t (CEF_CALLBACK *handle_jsalert)(struct _cef_handler_t* self,
      struct _cef_browser_t* browser, struct _cef_frame_t* frame,
      const cef_string_t* message);

  // Called on the UI thread to run a JS confirm request. Return RV_CONTINUE to
  // display the default alert or RV_HANDLED if you displayed a custom alert. If
  // you handled the alert set |retval| to true (1) if the user accepted the
  // confirmation.
  enum cef_retval_t (CEF_CALLBACK *handle_jsconfirm)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_frame_t* frame, const cef_string_t* message, int* retval);

  // Called on the UI thread to run a JS prompt request. Return RV_CONTINUE to
  // display the default prompt or RV_HANDLED if you displayed a custom prompt.
  // If you handled the prompt set |retval| to true (1) if the user accepted the
  // prompt and request and |result| to the resulting value.
  enum cef_retval_t (CEF_CALLBACK *handle_jsprompt)(struct _cef_handler_t* self,
      struct _cef_browser_t* browser, struct _cef_frame_t* frame,
      const cef_string_t* message, const cef_string_t* defaultValue,
      int* retval, cef_string_t* result);

  // Called on the UI thread for adding values to a frame's JavaScript 'window'
  // object. The return value is currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_jsbinding)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      struct _cef_frame_t* frame, struct _cef_v8value_t* object);

  // Called on the UI thread just before a window is closed. The return value is
  // currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_before_window_close)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser);

  // Called on the UI thread when the browser component is about to loose focus.
  // For instance, if focus was on the last HTML element and the user pressed
  // the TAB key. The return value is currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_take_focus)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      int reverse);

  // Called on the UI thread when the browser component is requesting focus.
  // |isWidget| will be true (1) if the focus is requested for a child widget of
  // the browser window. Return RV_CONTINUE to allow the focus to be set or
  // RV_HANDLED to cancel setting the focus.
  enum cef_retval_t (CEF_CALLBACK *handle_set_focus)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      int isWidget);

  // Called on the UI thread when the browser component receives a keyboard
  // event. |type| is the type of keyboard event, |code| is the windows scan-
  // code for the event, |modifiers| is a set of bit-flags describing any
  // pressed modifier keys and |isSystemKey| is true (1) if Windows considers
  // this a 'system key' message (see http://msdn.microsoft.com/en-
  // us/library/ms646286(VS.85).aspx). Return RV_HANDLED if the keyboard event
  // was handled or RV_CONTINUE to allow the browser component to handle the
  // event.
  enum cef_retval_t (CEF_CALLBACK *handle_key_event)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      enum cef_handler_keyevent_type_t type, int code, int modifiers,
      int isSystemKey);

  // Called on the UI thread when the browser is about to display a tooltip.
  // |text| contains the text that will be displayed in the tooltip. To handle
  // the display of the tooltip yourself return RV_HANDLED. Otherwise, you can
  // optionally modify |text| and then return RV_CONTINUE to allow the browser
  // to display the tooltip.
  enum cef_retval_t (CEF_CALLBACK *handle_tooltip)(struct _cef_handler_t* self,
      struct _cef_browser_t* browser, cef_string_t* text);

  // Called on the UI thread when the browser has a status message. |text|
  // contains the text that will be displayed in the status message and |type|
  // indicates the status message type. The return value is currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_status)(struct _cef_handler_t* self,
      struct _cef_browser_t* browser, const cef_string_t* value,
      enum cef_handler_statustype_t type);

  // Called on the UI thread to display a console message. Return RV_HANDLED to
  // stop the message from being output to the console.
  enum cef_retval_t (CEF_CALLBACK *handle_console_message)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      const cef_string_t* message, const cef_string_t* source, int line);

  // Called on the UI thread to report find results returned by
  // cef_browser_t::find(). |identifer| is the identifier passed to
  // cef_browser_t::find(), |count| is the number of matches currently
  // identified, |selectionRect| is the location of where the match was found
  // (in window coordinates), |activeMatchOrdinal| is the current position in
  // the search results, and |finalUpdate| is true (1) if this is the last find
  // notification. The return value is currently ignored.
  enum cef_retval_t (CEF_CALLBACK *handle_find_result)(
      struct _cef_handler_t* self, struct _cef_browser_t* browser,
      int identifier, int count, const cef_rect_t* selectionRect,
      int activeMatchOrdinal, int finalUpdate);

} cef_handler_t;


// Structure used to represent a web request. The functions of this structure
// may be called on any thread.
typedef struct _cef_request_t
{
  // Base structure.
  cef_base_t base;

  // Fully qualified URL to load.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_url)(struct _cef_request_t* self);
  void (CEF_CALLBACK *set_url)(struct _cef_request_t* self,
      const cef_string_t* url);

  // Optional request function type, defaulting to POST if post data is provided
  // and GET otherwise.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_method)(struct _cef_request_t* self);
  void (CEF_CALLBACK *set_method)(struct _cef_request_t* self,
      const cef_string_t* method);

  // Optional post data.
  struct _cef_post_data_t* (CEF_CALLBACK *get_post_data)(
      struct _cef_request_t* self);
  void (CEF_CALLBACK *set_post_data)(struct _cef_request_t* self,
      struct _cef_post_data_t* postData);

  // Optional header values.
  void (CEF_CALLBACK *get_header_map)(struct _cef_request_t* self,
      cef_string_map_t headerMap);
  void (CEF_CALLBACK *set_header_map)(struct _cef_request_t* self,
      cef_string_map_t headerMap);

  // Set all values at one time.
  void (CEF_CALLBACK *set)(struct _cef_request_t* self, const cef_string_t* url,
      const cef_string_t* method, struct _cef_post_data_t* postData,
      cef_string_map_t headerMap);

  // Optional flags. Used in combination with cef_web_urlrequest_t.
  enum cef_weburlrequest_flags_t (CEF_CALLBACK *get_flags)(
      struct _cef_request_t* self);
  void (CEF_CALLBACK *set_flags)(struct _cef_request_t* self,
      enum cef_weburlrequest_flags_t flags);

  // Optional URL to the first party for cookies. Used in combination with
  // cef_web_urlrequest_t.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_first_party_for_cookies)(
      struct _cef_request_t* self);
  void (CEF_CALLBACK *set_first_party_for_cookies)(struct _cef_request_t* self,
      const cef_string_t* url);

} cef_request_t;


// Create a new cef_request_t object.
CEF_EXPORT cef_request_t* cef_request_create();


// Structure used to represent post data for a web request. The functions of
// this structure may be called on any thread.
typedef struct _cef_post_data_t
{
  // Base structure.
  cef_base_t base;

  // Returns the number of existing post data elements.
  size_t (CEF_CALLBACK *get_element_count)(struct _cef_post_data_t* self);

  // Retrieve the post data elements.
  struct _cef_post_data_element_t* (CEF_CALLBACK *get_elements)(
      struct _cef_post_data_t* self, int elementIndex);

  // Remove the specified post data element.  Returns true (1) if the removal
  // succeeds.
  int (CEF_CALLBACK *remove_element)(struct _cef_post_data_t* self,
      struct _cef_post_data_element_t* element);

  // Add the specified post data element.  Returns true (1) if the add succeeds.
  int (CEF_CALLBACK *add_element)(struct _cef_post_data_t* self,
      struct _cef_post_data_element_t* element);

  // Remove all existing post data elements.
  void (CEF_CALLBACK *remove_elements)(struct _cef_post_data_t* self);

} cef_post_data_t;


// Create a new cef_post_data_t object.
CEF_EXPORT cef_post_data_t* cef_post_data_create();


// Structure used to represent a single element in the request post data. The
// functions of this structure may be called on any thread.
typedef struct _cef_post_data_element_t
{
  // Base structure.
  cef_base_t base;

  // Remove all contents from the post data element.
  void (CEF_CALLBACK *set_to_empty)(struct _cef_post_data_element_t* self);

  // The post data element will represent a file.
  void (CEF_CALLBACK *set_to_file)(struct _cef_post_data_element_t* self,
      const cef_string_t* fileName);

  // The post data element will represent bytes.  The bytes passed in will be
  // copied.
  void (CEF_CALLBACK *set_to_bytes)(struct _cef_post_data_element_t* self,
      size_t size, const void* bytes);

  // Return the type of this post data element.
  enum cef_postdataelement_type_t (CEF_CALLBACK *get_type)(
      struct _cef_post_data_element_t* self);

  // Return the file name.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_file)(
      struct _cef_post_data_element_t* self);

  // Return the number of bytes.
  size_t (CEF_CALLBACK *get_bytes_count)(struct _cef_post_data_element_t* self);

  // Read up to |size| bytes into |bytes| and return the number of bytes
  // actually read.
  size_t (CEF_CALLBACK *get_bytes)(struct _cef_post_data_element_t* self,
      size_t size, void* bytes);

} cef_post_data_element_t;


// Create a new cef_post_data_element_t object.
CEF_EXPORT cef_post_data_element_t* cef_post_data_element_create();


// Structure used to represent a web response. The functions of this structure
// may be called on any thread.
typedef struct _cef_response_t
{
  // Base structure.
  cef_base_t base;

  // Returns the response status code.
  int (CEF_CALLBACK *get_status)(struct _cef_response_t* self);

  // Returns the response status text.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_status_text)(
      struct _cef_response_t* self);

  // Returns the value for the specified response header field.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_header)(struct _cef_response_t* self,
      const cef_string_t* name);

  // Retrieves a map of all response header fields.
  void (CEF_CALLBACK *get_header_map)(struct _cef_response_t* self,
      cef_string_map_t headerMap);

} cef_response_t;


// Structure the client can implement to provide a custom stream reader. The
// functions of this structure may be called on any thread.
typedef struct _cef_read_handler_t
{
  // Base structure.
  cef_base_t base;

  // Read raw binary data.
  size_t (CEF_CALLBACK *read)(struct _cef_read_handler_t* self, void* ptr,
      size_t size, size_t n);

  // Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
  // SEEK_END or SEEK_SET.
  int (CEF_CALLBACK *seek)(struct _cef_read_handler_t* self, long offset,
      int whence);

  // Return the current offset position.
  long (CEF_CALLBACK *tell)(struct _cef_read_handler_t* self);

  // Return non-zero if at end of file.
  int (CEF_CALLBACK *eof)(struct _cef_read_handler_t* self);

} cef_read_handler_t;


// Structure used to read data from a stream. The functions of this structure
// may be called on any thread.
typedef struct _cef_stream_reader_t
{
  // Base structure.
  cef_base_t base;

  // Read raw binary data.
  size_t (CEF_CALLBACK *read)(struct _cef_stream_reader_t* self, void* ptr,
      size_t size, size_t n);

  // Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
  // SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure.
  int (CEF_CALLBACK *seek)(struct _cef_stream_reader_t* self, long offset,
      int whence);

  // Return the current offset position.
  long (CEF_CALLBACK *tell)(struct _cef_stream_reader_t* self);

  // Return non-zero if at end of file.
  int (CEF_CALLBACK *eof)(struct _cef_stream_reader_t* self);

} cef_stream_reader_t;


// Create a new cef_stream_reader_t object.
CEF_EXPORT cef_stream_reader_t* cef_stream_reader_create_for_file(
    const cef_string_t* fileName);
CEF_EXPORT cef_stream_reader_t* cef_stream_reader_create_for_data(void* data,
    size_t size);
CEF_EXPORT cef_stream_reader_t* cef_stream_reader_create_for_handler(
    cef_read_handler_t* handler);


// Structure the client can implement to provide a custom stream writer. The
// functions of this structure may be called on any thread.
typedef struct _cef_write_handler_t
{
  // Base structure.
  cef_base_t base;

  // Write raw binary data.
  size_t (CEF_CALLBACK *write)(struct _cef_write_handler_t* self,
      const void* ptr, size_t size, size_t n);

  // Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
  // SEEK_END or SEEK_SET.
  int (CEF_CALLBACK *seek)(struct _cef_write_handler_t* self, long offset,
      int whence);

  // Return the current offset position.
  long (CEF_CALLBACK *tell)(struct _cef_write_handler_t* self);

  // Flush the stream.
  int (CEF_CALLBACK *flush)(struct _cef_write_handler_t* self);

} cef_write_handler_t;


// Structure used to write data to a stream. The functions of this structure may
// be called on any thread.
typedef struct _cef_stream_writer_t
{
  // Base structure.
  cef_base_t base;

  // Write raw binary data.
  size_t (CEF_CALLBACK *write)(struct _cef_stream_writer_t* self,
      const void* ptr, size_t size, size_t n);

  // Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
  // SEEK_END or SEEK_SET.
  int (CEF_CALLBACK *seek)(struct _cef_stream_writer_t* self, long offset,
      int whence);

  // Return the current offset position.
  long (CEF_CALLBACK *tell)(struct _cef_stream_writer_t* self);

  // Flush the stream.
  int (CEF_CALLBACK *flush)(struct _cef_stream_writer_t* self);

} cef_stream_writer_t;


// Create a new cef_stream_writer_t object.
CEF_EXPORT cef_stream_writer_t* cef_stream_writer_create_for_file(
    const cef_string_t* fileName);
CEF_EXPORT cef_stream_writer_t* cef_stream_writer_create_for_handler(
    cef_write_handler_t* handler);


// Structure that should be implemented to handle V8 function calls. The
// functions of this structure will always be called on the UI thread.
typedef struct _cef_v8handler_t
{
  // Base structure.
  cef_base_t base;

  // Execute with the specified argument list and return value.  Return true (1)
  // if the function was handled.
  int (CEF_CALLBACK *execute)(struct _cef_v8handler_t* self,
      const cef_string_t* name, struct _cef_v8value_t* object,
      size_t argumentCount, struct _cef_v8value_t* const* arguments,
      struct _cef_v8value_t** retval, cef_string_t* exception);

} cef_v8handler_t;


// Structure representing a V8 value. The functions of this structure should
// only be called on the UI thread.
typedef struct _cef_v8value_t
{
  // Base structure.
  cef_base_t base;

  // Check the value type.
  int (CEF_CALLBACK *is_undefined)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *is_null)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *is_bool)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *is_int)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *is_double)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *is_string)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *is_object)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *is_array)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *is_function)(struct _cef_v8value_t* self);

  // Return a primitive value type.  The underlying data will be converted to
  // the requested type if necessary.
  int (CEF_CALLBACK *get_bool_value)(struct _cef_v8value_t* self);
  int (CEF_CALLBACK *get_int_value)(struct _cef_v8value_t* self);
  double (CEF_CALLBACK *get_double_value)(struct _cef_v8value_t* self);
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_string_value)(
      struct _cef_v8value_t* self);


  // OBJECT METHODS - These functions are only available on objects. Arrays and
  // functions are also objects. String- and integer-based keys can be used
  // interchangably with the framework converting between them as necessary.
  // Keys beginning with "Cef::" and "v8::" are reserved by the system.

  // Returns true (1) if the object has a value with the specified identifier.
  int (CEF_CALLBACK *has_value_bykey)(struct _cef_v8value_t* self,
      const cef_string_t* key);
  int (CEF_CALLBACK *has_value_byindex)(struct _cef_v8value_t* self, int index);

  // Delete the value with the specified identifier.
  int (CEF_CALLBACK *delete_value_bykey)(struct _cef_v8value_t* self,
      const cef_string_t* key);
  int (CEF_CALLBACK *delete_value_byindex)(struct _cef_v8value_t* self,
      int index);

  // Returns the value with the specified identifier.
  struct _cef_v8value_t* (CEF_CALLBACK *get_value_bykey)(
      struct _cef_v8value_t* self, const cef_string_t* key);
  struct _cef_v8value_t* (CEF_CALLBACK *get_value_byindex)(
      struct _cef_v8value_t* self, int index);

  // Associate value with the specified identifier.
  int (CEF_CALLBACK *set_value_bykey)(struct _cef_v8value_t* self,
      const cef_string_t* key, struct _cef_v8value_t* value);
  int (CEF_CALLBACK *set_value_byindex)(struct _cef_v8value_t* self, int index,
      struct _cef_v8value_t* value);

  // Read the keys for the object's values into the specified vector. Integer-
  // based keys will also be returned as strings.
  int (CEF_CALLBACK *get_keys)(struct _cef_v8value_t* self,
      cef_string_list_t keys);

  // Returns the user data, if any, specified when the object was created.
  struct _cef_base_t* (CEF_CALLBACK *get_user_data)(
      struct _cef_v8value_t* self);


  // ARRAY METHODS - These functions are only available on arrays.

  // Returns the number of elements in the array.
  int (CEF_CALLBACK *get_array_length)(struct _cef_v8value_t* self);


  // FUNCTION METHODS - These functions are only available on functions.

  // Returns the function name.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_function_name)(
      struct _cef_v8value_t* self);

  // Returns the function handler or NULL if not a CEF-created function.
  struct _cef_v8handler_t* (CEF_CALLBACK *get_function_handler)(
      struct _cef_v8value_t* self);

  // Execute the function.
  int (CEF_CALLBACK *execute_function)(struct _cef_v8value_t* self,
      struct _cef_v8value_t* object, size_t argumentCount,
      struct _cef_v8value_t* const* arguments, struct _cef_v8value_t** retval,
      cef_string_t* exception);

} cef_v8value_t;


// Create a new cef_v8value_t object of the specified type.  These functions
// should only be called from within the JavaScript context -- either in a
// cef_v8handler_t::execute() callback or a cef_handler_t::handle_jsbinding()
// callback.
CEF_EXPORT cef_v8value_t* cef_v8value_create_undefined();
CEF_EXPORT cef_v8value_t* cef_v8value_create_null();
CEF_EXPORT cef_v8value_t* cef_v8value_create_bool(int value);
CEF_EXPORT cef_v8value_t* cef_v8value_create_int(int value);
CEF_EXPORT cef_v8value_t* cef_v8value_create_double(double value);
CEF_EXPORT cef_v8value_t* cef_v8value_create_string(const cef_string_t* value);
CEF_EXPORT cef_v8value_t* cef_v8value_create_object(cef_base_t* user_data);
CEF_EXPORT cef_v8value_t* cef_v8value_create_array();
CEF_EXPORT cef_v8value_t* cef_v8value_create_function(const cef_string_t* name,
    cef_v8handler_t* handler);


// Structure that creates cef_scheme_handler_t instances. The functions of this
// structure will always be called on the IO thread.
typedef struct _cef_scheme_handler_factory_t
{
  // Base structure.
  cef_base_t base;

  // Return a new scheme handler instance to handle the request.
  struct _cef_scheme_handler_t* (CEF_CALLBACK *create)(
      struct _cef_scheme_handler_factory_t* self);

} cef_scheme_handler_factory_t;


// Structure used to represent a custom scheme handler structure. The functions
// of this structure will always be called on the IO thread.
typedef struct _cef_scheme_handler_t
{
  // Base structure.
  cef_base_t base;

  // Process the request. All response generation should take place in this
  // function. If there is no response set |response_length| to zero and
  // read_response() will not be called. If the response length is not known
  // then set |response_length| to -1 and read_response() will be called until
  // it returns false (0) or until the value of |bytes_read| is set to 0.
  // Otherwise, set |response_length| to a positive value and read_response()
  // will be called until it returns false (0), the value of |bytes_read| is set
  // to 0 or the specified number of bytes have been read. If there is a
  // response set |mime_type| to the mime type for the response.
  int (CEF_CALLBACK *process_request)(struct _cef_scheme_handler_t* self,
      struct _cef_request_t* request, cef_string_t* mime_type,
      int* response_length);

  // Cancel processing of the request.
  void (CEF_CALLBACK *cancel)(struct _cef_scheme_handler_t* self);

  // Copy up to |bytes_to_read| bytes into |data_out|. If the copy succeeds set
  // |bytes_read| to the number of bytes copied and return true (1). If the copy
  // fails return false (0) and read_response() will not be called again.
  int (CEF_CALLBACK *read_response)(struct _cef_scheme_handler_t* self,
      void* data_out, int bytes_to_read, int* bytes_read);

} cef_scheme_handler_t;


// Structure used to handle file downloads. The functions of this structure will
// always be called on the UI thread.
typedef struct _cef_download_handler_t
{
  // Base structure.
  cef_base_t base;

  // A portion of the file contents have been received. This function will be
  // called multiple times until the download is complete. Return |true (1)| to
  // continue receiving data and |false (0)| to cancel.
  int (CEF_CALLBACK *received_data)(struct _cef_download_handler_t* self,
      void* data, int data_size);

  // The download is complete.
  void (CEF_CALLBACK *complete)(struct _cef_download_handler_t* self);

} cef_download_handler_t;


// Structure used to make a Web URL request. Web URL requests are not associated
// with a browser instance so no cef_handler_t callbacks will be executed. The
// functions of this structure may be called on any thread.
typedef struct _cef_web_urlrequest_t
{
  // Base structure.
  cef_base_t base;

  // Cancels the request.
  void (CEF_CALLBACK *cancel)(struct _cef_web_urlrequest_t* self);

  // Returns the current ready state of the request.
  enum cef_weburlrequest_state_t (CEF_CALLBACK *get_state)(
      struct _cef_web_urlrequest_t* self);

} cef_web_urlrequest_t;


// Create a new CefWebUrlReqeust object.
CEF_EXPORT cef_web_urlrequest_t* cef_web_urlrequest_create(
    cef_request_t* request, struct _cef_web_urlrequest_client_t* client);


// Structure that should be implemented by the cef_web_urlrequest_t client. The
// functions of this structure will always be called on the UI thread.
typedef struct _cef_web_urlrequest_client_t
{
  // Base structure.
  cef_base_t base;

  // Notifies the client that the request state has changed. State change
  // notifications will always be sent before the below notification functions
  // are called.
  void (CEF_CALLBACK *on_state_change)(
      struct _cef_web_urlrequest_client_t* self,
      struct _cef_web_urlrequest_t* requester,
      enum cef_weburlrequest_state_t state);

  // Notifies the client that the request has been redirected and  provides a
  // chance to change the request parameters.
  void (CEF_CALLBACK *on_redirect)(struct _cef_web_urlrequest_client_t* self,
      struct _cef_web_urlrequest_t* requester, struct _cef_request_t* request,
      struct _cef_response_t* response);

  // Notifies the client of the response data.
  void (CEF_CALLBACK *on_headers_received)(
      struct _cef_web_urlrequest_client_t* self,
      struct _cef_web_urlrequest_t* requester,
      struct _cef_response_t* response);

  // Notifies the client of the upload progress.
  void (CEF_CALLBACK *on_progress)(struct _cef_web_urlrequest_client_t* self,
      struct _cef_web_urlrequest_t* requester, uint64 bytesSent,
      uint64 totalBytesToBeSent);

  // Notifies the client that content has been received.
  void (CEF_CALLBACK *on_data)(struct _cef_web_urlrequest_client_t* self,
      struct _cef_web_urlrequest_t* requester, const void* data,
      int dataLength);

  // Notifies the client that the request ended with an error.
  void (CEF_CALLBACK *on_error)(struct _cef_web_urlrequest_client_t* self,
      struct _cef_web_urlrequest_t* requester,
      enum cef_handler_errorcode_t errorCode);

} cef_web_urlrequest_client_t;


// Structure that supports the reading of XML data via the libxml streaming API.
// The functions of this structure should only be called on the thread that
// creates the object.
typedef struct _cef_xml_reader_t
{
  // Base structure.
  cef_base_t base;

  // Moves the cursor to the next node in the document. This function must be
  // called at least once to set the current cursor position. Returns true (1)
  // if the cursor position was set successfully.
  int (CEF_CALLBACK *move_to_next_node)(struct _cef_xml_reader_t* self);

  // Close the document. This should be called directly to ensure that cleanup
  // occurs on the correct thread.
  int (CEF_CALLBACK *close)(struct _cef_xml_reader_t* self);

  // Returns true (1) if an error has been reported by the XML parser.
  int (CEF_CALLBACK *has_error)(struct _cef_xml_reader_t* self);

  // Returns the error string.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_error)(
      struct _cef_xml_reader_t* self);


  // The below functions retrieve data for the node at the current cursor
  // position.

  // Returns the node type.
  enum cef_xml_node_type_t (CEF_CALLBACK *get_type)(
      struct _cef_xml_reader_t* self);

  // Returns the node depth. Depth starts at 0 for the root node.
  int (CEF_CALLBACK *get_depth)(struct _cef_xml_reader_t* self);

  // Returns the local name. See http://www.w3.org/TR/REC-xml-names/#NT-
  // LocalPart for additional details.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_local_name)(
      struct _cef_xml_reader_t* self);

  // Returns the namespace prefix. See http://www.w3.org/TR/REC-xml-names/ for
  // additional details.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_prefix)(
      struct _cef_xml_reader_t* self);

  // Returns the qualified name, equal to (Prefix:)LocalName. See
  // http://www.w3.org/TR/REC-xml-names/#ns-qualnames for additional details.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_qualified_name)(
      struct _cef_xml_reader_t* self);

  // Returns the URI defining the namespace associated with the node. See
  // http://www.w3.org/TR/REC-xml-names/ for additional details.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_namespace_uri)(
      struct _cef_xml_reader_t* self);

  // Returns the base URI of the node. See http://www.w3.org/TR/xmlbase/ for
  // additional details.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_base_uri)(
      struct _cef_xml_reader_t* self);

  // Returns the xml:lang scope within which the node resides. See
  // http://www.w3.org/TR/REC-xml/#sec-lang-tag for additional details.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_xml_lang)(
      struct _cef_xml_reader_t* self);

  // Returns true (1) if the node represents an NULL element. <a/> is considered
  // NULL but <a></a> is not.
  int (CEF_CALLBACK *is_empty_element)(struct _cef_xml_reader_t* self);

  // Returns true (1) if the node has a text value.
  int (CEF_CALLBACK *has_value)(struct _cef_xml_reader_t* self);

  // Returns the text value.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_value)(
      struct _cef_xml_reader_t* self);

  // Returns true (1) if the node has attributes.
  int (CEF_CALLBACK *has_attributes)(struct _cef_xml_reader_t* self);

  // Returns the number of attributes.
  size_t (CEF_CALLBACK *get_attribute_count)(struct _cef_xml_reader_t* self);

  // Returns the value of the attribute at the specified 0-based index.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_attribute_byindex)(
      struct _cef_xml_reader_t* self, int index);

  // Returns the value of the attribute with the specified qualified name.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_attribute_byqname)(
      struct _cef_xml_reader_t* self, const cef_string_t* qualifiedName);

  // Returns the value of the attribute with the specified local name and
  // namespace URI.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_attribute_bylname)(
      struct _cef_xml_reader_t* self, const cef_string_t* localName,
      const cef_string_t* namespaceURI);

  // Returns an XML representation of the current node's children.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_inner_xml)(
      struct _cef_xml_reader_t* self);

  // Returns an XML representation of the current node including its children.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_outer_xml)(
      struct _cef_xml_reader_t* self);

  // Returns the line number for the current node.
  int (CEF_CALLBACK *get_line_number)(struct _cef_xml_reader_t* self);


  // Attribute nodes are not traversed by default. The below functions can be
  // used to move the cursor to an attribute node. move_to_carrying_element()
  // can be called afterwards to return the cursor to the carrying element. The
  // depth of an attribute node will be 1 + the depth of the carrying element.

  // Moves the cursor to the attribute at the specified 0-based index. Returns
  // true (1) if the cursor position was set successfully.
  int (CEF_CALLBACK *move_to_attribute_byindex)(struct _cef_xml_reader_t* self,
      int index);

  // Moves the cursor to the attribute with the specified qualified name.
  // Returns true (1) if the cursor position was set successfully.
  int (CEF_CALLBACK *move_to_attribute_byqname)(struct _cef_xml_reader_t* self,
      const cef_string_t* qualifiedName);

  // Moves the cursor to the attribute with the specified local name and
  // namespace URI. Returns true (1) if the cursor position was set
  // successfully.
  int (CEF_CALLBACK *move_to_attribute_bylname)(struct _cef_xml_reader_t* self,
      const cef_string_t* localName, const cef_string_t* namespaceURI);

  // Moves the cursor to the first attribute in the current element. Returns
  // true (1) if the cursor position was set successfully.
  int (CEF_CALLBACK *move_to_first_attribute)(struct _cef_xml_reader_t* self);

  // Moves the cursor to the next attribute in the current element. Returns true
  // (1) if the cursor position was set successfully.
  int (CEF_CALLBACK *move_to_next_attribute)(struct _cef_xml_reader_t* self);

  // Moves the cursor back to the carrying element. Returns true (1) if the
  // cursor position was set successfully.
  int (CEF_CALLBACK *move_to_carrying_element)(struct _cef_xml_reader_t* self);

} cef_xml_reader_t;


// Create a new cef_xml_reader_t object. The returned object's functions can
// only be called from the thread that created the object.
CEF_EXPORT cef_xml_reader_t* cef_xml_reader_create(cef_stream_reader_t* stream,
    enum cef_xml_encoding_type_t encodingType, const cef_string_t* URI);


// Structure that supports the reading of zip archives via the zlib unzip API.
// The functions of this structure should only be called on the thread that
// creates the object.
typedef struct _cef_zip_reader_t
{
  // Base structure.
  cef_base_t base;

  // Moves the cursor to the first file in the archive. Returns true (1) if the
  // cursor position was set successfully.
  int (CEF_CALLBACK *move_to_first_file)(struct _cef_zip_reader_t* self);

  // Moves the cursor to the next file in the archive. Returns true (1) if the
  // cursor position was set successfully.
  int (CEF_CALLBACK *move_to_next_file)(struct _cef_zip_reader_t* self);

  // Moves the cursor to the specified file in the archive. If |caseSensitive|
  // is true (1) then the search will be case sensitive. Returns true (1) if the
  // cursor position was set successfully.
  int (CEF_CALLBACK *move_to_file)(struct _cef_zip_reader_t* self,
      const cef_string_t* fileName, int caseSensitive);

  // Closes the archive. This should be called directly to ensure that cleanup
  // occurs on the correct thread.
  int (CEF_CALLBACK *close)(struct _cef_zip_reader_t* self);


  // The below functions act on the file at the current cursor position.

  // Returns the name of the file.
  // The resulting string must be freed by calling cef_string_userfree_free().
  cef_string_userfree_t (CEF_CALLBACK *get_file_name)(
      struct _cef_zip_reader_t* self);

  // Returns the uncompressed size of the file.
  long (CEF_CALLBACK *get_file_size)(struct _cef_zip_reader_t* self);

  // Returns the last modified timestamp for the file.
  time_t (CEF_CALLBACK *get_file_last_modified)(struct _cef_zip_reader_t* self);

  // Opens the file for reading of uncompressed data. A read password may
  // optionally be specified.
  int (CEF_CALLBACK *open_file)(struct _cef_zip_reader_t* self,
      const cef_string_t* password);

  // Closes the file.
  int (CEF_CALLBACK *close_file)(struct _cef_zip_reader_t* self);

  // Read uncompressed file contents into the specified buffer. Returns < 0 if
  // an error occurred, 0 if at the end of file, or the number of bytes read.
  int (CEF_CALLBACK *read_file)(struct _cef_zip_reader_t* self, void* buffer,
      size_t bufferSize);

  // Returns the current offset in the uncompressed file contents.
  long (CEF_CALLBACK *tell)(struct _cef_zip_reader_t* self);

  // Returns true (1) if at end of the file contents.
  int (CEF_CALLBACK *eof)(struct _cef_zip_reader_t* self);

} cef_zip_reader_t;


// Create a new cef_zip_reader_t object. The returned object's functions can
// only be called from the thread that created the object.
CEF_EXPORT cef_zip_reader_t* cef_zip_reader_create(cef_stream_reader_t* stream);


#ifdef __cplusplus
}
#endif

#endif // _CEF_CAPI_H
